import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,e}from"./app-ff1d42f3.js";const t={},s=e('<h1 id="_2-1-进程与线程" tabindex="-1"><a class="header-anchor" href="#_2-1-进程与线程" aria-hidden="true">#</a> 2.1 进程与线程</h1><h3 id="_2-1-1-进程的概念、组成、特征" tabindex="-1"><a class="header-anchor" href="#_2-1-1-进程的概念、组成、特征" aria-hidden="true">#</a> 2.1.1 进程的概念、组成、特征</h3><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.1summary.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-1-2-进程的状态与转换、进程的组织" tabindex="-1"><a class="header-anchor" href="#_2-1-2-进程的状态与转换、进程的组织" aria-hidden="true">#</a> 2.1.2 进程的状态与转换、进程的组织</h3><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.2summary.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-1-3-进程控制" tabindex="-1"><a class="header-anchor" href="#_2-1-3-进程控制" aria-hidden="true">#</a> 2.1.3 进程控制</h2><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.3summary.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><ul><li>进程控制就是要实现进程状态的转换</li><li>进程控制用原语实现：进程控制用的程序段称为原语</li></ul><h3 id="相关原语" tabindex="-1"><a class="header-anchor" href="#相关原语" aria-hidden="true">#</a> 相关原语</h3><ul><li>进程的创建</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.3进程创建.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>进程的终止</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.3进程终止.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>进程的阻塞</li><li>进程的唤醒</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.3进程阻塞唤醒.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>进程的切换</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.3进程切换.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-1-4-进程通信" tabindex="-1"><a class="header-anchor" href="#_2-1-4-进程通信" aria-hidden="true">#</a> 2.1.4 进程通信</h2><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.4summary.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="为什么进程通信需要操作系统支持" tabindex="-1"><a class="header-anchor" href="#为什么进程通信需要操作系统支持" aria-hidden="true">#</a> 为什么进程通信需要操作系统支持？</h3><p>进程是分配系统资源的单位，各进程拥有独立的内存地址空间，为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><h3 id="通信方式" tabindex="-1"><a class="header-anchor" href="#通信方式" aria-hidden="true">#</a> 通信方式</h3><h4 id="_1-共享存储" tabindex="-1"><a class="header-anchor" href="#_1-共享存储" aria-hidden="true">#</a> 1.共享存储</h4><ul><li>基于数据结构的共享：低级的共享方式，速度慢，限制多</li><li>基于存储区的共享：高级共享方式，灵活性高，速度快</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.4共享存储.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-消息传递" tabindex="-1"><a class="header-anchor" href="#_2-消息传递" aria-hidden="true">#</a> 2.消息传递</h4><p>进程间的数据交换是以格式化的消息为单位的。</p><ul><li>直接通信方式：消息发送进程指明接收进程的ID</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.4直接通信方式.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>间接通信方式：通过“信箱”间接地通信，又成信箱通信方式</li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.4间接通信方式.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-管道通信" tabindex="-1"><a class="header-anchor" href="#_3-管道通信" aria-hidden="true">#</a> 3.管道通信</h4><p>管道，是指用于连接一个读进程和一个写进程，以实现他们之间的通信的一个共享文件，又名pipe文件。其实就是在内存中开辟一个<strong>大小固定的内存缓冲区</strong></p><ul><li>从管道读数据是一次性操作，数据一旦被读取，它就从管道中被抛弃</li><li>管道变空时，下次的读数据将会被阻塞，等待数据被写入；同理，当管道写满时，写进程将阻塞，等待数据被读走</li><li>管道只能采用半双工通信</li><li>各进程要互斥访问管道（由操作系统实现）</li></ul><h2 id="_2-1-5-线程概念" tabindex="-1"><a class="header-anchor" href="#_2-1-5-线程概念" aria-hidden="true">#</a> 2.1.5 线程概念</h2><h3 id="什么是线程-为什么要引入线程" tabindex="-1"><a class="header-anchor" href="#什么是线程-为什么要引入线程" aria-hidden="true">#</a> 什么是线程？为什么要引入线程？</h3><ul><li>引入进程的目的是：更好的使多道程序并发执行，提高资源利用率和系统吞吐量；</li><li>引入线程的目的是：增加并发度</li></ul><h3 id="引入线程后的变化" tabindex="-1"><a class="header-anchor" href="#引入线程后的变化" aria-hidden="true">#</a> 引入线程后的变化</h3><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.5引入线程变化.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="线程的属性" tabindex="-1"><a class="header-anchor" href="#线程的属性" aria-hidden="true">#</a> 线程的属性</h3><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.5线程属性.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-1-6-线程的实现方式和多线程模型" tabindex="-1"><a class="header-anchor" href="#_2-1-6-线程的实现方式和多线程模型" aria-hidden="true">#</a> 2.1.6 线程的实现方式和多线程模型</h2><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.6summary.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="线程的实现方式" tabindex="-1"><a class="header-anchor" href="#线程的实现方式" aria-hidden="true">#</a> 线程的实现方式</h3><ul><li>用户级线程（ULT） <ul><li>优点：不需要变态</li><li>缺点：其中一个用户级线程被阻塞后，整个进程都被阻塞</li></ul></li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.6ULT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>内核级线程（KLT） <ul><li>优点：其中一个用户级线程被阻塞后，别的线程还可以继续执行</li><li>缺点：需要变态</li></ul></li></ul><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.6KLT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h3><ul><li>一对一模型</li><li>多对一模型</li><li>多对多模型</li></ul><h2 id="_2-1-7-线程的状态与转换" tabindex="-1"><a class="header-anchor" href="#_2-1-7-线程的状态与转换" aria-hidden="true">#</a> 2.1.7 线程的状态与转换</h2><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.7转换.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/study/operating-system/2.1.7控制.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',54),r=[s];function o(l,h){return a(),n("div",null,r)}const d=i(t,[["render",o],["__file","2-1.html.vue"]]);export{d as default};
