import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as l,e as a}from"./app-ff1d42f3.js";const r={},d=a('<h3 id="事务是什么" tabindex="-1"><a class="header-anchor" href="#事务是什么" aria-hidden="true">#</a> 事务是什么</h3><blockquote><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><h4 id="事务的四大特性" tabindex="-1"><a class="header-anchor" href="#事务的四大特性" aria-hidden="true">#</a> 事务的四大特性？</h4><ul><li>原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性：事务执行前后，数据保持一致</li><li>隔离性：事务之间互不影响</li><li>持久性：事务一旦提交，数据将持久化到数据库</li></ul><h4 id="并行事务导致的问题" tabindex="-1"><a class="header-anchor" href="#并行事务导致的问题" aria-hidden="true">#</a> 并行事务导致的问题</h4><ul><li>脏读：一个事务读取到了另一个事务未提交的数据</li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的结果不一致</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 &quot;幻影&quot;。</li></ul><h4 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别" aria-hidden="true">#</a> 事务的隔离级别</h4><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">Read uncommitted</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">Read committed</td><td style="text-align:center;">❌</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">Repeatable Read(默认)</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">Serializable</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr></tbody></table><h3 id="事务的隔离级别是靠什么保证的" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别是靠什么保证的" aria-hidden="true">#</a> 事务的隔离级别是靠什么保证的</h3><p>简单来说：原子性、一致性、持久性是通过redo_log + undo_log实现的，隔离性是通过锁 + MVCC实现的<br> 复杂来说：要想回答这个问题，必须先清楚MySQL的结构，MySQL可分为连接层、服务层、引擎层、存储层。</p><p>❗️此处为附图</p><blockquote><p>连接层：负责连接管理、授权认证、安全等等。</p><p>服务层：负责查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等等。</p><p>引擎层：负责MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，</p><p>存储层：将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p></blockquote><p>MySQL默认为InnoDB引擎，其存储结构是由 表-段-区-页-行 组成的</p><blockquote><p>❗️这里介绍表-段-区-页-行</p></blockquote><p>❗️这里介绍体系结构</p><p><strong>redo_log</strong>: 重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。当事务提交之后会把所有修改信息都存到该日志文件中,<br> 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。一般由==重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)<br> ==两部分组成，前者是在内存中，后者在磁盘中</p>',16),n=[d];function i(o,c){return e(),l("div",null,n)}const g=t(r,[["render",i],["__file","transaction.html.vue"]]);export{g as default};
