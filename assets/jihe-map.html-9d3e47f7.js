import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as h,a,b as s,d as r,e as l}from"./app-ff1d42f3.js";const i={},p=l('<h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h2><h3 id="_1-hashmap的底层实现是什么" tabindex="-1"><a class="header-anchor" href="#_1-hashmap的底层实现是什么" aria-hidden="true">#</a> 1.HashMap的底层实现是什么？</h3><ul><li>JDK1.8之前：数组 + 链表</li></ul><blockquote><p>即拉链法，也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的 值加到链表中即可。</p></blockquote><ul><li>JDK1.8之后：<strong>数组 + （链表 | 红黑树）</strong></li></ul><h3 id="_2-树化与退化" tabindex="-1"><a class="header-anchor" href="#_2-树化与退化" aria-hidden="true">#</a> 2.树化与退化</h3><ul><li><p>树化规则：<strong>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化</strong></p></li><li><p>退化规则：</p><ul><li><p>数组扩容时，会重新计算索引位置，也就是原本的树结构可能会变，如果<strong>重新计算后的树元素个数 &lt;= 6 则会退化为链表</strong></p></li><li><p>移除树节点时，如果root、root.left、root.right、root.left.left有一个为 null ，退化为链表</p></li></ul></li></ul><blockquote><p>树化的意义是什么？</p><p>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</p><p>为什么一上来不树化？</p></blockquote>',8),c=a("blockquote",null,[a("p",null,[s("哈希表的查找、更新的时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s(" ，而红黑树的查找、更新的时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"l"),a("mi",null,"o"),a("msub",null,[a("mi",null,"g"),a("mn",null,"2")]),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(log_2n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),a("span",{class:"mord mathnormal"},"o"),a("span",{class:"mord"},[a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t vlist-t2"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.3011em"}},[a("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},"2")])])]),a("span",{class:"vlist-s"},"​")]),a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.15em"}},[a("span")])])])])]),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s(" ，TreeNode 占用空间也比普通Node 的大，如非必要，尽量还是使用链表")]),a("p",null,"树化应是偶然情况，是保底策略"),a("p",null,"为什么树化的阈值是8？"),a("p",null,"按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小提高了计算效率。table.length * 3/4可以被优化为((table.length >> 2) << 2) - (table.length >> 2) == table.length - (table.length >> 2), JAVA的位运算比乘除的效率更高, 所以取3/4在保证hash冲突小的情况下兼顾了效率;"),a("p",null,"扩容时如何重新计算索引位置？"),a("p",null,"hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap")],-1),m=l('<h3 id="_3-索引计算规则" tabindex="-1"><a class="header-anchor" href="#_3-索引计算规则" aria-hidden="true">#</a> 3.索引计算规则</h3><p>一共分为3步：</p><ul><li><p>计算对象的 hashCode()</p></li><li><p>扰动计算<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></p></li><li><p>上面的结果 <code>&amp; (capacity – 1)</code> 得到索引</p></li></ul>',3),d=a("p",null,"hashCode()都有了，为什么还要提供hash方法（为什么还要进行扰动计算）？",-1),u=a("strong",null,"随机性",-1),g={href:"https://www.zhihu.com/question/20733617/answer/111577937",target:"_blank",rel:"noopener noreferrer"},_=l('<h3 id="_4-扩容流程" tabindex="-1"><a class="header-anchor" href="#_4-扩容流程" aria-hidden="true">#</a> 4.扩容流程</h3><p>默认容量为16</p><p>数组容量为什么必须是2的n次幂？</p><p>只有2的幂次方在减1的时候，才会出现<code>01111</code>这样的值。</p><p>2的n次幂有什么好坏处？</p><p>数组容量不是2的n次幂可不可以</p><p>如果追求效率，应该用2的n次幂作为容量，这样可以保证最高位为1，这样可以通过位运算来计算hash值，而不是用取模运算，效率更高。</p><p>如果追求hash分布性，应该用质数作为容量，这样可以保证hash值分布更均匀，减少hash冲突，提高效率。</p>',8);function f(x,b){const e=n("ExternalLinkIcon");return o(),h("div",null,[p,c,m,a("blockquote",null,[d,a("p",null,[s("简单来说就是混合了原哈希值中的高位和低位，增大了"),u,s("，可参考"),a("a",g,[s("JDK 源码中 HashMap 的 hash 方法原理是什么？"),r(e)])])]),_])}const w=t(i,[["render",f],["__file","jihe-map.html.vue"]]);export{w as default};
