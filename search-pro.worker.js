const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":569,\"nextId\":569,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-79fdd481\",\"3\":\"v-791b0205\",\"4\":\"v-7e254617\",\"5\":\"v-7e254617#分支管理\",\"6\":\"v-7e254617#常用分支概览\",\"7\":\"v-7e254617#分支管理具体说明\",\"8\":\"v-7e254617#命名规则\",\"9\":\"v-7e254617#标签规则\",\"10\":\"v-7e254617#流程举例说明\",\"11\":\"v-7e254617#常见问题\",\"12\":\"v-7e254617#为什么单独出一个发布分支\",\"13\":\"v-7e254617#为什么单独出一个hotfix分支\",\"14\":\"v-7e254617#master的作用\",\"15\":\"v-7e254617#常见操作场景\",\"16\":\"v-7e254617@0\",\"17\":\"v-7e254617@1\",\"18\":\"v-4367823d\",\"19\":\"v-4367823d#nginx基本概念\",\"20\":\"v-4367823d#什么是nginx\",\"21\":\"v-4367823d#正向代理\",\"22\":\"v-4367823d#反向代理\",\"23\":\"v-4367823d#负载均衡\",\"24\":\"v-4367823d#动静分离\",\"25\":\"v-4367823d#nginx安装\",\"26\":\"v-4367823d#安装相关依赖\",\"27\":\"v-4367823d#安装nginx\",\"28\":\"v-4367823d#下载\",\"29\":\"v-4367823d#解压\",\"30\":\"v-4367823d#配置\",\"31\":\"v-4367823d#启动\",\"32\":\"v-4367823d#nginx配置文件\",\"33\":\"v-4367823d#安装tomcat\",\"34\":\"v-4367823d#_1下载安装\",\"35\":\"v-4367823d#_2相关命令\",\"36\":\"v-4367823d#实现反向代理\",\"37\":\"v-4367823d#_1启动多个tomcat-分别监听不同的端口\",\"38\":\"v-4367823d#_2配置nginx\",\"39\":\"v-4367823d#_3测试\",\"40\":\"v-4367823d#实现负载均衡\",\"41\":\"v-4367823d#负载分配策略\",\"42\":\"v-4367823d#实现动静分离\",\"43\":\"v-4367823d#实现高可用集群\",\"44\":\"v-4367823d#nginx原理解析\",\"45\":\"v-4367823d#worker-是如何工作的\",\"46\":\"v-4367823d#master-workers-的机制的好处\",\"47\":\"v-4367823d#设置多少个-worker-合适\",\"48\":\"v-4367823d#连接数-worker-connection\",\"49\":\"v-4367823d#两个问题\",\"50\":\"v-4367823d@0\",\"51\":\"v-4367823d@1\",\"52\":\"v-4f780cc3\",\"53\":\"v-4f780cc3#一般软件生命周期中需要画图的地方\",\"54\":\"v-4f780cc3#定义\",\"55\":\"v-4f780cc3#符号规范\",\"56\":\"v-4f780cc3#结构规范\",\"57\":\"v-4f780cc3#路径规范\",\"58\":\"v-4f780cc3#案例\",\"59\":\"v-4f780cc3#用例图\",\"60\":\"v-4f780cc3#_1-关联关系\",\"61\":\"v-4f780cc3#_2-归纳-泛化-关系\",\"62\":\"v-4f780cc3#_3-包含关系\",\"63\":\"v-4f780cc3#_4-拓展关系\",\"64\":\"v-4f780cc3#类图\",\"65\":\"v-4f780cc3#_1-类\",\"66\":\"v-4f780cc3#_2-类的关系\",\"67\":\"v-4f780cc3#对象图\",\"68\":\"v-4f780cc3#_1-对象图概念\",\"69\":\"v-4f780cc3#类图和对象图的关系及异同\",\"70\":\"v-4f780cc3#_2-对象图的组成元素\",\"71\":\"v-4f780cc3#_3-对象图实例\",\"72\":\"v-4f780cc3#_4-对象图的建模过程\",\"73\":\"v-4f780cc3#包图\",\"74\":\"v-4f780cc3#部署图\",\"75\":\"v-4f780cc3#_1-节点-node-节点实例-node-instance\",\"76\":\"v-4f780cc3#_2-构件-artifact\",\"77\":\"v-4f780cc3#_3-连接-association\",\"78\":\"v-4f780cc3#_4-部署图实例\",\"79\":\"v-4f780cc3#顺序图\",\"80\":\"v-4f780cc3#_1-什么是时序图\",\"81\":\"v-4f780cc3#_2-时序图的组成元素\",\"82\":\"v-4f780cc3#_3-如何绘制时序图\",\"83\":\"v-4f780cc3#流程图、顺序图、状态图他们三者分别解决什么样的问题\",\"84\":\"v-4f780cc3#流程图-vs-顺序图\",\"85\":\"v-4f780cc3#流程图-vs-状态图\",\"86\":\"v-4f780cc3#通信图-协作图\",\"87\":\"v-4f780cc3#状态机图\",\"88\":\"v-4f780cc3#活动图\",\"89\":\"v-4f780cc3#什么是e-r图\",\"90\":\"v-4f780cc3#e-r图的绘图规范\",\"91\":\"v-4f780cc3#e-r图的具体绘制流程\",\"92\":\"v-4f780cc3@0\",\"93\":\"v-4f780cc3@1\",\"94\":\"v-c581ed48\",\"95\":\"v-c581ed48#_2023年6月5日\",\"96\":\"v-9f6fbd9a\",\"97\":\"v-90a0d10c\",\"98\":\"v-3025912a\",\"99\":\"v-3025912a#😺-项目起源\",\"100\":\"v-3025912a#👏-项目特点\",\"101\":\"v-51c3aa2a\",\"102\":\"v-51c3aa2a#前言\",\"103\":\"v-51c3aa2a#http-为什么不安全\",\"104\":\"v-51c3aa2a#安全通信的四大原则\",\"105\":\"v-51c3aa2a#https-通信原理简述\",\"106\":\"v-51c3aa2a#对称加密-https-的最终加密形式\",\"107\":\"v-51c3aa2a#非对称加密-解决单向对称密钥的传输问题\",\"108\":\"v-51c3aa2a#数字证书-解决公钥传输信任问题\",\"109\":\"v-51c3aa2a#其它-https-相关问题\",\"110\":\"v-51c3aa2a#总结\",\"111\":\"v-51c3aa2a@0\",\"112\":\"v-51c3aa2a@1\",\"113\":\"v-12f86093\",\"114\":\"v-12f86093#_2-1-1-进程的概念、组成、特征\",\"115\":\"v-12f86093#_2-1-2-进程的状态与转换、进程的组织\",\"116\":\"v-12f86093#_2-1-3-进程控制\",\"117\":\"v-12f86093#基本概念\",\"118\":\"v-12f86093#相关原语\",\"119\":\"v-12f86093#_2-1-4-进程通信\",\"120\":\"v-12f86093#为什么进程通信需要操作系统支持\",\"121\":\"v-12f86093#通信方式\",\"122\":\"v-12f86093#_1-共享存储\",\"123\":\"v-12f86093#_2-消息传递\",\"124\":\"v-12f86093#_3-管道通信\",\"125\":\"v-12f86093#_2-1-5-线程概念\",\"126\":\"v-12f86093#什么是线程-为什么要引入线程\",\"127\":\"v-12f86093#引入线程后的变化\",\"128\":\"v-12f86093#线程的属性\",\"129\":\"v-12f86093#_2-1-6-线程的实现方式和多线程模型\",\"130\":\"v-12f86093#线程的实现方式\",\"131\":\"v-12f86093#多线程模型\",\"132\":\"v-12f86093#_2-1-7-线程的状态与转换\",\"133\":\"v-14ad3932\",\"134\":\"v-14ad3932#_2-2-1-调度的概念、层次\",\"135\":\"v-14ad3932#_2-2-2-进程调度的时机\",\"136\":\"v-14ad3932#_2-2-4-调度的基本准则\",\"137\":\"v-4e804e63\",\"138\":\"v-4e804e63#mysql-执行流程是怎样的\",\"139\":\"v-4e804e63#第一步-连接器\",\"140\":\"v-4e804e63#第二步-查询缓存\",\"141\":\"v-4e804e63#第三步-解析-sql\",\"142\":\"v-4e804e63#解析器\",\"143\":\"v-4e804e63#第四步-执行-sql\",\"144\":\"v-4e804e63#预处理器\",\"145\":\"v-4e804e63#优化器\",\"146\":\"v-4e804e63#执行器\",\"147\":\"v-4e804e63#主键索引查询\",\"148\":\"v-4e804e63#全表扫描\",\"149\":\"v-4e804e63#索引下推\",\"150\":\"v-4e804e63#总结\",\"151\":\"v-1b2b56d2\",\"152\":\"v-1b2b56d2#mysql-的数据存放在哪个文件\",\"153\":\"v-1b2b56d2#表空间文件的结构是怎么样的\",\"154\":\"v-1b2b56d2#_1、行-row\",\"155\":\"v-1b2b56d2#_2、页-page\",\"156\":\"v-1b2b56d2#_3、区-extent\",\"157\":\"v-1b2b56d2#_4、段-segment\",\"158\":\"v-1b2b56d2#innodb-行格式有哪些\",\"159\":\"v-1b2b56d2#compact-行格式长什么样\",\"160\":\"v-1b2b56d2#记录的额外信息\",\"161\":\"v-1b2b56d2#_1-变长字段长度列表\",\"162\":\"v-1b2b56d2#_2-null-值列表\",\"163\":\"v-1b2b56d2#_3-记录头信息\",\"164\":\"v-1b2b56d2#记录的真实数据\",\"165\":\"v-1b2b56d2#varchar-n-中-n-最大取值为多少\",\"166\":\"v-1b2b56d2#单字段的情况\",\"167\":\"v-1b2b56d2#多字段的情况\",\"168\":\"v-1b2b56d2#行溢出后-mysql-是怎么处理的\",\"169\":\"v-1b2b56d2#总结\",\"170\":\"v-f3c1c0f2\",\"171\":\"v-f23e6af6\",\"172\":\"v-f23e6af6#为什么要有-buffer-pool\",\"173\":\"v-f23e6af6#buffer-pool-有多大\",\"174\":\"v-f23e6af6#buffer-pool-缓存什么\",\"175\":\"v-f23e6af6#如何管理-buffer-pool\",\"176\":\"v-f23e6af6#如何管理空闲页\",\"177\":\"v-f23e6af6#如何管理脏页\",\"178\":\"v-f23e6af6#如何提高缓存命中率\",\"179\":\"v-f23e6af6#脏页什么时候会被刷入磁盘\",\"180\":\"v-f23e6af6#总结\",\"181\":\"v-34ca0d90\",\"182\":\"v-34ca0d90#实验\",\"183\":\"v-34ca0d90#单表数量限制\",\"184\":\"v-34ca0d90#表空间\",\"185\":\"v-34ca0d90#页的数据结构\",\"186\":\"v-34ca0d90#索引的数据结构\",\"187\":\"v-34ca0d90#单表建议值\",\"188\":\"v-34ca0d90#总结\",\"189\":\"v-3e04edba\",\"190\":\"v-3e04edba#哪种-count-性能最好\",\"191\":\"v-3e04edba#count-是什么\",\"192\":\"v-3e04edba#count-主键字段-执行过程是怎样的\",\"193\":\"v-3e04edba#count-1-执行过程是怎样的\",\"194\":\"v-3e04edba#count-执行过程是怎样的\",\"195\":\"v-3e04edba#count-字段-执行过程是怎样的\",\"196\":\"v-3e04edba#小结\",\"197\":\"v-3e04edba#为什么要通过遍历的方式来计数\",\"198\":\"v-3e04edba#如何优化-count\",\"199\":\"v-3e04edba#第一种-近似值\",\"200\":\"v-3e04edba#第二种-额外表保存计数值\",\"201\":\"v-85ec90d6\",\"202\":\"v-85ec90d6#什么是索引\",\"203\":\"v-85ec90d6#索引的分类\",\"204\":\"v-85ec90d6#按数据结构分类\",\"205\":\"v-85ec90d6#通过主键查询商品数据的过程\",\"206\":\"v-85ec90d6#通过二级索引查询商品数据的过程\",\"207\":\"v-85ec90d6#为什么-mysql-innodb-选择-b-tree-作为索引的数据结构\",\"208\":\"v-85ec90d6#按物理存储分类\",\"209\":\"v-85ec90d6#按字段特性分类\",\"210\":\"v-85ec90d6#主键索引\",\"211\":\"v-85ec90d6#唯一索引\",\"212\":\"v-85ec90d6#普通索引\",\"213\":\"v-85ec90d6#前缀索引\",\"214\":\"v-85ec90d6#按字段个数分类\",\"215\":\"v-85ec90d6#联合索引\",\"216\":\"v-85ec90d6#联合索引范围查询\",\"217\":\"v-85ec90d6#索引下推\",\"218\":\"v-85ec90d6#索引区分度\",\"219\":\"v-85ec90d6#联合索引进行排序\",\"220\":\"v-85ec90d6#什么时候需要-不需要创建索引\",\"221\":\"v-85ec90d6#什么时候适用索引\",\"222\":\"v-85ec90d6#什么时候不需要创建索引\",\"223\":\"v-85ec90d6#有什么优化索引的方法\",\"224\":\"v-85ec90d6#前缀索引优化\",\"225\":\"v-85ec90d6#覆盖索引优化\",\"226\":\"v-85ec90d6#主键索引最好是自增的\",\"227\":\"v-85ec90d6#索引最好设置为-not-null\",\"228\":\"v-85ec90d6#防止索引失效\",\"229\":\"v-85ec90d6#总结\",\"230\":\"v-7537e486\",\"231\":\"v-7537e486#题目一\",\"232\":\"v-7537e486#题目二\",\"233\":\"v-3f3b1127\",\"234\":\"v-3f3b1127#索引存储结构长什么样\",\"235\":\"v-3f3b1127#对索引使用左或者左右模糊匹配\",\"236\":\"v-3f3b1127#对索引使用函数\",\"237\":\"v-3f3b1127#对索引进行表达式计算\",\"238\":\"v-3f3b1127#对索引隐式类型转换\",\"239\":\"v-3f3b1127#联合索引非最左匹配\",\"240\":\"v-3f3b1127#where-子句中的-or\",\"241\":\"v-3f3b1127#总结\",\"242\":\"v-6797a11a\",\"243\":\"v-6797a11a#innodb-是如何存储数据的\",\"244\":\"v-6797a11a#b-树是如何进行查询的\",\"245\":\"v-6797a11a#聚簇索引和二级索引\",\"246\":\"v-6797a11a#总结\",\"247\":\"v-be92aa9a\",\"248\":\"v-be92aa9a#怎样的索引的数据结构是好的\",\"249\":\"v-be92aa9a#什么是二分查找\",\"250\":\"v-be92aa9a#什么是二分查找树\",\"251\":\"v-be92aa9a#什么是自平衡二叉树\",\"252\":\"v-be92aa9a#什么是-b-树\",\"253\":\"v-be92aa9a#什么是-b-树-1\",\"254\":\"v-be92aa9a#_1、单点查询\",\"255\":\"v-be92aa9a#_2、插入和删除效率\",\"256\":\"v-be92aa9a#_3、范围查询\",\"257\":\"v-be92aa9a#mysql-中的-b-树\",\"258\":\"v-be92aa9a#总结\",\"259\":\"v-ebd59cd6\",\"260\":\"v-ebd59cd6#常见多表查询方式\",\"261\":\"v-ebd59cd6#分类\",\"262\":\"v-ebd59cd6#部分解释\",\"263\":\"v-ebd59cd6#_1-内连接\",\"264\":\"v-ebd59cd6#_2-外连接\",\"265\":\"v-ebd59cd6#_3-自连接\",\"266\":\"v-ebd59cd6#_4-子查询\",\"267\":\"v-7008c2fc\",\"268\":\"v-7008c2fc#事务是什么\",\"269\":\"v-7008c2fc#事务的四大特性\",\"270\":\"v-7008c2fc#并行事务导致的问题\",\"271\":\"v-7008c2fc#事务的隔离级别\",\"272\":\"v-7008c2fc#事务的隔离级别是靠什么保证的\",\"273\":\"v-1852ef39\",\"274\":\"v-1852ef39#死锁的发生\",\"275\":\"v-1852ef39#为什么会产生死锁\",\"276\":\"v-1852ef39#insert-语句是怎么加行级锁的\",\"277\":\"v-1852ef39#_1、记录之间加有间隙锁\",\"278\":\"v-1852ef39#_2、遇到唯一键冲突\",\"279\":\"v-1852ef39#主键索引冲突\",\"280\":\"v-1852ef39#唯一二级索引冲突\",\"281\":\"v-1852ef39#如何避免死锁\",\"282\":\"v-abe7f32c\",\"283\":\"v-abe7f32c#什么-sql-语句会加行级锁\",\"284\":\"v-abe7f32c#行级锁有哪些种类\",\"285\":\"v-abe7f32c#record-lock\",\"286\":\"v-abe7f32c#gap-lock\",\"287\":\"v-abe7f32c#next-key-lock\",\"288\":\"v-abe7f32c#mysql-是怎么加行级锁的\",\"289\":\"v-abe7f32c#唯一索引等值查询\",\"290\":\"v-abe7f32c#_1、记录存在的情况\",\"291\":\"v-abe7f32c#_2、记录不存在的情况\",\"292\":\"v-abe7f32c#唯一索引范围查询\",\"293\":\"v-abe7f32c#_1、针对「大于或者大于等于」的范围查询\",\"294\":\"v-abe7f32c#_2、针对「小于或者小于等于」的范围查询\",\"295\":\"v-abe7f32c#非唯一索引等值查询\",\"296\":\"v-abe7f32c#_1、记录不存在的情况\",\"297\":\"v-abe7f32c#_2、记录存在的情况\",\"298\":\"v-abe7f32c#非唯一索引范围查询\",\"299\":\"v-abe7f32c#没有加索引的查询\",\"300\":\"v-abe7f32c#总结\",\"301\":\"v-2cc5098f\",\"302\":\"v-2cc5098f#什么是幻读\",\"303\":\"v-2cc5098f#实验验证\",\"304\":\"v-2cc5098f#加锁分析\",\"305\":\"v-2cc5098f#总结\",\"306\":\"v-6647a800\",\"307\":\"v-6647a800#全局锁\",\"308\":\"v-6647a800#表级锁\",\"309\":\"v-6647a800#表锁\",\"310\":\"v-6647a800#元数据锁\",\"311\":\"v-6647a800#意向锁\",\"312\":\"v-6647a800#auto-inc-锁\",\"313\":\"v-6647a800#行级锁\",\"314\":\"v-6647a800#record-lock\",\"315\":\"v-6647a800#gap-lock\",\"316\":\"v-6647a800#next-key-lock\",\"317\":\"v-6647a800#插入意向锁\",\"318\":\"v-2c0f5dc6\",\"319\":\"v-2c0f5dc6#准备工作\",\"320\":\"v-2c0f5dc6#开始实验\",\"321\":\"v-2c0f5dc6#为什么会发生死锁\",\"322\":\"v-2c0f5dc6#time-1-阶段加锁分析\",\"323\":\"v-2c0f5dc6#time-2-阶段加锁分析\",\"324\":\"v-2c0f5dc6#time-3-阶段加锁分析\",\"325\":\"v-2c0f5dc6#time-4-阶段加锁分析\",\"326\":\"v-2c0f5dc6#总结\",\"327\":\"v-2c0f5dc6#读者问答\",\"328\":\"v-dcd7c4e8\",\"329\":\"v-dcd7c4e8#为什么会发生这种的事故\",\"330\":\"v-dcd7c4e8#如何避免这种事故的发生\",\"331\":\"v-dcd7c4e8#总结\",\"332\":\"v-2051151e\",\"333\":\"v-7f166363\",\"334\":\"v-7f166363#为什么需要-undo-log\",\"335\":\"v-7f166363#为什么需要-buffer-pool\",\"336\":\"v-7f166363#buffer-pool-缓存什么\",\"337\":\"v-7f166363#为什么需要-redo-log\",\"338\":\"v-7f166363#redo-log-什么时候刷盘\",\"339\":\"v-7f166363#redo-log-文件写满了怎么办\",\"340\":\"v-7f166363#为什么需要-binlog\",\"341\":\"v-7f166363#redo-log-和-binlog-有什么区别\",\"342\":\"v-7f166363#主从复制是怎么实现\",\"343\":\"v-7f166363#binlog-什么时候刷盘\",\"344\":\"v-7f166363#为什么需要两阶段提交\",\"345\":\"v-7f166363#两阶段提交的过程是怎样的\",\"346\":\"v-7f166363#异常重启会出现什么现象\",\"347\":\"v-7f166363#两阶段提交有什么问题\",\"348\":\"v-7f166363#组提交\",\"349\":\"v-7f166363#mysql-磁盘-i-o-很高-有什么优化的方法\",\"350\":\"v-7f166363#总结\",\"351\":\"v-041ba96c\",\"352\":\"v-041ba96c#事务有哪些特性\",\"353\":\"v-041ba96c#并行事务会引发什么问题\",\"354\":\"v-041ba96c#脏读\",\"355\":\"v-041ba96c#不可重复读\",\"356\":\"v-041ba96c#幻读\",\"357\":\"v-041ba96c#事务的隔离级别有哪些\",\"358\":\"v-041ba96c#read-view-在-mvcc-里如何工作的\",\"359\":\"v-041ba96c#可重复读是如何工作的\",\"360\":\"v-041ba96c#读提交是如何工作的\",\"361\":\"v-041ba96c#总结\",\"362\":\"v-426df9b0\",\"363\":\"v-426df9b0#什么是幻读\",\"364\":\"v-426df9b0#快照读是如何避免幻读的\",\"365\":\"v-426df9b0#当前读是如何避免幻读的\",\"366\":\"v-426df9b0#幻读被完全解决了吗\",\"367\":\"v-426df9b0#第一个发生幻读现象的场景\",\"368\":\"v-426df9b0#第二个发生幻读现象的场景\",\"369\":\"v-426df9b0#总结\",\"370\":\"v-133c6190\",\"371\":\"v-133c6190#一、redis持久化\",\"372\":\"v-133c6190#_1-1-rdb持久化\",\"373\":\"v-133c6190#_1-1-1-执行时机\",\"374\":\"v-133c6190#_1-1-2-rdb原理\",\"375\":\"v-133c6190#_1-1-3-小结\",\"376\":\"v-133c6190#_1-2-aof持久化\",\"377\":\"v-133c6190#_1-2-1-aof原理\",\"378\":\"v-133c6190#_1-2-2-aof配置\",\"379\":\"v-133c6190#_1-2-3-aof文件重写\",\"380\":\"v-133c6190#_1-3-rdb与aof对比\",\"381\":\"v-133c6190#二、redis主从\",\"382\":\"v-133c6190#_2-1-搭建主从架构\",\"383\":\"v-133c6190#_2-2-主从数据同步原理\",\"384\":\"v-133c6190#_2-2-1-全量同步\",\"385\":\"v-133c6190#_2-2-2-增量同步\",\"386\":\"v-133c6190#_2-2-3-repl-backlog原理\",\"387\":\"v-133c6190#_2-3-主从同步优化\",\"388\":\"v-133c6190#_2-4-小结\",\"389\":\"v-133c6190#三、redis哨兵\",\"390\":\"v-133c6190#_3-1-哨兵原理\",\"391\":\"v-133c6190#_3-1-1-集群结构和作用\",\"392\":\"v-133c6190#_3-1-2-集群监控原理\",\"393\":\"v-133c6190#_3-1-3-集群故障恢复原理\",\"394\":\"v-133c6190#_3-1-4-小结\",\"395\":\"v-133c6190#_3-2-redistemplate\",\"396\":\"v-133c6190#_3-2-1-引入依赖\",\"397\":\"v-133c6190#_3-2-2-配置redis地址\",\"398\":\"v-133c6190#_3-2-3-配置读写分离\",\"399\":\"v-133c6190#四、redis分片集群\",\"400\":\"v-133c6190#_4-1-搭建分片集群\",\"401\":\"v-133c6190#_4-2-散列插槽\",\"402\":\"v-133c6190#_4-2-1-插槽原理\",\"403\":\"v-133c6190#_4-2-1-小结\",\"404\":\"v-133c6190#_4-3-集群伸缩\",\"405\":\"v-133c6190#_4-3-1-需求分析\",\"406\":\"v-133c6190#_4-3-2-创建新的redis实例\",\"407\":\"v-133c6190#_4-3-3-添加新节点到redis\",\"408\":\"v-133c6190#_4-3-4-转移插槽\",\"409\":\"v-133c6190#_4-4-故障转移\",\"410\":\"v-133c6190#_4-4-1-自动故障转移\",\"411\":\"v-133c6190#_4-4-2-手动故障转移\",\"412\":\"v-133c6190#_4-5-redistemplate访问分片集群\",\"413\":\"v-165529fd\",\"414\":\"v-165529fd#一、什么是多级缓存\",\"415\":\"v-165529fd#二、jvm进程缓存\",\"416\":\"v-165529fd#_2-1-初识caffeine\",\"417\":\"v-165529fd#_2-2-实现jvm进程缓存\",\"418\":\"v-165529fd#_2-2-1-需求\",\"419\":\"v-165529fd#_2-2-2-实现\",\"420\":\"v-165529fd#三、lua语法入门\",\"421\":\"v-165529fd#_3-1-初识lua\",\"422\":\"v-165529fd#_3-1-hello·world\",\"423\":\"v-165529fd#_3-2-变量和循环\",\"424\":\"v-165529fd#_3-2-1-lua的数据类型\",\"425\":\"v-165529fd#_3-2-2-声明变量\",\"426\":\"v-165529fd#_3-2-3-循环\",\"427\":\"v-165529fd#_3-3-条件控制、函数\",\"428\":\"v-165529fd#_3-3-1-函数\",\"429\":\"v-165529fd#_3-3-2-条件控制\",\"430\":\"v-165529fd#_3-3-3-案例\",\"431\":\"v-165529fd#四、实现多级缓存\",\"432\":\"v-165529fd#_4-1-安装openresty\",\"433\":\"v-165529fd#_4-2-openresty快速入门\",\"434\":\"v-165529fd#_4-2-1-反向代理流程\",\"435\":\"v-165529fd#_4-2-2-openresty监听请求\",\"436\":\"v-165529fd#_4-2-3-编写item-lua\",\"437\":\"v-165529fd#_4-3-请求参数处理\",\"438\":\"v-165529fd#_4-3-1-获取参数的api\",\"439\":\"v-165529fd#_4-3-2-获取参数并返回\",\"440\":\"v-165529fd#_4-4-查询tomcat\",\"441\":\"v-165529fd#_4-4-1-发送http请求的api\",\"442\":\"v-165529fd#_4-4-2-封装http工具\",\"443\":\"v-165529fd#_4-4-3-cjson工具类\",\"444\":\"v-165529fd#_4-4-4-实现tomcat查询\",\"445\":\"v-165529fd#_4-4-5-基于id负载均衡\",\"446\":\"v-165529fd#_1-原理\",\"447\":\"v-165529fd#_2-实现\",\"448\":\"v-165529fd#_4-5-redis缓存预热\",\"449\":\"v-165529fd#_4-6-查询redis缓存\",\"450\":\"v-165529fd#_4-6-1-封装redis工具\",\"451\":\"v-165529fd#_4-6-2-实现redis查询\",\"452\":\"v-165529fd#_4-7-nginx本地缓存\",\"453\":\"v-165529fd#_4-7-1-本地缓存api\",\"454\":\"v-165529fd#_4-7-2-实现本地缓存查询\",\"455\":\"v-165529fd#五、缓存同步\",\"456\":\"v-165529fd#_5-1-数据同步策略\",\"457\":\"v-165529fd#_5-2-安装canal\",\"458\":\"v-165529fd#_5-2-1-认识canal\",\"459\":\"v-165529fd#_5-2-监听canal\",\"460\":\"v-165529fd#_5-2-1-引入依赖\",\"461\":\"v-165529fd#_5-2-2-编写配置\",\"462\":\"v-165529fd#_5-2-3-修改item实体类\",\"463\":\"v-165529fd#_5-3-4-编写监听器\",\"464\":\"v-f6f39f80\",\"465\":\"v-f6f39f80@0\",\"466\":\"v-f6f39f80@1\",\"467\":\"v-6cb43393\",\"468\":\"v-6cb43393@0\",\"469\":\"v-6cb43393@1\",\"470\":\"v-24032165\",\"471\":\"v-24032165#hashmap\",\"472\":\"v-24032165#_1-hashmap的底层实现是什么\",\"473\":\"v-24032165#_2-树化与退化\",\"474\":\"v-24032165#_3-索引计算规则\",\"475\":\"v-24032165#_4-扩容流程\",\"476\":\"v-24032165@0\",\"477\":\"v-24032165@1\",\"478\":\"v-02f52dba\",\"479\":\"v-02f52dba#一、反射的概述\",\"480\":\"v-02f52dba#_1-关于反射的理解\",\"481\":\"v-02f52dba#_2-体会反射机制的-动态性\",\"482\":\"v-02f52dba#二、-class类\",\"483\":\"v-02f52dba#_2-1-class类的理解\",\"484\":\"v-02f52dba#_2-2-获取class实例的几种方式\",\"485\":\"v-02f52dba#_1-调用运行时类的属性-class\",\"486\":\"v-02f52dba#_2通过运行时类的对象-调用getclass\",\"487\":\"v-02f52dba#_3调用class的静态方法-forname-string-classpath\",\"488\":\"v-02f52dba#_4使用类的加载器-classloader\",\"489\":\"v-02f52dba#_2-3-总结-创建类的对象的方式\",\"490\":\"v-02f52dba#_2-4-class实例可以是哪些结构的说明\",\"491\":\"v-02f52dba#三、了解classloader\",\"492\":\"v-02f52dba#_3-1-类的加载过程\",\"493\":\"v-02f52dba#_3-2-类的加载器的作用\",\"494\":\"v-02f52dba#_3-3-类的加载器的分类\",\"495\":\"v-02f52dba#_3-4-java类编译、运行的执行的流程\",\"496\":\"v-02f52dba#_3-5-使用classloader加载src目录下的配置文件\",\"497\":\"v-02f52dba#四、反射应用\",\"498\":\"v-02f52dba#_4-1-创建运行时类的对象\",\"499\":\"v-02f52dba#_4-2-获取运行时类的完整结构\",\"500\":\"v-02f52dba#_4-3-调用运行时类的指定结构\",\"501\":\"v-02f52dba#_1调用指定的属性\",\"502\":\"v-02f52dba#_2-调用指定的方法\",\"503\":\"v-02f52dba#_3-调用指定的构造器\",\"504\":\"v-02f52dba#_4-4-动态代理\",\"505\":\"v-02f52dba#_1-代理模式的原理\",\"506\":\"v-02f52dba#_2-静态代理\",\"507\":\"v-02f52dba#_3-动态代理\",\"508\":\"v-02f52dba#五、反射实战-利用反射-策略模式去除过多的if\",\"509\":\"v-02f52dba@0\",\"510\":\"v-02f52dba@1\",\"511\":\"v-ff8d2af6\",\"512\":\"v-ff8d2af6@0\",\"513\":\"v-ff8d2af6@1\",\"514\":\"v-14248ea4\",\"515\":\"v-14248ea4#_1-如何判断对象可以回收\",\"516\":\"v-14248ea4#引用计数法\",\"517\":\"v-14248ea4#可达性分析算法\",\"518\":\"v-14248ea4#_2-引用类型\",\"519\":\"v-14248ea4#强引用\",\"520\":\"v-14248ea4#软引用\",\"521\":\"v-14248ea4#弱引用\",\"522\":\"v-14248ea4#虚引用\",\"523\":\"v-14248ea4#终结器引用\",\"524\":\"v-14248ea4#_3-垃圾回收算法\",\"525\":\"v-14248ea4#理论-分代收集\",\"526\":\"v-14248ea4#三种回收算法的对比\",\"527\":\"v-14248ea4#标记-清除\",\"528\":\"v-14248ea4#标记-整理\",\"529\":\"v-14248ea4#标记-复制\",\"530\":\"v-14248ea4#_4-hotspot算法细节\",\"531\":\"v-14248ea4@0\",\"532\":\"v-14248ea4@1\",\"533\":\"v-23161d50\",\"534\":\"v-23161d50#jvm整体架构\",\"535\":\"v-23161d50@0\",\"536\":\"v-23161d50@1\",\"537\":\"v-cd0c5b0e\",\"538\":\"v-cd0c5b0e#内存概述\",\"539\":\"v-cd0c5b0e#程序计数器\",\"540\":\"v-cd0c5b0e@0\",\"541\":\"v-cd0c5b0e@1\",\"542\":\"v-71b3ae87\",\"543\":\"v-1559ca3e\",\"544\":\"v-14ce05ae\",\"545\":\"v-74bc627b\",\"546\":\"v-33f1cc8b\",\"547\":\"v-1bd6979a\",\"548\":\"v-a85f5c34\",\"549\":\"v-44b5517e\",\"550\":\"v-2d0a776e\",\"551\":\"v-394ada5c\",\"552\":\"v-a94a8cca\",\"553\":\"v-9a726960\",\"554\":\"v-2d830baa\",\"555\":\"v-4b332090\",\"556\":\"v-8700477e\",\"557\":\"v-2c5cf1de\",\"558\":\"v-60b275c4\",\"559\":\"v-4384f976\",\"560\":\"v-939c0212\",\"561\":\"v-549227b8\",\"562\":\"v-640b2e69\",\"563\":\"v-673af10a\",\"564\":\"v-14c69af4\",\"565\":\"v-2a48c5f2\",\"566\":\"v-6037907c\",\"567\":\"v-0e1c828b\",\"568\":\"v-6037868e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,30],\"2\":[1,14],\"3\":[1,1],\"4\":[2,3],\"5\":[1],\"6\":[1,15],\"7\":[1,51],\"8\":[1,6],\"9\":[1,3],\"10\":[1,36],\"11\":[1],\"12\":[2,22],\"13\":[2,6],\"14\":[1,6],\"15\":[1,46],\"16\":[null,null,1],\"17\":[null,null,1],\"18\":[1],\"19\":[1],\"20\":[1,13],\"21\":[1,5],\"22\":[1,11],\"23\":[1,7],\"24\":[1,6],\"25\":[1,2],\"26\":[1,54],\"27\":[1],\"28\":[1,27],\"29\":[1,8],\"30\":[1,4],\"31\":[1,18],\"32\":[1,181],\"33\":[1],\"34\":[1,32],\"35\":[1,17],\"36\":[1],\"37\":[2,1],\"38\":[1,28],\"39\":[1,35],\"40\":[1,13],\"41\":[1,42],\"42\":[1,49],\"43\":[1,154],\"44\":[1,30],\"45\":[3,18],\"46\":[3,27],\"47\":[4,38],\"48\":[3,50],\"49\":[1,20],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[1,17],\"53\":[1,20],\"54\":[1,24],\"55\":[1,6],\"56\":[1,32],\"57\":[1,29],\"58\":[1,179],\"59\":[1,26],\"60\":[2,9],\"61\":[4,26],\"62\":[2,17],\"63\":[2,12],\"64\":[1,8],\"65\":[2,20],\"66\":[2,70],\"67\":[1],\"68\":[2,15],\"69\":[1,11],\"70\":[2,35],\"71\":[2,1],\"72\":[2,32],\"73\":[1,26],\"74\":[1,7],\"75\":[6,17],\"76\":[4,15],\"77\":[4,5],\"78\":[2,8],\"79\":[1,17],\"80\":[3,9],\"81\":[2,45],\"82\":[3,9],\"83\":[4,19],\"84\":[3,12],\"85\":[3,18],\"86\":[2,16],\"87\":[1,13],\"88\":[1,14],\"89\":[3,79],\"90\":[2,30],\"91\":[2,84],\"92\":[null,null,1],\"93\":[null,null,1],\"94\":[1],\"95\":[1,14],\"96\":[1,64],\"97\":[1,19],\"98\":[2,2],\"99\":[2,19],\"100\":[2,10],\"101\":[4],\"102\":[1,25],\"103\":[2,22],\"104\":[1,37],\"105\":[2],\"106\":[3,30],\"107\":[2,41],\"108\":[2,186],\"109\":[3,98],\"110\":[1,38],\"111\":[null,null,1],\"112\":[null,null,1],\"113\":[3],\"114\":[5],\"115\":[4],\"116\":[4],\"117\":[1,3],\"118\":[1,5],\"119\":[4],\"120\":[2,5],\"121\":[1],\"122\":[2,8],\"123\":[2,8],\"124\":[2,19],\"125\":[4],\"126\":[3,5],\"127\":[1],\"128\":[1],\"129\":[4],\"130\":[1,11],\"131\":[1,3],\"132\":[4],\"133\":[2],\"134\":[4,5],\"135\":[2,3],\"136\":[3],\"137\":[5,31],\"138\":[3,65],\"139\":[2,210],\"140\":[2,76],\"141\":[3,10],\"142\":[1,49],\"143\":[3,14],\"144\":[1,68],\"145\":[1,81],\"146\":[1,21],\"147\":[1,60],\"148\":[1,57],\"149\":[1,110],\"150\":[1,71],\"151\":[3,32],\"152\":[3,104],\"153\":[2,12],\"154\":[4,10],\"155\":[4,51],\"156\":[4,38],\"157\":[4,31],\"158\":[3,50],\"159\":[3,13],\"160\":[1,8],\"161\":[2,139],\"162\":[3,96],\"163\":[2,33],\"164\":[1,40],\"165\":[5,42],\"166\":[1,129],\"167\":[1,11],\"168\":[4,53],\"169\":[1,77],\"170\":[1,10],\"171\":[4,7],\"172\":[4,31],\"173\":[4,20],\"174\":[4,79],\"175\":[4],\"176\":[2,40],\"177\":[2,25],\"178\":[2,318],\"179\":[2,59],\"180\":[1,83],\"181\":[6,33],\"182\":[1,146],\"183\":[1,60],\"184\":[1,29],\"185\":[1,49],\"186\":[1,54],\"187\":[1,233],\"188\":[1,28],\"189\":[6,29],\"190\":[4,10],\"191\":[3,36],\"192\":[4,65],\"193\":[4,41],\"194\":[3,59],\"195\":[4,18],\"196\":[1,26],\"197\":[2,72],\"198\":[3,22],\"199\":[2,22],\"200\":[2,10],\"201\":[1,20],\"202\":[2,31],\"203\":[1,34],\"204\":[1,98],\"205\":[1,56],\"206\":[1,55],\"207\":[7,77],\"208\":[1,27],\"209\":[1,6],\"210\":[1,18],\"211\":[1,23],\"212\":[1,20],\"213\":[1,26],\"214\":[1,8],\"215\":[1,107],\"216\":[1,240],\"217\":[1,57],\"218\":[1,38],\"219\":[1,46],\"220\":[3,17],\"221\":[2,18],\"222\":[2,33],\"223\":[2,6],\"224\":[1,15],\"225\":[1,30],\"226\":[1,62],\"227\":[3,31],\"228\":[1,172],\"229\":[1,5],\"230\":[6,15],\"231\":[1,22],\"232\":[1,116],\"233\":[2,19],\"234\":[2,124],\"235\":[1,83],\"236\":[1,49],\"237\":[1,53],\"238\":[1,109],\"239\":[1,89],\"240\":[3,45],\"241\":[1,38],\"242\":[3,17],\"243\":[3,179],\"244\":[3,91],\"245\":[1,57],\"246\":[1,43],\"247\":[6,20],\"248\":[2,58],\"249\":[2,23],\"250\":[2,90],\"251\":[2,61],\"252\":[3,106],\"253\":[4,29],\"254\":[2,29],\"255\":[2,61],\"256\":[2,44],\"257\":[4,44],\"258\":[1,92],\"259\":[1],\"260\":[2],\"261\":[1,32],\"262\":[1],\"263\":[2,20],\"264\":[2,28],\"265\":[2,24],\"266\":[2,11],\"267\":[1],\"268\":[1,7],\"269\":[2,12],\"270\":[1,14],\"271\":[1,12],\"272\":[1,72],\"273\":[4,19],\"274\":[1,72],\"275\":[2,364],\"276\":[3,29],\"277\":[2,102],\"278\":[2,36],\"279\":[1,66],\"280\":[1,169],\"281\":[2,68],\"282\":[3,38],\"283\":[4,65],\"284\":[2,25],\"285\":[2,50],\"286\":[2,29],\"287\":[3,52],\"288\":[3,67],\"289\":[1,20],\"290\":[2,153],\"291\":[2,134],\"292\":[1,39],\"293\":[4,127],\"294\":[4,180],\"295\":[1,36],\"296\":[2,215],\"297\":[2,200],\"298\":[1,134],\"299\":[1,37],\"300\":[1,75],\"301\":[3,10],\"302\":[2,116],\"303\":[1,35],\"304\":[1,167],\"305\":[1,24],\"306\":[3,19],\"307\":[1,105],\"308\":[1,12],\"309\":[1,37],\"310\":[1,93],\"311\":[1,68],\"312\":[3,161],\"313\":[1,56],\"314\":[2,45],\"315\":[2,28],\"316\":[3,51],\"317\":[1,72],\"318\":[4,16],\"319\":[1,31],\"320\":[1,28],\"321\":[2,16],\"322\":[3,99],\"323\":[3,116],\"324\":[3,164],\"325\":[3,66],\"326\":[1,21],\"327\":[1],\"328\":[3,19],\"329\":[2,122],\"330\":[2,84],\"331\":[1,33],\"332\":[1,6],\"333\":[8,83],\"334\":[4,175],\"335\":[4,36],\"336\":[4,65],\"337\":[4,183],\"338\":[4,141],\"339\":[4,99],\"340\":[3,51],\"341\":[6,111],\"342\":[2,120],\"343\":[3,173],\"344\":[2,125],\"345\":[2,61],\"346\":[2,111],\"347\":[2,86],\"348\":[1,189],\"349\":[7,85],\"350\":[1,125],\"351\":[2,46],\"352\":[2,106],\"353\":[2,18],\"354\":[1,33],\"355\":[1,22],\"356\":[1,36],\"357\":[2,221],\"358\":[6,102],\"359\":[2,142],\"360\":[2,107],\"361\":[1,106],\"362\":[4,41],\"363\":[2,80],\"364\":[2,38],\"365\":[2,81],\"366\":[2,4],\"367\":[1,88],\"368\":[1,44],\"369\":[1,51],\"370\":[1,1],\"371\":[2,3],\"372\":[2,13],\"373\":[2,54],\"374\":[3,14],\"375\":[3,17],\"376\":[3],\"377\":[3,7],\"378\":[3,24],\"379\":[4,38],\"380\":[3,4],\"381\":[2],\"382\":[3,5],\"383\":[2],\"384\":[3,57],\"385\":[2,10],\"386\":[4,42],\"387\":[3,22],\"388\":[3,20],\"389\":[2,4],\"390\":[3],\"391\":[3,13],\"392\":[4,12],\"393\":[3,39],\"394\":[4,18],\"395\":[3,8],\"396\":[4,15],\"397\":[3,16],\"398\":[3,24],\"399\":[2],\"400\":[3,14],\"401\":[3],\"402\":[4,39],\"403\":[4,11],\"404\":[3,7],\"405\":[4,15],\"406\":[4,15],\"407\":[3,22],\"408\":[3,38],\"409\":[2,6],\"410\":[3,19],\"411\":[3,29],\"412\":[3,26],\"413\":[1],\"414\":[2,49],\"415\":[2],\"416\":[3,114],\"417\":[2],\"418\":[3,6],\"419\":[2,75],\"420\":[2,3],\"421\":[3,16],\"422\":[4,13],\"423\":[3,3],\"424\":[4,5],\"425\":[3,44],\"426\":[3,32],\"427\":[3,2],\"428\":[3,23],\"429\":[3,15],\"430\":[2,21],\"431\":[2,3],\"432\":[3,24],\"433\":[3,5],\"434\":[4,15],\"435\":[3,54],\"436\":[5,78],\"437\":[3,8],\"438\":[4,2],\"439\":[4,93],\"440\":[2,12],\"441\":[3,43],\"442\":[3,115],\"443\":[3,31],\"444\":[2,35],\"445\":[3,29],\"446\":[2,23],\"447\":[2,36],\"448\":[3,125],\"449\":[3,8],\"450\":[4,101],\"451\":[4,73],\"452\":[3,5],\"453\":[4,37],\"454\":[4,91],\"455\":[2,8],\"456\":[3,52],\"457\":[3],\"458\":[4,43],\"459\":[3,20],\"460\":[5,17],\"461\":[4,13],\"462\":[4,71],\"463\":[4,124],\"464\":[1],\"465\":[null,null,1],\"466\":[null,null,1],\"467\":[1],\"468\":[null,null,1],\"469\":[null,null,1],\"470\":[1],\"471\":[1],\"472\":[3,15],\"473\":[2,74],\"474\":[2,26],\"475\":[2,18],\"476\":[null,null,1],\"477\":[null,null,1],\"478\":[1,18],\"479\":[2],\"480\":[2,47],\"481\":[4,9],\"482\":[2],\"483\":[3,18],\"484\":[2],\"485\":[3,6],\"486\":[4,8],\"487\":[4,9],\"488\":[2,14],\"489\":[4,12],\"490\":[3,18],\"491\":[2],\"492\":[3,69],\"493\":[3,17],\"494\":[2,30],\"495\":[4,1],\"496\":[3,40],\"497\":[2],\"498\":[3,36],\"499\":[3,74],\"500\":[3],\"501\":[1,25],\"502\":[2,43],\"503\":[2,28],\"504\":[2],\"505\":[2,5],\"506\":[2,50],\"507\":[2,110],\"508\":[3,109],\"509\":[null,null,1],\"510\":[null,null,2],\"511\":[1],\"512\":[null,null,1],\"513\":[null,null,2],\"514\":[1],\"515\":[2],\"516\":[1,34],\"517\":[1,39],\"518\":[2],\"519\":[1,17],\"520\":[1,70],\"521\":[1,17],\"522\":[1,40],\"523\":[1,13],\"524\":[2],\"525\":[2,6],\"526\":[1,18],\"527\":[2,20],\"528\":[2,6],\"529\":[2,15],\"530\":[2,4],\"531\":[null,null,1],\"532\":[null,null,2],\"533\":[1],\"534\":[1],\"535\":[null,null,1],\"536\":[null,null,2],\"537\":[1],\"538\":[1,16],\"539\":[1,12],\"540\":[null,null,1],\"541\":[null,null,2],\"542\":[1],\"543\":[1],\"544\":[1],\"545\":[1],\"546\":[1],\"547\":[1],\"548\":[1],\"549\":[1],\"550\":[1],\"551\":[1],\"552\":[1],\"553\":[1],\"554\":[1],\"555\":[1],\"556\":[1],\"557\":[1],\"558\":[1],\"559\":[1],\"560\":[2],\"561\":[2],\"562\":[1],\"563\":[1],\"564\":[1],\"565\":[2],\"566\":[1],\"567\":[1],\"568\":[1]},\"averageFieldLength\":[2.14555618937837,45.523300284674264,0.213389031451364],\"storedFields\":{\"0\":{\"h\":\"\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"🎉欢迎来到我的个人学习空间，这个网站是我自我提升和知识探索的见证。我创建这个网站的初衷是为了记录我的学习旅程，分享我所学到的知识和经验，同时也是为了自我监督和激励。在这个快节奏的世界里，我们很容易迷失方向，忘记初心。因此，这里不仅是一个知识库，更是一个提醒，提醒我保持好奇心，不断学习，不断进步。\",\"👏我不生产知识，只是知识的搬运工。我希望这个网站能够成为一个互动的平台，让志同道合的朋友们可以一起讨论、学习和成长。无论你是偶然路过的访客，还是长期关注的朋友，我都希望你能在这里找到一些有价值的内容，激发你的思考，或者仅仅是为你的日常生活带来一丝灵感。\",\"🔝让我们一起在这个知识的海洋中航行，探索未知，追求卓越。感谢你的访问，期待与你共同成长！\"]},\"2\":{\"h\":\"更新日志\",\"t\":[\"Redis\",\"2024/05/14 ： \",\"分布式缓存：持久化、主从、哨兵、分片集群\",\"多级缓存：浏览器缓存、Nginx缓存、redis缓存、JVM进程缓存\"]},\"3\":{\"h\":\"\",\"t\":[\"redis面试题\"]},\"4\":{\"h\":\"Git工作流-Gitflow\",\"t\":[\"相关信息\",\"本文参考和转载文章\",\"Gitflow工作流程\"]},\"5\":{\"h\":\"分支管理\"},\"6\":{\"h\":\"常用分支概览\",\"t\":[\"master：稳定的最新版本分支，线上版本\",\"hotfix：用于维护的分支\",\"release：用于（测试）发布的分支\",\"develop：用于集成的分支\",\"feature：用于功能开发的分支\",\"示例图如下：\",\"gitflow\"]},\"7\":{\"h\":\"分支管理具体说明\",\"t\":[\"中云监测平台长期存在两个分支master跟develop分支。Master分支上的最新代码永远是版本发布状态。Develop则是最新的开发进度。\",\"Hotfix分支是用来做线上紧急BUG,命名一般为hotfix-xxx。xxx对应版本号,例如，master分支上最新版本为3.5.0，此时线上环境出现bug需要修改代码重新部署时，应在master分支上新建一个紧急分支，分支名称命名为hotfix-3.5.1。问题修复后，合并回master和develop分支。Master此时最新代码对应版本为master-3.5.1。 3. Release 分支用来做版本发布的预发布分支，建议命名为 release-xxx。例如在软件 1.0.0 版本的功能全部开发完成，提交测试之后，从 develop 检出release-1.0.0 ,测试中出现的小问题，在 release 分支进行修改提交，测试完毕准备发布的时候，代码会合并到 master 和 develop，master 分支合并后会打上对应版本标签 v1.0.0, 合并后删除自己，这样做的好处是，在测试的时候，不影响下一个版本功能并行开发。（具体场景会使用此分支） 4. Feature 分支用来做分模块功能开发，建议命名为feature-xxx,模块完成之后，会合并到 develop 分支，然后删除\"]},\"8\":{\"h\":\"命名规则\",\"t\":[\"hotfix-xxx\",\"release-xxx\",\"feature-xxx\",\"​ 其中xxx为对应的版本号或者模块名称\"]},\"9\":{\"h\":\"标签规则\",\"t\":[\"hotfix合并入master时，标签为xxx-\"]},\"10\":{\"h\":\"流程举例说明\",\"t\":[\"​ 举一个例子，以高支模版本和V4.6.2版本并行开发为例。lc和zp负责高支模，lzy负责4.6.2\",\"基于develop模块新建两个新分支，分别命名为feature-v4.6.2和feature-gzm\",\"lzy开发完毕v4.6.2，将代码合并到develop（开发完毕后才能合并），加入此时高支模还没有开发完成\",\"v4.6.2可以进行测试了，从develop模块克隆新分支，命名为release-v4.6.2，在此分支上进行测试，在这个分支上只能进行修复bug，做一些文档工作或者跟发布相关的任务\",\"v4.6.2测试完毕，合并release-v4.6.2分支入develop分支，最后删除release-v4.6.2\",\"feature-gzm分支重复234的过程\",\"v4.6.2上线后，develop合并入master，某天发现了一个线上bug，基于master分支新建hotfix-v4.6.2分支用于解决线上bug，解决完毕后，合并入master和develop分支\"]},\"11\":{\"h\":\"常见问题\"},\"12\":{\"h\":\"为什么单独出一个发布分支？\",\"t\":[\"​ 使用专门的一个分支来为发布做准备的好处是，在一个团队（lzy）忙于当前的发布的同时，另一个团队（lc、zp）可以继续为接下来的一次发布开发新功能。\",\"​ 这也有助于清晰表明开发的状态，比如说，团队在汇报状态时可以轻松使用这样的措辞，“这星期我们要为发布4.0版本做准备。”从代码仓库的结构上也能直接反映出来。命名规则为：release-xxx\",\"​ 一旦创建了这个分支并把它推向中央仓库，这次产品发布包含的功能也就固定下来了。任何还处于开发状态的功能只能等待下一个发布周期。\"]},\"13\":{\"h\":\"为什么单独出一个hotfix分支？\",\"t\":[\"​ 这种为解决紧急问题专设的绿色通道，让团队不必打乱当前的工作流程，也不必等待下一次的产品发布周期。你可以把用于维护的分支看成是依附于master的一种特别的发布分支。\"]},\"14\":{\"h\":\"master的作用\",\"t\":[\"​ master只是用于保存官方的发布历史，而develop分支才是用于集成各种功能开发的分支。使用版本号为master上的所有提交打标签（tag）也很方便\"]},\"15\":{\"h\":\"常见操作场景\",\"t\":[\"开发新模块，需建立分支并且提交代码\",\"# 注意此时是基于develop新建的 git checkout -b feature-xxx develop # git三部曲 git status git add <some-file> git commit \",\"功能开发完成后合并入develop分支\",\"git pull origin develop git checkout develop git merge feature-xxx git push # 合并后即可删除 git branch -d feature-xxx \",\"新模块提交测试\",\"git checkout -b release-xxx develop \",\"测试完毕，需要上线\",\"# 合并入develop git checkout develop git merge release-xxx git push # 合并入master git checkout master git merge release-xxx git push # git branch -d release-0.1 # 打标签 git tag -a xxx -m\\\"Initial public release\\\" master git push --tags \",\"正式环境需要改bug\",\"# 新建分支 git checkout -b hotfix-xxx master # 改完bug后,合并入develop git checkout develop git merge hotfix-xxx git push # 合并入master git checkout master git merge develop git push # 删除bug分支 git branch -d iotfix-xxx \"]},\"16\":{\"c\":[\"Git\"]},\"17\":{\"c\":[\"Git\"]},\"18\":{\"h\":\"Nginx从入门到实践\"},\"19\":{\"h\":\"Nginx基本概念\"},\"20\":{\"h\":\"什么是Nginx\",\"t\":[\"Nginx (\\\"engine x\\\")是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 Nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50000个并发连接数 \"]},\"21\":{\"h\":\"正向代理\",\"t\":[\"​ 在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问\"]},\"22\":{\"h\":\"反向代理\",\"t\":[\"​ 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\"]},\"23\":{\"h\":\"负载均衡\",\"t\":[\"​ 由于单个服务器解决不了，所以我们增加服务器的数量，然后将请求分发到各个服务器上,将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上,将负载分发到不同的服务器，也就是我们所说的负载均衡\"]},\"24\":{\"h\":\"动静分离\",\"t\":[\"​ 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。\"]},\"25\":{\"h\":\"Nginx安装\",\"t\":[\"操作平台 CentOS7\"]},\"26\":{\"h\":\"安装相关依赖\",\"t\":[\"安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装\",\"yum install gcc-c++ \",\"PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库\",\"yum install -y pcre pcre-devel \",\"zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库\",\"yum install -y zlib zlib-devel \",\"OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库\",\"yum install -y openssl openssl-devel \"]},\"27\":{\"h\":\"安装Nginx\"},\"28\":{\"h\":\"下载\",\"t\":[\"a. 直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html\",\"b. 使用wget命令下载（推荐）。确保系统已经安装了wget，如果没有安装，执行 yum install wget 安装。\",\"wget -c https://nginx.org/download/nginx-1.19.0.tar.gz \"]},\"29\":{\"h\":\"解压\",\"t\":[\"tar -zxvf nginx-1.19.0.tar.gz \"]},\"30\":{\"h\":\"配置\",\"t\":[\"./configure make && make install \"]},\"31\":{\"h\":\"启动\",\"t\":[\"ps aux|grep nginx #查看是否开启 ./nginx -v #查看版本 cd /usr/local/nginx/sbin/nginx ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #停止 ./nginx -s reload #重载 \"]},\"32\":{\"h\":\"Nginx配置文件\",\"t\":[\"Nginx 配置文件由三部分组成\",\"... #全局块 events { #events块 ... } http #http块 { ... #http全局块 server #server块 { ... #server全局块 location [PATTERN] #location块 { ... } location [PATTERN] { ... } } server { ... } ... #http全局块 } \",\"第一部分 全局块 主要设置一些影响 nginx 服务器整体运行的配置指令。 比如： worker_processes 1; ， worker_processes 值越大，可以支持的并发处理量就越多。\",\"第二部分 events块 events 块涉及的指令主要影响Nginx服务器与用户的网络连接。 比如： worker_connections 1024; ，支持的最大连接数。\",\"第三部分 http块 http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。\",\"server块：配置虚拟主机的相关参数。\",\"location块：配置请求路由，以及各种页面的处理情况。\",\"示例配置文件\",\"########### 每个指令必须有分号结束。################# #user administrator administrators; #配置用户或者组，默认为nobody nobody。 #worker_processes 2; #允许生成的进程数，默认为1 #pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址 error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg events { accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #最大连接数，默认为512 } http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 upstream mysvr { server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 } error_page 404 https://www.baidu.com; #错误页 server { keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 location ~*^.+$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip } } } \"]},\"33\":{\"h\":\"安装Tomcat\"},\"34\":{\"h\":\"①下载安装\",\"t\":[\"tomcat官网\",\"tar -zxvf apache-tomcat-10.0.5.tar.gz \",\"bin: 存放 Tomcat 的 启动、停止 等相关命令lib: 存放 Tomcat 运行时所需要的 jar 包conf: Tomcat 配置文件目录logs: Tomcat 运行日志目录webapps: 存放运行在 Tomcat 服务器内的应用程序（JavaWeb 应用部署目录）work: 存放应用程序运行时动态生成的 java 代码和动态编译的 class 文件temp: 存放 Tomcat 运行时产生的临时文件\"]},\"35\":{\"h\":\"②相关命令\",\"t\":[\"./startup.sh #启动 netstat -npl | grep :8080 #查看端口状态（Tomcat 默认监听 8080 端口） ./shutdown.sh #停止 \",\"注：详细过程可参考linux下安装tomcat\"]},\"36\":{\"h\":\"实现反向代理\"},\"37\":{\"h\":\"①启动多个tomcat，分别监听不同的端口\",\"t\":[\"详细过程可以参考开启多个tomcat\"]},\"38\":{\"h\":\"②配置nginx\",\"t\":[\"找到nginx配置文件，进行反向代理配置。\",\"server { listen 9001; server_name 0.0.0.0 #监听地址 location ~ /edu/ { root html; #/html目录 proxy_pass http://127.0.0.1:8081; #请求转向 index index.html index.htm; #设置默认页 } location ~ /vod/ { root html; #/html目录 proxy_pass http://127.0.0.1:8081; #请求转向 index index.html index.htm; #设置默认页 } } \",\"开放对外访问的端口号9001\",\"重启nginx服务器，使配置文件生效\"]},\"39\":{\"h\":\"③测试\",\"t\":[\"访问http://127.0.0.1:9001/edu/ 直接跳转到127.0.0.1:8081 访问http://127.0.0.1:9001/vod/ 直接跳转到127.0.0.1:8082\",\"Nginx-location相关指令\",\"​ =：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功， ​ 就停止继续向下搜索并立即处理该请求 ​ ~：用于表示uri包含正则表达式，并且区分大小写 ​ ~*：用于表示uri包含正则表达式，并且不区分大小写 ​ ^~：用于不含正则表达式的uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配 ​ 注意: 如果uri包含正则表达式，则必须要有或者*标识。\",\"# 基本语法 location [ = | ~ | ~* | ^~] uri {} \"]},\"40\":{\"h\":\"实现负载均衡\",\"t\":[\"1、实现效果\",\"(1) 浏览器地址栏输入地址http://192.168.xxx.xxx/edu/index.html, 负载均衡效果，平均到8080 和8081端口中，\"]},\"41\":{\"h\":\"负载分配策略\",\"t\":[\"在linux下有Nginx、LVS、 Haproxy 等等服务可以提供负载均衡服务，而且Nginx提供了以下几种分配方式(策略)\",\"1、轮询(默认)\",\"每个请求按时间顺序逐一分配到不 同的后端服务器，如果后端服务器down掉，能自动剔除\",\"2、weight weight代表权重默认为1,权重越高被分配的客户端越多。 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如: 。\",\"3、ip hash\",\"每个请求按访问ip的hash结果分配, 这样每个访客固定访问一个后端服务器,可以解诀session的问题。例如:\",\"upstream server pool{ ip_ hash server 192.168.5.21:80 server 192.168.5.22:80 } \",\"4、fair (第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配\",\"upstream server_pool server 192.168.5.21:80; server 192.168.5.22:80; fair; } \"]},\"42\":{\"h\":\"实现动静分离\",\"t\":[\"​ 通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义: 是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。( 如果经常更新的文件，不建议使用Expires来缓存)，如果设置3d, 表示在这3天之内访问这个URL, 发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304,如果有修改，则直接从服务器重新下载，返回状态码200。\",\"2、准备工作\",\"(1) 在liunx系统中准备静态资源，用于进行访问\",\"/data/image 图片文件夹\",\"/data/www html文件夹\",\"3、具体配置\",\"(1) 在nginx配置文件中进行配置\",\"location /www/{ root /data/; index index.html index.htm; } location /image/{ root /data/; autoindex on; } \",\"4、实际测试\",\"http://localhost/www/index.html http://1ocalhost/image/1.jpg \"]},\"43\":{\"h\":\"实现高可用集群\",\"t\":[\"1、什么是nginx高可用\",\"2、配置高可用的准备工作\",\"(1) 需要两台服务器192.168.17.129 和192.168.17.131 (2) 在两台服务器安装nginx. (3) 在两合服务器安装keepalived.\",\"3、在两台服务器安装keepalived 使用yum命令进行安装\",\"$ yum install keepalived $ rpm -q -a keepalived #查看是否已经安装上 \",\"默认安装路径: /etc/keepalived\",\"安装之后，在etc里面生成目录keepalived, 有配置文件keepalived.conf\",\"4、完成高可用配置(主从配置)\",\"（1）修改keepalived的配置文件keepalived.conf为：\",\"global_defs { notification_email { acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc smtp_ server 192.168.17.129 smtp_connect_timeout 30 router_id LVS_DEVEL # LVS_DEVEL这字段在/etc/hosts文件中看；通过它访问到主机 } vrrp_script chk_http_ port { script \\\"/usr/local/src/nginx_check.sh\\\" interval 2 # (检测脚本执行的间隔)2s weight 2 #权重，如果这个脚本检测为真，服务器权重+2 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将MASTER 改为BACKUP interface ens33 //网卡名称 virtual_router_id 51 # 主、备机的virtual_router_id必须相同 priority 100 #主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 #每隔1s发送一次心跳 authentication { # 校验方式， 类型是密码，密码1111 auth type PASS auth pass 1111 } virtual_ipaddress { # 虛拟ip 192.168.17.50 // VRRP H虛拟ip地址 } } \",\"（2）在路径/usr/local/src/ 下新建检测脚本 nginx_check.sh\",\"#! /bin/bash A=`ps -C nginx -no-header | wc - 1` if [ $A -eq 0];then /usr/local/nginx/sbin/nginx sleep 2 if [`ps -C nginx --no-header| wc -1` -eq 0 ];then killall keepalived fi fi \",\"(3) 把两台服务器上nginx和keepalived启动\",\"$ systemctl start keepalived.service #keepalived启动 $ ps -ef I grep keepalived #查看keepalived是否启动 $ systemctl stop keepalived.service #keepalived停止 \",\"5、最终测试\",\"(1) 在浏览器地址栏输入虚拟ip地址192.168.17.50\",\"(2) 把主服务器(192.168.17.129) nginx和keealived停止，再输入192.168.17.50.\"]},\"44\":{\"h\":\"Nginx原理解析\",\"t\":[\"​ Nginx 启动之后，在 Linux 系统中有两个进程，一个为 master，一个为 worker。master 作为管理员不参与任何工作，只负责给多个 worker 分配不同的任务（worker 一般有多个）。\",\"ps -ef |grep nginx root 20473 1 0 2019 ? 00:00:00 nginx: master process /usr/sbin/nginx nginx 4628 20473 0 Jan06 ? 00:00:00 nginx: worker process nginx 4629 20473 0 Jan06 ? 00:00:00 nginx: worker process \"]},\"45\":{\"h\":\"worker 是如何工作的？\",\"t\":[\"​ 客户端发送一个请求首先要经过 master，管理员收到请求后会将请求通知给 worker，多个 worker 以争抢的机制来抢夺任务，得到任务的 worker 会将请求经由 tomcat 等做请求转发、反向代理、访问数据库等（nginx 本身是不直接支持 java 的）。\"]},\"46\":{\"h\":\"master-workers 的机制的好处\",\"t\":[\"对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。\",\"采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。\"]},\"47\":{\"h\":\"设置多少个 worker 合适？\",\"t\":[\"​ Nginx 和 redis 类似，都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，每个 worker 的线程可以把一个 cpu 的性能发挥到极致，因此，worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗\",\"# 设置worker数量 worker.processes 4 # work绑定cpu(4work绑定4cpu) worker_cpu_affinity 0001 0010 0100 1000 # work绑定cpu (4work绑定8cpu中的4个) worker_cpu_affinity 0000001 00000010 00000100 00001000 \"]},\"48\":{\"h\":\"连接数 worker_connection\",\"t\":[\"​ 这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\"]},\"49\":{\"h\":\"两个问题\",\"t\":[\"发送请求，占用了woker的几个连接数? 2或者4个。\",\"nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少? 普通的静态访问最大并发数是: worker connections * worker processes /2， 而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections * worker processes/4\",\"知识来源 | 尚硅谷Nginx\",\"知识整理 | Monster\"]},\"50\":{\"c\":[\"开发工具\"]},\"51\":{\"c\":[\"Nginx\"]},\"52\":{\"h\":\"程序猿常用画图知识及工具\",\"t\":[\"相关信息\",\"本文参考和转载文章\",\"亿图图示官方、ProcessOn官方、程序员需要掌握的几种图、需要哪些设计图、画流程图常用的工具\",\"图是一种用来说明的工具，所以只要是你认为能更好的说明你的意图，任何图都是可以的。\",\"最终要做的是软件而不是图表，不要为了做图而做图，最后本末倒置，毕竟图标的目的是方便沟通\",\"在绘制任何图形之前，都应该先弄清楚图形的概念、组成元素以及绘制规范\"]},\"53\":{\"h\":\"一般软件生命周期中需要画图的地方\",\"t\":[\"业务流程图:做项目之前要搞清楚业务是怎样流转的，不要上来去想要实现什么功能。经过几次开会讨论，找相关领域专家探讨( 确认各个环节怎样操作)。\",\"功能图:\",\"一般情况下产品或系统的总功能可分解为若干分功能，各分功能又可进一步分解为若干二级分功能，如此继续，直至各分功能被分解为功能单元为止。这种由分功能或功能单元按照其逻辑关系连成的结构称为功能结构。分功能或功能单元的相互关系可以用图来描述，表达分功能或功能单元相互关系或从属关系的图称为功能结构图。功能图不要有专业术语，比如查询订单，修改订单审核状态等。要换成查看有哪些订单，对订单审核等。\"]},\"54\":{\"h\":\"定义\",\"t\":[\"​ 流程图=流程+图。\",\"所谓流程，IS09000系列国际标准中将流程定义为一组将输入转化为输出的相互群或相互作用的活动。流程有六个要素构成，分别是流程的输入资源、流程中的若干活动、活动的相互作用、输出结果、顾客、最终流程创造的价值。\",\"一个流程会将这6个要素有序串联起来，而流程图则是承载上述程序的图形载体。\",\"根据流程图“流动”信息的不同，又可以细分为产品流程图、数据流程图、程序流程图等，比如：\",\"页面流程图，呈现的是页面跳转顺序；\",\"数据流程图，用于表达数据的流转。\"]},\"55\":{\"h\":\"符号规范\",\"t\":[\"流程图中的每个符号都有着特定含义。\",\"画流程图的时候如果弄错了，整幅流程图的专业性就会大打折扣。\",\"面是几个重要且最常用的符号，需要牢记！\",\"img\"]},\"56\":{\"h\":\"结构规范\",\"t\":[\"流程图有三大结构，分别是顺序结构、选择结构和循环结构。\",\"1）顺序结构\",\"这种结构最简单，各个步骤是按先后顺序执行的。如图，A、B、C是三个连续的步骤，它们是按顺序执行的，即完成上一个框中指定的操作才能再执行下一个动作。\",\"顺序结构\",\"2） 选择结构\",\"选择结构又称分支结构，用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。\",\"选择结构\",\"3）循环结构\",\"循环结构又称为重复结构，指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。\",\"根据判断条件，循环结构又可细分为以下两种形式：先判断后执行的循环结构（当型结构），和先执行后判断的循环结构（直到型结构）。\",\"img\"]},\"57\":{\"h\":\"路径规范\",\"t\":[\"除了符号规划、结构规划，绘制流程图过程中还要注意一些约定俗成的路径规划，比如\",\"1）绘制流程图时，为了提高流程图的逻辑性，应遵循从左到右、从上到下的顺序排列。\",\"2）一个流程从开始符开始，以结束符结束。开始符号只能出现一次，而结束符号可出现多次。若流程足够清晰，可省略开始、结束符号。\",\"3）同一流程图内，符号大小需要保持一致，同时连接线不能交叉，连接线不能无故弯曲。\",\"4）流程处理关系为并行关系的，需要将流程放在同一高度。\",\"5）处理流程须以单一入口和单一出口绘制，同一路径的指示箭头应只有一个。\",\"img\"]},\"58\":{\"h\":\"案例\",\"t\":[\"img\",\"​ 计算机语言只是一种工具。光学习语言的规则还不够，最重要的是学会针对各种类型的问题，拟定出有效的解决方法和步骤即算法。有了正确而有效的算法，可以利用任何一种计算机高级语言编写程序，使计算机进行工作。因此，设计算法是程序设计的核心。\",\"​ 对同一个问题，可以有不同的解题方法和步骤。\",\"​ *例如，求1+2+3+…+100，可以先进行1+2，再加3，再加4，一直加到100，也可采取100+(1+99)+(2+98)+…+(49+51)+50＝100+50+49×100＝5050。*\",\"​ 还可以有其它的方法。当然，方法有优劣之分。有的方法只需进行很少的步骤，而有些方法则需要较多的步骤。一般说，希望采用方法简单，运算步骤少的方法。因此，为了有效地进行解题，不仅需要保证算法正确，还要考虑算法的质量，选择合适的算法。\",\"​ 一个计算问题的解决过程通常包含下面几步:\",\" a.确立所需解决的问题以及最后应达到的要求。必须保证在任务一开始就对它有详细而确切的了解，避免模棱两可和含混不清之处。 b.分析问题构造模型。在得到一个基本的物理模型后，用数学语言描述它，例如列出解题的数学公式或联立方程式，即建立数学模型。 c.选择计算方法。如定积分求值问题，可以用矩形法、梯形法或辛普生法等不同的方法。因此用计算机解题应当先确定用哪一种方法来计算。专门有一门学科“计算方法”，就是研究用什么方法最有效、最近似地实现各种数值计算的，换句话说，计算方法是研究数值计算的近似方法的。 d.确定算法和画流程图。在编写程序之前，应当整理好思路，设想好一步一步怎样运算或处理，即为“算法”。把它用框图画出来，用一个框表示要完成的一个或几个步骤，它表示工作的流程，称为流程图。它能使人们思路清楚，减少编写程序中的错误。 f.编写程序。 g.程序调试，即试算。一个复杂的程序往往不是一次上机就能通过并得到正确的结果的，需要反复试算修改，才得到正确的可供正式运行的程序。 h.正式运行得到必要的运算结果。 \",\"传统流程图\",\"​ 用图表示的算法就是流程图。流程图是用一些图框来表示各种类型的操作，在框内写出各个步骤，然后用带箭头的线把它们连接起来，以表示执行的先后顺序。用图形表示算法，直观形象，易于理解。\",\"​ 美国国家标准化协会ANSI曾规定了一些常用的流程图符号，为世界各国程序工作者普遍采用。最常用的流程图符号见图。\",\" a.处理框（矩形框），表示一般的处理功能。 b.判断框（菱形框），表示对一个给定的条件进行判断，根据给定的条件是否成立决定如何执行其后的操作。它有一个入口，二个出口。 c.输入输出框（平行四边形框）。 d.起止框（圆弧形框），表示流程开始或结束。 f.连接点（圆圈），用于将画在不同地方的流程线连接起来。如图中有两个以1标志的连接点(在连接点圈中写上“l”)则表示这两个点是连接在一起的，相当于一个点一样。用连接点，可以避免流程线的交叉或过长，使流程图清晰。 g.流程线（指向线），表示流程的路径和方向。 h.注释框, 是为了对流程图中某些框的操作做必要的补充说明，以帮助阅读流程图的人更好地理解流程图的作用。它不是流程图中必要的部分，不反映流程和操作。 \",\"img\",\"​ 流程图不仅可以指导编写程序，而且可以在调试程序中用来检查程序的正确性。如果框图是正确的而结果不对，则按照框图逐步检查程序是很容易发现其错误的。流程图还能作为程序说明书的一部分提供给别人，以便帮助别人理解你编写程序的思路和结构。\",\"泳道图也叫跨职能流程图 ，旨在展示工作流中每个步骤涉及的流程和职能部门。泳道流程图是一种特殊的图表，展示出一个商业过程之间的关系，并展示为那个过程负责的功能板块。泳道流程图专注于价值活动之间的逻辑关系，更好地展示每个价值活动的责任。\",\"泳道图绘制的场景非常清晰： 流程图是描述一个事件过程的步骤，当这个过程涉及许多不同人、不同部门或不同功能区域时，很难跟踪每个步骤的负责人。解决此问题的有效方法是用泳道图把流程图分栏，这样能清晰地了解任务转交的流程。\",\"img\",\"这是一个部门维度的泳道图。该跨职能流程图是展示了商城运营流程和负责各个子流程的功能单位（部门）之间的关系，一栏代表一个职能单位。代表流程中步骤的形状放在负责这些步骤的职能单位相应的一栏中。\",\"一般情况下，可以通过3个维度来确定泳道图类型：\",\"**部门维度：**通过部门或者责任来区分，明确每个部门/人负责完成的任务环节。\",\"**阶段维度：**通过任务阶段来区分。\",\"**活动维度：**在不同的阶段，每一个网格中的活动都应该有相对应的部门来实施。\",\"​\",\"统一建模语言（UML）是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\"]},\"59\":{\"h\":\"用例图\",\"t\":[\"用例图是编写需求说明时经常用到的需求表达方式，用于向开发、测试同事说明需求中用户与系统功能单元之间的关系。\",\"用例图的三大组成元素：参与者、用例、参与者与用例之间的关系。\",\"参与者：不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此参与者可以是人，可以是事物，也可以是时间或其他系统等等。\",\"**用例：**是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定参与者的价值的可观察结果。\",\"关系：参与者与用例之间的关系主要包括关联、归纳（泛化）、包含、拓展和依赖。\",\"接下来将重点讲第三部分：参与者与用例之间的关系，主要分为4中：关联、归纳（泛化）、包含、拓展和依赖。\"]},\"60\":{\"h\":\"1）关联关系\",\"t\":[\"**关系说明：**表示参与者与用例之间的关系\",\"**表示方法：**带箭头的实线，箭头指向用例。\",\"**举例说明：**用户登录系统\",\"img\"]},\"61\":{\"h\":\"2）归纳（泛化）关系\",\"t\":[\"**关系说明：**表示参与者与参与者之间、用例与用例之间的关系。一个用例可以被特别列举为一个或多个子用例，这被称为用例泛化。\",\"**表示方法：**带空心箭头的实线，箭头指向被泛化（被继承）的用例，即基础用例/父用例。（注意：泛化关系的箭头不是指向被泛化，而是指向被继承。泛化和继承是不同的方向。泛化是从下到上的抽象过程，继承是从上到下，从一般到特殊的过程。）\",\"**举例说明：**VIP会员和普通用户，归纳为用户；账号登录与微信登录，也可归纳为登录系统。\",\"img\"]},\"62\":{\"h\":\"3）包含关系\",\"t\":[\"**关系说明：**表示用例与用例之间的关系，其中一个用例（基础用例）的行为包含了另一个用例（包含用例）的行为。\",\"**表示方法：**虚线箭头+include字样，箭头指向被包含的用例\",\"**举例说明：**用户在账号登录过程中，包括输入账号、输入密码、确认登录等操作\",\"img\"]},\"63\":{\"h\":\"4）拓展关系\",\"t\":[\"关系说明：表示用例与用例之间的关系；用于拓展用例对基础用例的增强；拓展用例是在特定条件出现时，才会被执行的用例。\",\"表示方法：虚线箭头+extend字样，箭头指向被扩展的用例（即基础用例）\",\"举例说明：用户在登录过程中忘记了密码\",\"img\"]},\"64\":{\"h\":\"类图\",\"t\":[\"UML类图，UML中的一种重要图形，是在面向对象语言用中用来表示一个类。\",\"如下图所示（它由两部分组成，类，类之间的关系）：\",\"img\"]},\"65\":{\"h\":\"1）类\",\"t\":[\"类是具有相似结构、行为和关系的一组对象的描述符，是面向对象系统中最重要的构造块。\",\"如下图所示，就表示一个类：\",\"img\",\"三个格子从上至下分别表示：\",\"类名称（如果是接口，就使用斜体表示）\",\"类的特性（一般是类的字段和属性，可以没有）\",\"类的操作（一般是类的方法或行为）\",\"它们前边的符号有以下几类：\",\"“+”表示public\",\"“-”表示private\",\"“#”表示protected\"]},\"66\":{\"h\":\"2）类的关系\",\"t\":[\"除了类，类图中还有一个重要元素，即类之间的关系。\",\"根据类的关系的不同，具体可分为6种：\",\"（1）依赖关系（用虚箭线表示）\",\"所谓依赖关系，就是构造这个类的时候，需要依赖其他的类，比如：动物依赖水和氧气。如下图所以：\",\"img\",\"（2）继承、泛化关系（用带空心三角形的实线表示）\",\"继承（泛化）关系，它指定了子类如何特化父类的所有特征和行为。例如：鸟是动物的一种，企鹅、鸭、大雁是鸟的一种。\",\"img\",\"（3）实线关系（用带空心三角形的虚线表示）\",\"一种类与接口的关系，表示类是接口所有特征和行为的实现。它有两种表示方法：\",\"第一种，矩形表示法，\",\"顶端有interface\",\"第一行：接口名称\",\"第二行：接口方法\",\"img\",\"第二种，棒棒糖表示法\",\"圆圈旁为接口名称\",\"接口方法在实现类中出现\",\"img\",\"（4）关联关系（用实箭线表示）\",\"所谓关联关系，就是这个类有一个属性是其他类。\",\"img\",\"（5）聚合关系（用带空心菱形的实线表示）\",\"聚合关系是关联关系的一种，是强的关联关系 ；\",\"特点： 部分对象的生命周期并不由整体对象来管理。也就是说，当整体对象已经不存在的时候，部分的对象还是可能继续存在的。比如：一只大雁脱离了雁群，依然是可以继续存活的。\",\"img\",\"（6）组合关系（用带实心菱形的实线表示）\",\"组合关系同样是关联关系的一种，是比聚合关系还要强的关系。\",\"特点：在组合中，部分与整体生命期一致，部分与组合同时创建并同时消亡 。比如：鸟与翅膀的关系。\",\"img\"]},\"67\":{\"h\":\"对象图\"},\"68\":{\"h\":\"1）对象图概念\",\"t\":[\"对象图是表示在某一时刻一组对象以及它们之间关系的图形。\",\"对于复杂的数据结构，有时候很难对其进行抽象成类表达之间的关系，一般就会使用对象图。\",\"说到对象图，就不得不提到UML的另一种图形——类图，两者几乎使用一套完全相同的标识。不同在于对象图显示类的多个对象实例，而不是实际的类。一个对象图是类图的一个实例。由于对象存在生命周期，因此对象图只能在系统某一时间段存在（这一点从定义上也不难看出）。\"]},\"69\":{\"h\":\"类图和对象图的关系及异同\",\"t\":[\"两者的关系：对象图可以看做是类图的实例，用来表达各个对象在某一时刻的状态。\",\"两者的异同：\",\"​ 类图：用于描述系统中所包含的类以及它们之间的相互关系。\",\"​ 对象图：用于描述某一时刻的一组对象及它们之间的关系。\",\"​ 主要表现为两者建模元素的异同\",\"img\"]},\"70\":{\"h\":\"2）对象图的组成元素\",\"t\":[\"对象图中的建模元素主要有对象和链。\",\"对象\",\"对象是类的实例，是一个封装了状态和行为的实体。对象通过其类型、名称和状态区别于其他对象而存在。\",\"对象名：在矩形框的顶端显示。 类型：具体的类目 状态：由对象的所有属性以及运行时的当前值组成。 表示法：在对象名后跟一个冒号加上类型名，并且使用下划线与类进行区分。\",\"img\",\"链\",\"链是类之间的关联关系的实例，是两个或多个对象之间的独立连接。因此，链在对象图中的作用类似于关联关系在类图中的作用。\",\"之前专栏对UML类图的4种关联关系进行过详细拆解，这里同样不再赘述，有需要的可以移步查看▼\",\"亿图图示：干货！3分钟掌握UML类图zhuanlan.zhihu.com\",\"在对象图中，链同样使用一根实线段来表示。\",\"链主要用来导航。链一端的一个对象可以得到另一位置上的一个或一组对象，然后向其发送消息。\"]},\"71\":{\"h\":\"3）对象图实例\",\"t\":[\"img\"]},\"72\":{\"h\":\"4）对象图的建模过程\",\"t\":[\"对象图的建模过程如下（以亿图图示绘制为例）：\",\"1）确定好对象及对象状态，可以参照相应的类图；\",\"打开亿图图示，依次选择“新建>软件>UML图>+”，新建一张空白画布，画布左侧会自动出现绘制UML所需的符号，选择合适的对象符号，然后拖拽至画布上即可；\",\"img\",\"img\",\"2）建立链（即确定类间的关系），如依赖、泛化、关联和实现；\",\"其实就是连线，选中其中一个对象图形，其边框上会显示蓝边的空心圆，确定连接点后则会变成红色实心圆点，连接起来非常方便。\",\"img\",\"3）针对交互在某特定时刻各对象的状态，使用对象图为这些对象建模；\",\"4）建模时，系统分析师要根据建模的目标，绘制对象的关键状态和关键对象之间的连接关系。\"]},\"73\":{\"h\":\"包图\",\"t\":[\"包图通常用于描述系统的逻辑架构——层、子系统、包等。层可以建模为UML包。UML包用一大一小两个矩形组合而成。如果内部显示了其成员，则包名称标在上面的小矩形内，否则可以标在包内。\",\"img\",\"包拥有的元素**：类、接口、组件、节点、协作、用例、图以及其他包。**包的可见性用来控制包外界的元素对包内元素的可访问权限。这种可见性它分为3种，即公有访问、保护访问和私有访问。\",\"包之间可以有两种关系：依赖、泛化。\"]},\"74\":{\"h\":\"部署图\",\"t\":[\"​ 部署图是用来显示系统中软件和硬件的物理架构。使用部署图不仅可以显示运行时系统的结构，还能够传达构成应用程序的硬件和软件元素的配置和部署方式。\",\"​ 一个系统模型只有一个部署图，它通常用来帮助理解分布式系统。\"]},\"75\":{\"h\":\"1）节点（Node）& 节点实例（Node Instance）\",\"t\":[\"节点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。\",\"一般用立方体表示，如下图：\",\"img\",\"注：处理器是带阴影的立方体，设备是不带阴影的立方体\",\"区别于节点，节点实例的名称会有下划线，并且节点类型前会有冒号（注：冒号前面可以有示例名称也可以没有示例名称），如下图：\",\"img\"]},\"76\":{\"h\":\"2）构件（Artifact）\",\"t\":[\"构件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。\",\"构件表示如下，带有关键字«artifact»和文档图标：\",\"img\"]},\"77\":{\"h\":\"3）连接（Association）\",\"t\":[\"节点之间的连线表示系统之间进行交互的通信路径，这个通信路径称为连接。如下图所示，连接中可以标注上网络协议：\",\"img\"]},\"78\":{\"h\":\"4）部署图实例\",\"t\":[\"img\",\"​ 部署图的组成元素：结点、构件（因此部署图也经常和构件图一起使用）、接口、连接。\",\"img\"]},\"79\":{\"h\":\"顺序图\",\"t\":[\"顺序图，又名序列图、时序图。用于描述对象之间的传递消息的时间顺序（包括发送消息、接收消息、处理消息、返回消息等）。\",\"顺序图的组成元素：对象、生命线、消息，其中消息又分为同步消息、异步消息、返回消息、自关联消息。\"]},\"80\":{\"h\":\"1） 什么是时序图？\",\"t\":[\"时序图是UML交互图中的一类，又名序列图、顺序图。\",\"用于描述对象之间的传递消息的时间顺序（包括发送消息、接收消息、处理消息、返回消息等）。\",\"img\"]},\"81\":{\"h\":\"2） 时序图的组成元素\",\"t\":[\"1）对象\",\"对象代表时序图中的对象在交互中所扮演的角色，一般使用矩形表示。\",\"如果对象位于时序图的顶部，说明在交互开始时对象就已经存在了。如果对象的位置在中间部分，说明对象是在交互的过程中被创建的。*当一个对象被删除或自我删除时，在其生命线*（生命线详见下方）终止点处放置 “ X”标识。\",\"2）生命线\",\"生命线代表时序图中的对象在一段时期内的存在。时序图中每个对象底部中心都有一条垂直的虚线，这就是对象的生命线。\",\"对象间的消息存在于两条虚线间。\",\"3）消息\",\"两个对象之间的单路通信，从发送方指向接收方。\",\"消息的传递一般有以下几种方式：\",\"同步消息：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。\",\"注意：发送人需要等待消息的响应。带实心箭头的实线表示\",\"img\",\"异步消息：消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。\",\"注意：发送人不需要等待消息的响应。带线型箭头的实线表示\",\"img\",\"返回消息：返回消息表示从过程调用返回\",\"带线型箭头的虚线表示。\",\"img\",\"自关联消息： 自身调用自身的方法，即自我调用的同步消息\",\"img\"]},\"82\":{\"h\":\"3） 如何绘制时序图？\",\"t\":[\"时序图绘制具体分为以下5步：\",\"确定交互过程的上下文；\",\"识别参与过程的交互对象；\",\"为每个对象设置生命线；\",\"从初始消息开始，依次画出随后消息；\",\"考虑消息的嵌套，标示消息发生时的时间点。\"]},\"83\":{\"h\":\"流程图、顺序图、状态图他们三者分别解决什么样的问题？\",\"t\":[\"流程图：用于表示完成某件事情中的各个活动过程，其中最重要的部分是“处理 process”单元；\",\"顺序图：用于表示程序执行时各个对象的交互过程（这些对象会按调用时间顺序排序）；\",\"状态图：描述一个特定对象的所有可能状态，以及由于各种事件的发生而引起的状态之间的转移，其最主要的就是程序目前的状态，每一个状态总结记录程序由开始到目前所有接到的输入。\",\"这么描述可能还不够清晰，下面我将从流程图VS顺序图，以及流程图VS状态图，对这三者的优势和局限性作进一步解读：\"]},\"84\":{\"h\":\"流程图 VS 顺序图\",\"t\":[\"这是push流程的一张顺序图：\",\"img\",\"它直观地反应了push程序执行的过程，各个对象之间的调用顺序是怎样的一目了然。\",\"这还属于比较简单的顺序图。如果是下面这类复杂的，甚至一个方法里面有很多分支语句的，那用顺序图肯定是很不好画了。\",\"img\",\"因此，一般情况下分析程序中的方法用流程图更好，它可以很好的反应各种复杂的逻辑。\"]},\"85\":{\"h\":\"流程图 VS 状态图\",\"t\":[\"这是表示电梯运行状态的一张状态图：\",\"状态图：电梯运行的三种状态\",\"如果用流程图来表示上述状态图，就需要做的处理单元比较多，这种情况下状态图明显在结构上要比流程图要更简单。\",\"流程图和状态图的差别在于，流程图更在意动作是如何完成的，状态图更重视动作的完成，相较不在意是哪一个程序完成的。\",\"因此，当状态图中某一个状态下少考虑了哪一个输入事件，我们可以很快地检查出来，但如果在流程图上，我们就无法分辨了。\",\"因此，状态图比较适合对象导向的程序，流程图则比较适合描述程序导向或是数据处理的程序。\"]},\"86\":{\"h\":\"通信图/协作图\",\"t\":[\"通信图描述的是对象和对象之间的调用关系，体现的是一种组织关系。\",\"通信图组成元素：对象、链接、消息。\",\"通信图和时序图有点类似。但时序图着重于时间顺序，而通信图则关注的是对象之间的组织关系，通信图中的时间顺序可以从消息序号中获得。在语义上这两个图是等价的可以互相转换而不会丢失信息。\",\"如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择协作图；这两种图合称为交互图\"]},\"87\":{\"h\":\"状态机图\",\"t\":[\"状态机图描述一个对象在其生命周期中的各种状态以及状态的转换。\",\"状态机主要由状态、转换、事件、动作、活动5部分组成。\",\"顺序图、通信图：描述多个对象间的交互。 状态机图：描述单个对象的状态及引起状态变化的原因。\",\"用一个简化的图来表示三者的差别就是：\",\"img\"]},\"88\":{\"h\":\"活动图\",\"t\":[\"活动图描述活动的顺序，展现从一个活动到另一个活动的控制流，它本质上是一种流程图。\",\"组成元素：起点、终点、活动名称、判断条件、分支与合并、接收信号、发送信号、泳道（其实和流程图很相像）\"]},\"89\":{\"h\":\"什么是E-R图？\",\"t\":[\"E-R图又称实体关系图，是一种提供了实体，属性和联系的方法，用来描述现实世界的概念模型。通俗点讲就是，当我们理解了实际问题的需求之后，需要用一种方法来表示这种需求，概念模型就是用来描述这种需求。\",\"比如学生生活中的校园卡系统数据库、公交卡系统数据库等等，都离不来实体关系图。\",\"img\",\"E-R图中的基本元素（以上面的学生饭卡E-R图为例）：\",\"① 实体\",\"​ 实际问题中客观存在的并且可以相互区别的事物称为实体。实体是现实世界中的对象，可以具体到人，事，物。比如：上图中的饭卡、学生、办公室、食堂、超市。\",\"② 属性\",\"​ 实体所具有的某一个特性称为属性，在E-R图中属性用来描述实体。比如上图中的学生，可以用“姓名”、“院系”、“班级”、“手机号”进行属性描述。\",\"属性\",\"③ 实体集\",\"​ 具有相同属性的实体的集合称为实体集。例如：全体学生就是一个实体集，（983573，李刚，男，2000/12/12）是学生实体集中的一个实体。\",\"④ 键\",\"​ 在描述实体集的所有属性中，可以唯一标识每个实体的属性称为键。键也是属于实体的属性，作为键的属性取值必须唯一且不能“空置”。比如：不重复的学生号，就可以作为学生的“键”。\",\"⑤ 实体型\",\"​ 具有相同的特征和性质的实体一定有相同的属性，用实体名及其属性名集合来抽象和刻画同类实体称为实体型，其表示格式为：实体名（属性1，属性2，……）\",\"⑥ 联系\",\"​ 世界上任何事物都不是孤立存在的，事物内部和事物之间都有联系的，实体之间的联系通常有3种类型：一对一联系，一对多联系，多对多联系。\"]},\"90\":{\"h\":\"E-R图的绘图规范\",\"t\":[\"在ER图中有如下四个成分：\",\"**① 矩形框：**表示实体，在框中记入实体名。\",\"img\",\"**② 菱形框：**表示联系，在框中记入联系名。\",\"img\",\"③ 椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。\",\"img\",\"**④ 连线：**实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N，M。)\",\"img\"]},\"91\":{\"h\":\"E-R图的具体绘制流程\",\"t\":[\"前面了解完E-R图的定义、组成元素以及绘制规范，我们这部分具体介绍E-R图的绘制步骤，大致可以分为以下5步：\",\"确定所有的实体集合；\",\"选择实体集应包含的属性；\",\"确定实体集之间的联系；\",\"确定实体集的关键字，用下划线在属性上表明关键字的属性组合；\",\"确定联系的类型，在用线将表示联系的菱形框联系到实体集时，在线旁注明是1或n(多）来表示联系的类型。\",\"一些精彩的流程图\",\"名称\",\"特点\",\"安装\",\"收费\",\"Visio\",\"office系列，可以和word办公软件结合起来使用，只支持Windows\",\"是\",\"是，标准版永久2638，1设备\",\"XMind\",\"基于java开发，安装包小，多平台支持\",\"是\",\"是，384一年，5设备\",\"MindManager\",\"同Office无缝集成，多平台支持，安装包大\",\"是\",\"是，1081一年，多设备\",\"ProcessOn\",\"方便快捷，优雅强大，文件备份，模板丰富，免费账号只能9个文件\",\"否\",\"是，259元 / 人 / 年\",\"draw.io\",\"支持网页版，持续更新\",\"是\",\"永久免费\",\"推荐使用draw.io\",\" {% btn 'https://github.com/jgraph/drawio-desktop/releases/tag/v14.6.13',客户端下载,far fa-hand-point-right,outline orange larger %} {% btn 'https://app.diagrams.net/',Web端在线编辑,far fa-hand-point-right,outline green larger %} \",\"推荐使用ProcessOn，在线画图快捷方便真的香！！！\"]},\"92\":{\"c\":[\"开发工具\"]},\"93\":{\"c\":[\"UML\"]},\"94\":{\"h\":\"2023年6月\"},\"95\":{\"h\":\"2023年6月5日\",\"t\":[\"今天翻了一下以前的旧相片，发现了一张小七以前的照片，明明在我印象中小七没有太依赖人的时候，小小的真可爱🥰。 这里是图片站位\",\"又看到了一些大学时候的照片，时间过的真快啊，挺让人怀念的，毕竟那个时候的我，真的挺瘦的！！！\",\"感慨万千，不能这么颓废下去了。是时候该改变了。\"]},\"96\":{\"h\":\"MySQL介绍\",\"t\":[\"目前已经更新好的文章：\",\"面试汇总篇👇\",\"基础面试题一\",\"事务面试题\",\"下面的内容本文非原创，转自小林Coding-《图解MySQL》，部分地方结合自己的理解与网上的资料可能有所更改，不做另行说明！\",\"基础篇👇\",\"执行一条 SQL 查询语句，期间发生了什么？\",\"索引篇 👇\",\"索引常见面试题\",\"从数据页的角度看 B+ 树\",\"为什么 MySQL 采用 B+ 树作为索引？\",\"MySQL 单表不要超过 2000W 行，靠谱吗？\",\"索引失效有哪些？\",\"MySQL 使用 like “%x“，索引一定会失效吗？\",\"count(*) 和 count(1) 有什么区别？哪个性能最好？\",\"事务篇 👇\",\"事务隔离级别是怎么实现的？\",\"MySQL 可重复读隔离级别，完全解决幻读了吗？\",\"锁篇 👇\",\"MySQL 有哪些锁？\",\"MySQL 是怎么加锁的？\",\"update 没加索引会锁全表?\",\"MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？\",\"MySQL 死锁了，怎么办？\",\"字节面试：加了什么锁，导致死锁的？\",\"日志篇 👇\",\"undo log、redo log、binlog 有什么用？\",\"内存篇 👇\",\"揭开 Buffer_Pool 的面纱\"]},\"97\":{\"h\":\"Redis食用指南\",\"t\":[\"学习指路\",\"关于Redis的学习，推荐观看B站黑马程序员的Redis教程\",\"本文基于黑马的教程与其他文章进行整理\",\"相应的面试题整理会放在Redis面试题\",\"基础篇👇\",\"redis常用场景\",\"高级篇 👇\",\"分布式缓存：持久化、主从、哨兵、分片集群\",\"多级缓存：浏览器缓存、Nginx缓存、redis缓存、JVM进程缓存\"]},\"98\":{\"h\":\"RapidOcr-Java\",\"t\":[\"此项目已经在github上开源，点击前往查看最新动态\"]},\"99\":{\"h\":\"😺 项目起源\",\"t\":[\"现有的JavaOCR工具包识别效果差强人意，PaddleOCR在实现前沿算法的基础上，考虑精度与速度的平衡，进行模型瘦身和深度优化，使其尽可能满足产业落地需求。\",\"PaddleOCR官方并未提供Java版本，而RapidOcr解决了这个问题，其提供了Kotlin和Java混合版本的Demo-onnx和Demo-ncnn\",\"而实际使用过程中\",\"项目中并不想再引入Kotlin\",\"不想了解OCR相关知识，开箱即用\",\"不想额外再部署OCR服务\",\"因此本项目将Kotlin部分移除，并在此基础上加以完善且提供了更友好的的调用方法，更方便java开发者直接进行使用。\"]},\"100\":{\"h\":\"👏 项目特点\",\"t\":[\"纯Java代码调用RapidOcr\",\"使用ncnn和onnx推理引擎方式，并编写了简单工具类，默认使用Onnx推理方式\",\"均使用CPU版本，GPU版本请自行编译\",\"⚠️ 注意：当前JVM启动时只能同时启动一种推理引擎，以第一次调用runOcr方法时的引擎配置为准\"]},\"101\":{\"h\":\"20 张图彻底弄懂 HTTPS!\"},\"102\":{\"h\":\"前言\",\"t\":[\"近年来各大公司对信息安全传输越来越重视，也逐步把网站升级到 HTTPS 了，那么大家知道 HTTPS 的原理是怎样的吗，到底是它是如何确保信息安全传输的？网上挺多介绍 HTTPS，但我发现总是或多或少有些点有些遗漏，没有讲全，今天试图由浅入深地把 HTTPS 讲明白，相信大家看完一定能掌握 HTTPS 的原理，本文大纲如下：\",\"HTTP 为什么不安全\",\"安全通信的四大原则\",\"HTTPS 通信原理简述\",\"对称加密\",\"数字证书\",\"非对称加密\",\"数字签名\",\"其它 HTTPS 相关问题\"]},\"103\":{\"h\":\"HTTP 为什么不安全\",\"t\":[\"HTTP 由于是明文传输，主要存在三大风险\",\"1、 窃听风险\",\"中间人可以获取到通信内容，由于内容是明文，所以获取明文后有安全风险\",\"img\",\"2、 篡改风险\",\"中间人可以篡改报文内容后再发送给对方，风险极大\",\"img\",\"3、 冒充风险\",\"比如你以为是在和某宝通信，但实际上是在和一个钓鱼网站通信。\",\"img\",\"HTTPS 显然是为了解决这三大风险而存在的，接下来我们看看 HTTPS 到底解决了什么问题。\"]},\"104\":{\"h\":\"安全通信的四大原则\",\"t\":[\"看了上一节，不难猜到 HTTPS 就是为了解决上述三个风险而生的，一般我们认为安全的通信需要包括以下四个原则: 机密性、完整性，身份认证和不可否认\",\"机密性：即对数据加密，解决了窃听风险，因为即使被中间人窃听，由于数据是加密的，他也拿不到明文\",\"完整性：指数据在传输过程中没有被篡改，不多不少，保持原样，中途如果哪怕改了一个标点符号，接收方也能识别出来，从来判定接收报文不合法\",\"身份认证：确认对方的真实身份，即证明「你妈是你妈」的问题，这样就解决了冒充风险，用户不用担心访问的是某宝结果却在和钓鱼网站通信的问题\",\"不可否认: 即不可否认已发生的行为，比如小明向小红借了 1000 元，但没打借条，或者打了借条但没有签名，就会造成小红的资金损失\",\"接下来我们一步步来看看 HTTPS 是如何实现以满足以上四大安全通信原则的。\"]},\"105\":{\"h\":\"HTTPS 通信原理简述\"},\"106\":{\"h\":\"对称加密： HTTPS 的最终加密形式\",\"t\":[\"既然 HTTP 是明文传输的，那我们给报文加密不就行了，既然要加密，我们肯定需要通信双方协商好密钥吧，一种是通信双方使用同一把密钥，即对称加密的方式来给报文进行加解密。\",\"img\",\"如图示：使用对称加密的通信双方使用同一把密钥进行加解密。\",\"对称加密具有加解密速度快，性能高的特点，也是 HTTPS 最终采用的加密形式，但是这里有一个关键问题，对称加密的通信双方要使用同一把密钥，这个密钥是如何协商出来的？如果通过报文的方式直接传输密钥，之后的通信其实还是在裸奔，因为这个密钥会被中间人截获甚至替换掉，这样中间人就可以用截获的密钥解密报文，甚至替换掉密钥以达到篡改报文的目的。\",\"img\",\"有人说对这个密钥加密不就完了，但对方如果要解密这个密钥还是要传加密密钥给对方，依然还是会被中间人截获的，这么看来直接传输密钥无论怎样都无法摆脱俄罗斯套娃的难题，是不可行的。\"]},\"107\":{\"h\":\"非对称加密：解决单向对称密钥的传输问题\",\"t\":[\"直接传输密钥无论从哪一端传从上节分析来看是不行了，这里我们再看另一种加密方式：非对称加密。\",\"非对称加密即加解密双方使用不同的密钥，一把作为公钥，可以公开的，一把作为私钥，不能公开，公钥加密的密文只有私钥可以解密，私钥加密的内容，也只有公钥可以解密。\",\"**注：私钥加密其实这个说法其实并不严谨，准确的说私钥加密应该叫私钥签名，因为私密加密的信息公钥是可以解密的，而公钥是公开的，任何人都可以拿到，用公钥解密叫做验签 **\",\"这样的话对于 server 来说，保管好私钥，发布公钥给其他 client, 其他 client 只要把对称加密的密钥加密传给 server 即可，如此一来由于公钥加密只有私钥能解密，而私钥只有 server 有，所以能保证 client 向 server 传输是安全的，server 解密后即可拿到对称加密密钥，这样交换了密钥之后就可以用对称加密密钥通信了。\",\"img\",\"但是问题又来了， server 怎么把公钥安全地传输给 client 呢。如果直接传公钥，也会存在被中间人调包的风险。\",\"img\"]},\"108\":{\"h\":\"数字证书，解决公钥传输信任问题\",\"t\":[\"如何解决公钥传输问题呢，从现实生活中的场景找答案，员工入职时，企业一般会要求提供学历证明，显然不是什么阿猫阿狗的本本都可称为学历，这个学历必须由** 第三方权威机构（Certificate Authority，简称 CA）**即教育部颁发，同理，server 也可以向 CA 申请证书，在证书中附上公钥 ，然后将证书传给 client，证书由站点管理者向 CA 申请，申请的时候会提交 DNS 主机名等信息，CA 会根据这些信息生成证书\",\"img\",\"这样当 client 拿到证书后，就可以获得证书上的公钥，再用此公钥加密对称加密密钥传给 server 即可，看起来确实很完美，不过在这里大家要考虑两个问题\",\"问题一、 如何验证证书的真实性，如何防止证书被篡改\",\"想象一下上文中我们提到的学历，企业如何认定你提供的学历证书是真是假呢，答案是用学历编号，企业拿到证书后用学历编号在学信网上一查就知道证书真伪了，学历编号其实就是我们常说的数字签名，可以防止证书造假。\",\"回到 HTTPS 上，证书的数字签名该如何产生的呢，一图胜千言\",\"img\",\"步骤如下 1、 首先使用一些摘要算法（如 MD5）将证书明文（如证书序列号，DNS主机名等）生成摘要，然后再用第三方权威机构的私钥对生成的摘要进行加密（签名）\",\"消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法，无论输入的消息有多长，计算出来的消息摘要的长度总是固定的，一般来说，只要内容不同，产生的摘要必然不同（相同的概率可以认为接近于 0），所以可以验证内容是否被篡改了。\",\"为啥要先生成摘要再加密呢，不能直接加密？\",\"因为使用非对称加密是非常耗时的，如果把整个证书内容都加密生成签名的话，客户端验验签也需要把签名解密，证书明文较长，客户端验签就需要很长的时间，而用摘要的话，会把内容很长的明文压缩成小得多的定长字符串，客户端验签的话就会快得多。\",\"2、客户端拿到证书后也用同样的摘要算法对证书明文计算摘要，两者一笔对就可以发现报文是否被篡改了，那为啥要用第三方权威机构（Certificate Authority，简称 CA）私钥对摘要加密呢，因为摘要算法是公开的，中间人可以替换掉证书明文，再根据证书上的摘要算法计算出摘要后把证书上的摘要也给替换掉！这样 client 拿到证书后计算摘要发现一样，误以为此证书是合法就中招了。所以必须要用 CA 的私钥给摘要进行加密生成签名，这样的话 client 得用 CA 的公钥来给签名解密，拿到的才是未经篡改合法的摘要（私钥签名，公钥才能解密）\",\"server 将证书传给 client 后，client 的验签过程如下\",\"img\",\"这样的话，由于只有 CA 的公钥才能解密签名，如果客户端收到一个假的证书，使用 CA 的公钥是无法解密的，如果客户端收到了真的证书，但证书上的内容被篡改了，摘要比对不成功的话，客户端也会认定此证书非法。\",\"细心的你一定发现了问题，CA 公钥如何安全地传输到 client ？如果还是从 server 传输到 client，依然无法解决公钥被调包的风险，*实际上此公钥是存在于 CA 证书上，而此证书（也称 Root CA 证书）被操作系统信任，内置在操作系统上的，无需传输*，如果用的是 Mac 的同学，可以打开 keychain 查看一下，可以看到很多内置的被信任的证书。\",\"img\",\"server 传输 CA 颁发的证书，客户中收到证书后使用内置 CA 证书中的公钥来解密签名，验签即可，这样的话就解决了公钥传输过程中被调包的风险。\",\"问题二、 如何防止证书被调包\",\"实际上任何站点都可以向第三方权威机构申请证书，中间人也不例外。\",\"img\",\"正常站点和中间人都可以向 CA 申请证书，获得认证的证书由于都是 CA 颁发的，所以都是合法的，那么此时中间人是否可以在传输过程中将正常站点发给 client 的证书替换成自己的证书呢，如下所示\",\"img\",\"答案是不行，因为客户端除了通过验签的方式验证证书是否合法之外，还需要验证证书上的域名与自己的请求域名是否一致 ，中间人中途虽然可以替换自己向 CA 申请的合法证书，但此证书中的域名与 client 请求的域名不一致，client 会认定为不通过！\",\"但是上面的证书调包给了我们一种思路，什么思路？大家想想， HTTPS 既然是加密的， charles 这些「中间人」为啥能抓到明文的包呢，其实就是用了证书调包这一手法，想想看，在用 charles 抓 HTTPS 的包之前我们先要做什么，当然是安装 charles 的证书\",\"img\",\"这个证书里有 charles 的公钥，这样的话 charles 就可以将 server 传给 client 的证书调包成自己的证书，client 拿到后就可以用你安装的 charles 证书来验签等，验证通过之后就会用 charles 证书中的公钥来加密对称密钥了，整个流程如下\",\"img\",\"由此可知，charles 这些中间人能抓取 HTTPS 包的前提是信任它们的 CA 证书，然后就可以通过替换证书的方式进行瞒天过海，所以我们千万不要随便信任第三方的证书，避免安全风险。\"]},\"109\":{\"h\":\"其它 HTTPS 相关问题\",\"t\":[\"什么是双向认证 以上的讲述过程中，我们只是在 client 端验证了 server 传输证书的合法性，但 server 如何验证 client 的合法性，还是用证书，我们在网上进行转账等操作时，想想看是不是要先将银行发给我们的 U 盾插到电脑上？其实也是因为 U 盾内置了证书，通信时将证书发给 server，server 验证通过之后即可开始通信。 画外音：身份认证只是 U 盾功能的一种，还有其他功能，比如加解密都是在 U 盾中执行，保证了密钥不会出现在内存中\",\"什么是证书信任链\",\"前文说了，我们可以向 CA 申请证书，但全世界的顶级 CA（Root CA） 就那么几个，每天都有很多人要向它申请证书，它也忙不过来啊，怎么办呢，想想看在一个公司里如果大家都找 CEO 办事，他是不是要疯了，那他能怎么办？授权，他会把权力交给 CTO，CFO 等，这样你们只要把 CTO 之类的就行了，CTO 如果也忙不过来呢，继续往下授权啊。\",\"img\",\"同样的，既然顶级 CA 忙不过来，那它就向下一级，下下级 CA 授权即可，这样我们就只要找一级/二级/三级 CA 申请证书即可。怎么证明这些证书被 Root CA 授权过了呢，小一点的 CA 可以让大一点的 CA 来签名认证，比如一级 CA 让 Root CA 来签名认证，二级 CA 让一级 CA 来签名认证,Root CA 没有人给他签名认证，只能自己证明自己了，这个证书就叫「自签名证书」或者「根证书」，我们必须信任它，不然证书信任链是走不下去的（这个根证书前文我们提过，其实是是内置在操作系统中的）\",\"img\",\"现在我们看看如果站点申请的是 二级 CA 颁发的证书，client 收到之后会如何验证这个证书呢，实际上 service 传了传给二级 CA 的证书外，还会把证书信任链也一起传给客户端，这样客户端会按如下步骤进行验证：\",\"浏览器就使用信任的根证书（根公钥）解析证书链的根证书得到一级证书的公钥+摘要验签\",\"拿一级证书的公钥解密一级证书，拿到二级证书的公钥和摘要验签\",\"再然后拿二级证书的公钥解密 server 传过来的二级证书，得到服务器的公钥和摘要验签，验证过程就结束了\"]},\"110\":{\"h\":\"总结\",\"t\":[\"相信大家看完本文应该对 HTTPS 的原理有了很清楚的认识了， HTTPS 无非就是 HTTP + SSL/TLS\",\"img\",\"而 SSL/TLS 的功能其实本质上是如何协商出安全的对称加密密钥以利用此密钥进行后续通讯的过程 ，带着这个疑问相信你不难理解数字证书和数字签名这两个让人费解的含义，搞懂了这些也就明白了为啥 HTTPS 是加密的，charles 这些工具却能抓包出明文来。\",\"巨人的肩膀\",\"https://juejin.cn/post/6844903958863937550\",\"https://showme.codes/2017-02-20/understand-https/\",\"极客时间，透视 HTTP 协议\",\"https://zhuanlan.zhihu.com/p/67199487\",\"本文转自知乎：https://zhuanlan.zhihu.com/p/328636728\"]},\"111\":{\"c\":[\"Java\"]},\"112\":{\"c\":[\"network\"]},\"113\":{\"h\":\"2.1 进程与线程\"},\"114\":{\"h\":\"2.1.1 进程的概念、组成、特征\"},\"115\":{\"h\":\"2.1.2 进程的状态与转换、进程的组织\"},\"116\":{\"h\":\"2.1.3 进程控制\"},\"117\":{\"h\":\"基本概念\",\"t\":[\"进程控制就是要实现进程状态的转换\",\"进程控制用原语实现：进程控制用的程序段称为原语\"]},\"118\":{\"h\":\"相关原语\",\"t\":[\"进程的创建\",\"进程的终止\",\"进程的阻塞\",\"进程的唤醒\",\"进程的切换\"]},\"119\":{\"h\":\"2.1.4 进程通信\"},\"120\":{\"h\":\"为什么进程通信需要操作系统支持？\",\"t\":[\"进程是分配系统资源的单位，各进程拥有独立的内存地址空间，为了保证安全，一个进程不能直接访问另一个进程的地址空间。\"]},\"121\":{\"h\":\"通信方式\"},\"122\":{\"h\":\"1.共享存储\",\"t\":[\"基于数据结构的共享：低级的共享方式，速度慢，限制多\",\"基于存储区的共享：高级共享方式，灵活性高，速度快\"]},\"123\":{\"h\":\"2.消息传递\",\"t\":[\"进程间的数据交换是以格式化的消息为单位的。\",\"直接通信方式：消息发送进程指明接收进程的ID\",\"间接通信方式：通过“信箱”间接地通信，又成信箱通信方式\"]},\"124\":{\"h\":\"3.管道通信\",\"t\":[\"管道，是指用于连接一个读进程和一个写进程，以实现他们之间的通信的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区\",\"从管道读数据是一次性操作，数据一旦被读取，它就从管道中被抛弃\",\"管道变空时，下次的读数据将会被阻塞，等待数据被写入；同理，当管道写满时，写进程将阻塞，等待数据被读走\",\"管道只能采用半双工通信\",\"各进程要互斥访问管道（由操作系统实现）\"]},\"125\":{\"h\":\"2.1.5 线程概念\"},\"126\":{\"h\":\"什么是线程？为什么要引入线程？\",\"t\":[\"引入进程的目的是：更好的使多道程序并发执行，提高资源利用率和系统吞吐量；\",\"引入线程的目的是：增加并发度\"]},\"127\":{\"h\":\"引入线程后的变化\"},\"128\":{\"h\":\"线程的属性\"},\"129\":{\"h\":\"2.1.6 线程的实现方式和多线程模型\"},\"130\":{\"h\":\"线程的实现方式\",\"t\":[\"用户级线程（ULT） \",\"优点：不需要变态\",\"缺点：其中一个用户级线程被阻塞后，整个进程都被阻塞\",\"内核级线程（KLT） \",\"优点：其中一个用户级线程被阻塞后，别的线程还可以继续执行\",\"缺点：需要变态\"]},\"131\":{\"h\":\"多线程模型\",\"t\":[\"一对一模型\",\"多对一模型\",\"多对多模型\"]},\"132\":{\"h\":\"2.1.7 线程的状态与转换\"},\"133\":{\"h\":\"2.2 处理机调度\"},\"134\":{\"h\":\"2.2.1 调度的概念、层次\",\"t\":[\"处理机调度是对处理机进行分配\",\"高级调度：又称作业调度\",\"中级调度\",\"低级调度\"]},\"135\":{\"h\":\"2.2.2 进程调度的时机\",\"t\":[\"进程调度的方式\",\"非剥夺调度方式\",\"剥夺调度方式\"]},\"136\":{\"h\":\"2.2.4 调度的基本准则\"},\"137\":{\"h\":\"执行一条 select 语句，期间发生了什么？\",\"t\":[\"学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：\",\"// 在 product 表中，查询 id = 1 的记录 select * from product where id = 1; \",\"但是有没有想过，MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？\",\"带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次小林就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。\"]},\"138\":{\"h\":\"MySQL 执行流程是怎样的？\",\"t\":[\"先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。\",\"查询语句执行流程\",\"可以看到， MySQL 的架构共分为两层：Server 层和存储引擎层，\",\"Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。\",\"存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。\",\"好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。\"]},\"139\":{\"h\":\"第一步：连接器\",\"t\":[\"如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：\",\"# -h 指定 MySQL 服务的 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数； # -u 指定用户名，管理员角色名为 root； # -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码 mysql -h$ip -u$user -p \",\"连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：\",\"如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个\\\"Access denied for user\\\"的错误，然后客户端程序结束执行。\",\"如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。\",\"所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\",\"如何查看 MySQL 服务被多少个客户端连接了？\",\"如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 show processlist 命令进行查看。\",\"比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 Sleep ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。\",\"空闲连接会一直占用着吗？\",\"当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。\",\"mysql> show variables like 'wait_timeout'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 28800 | +---------------+-------+ 1 row in set (0.00 sec) \",\"当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。\",\"mysql> kill connection +6; Query OK, 0 rows affected (0.00 sec) \",\"一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。\",\"MySQL 的连接数有限制吗？\",\"MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。\",\"mysql> show variables like 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 151 | +-----------------+-------+ 1 row in set (0.00 sec) \",\"MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：\",\"// 短连接 连接 mysql 服务（TCP 三次握手） 执行sql 断开 mysql 服务（TCP 四次挥手） // 长连接 连接 mysql 服务（TCP 三次握手） 执行sql 执行sql 执行sql .... 断开 mysql 服务（TCP 四次挥手） \",\"可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。\",\"但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。\",\"怎么解决长连接占用内存的问题？\",\"有两种解决方式。\",\"第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。\",\"第二种，客户端主动重置连接。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\",\"至此，连接器的工作做完了，简单总结一下：\",\"与客户端进行 TCP 三次握手建立连接；\",\"校验客户端的用户名和密码，如果用户名或密码不对，则会报错；\",\"如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；\"]},\"140\":{\"h\":\"第二步：查询缓存\",\"t\":[\"连接器的工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。\",\"如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。\",\"如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。\",\"这么看，查询缓存还挺有用，但是其实查询缓存挺鸡肋的。\",\"对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。\",\"所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。\",\"对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。\",\"提示\",\"这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。\"]},\"141\":{\"h\":\"第三步：解析 SQL\",\"t\":[\"在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。\"]},\"142\":{\"h\":\"解析器\",\"t\":[\"解析器会做如下两件事情。\",\"第一件事情，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。\",\"第二件事情，语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。\",\"如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。\",\"但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。\",\"那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了。\"]},\"143\":{\"h\":\"第四步：执行 SQL\",\"t\":[\"经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条SELECT 查询语句流程主要可以分为下面这三个阶段：\",\"prepare 阶段，也就是预处理阶段；\",\"optimize 阶段，也就是优化阶段；\",\"execute 阶段，也就是执行阶段；\"]},\"144\":{\"h\":\"预处理器\",\"t\":[\"我们先来说说预处理阶段做了什么事情。\",\"检查 SQL 查询语句中的表或者字段是否存在；\",\"将 select * 中的 * 符号，扩展为表上的所有列；\",\"我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。\",\"mysql> select * from test; ERROR 1146 (42S02): Table 'mysql.test' doesn't exist \",\"这里贴个 MySQL 8.0 源码来证明表或字段是否存在的判断，不是在解析器里做的，而是在 prepare 阶段。（PS：下图是公众号「一树一溪」老哥帮我分析的，这位老哥专门写 MySQL 源码文章，感兴趣的朋友，可以微信搜索关注）\",\"上面的中间部分是 MySQL 报错表不存在时的函数调用栈，可以看到表不存在的错误是在get_table_share() 函数里报错的，而这个函数是在 prepare 阶段调用的。\",\"不过，对于 MySQL 5.7 判断表或字段是否存在的工作，是在词法分析&语法分析之后，prepare 阶段之前做的。结论都一样，不是在解析器里做的。代码我就不放了，正因为 MySQL 5.7 代码结构不好，所以 MySQL 8.0 代码结构变化很大，后来判断表或字段是否存在的工作就被放入到 prepare 阶段做了。\"]},\"145\":{\"h\":\"优化器\",\"t\":[\"经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。\",\"优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。\",\"当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。\",\"要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 explain 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 PRIMARY 就是使用了主键索引。\",\"如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：\",\"这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。\",\"这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：\",\"select id from product where id > 1 and name like 'i%'; \",\"这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。\",\"很显然这条查询语句是覆盖索引，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。\",\"在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。\"]},\"146\":{\"h\":\"执行器\",\"t\":[\"经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以数据行为单位的。\",\"接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。\",\"主键索引查询\",\"全表扫描\",\"索引下推\"]},\"147\":{\"h\":\"主键索引查询\",\"t\":[\"以本文开头查询语句为例，看看执行器是怎么工作的。\",\"select * from product where id = 1; \",\"这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：\",\"执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id = 1 交给存储引擎，让存储引擎定位符合条件的第一条记录。\",\"存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；\",\"执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。\",\"执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。\",\"至此，这个语句就执行完成了。\"]},\"148\":{\"h\":\"全表扫描\",\"t\":[\"举个全表扫描的例子：\",\"select * from product where name = 'iphone'; \",\"这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：\",\"执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录；\",\"执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户端（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。\",\"执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；\",\"一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；\",\"执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。\",\"至此，这个语句就执行完成了。\"]},\"149\":{\"h\":\"索引下推\",\"t\":[\"在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。\",\"索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。\",\"举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：\",\"现在有下面这条查询语句：\",\"select * from t_user where age > 20 and reward = 100000; \",\"联合索引当遇到范围查询 (>、<) 就会停止匹配，也就是 age 字段能用到联合索引，但是 reward 字段则无法利用到索引 。具体原因这里可以看这篇：索引常见面试题\",\"那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：\",\"Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；\",\"存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后进行回表操作，将完整的记录返回给 Server 层；\",\"Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；\",\"接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；\",\"如此往复，直到存储引擎把表中的所有记录读完。\",\"可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。\",\"而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：\",\"Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；\",\"存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。\",\"Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。\",\"如此往复，直到存储引擎把表中的所有记录读完。\",\"可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。\",\"当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。\"]},\"150\":{\"h\":\"总结\",\"t\":[\"执行一条 SQL 查询语句，期间发生了什么？\",\"连接器：建立连接，管理连接、校验用户身份；\",\"查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；\",\"解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；\",\"执行 SQL：执行 SQL 共有三个阶段： \",\"预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。\",\"优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；\",\"执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；\",\"怎么样？现在再看这张图，是不是很清晰了。\",\"查询语句执行流程\",\"完！\",\"参考资料：\",\"《MySQL 45 讲》\",\"《MySQL是怎样运行的：从根儿上理解MySQL》\",\"https://gohalo.me/post/mysql-executor.html\",\"http://www.iskm.org/mysql56/sql__executor_8cc_source.html\",\"https://tangocc.github.io/2018/10/11/mysql-sourcecode/\"]},\"151\":{\"h\":\"MySQL 一行记录是怎么存储的？\",\"t\":[\"之前有位读者在面字节的时候，被问到这么个问题：\",\"如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。\",\"如果你不知道也没关系，这次我跟大家聊聊 MySQL 一行记录是怎么存储的？\",\"知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题：\",\"MySQL 的 NULL 值会占用空间吗？\",\"MySQL 怎么知道 varchar(n) 实际占用数据的大小？\",\"varchar(n) 中 n 最大取值为多少？\",\"行溢出后，MySQL 是怎么处理的？\",\"这些问题看似毫不相干，其实都是在围绕「 MySQL 一行记录的存储结构」这一个知识点，所以攻破了这个知识点后，这些问题就引刃而解了。\",\"好了，话不多说，发车！\"]},\"152\":{\"h\":\"MySQL 的数据存放在哪个文件？\",\"t\":[\"大家都知道 MySQL 的数据都是保存在磁盘的，那具体是保存在哪个文件呢？\",\"MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。\",\"InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。\",\"先来看看 MySQL 数据库的文件存放在哪个目录？\",\"mysql> SHOW VARIABLES LIKE 'datadir'; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.00 sec) \",\"我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。\",\"比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。\",\"然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？\",\"[root@monster~]#ls /var/lib/mysql/my_test db.opt t_order.frm t_order.ibd \",\"可以看到，共有三个文件，这三个文件分别代表着：\",\"db.opt，用来存储当前数据库的默认字符集和字符校验规则。\",\"t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。\",\"t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。\",\"好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。\"]},\"153\":{\"h\":\"表空间文件的结构是怎么样的？\",\"t\":[\"表空间由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB存储引擎的逻辑存储结构大致如下图：\",\"下面我们从下往上一个个看看。\"]},\"154\":{\"h\":\"1、行（row）\",\"t\":[\"数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。\",\"后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。\"]},\"155\":{\"h\":\"2、页（page）\",\"t\":[\"记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。\",\"因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。\",\"默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。\",\"页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。\",\"页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章：换一个角度看 B+ 树\",\"总之知道表中的记录存储在「数据页」里面就行。\"]},\"156\":{\"h\":\"3、区（extent）\",\"t\":[\"我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。\",\"B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。\",\"解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。\",\"那具体怎么解决呢？\",\"在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。\"]},\"157\":{\"h\":\"4、段（segment）\",\"t\":[\"表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。\",\"索引段：存放 B + 树的非叶子节点的区的集合；\",\"数据段：存放 B + 树的叶子节点的区的集合；\",\"回滚段：存放的是回滚数据的区的集合，之前讲事务隔离的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。\",\"好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。\",\"之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。\"]},\"158\":{\"h\":\"InnoDB 行格式有哪些？\",\"t\":[\"行格式（row_format），就是一条记录的存储结构。\",\"InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。\",\"Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。\",\"由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。\",\"Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。\",\"Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。\",\"所以，弄懂了 Compact 行格式，之后你们在去了解其他行格式，很快也能看懂。\"]},\"159\":{\"h\":\"COMPACT 行格式长什么样？\",\"t\":[\"先跟 Compact 行格式混个脸熟，它长这样：\",\"可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。\",\"接下里，分别详细说下。\"]},\"160\":{\"h\":\"记录的额外信息\",\"t\":[\"记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。\"]},\"161\":{\"h\":\"1. 变长字段长度列表\",\"t\":[\"varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。\",\"所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。\",\"为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：\",\"CREATE TABLE `t_user` ( `id` int(11) NOT NULL, `name` VARCHAR(20) DEFAULT NULL, `phone` VARCHAR(20) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT; \",\"现在 t_user 表里有这三条记录：\",\"接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。\",\"先来看第一条记录：\",\"name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；\",\"phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；\",\"age 列和 id 列不是变长字段，所以这里不用管。\",\"这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。\",\"同样的道理，我们也可以得出第二条记录的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：\",\"第三条记录中 phone 列的值是 NULL，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。\",\"为什么「变长字段长度列表」的信息要按照逆序存放？\",\"这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。\",\"「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。\",\"同样的道理， NULL 值列表的信息也需要逆序存放。\",\"如果你不知道什么是 CPU Cache，可以看这篇文章 ，这属于计算机组成的知识。\",\"每个数据库表的行格式都有「变长字段字节数列表」吗？\",\"其实变长字段字节数列表不是必须的。\",\"当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了 ，因为没必要，不如去掉以节省空间。\",\"所以「变长字段长度列表」只出现在数据表有变长字段的时候。\"]},\"162\":{\"h\":\"2. NULL 值列表\",\"t\":[\"表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。\",\"如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。\",\"二进制位的值为1时，代表该列的值为NULL。\",\"二进制位的值为0时，代表该列的值不为NULL。\",\"另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 0。\",\"还是以 t_user 表的这三条记录作为例子：\",\"接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。\",\"先来看第一条记录，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：\",\"但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：\",\"所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。\",\"接下来看第二条记录，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。\",\"最后第三条记录，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。\",\"我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：\",\"每个数据库表的行格式都有「NULL 值列表」吗？\",\"NULL 值列表也不是必须的。\",\"当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。\",\"所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。\",\"「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？\",\"「NULL 值列表」的空间不是固定 1 字节的。\",\"当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。\"]},\"163\":{\"h\":\"3. 记录头信息\",\"t\":[\"记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：\",\"delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。\",\"next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。\",\"record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录\"]},\"164\":{\"h\":\"记录的真实数据\",\"t\":[\"记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。\",\"row_id\",\"如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。\",\"trx_id\",\"事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。\",\"roll_pointer\",\"这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。\",\"如果你熟悉 MVCC 机制，你应该就清楚 trx_id 和 roll_pointer 的作用了，如果你还不知道 MVCC 机制，可以看完这篇文章，一定要掌握，面试也很经常问 MVCC 是怎么实现的。\"]},\"165\":{\"h\":\"varchar(n) 中 n 最大取值为多少？\",\"t\":[\"我们要清楚一点，MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。\",\"也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。\",\"知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」\",\"varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。\",\"要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。\"]},\"166\":{\"h\":\"单字段的情况\",\"t\":[\"前面我们知道了，一行记录最大只能存储 65535 字节的数据。\",\"那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？\",\"不着急说结论，我们先来做个实验验证一下。\",\"我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。\",\"CREATE TABLE test ( `name` VARCHAR(65535) NULL ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT; \",\"看能不能成功创建一张表：\",\"可以看到，创建失败了。\",\"从报错信息就可以知道一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead。\",\"问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。\",\"这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：\",\"真实数据\",\"真实数据占用的字节数\",\"NULL 标识，如果不允许为NULL，这部分不需要\",\"本次案例中，「NULL 值列表」所占用的字节数是多少？\",\"前面我创建表的时候，字段是允许为 NULL 的，所以会用 1 字节来表示「NULL 值列表」。\",\"本次案例中，「变长字段长度列表」所占用的字节数是多少？\",\"「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。\",\"所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：\",\"条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；\",\"条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；\",\"我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。\",\"因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节。\",\"因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532。\",\"我们先来测试看看 varchar(65533) 是否可行？\",\"可以看到，还是不行，接下来看看 varchar(65532) 是否可行？\",\"可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\",\"当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：\",\"在 UTF-8 字符集下，一个字符串最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。\",\"上面所说的只是针对于一个字段的计算方式。\"]},\"167\":{\"h\":\"多字段的情况\",\"t\":[\"如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。\",\"这里举个多字段的情况的例子（感谢@Emoji同学提供的例子）\"]},\"168\":{\"h\":\"行溢出后，MySQL 是怎么处理的？\",\"t\":[\"MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384字节，而一个 varchar(n) 类型的列最多可以存储 65532字节，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会*发生行溢出，多的数据就会存到另外的「溢出页」中*。\",\"如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。\",\"当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。\",\"上面这个是 Compact 行格式在发生行溢出后的处理。\",\"Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。\",\"这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：\"]},\"169\":{\"h\":\"总结\",\"t\":[\"MySQL 的 NULL 值是怎么存放的？\",\"MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。\",\"NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。\",\"MySQL 怎么知道 varchar(n) 实际占用数据的大小？\",\"MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。\",\"varchar(n) 中 n 最大取值为多少？\",\"一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。\",\"如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。\",\"计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。\",\"如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。\",\"行溢出后，MySQL 是怎么处理的？\",\"如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。\",\"Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。\",\"Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。\",\"参考资料：\",\"《MySQL 是怎样运行的》\",\"《MySQL技术内幕 InnoDB存储引擎》\"]},\"170\":{\"h\":\"\",\"t\":[\"buffer poll、Change Buffer、Adaptive Hash Index、Change Buffer、Doublewrite Buffer 正在赶稿的路上。。。。。\"]},\"171\":{\"h\":\"揭开 Buffer Pool  的面纱\",\"t\":[\"今天就聊 MySQL 的 Buffer Pool，发车！\"]},\"172\":{\"h\":\"为什么要有 Buffer Pool？\",\"t\":[\"虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。\",\"要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。\",\"为此，Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\",\"有了缓冲池后：\",\"当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。\",\"当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。\"]},\"173\":{\"h\":\"Buffer Pool 有多大？\",\"t\":[\"Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 128MB 。\",\"可以通过调整 innodb_buffer_pool_size 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。\"]},\"174\":{\"h\":\"Buffer Pool 缓存什么？\",\"t\":[\"InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。\",\"在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。\",\"所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。\",\"Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。\",\"为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个控制块 ，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。\",\"控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：\",\"上图中控制块和缓存页之间灰色部分称为碎片空间。\",\"为什么会有碎片空间呢？\",\"你想想啊，每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，自然就用不到喽，这个用不到的那点儿内存空间就被称为碎片了。\",\"当然，如果你把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。\",\"查询一条记录，就只需要缓冲一条记录吗？\",\"不是的。\",\"当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。\",\"关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案：换一个角度看 B+ 树\"]},\"175\":{\"h\":\"如何管理 Buffer Pool？\"},\"176\":{\"h\":\"如何管理空闲页？\",\"t\":[\"Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。\",\"那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。\",\"所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 Free 链表 （空闲链表）。\",\"Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。\",\"Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。\",\"有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。\"]},\"177\":{\"h\":\"如何管理脏页？\",\"t\":[\"设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为脏页，然后再由后台线程将脏页写入到磁盘。\",\"那为了能快速知道哪些缓存页是脏的，于是就设计出 Flush 链表，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。\",\"有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。\"]},\"178\":{\"h\":\"如何提高缓存命中率？\",\"t\":[\"Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。\",\"要实现这个，最容易想到的就是 LRU（Least recently used）算法。\",\"该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。\",\"简单的 LRU 算法的实现思路是这样的：\",\"当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。\",\"当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。\",\"比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。\",\"如果访问了 3 号的页，因为 3 号页在 Buffer Pool 里，所以把 3 号页移动到头部即可。\",\"而如果接下来，访问了 8 号页，因为 8 号页不在 Buffer Pool 里，所以需要先淘汰末尾的 5 号页，然后再将 8 号页加入到头部。\",\"到这里我们可以知道，Buffer Pool 里有三种页和链表来管理数据。\",\"图中：\",\"Free Page（空闲页），表示此页未被使用，位于 Free 链表；\",\"Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。\",\"Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。\",\"简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：\",\"预读失效；\",\"Buffer Pool 污染；\",\"什么是预读失效？\",\"先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。\",\"所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。\",\"但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是预读失效。\",\"如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。\",\"如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。\",\"怎么解决预读失效而导致缓存命中率降低的问题？\",\"我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。\",\"要避免预读失效带来影响，最好就是让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长。\",\"那到底怎么才能避免呢？\",\"MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：old 区域 和 young 区域。\",\"young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：\",\"old 区域占整个 LRU 链表长度的比例可以通过 innodb_old_blocks_pct 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。\",\"划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部 。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。\",\"接下来，给大家举个例子。\",\"假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 30 %。\",\"现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。\",\"如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。\",\"如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。\",\"虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 Buffer Pool 污染的问题。\",\"什么是 Buffer Pool 污染？\",\"当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。\",\"注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。\",\"比如，在一个数据量非常大的表，执行了这条语句：\",\"select * from t_user where name like \\\"%xiaolin%\\\"; \",\"可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：\",\"从磁盘读到的页加入到 LRU 链表的 old 区域头部；\",\"当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；\",\"接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；\",\"如此往复，直到扫描完表中的所有记录。\",\"经过这一番折腾，原本 young 区域的热点数据都会被替换掉。\",\"举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。\",\"在批量访问这些数据的时候，会被逐一插入到 young 区域头部。\",\"可以看到，原本在 young 区域的热点数据 6 和 7 号页都被淘汰了，这就是 Buffer Pool 污染的问题。\",\"怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？\",\"像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。\",\"LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。\",\"MySQL 是这样做的，进入到 young 区域条件增加了一个停留在 old 区域的时间判断。\",\"具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：\",\"如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；\",\"如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；\",\"这个间隔时间是由 innodb_old_blocks_time 控制的，默认是 1000 ms。\",\"也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，这样就解决了 Buffer Pool 污染的问题 。\",\"另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。\"]},\"179\":{\"h\":\"脏页什么时候会被刷入磁盘？\",\"t\":[\"引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。\",\"因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。\",\"可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？\",\"这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。\",\"下面几种情况会触发脏页的刷新：\",\"当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；\",\"Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；\",\"MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；\",\"MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；\",\"在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。\",\"如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。\"]},\"180\":{\"h\":\"总结\",\"t\":[\"Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\",\"Buffer Pool 以页为单位缓冲数据，可以通过 innodb_buffer_pool_size 参数调整缓冲池的大小，默认是 128 M。\",\"Innodb 通过三种链表来管理缓页：\",\"Free List （空闲页链表），管理空闲页；\",\"Flush List （脏页链表），管理脏页；\",\"LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；\",\"InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：\",\"将 LRU 链表 分为young 和 old 两个区域，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。\",\"当**「页被访问」且「 old 区域停留时间超过 innodb_old_blocks_time 阈值（默认为1秒）」**时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。\",\"可以通过调整 innodb_old_blocks_pct 参数，设置 young 区域和 old 区域比例。\",\"在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。\"]},\"181\":{\"h\":\"MySQL 单表不要超过 2000W 行，靠谱吗？\",\"t\":[\"作为在后端圈开车的多年老司机，是不是经常听到过：\",\"“MySQL 单表最好不要超过 2000W”\",\"“单表超过 2000W 就要考虑数据迁移了”\",\"“你这个表数据都马上要到 2000W 了，难怪查询速度慢”\",\"这些名言民语就和 “群里只讨论技术，不开车，开车速度不要超过 120 码，否则自动踢群”，只听过，没试过，哈哈。\",\"下面我们就把车速踩到底，干到 180 码试试…….\",\"原文链接：https://my.oschina.net/u/4090830/blog/5559454\"]},\"182\":{\"h\":\"实验\",\"t\":[\"实验一把看看… 建一张表\",\"CREATE TABLE person( id int NOT NULL AUTO_INCREMENT PRIMARY KEY comment '主键', person_id tinyint not null comment '用户id', person_name VARCHAR(200) comment '用户名称', gmt_create datetime comment '创建时间', gmt_modified datetime comment '修改时间' ) comment '人员信息表'; \",\"插入一条数据\",\"insert into person values(1, 1,'user_1', NOW(), now()); \",\"利用 MySQL 伪列 rownum 设置伪列起始点为 1\",\"select (@i:=@i+1) as rownum, person_name from person, (select @i:=100) as init; set @i=1; \",\"运行下面的 sql，连续执行 20 次，就是 2 的 20 次方约等于 100w 的数据；执行 23 次就是 2 的 23 次方约等于 800w , 如此下去即可实现千万测试数据的插入。\",\"如果不想翻倍翻倍的增加数据，而是想少量，少量的增加，有个技巧，就是在 SQL 的后面增加 where 条件，如 id > 某一个值去控制增加的数据量即可。\",\"insert into person(id, person_id, person_name, gmt_create, gmt_modified) select @i:=@i+1, left(rand()*10,10) as person_id, concat('user_',@i%2048), date_add(gmt_create,interval + @i*cast(rand()*100 as signed) SECOND), date_add(date_add(gmt_modified,interval +@i*cast(rand()*100 as signed) SECOND), interval + cast(rand()*1000000 as signed) SECOND) from person; \",\"此处需要注意的是，也许你在执行到近 800w 或者 1000w 数据的时候，会报错：The total number of locks exceeds the lock table size。\",\"这是由于你的临时表内存设置的不够大，只需要扩大一下设置参数即可。\",\"SET GLOBAL tmp_table_size =512*1024*1024; （512M） SET global innodb_buffer_pool_size= 1*1024*1024*1024 (1G); \",\"先来看一组测试数据，这组数据是在 MySQL 8.0 的版本，并且是在我本机上，由于本机还跑着 idea , 浏览器等各种工具，所以并不是机器配置就是用于数据库配置，所以测试数据只限于参考。\",\"图片\",\"图片\",\"看到这组数据似乎好像真的和标题对应，当数据达到 2000W 以后，查询时长急剧上升，难道这就是铁律吗？\",\"那下面我们就来看看这个建议值 2000W 是怎么来的？\"]},\"183\":{\"h\":\"单表数量限制\",\"t\":[\"首先我们先想想数据库单表行数最大多大？\",\"CREATE TABLE person( id int(10) NOT NULL AUTO_INCREMENT PRIMARY KEY comment '主键', person_id tinyint not null comment '用户id', person_name VARCHAR(200) comment '用户名称', gmt_create datetime comment '创建时间', gmt_modified datetime comment '修改时间' ) comment '人员信息表'; \",\"看看上面的建表 sql。id 是主键，本身就是唯一的，也就是说主键的大小可以限制表的上限：\",\"如果主键声明 int 类型，也就是 32 位，那么支持 2^32-1 ~~21 亿；\",\"如果主键声明 bigint 类型，那就是 2^62-1 （36893488147419103232），难以想象这个的多大了，一般还没有到这个限制之前，可能数据库已经爆满了！！\",\"有人统计过，如果建表的时候，自增字段选择无符号的 bigint , 那么自增长最大值是 18446744073709551615，按照一秒新增一条记录的速度，大约什么时候能用完？\",\"图片\"]},\"184\":{\"h\":\"表空间\",\"t\":[\"下面我们再来看看索引的结构，我们下面讲内容都是基于 Innodb 引擎的，大家都知道 Innodb 的索引内部用的是 B+ 树。\",\"图片\",\"这张表数据，在硬盘上存储也是类似如此的，它实际是放在一个叫 person.ibd （innodb data）的文件中，也叫做表空间；虽然数据表中，他们看起来是一条连着一条，但是实际上在文件中它被分成很多小份的数据页，而且每一份都是 16K。\",\"大概就像下面这样，当然这只是我们抽象出来的，在表空间中还有段、区、组等很多概念，但是我们需要跳出来看。\",\"图片\"]},\"185\":{\"h\":\"页的数据结构\",\"t\":[\"实际页的内部结构像是下面这样的：\",\"图片\",\"从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。\",\"在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 User Records 部分。\",\"但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分。\",\"当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。\",\"这个过程的图示如下：\",\"图片\",\"刚刚上面说到了数据的新增的过程。\",\"那下面就来说说，数据的查找过程，假如我们需要查找一条记录，我们可以把表空间中的每一页都加载到内存中，然后对记录挨个判断是不是我们想要的。\",\"在数据量小的时候，没啥问题，内存也可以撑。但是现实就是这么残酷，不会给你这个局面。\",\"为了解决这问题，MySQL 中就有了索引的概念，大家都知道索引能够加快数据的查询，那到底是怎么个回事呢？下面我就来看看。\"]},\"186\":{\"h\":\"索引的数据结构\",\"t\":[\"在 MySQL 中索引的数据结构和刚刚描述的页几乎是一模一样的，而且大小也是 16K,。\",\"但是在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息，从 0 开始往上算，所以页与页之间就有了上下层级的概念。\",\"图片\",\"看到这个图之后，是不是有点似曾相似的感觉，是不是像一棵二叉树啊，对，没错！它就是一棵树。\",\"只不过我们在这里只是简单画了三个节点，2 层结构的而已，如果数据多了，可能就会扩展到 3 层的树，这个就是我们常说的 B+ 树，最下面那一层的 page level =0, 也就是叶子节点，其余都是非叶子节点。\",\"图片\",\"看上图中，我们是单拿一个节点来看，首先它是一个非叶子节点（索引页），在它的内容区中有 id 和 页号地址两部分：\",\"id ：对应页中记录的最小记录 id 值；\",\"页号：地址是指向对应页的指针；\",\"而数据页与此几乎大同小异，区别在于数据页记录的是真实的行数据而不是页地址，而且 id 的也是顺序的。\"]},\"187\":{\"h\":\"单表建议值\",\"t\":[\"下面我们就以 3 层，2 分叉（实际中是 M 分叉）的图例来说明一下查找一个行数据的过程。\",\"图片\",\"比如说我们需要查找一个 id=6 的行数据：\",\"因为在非叶子节点中存放的是页号和该页最小的 id，所以我们从顶层开始对比，首先看页号 10 中的目录，有 [id=1, 页号 = 20],[id=5, 页号 = 30], 说明左侧节点最小 id 为 1，右侧节点最小 id 是 5。6>5, 那按照二分法查找的规则，肯定就往右侧节点继续查找；\",\"找到页号 30 的节点后，发现这个节点还有子节点（非叶子节点），那就继续比对，同理，6>5 && 6<7, 所以找到了页号 60；\",\"找到页号 60 之后，发现此节点为叶子节点（数据节点），于是将此页数据加载至内存进行一一对比，结果找到了 id=6 的数据行。\",\"从上述的过程中发现，我们为了查找 id=6 的数据，总共查询了三个页，如果三个页都在磁盘中（未提前加载至内存），那么最多需要经历三次的磁盘 IO。\",\"需要注意的是，图中的页号只是个示例，实际情况下并不是连续的，在磁盘中存储也不一定是顺序的。\",\"至此，我们大概已经了解了表的数据是怎么个结构了，也大概知道查询数据是个怎么的过程了，这样我们也就能大概估算这样的结构能存放多少数据了。\",\"从上面的图解我们知道 B+ 数的叶子节点才是存在数据的，而非叶子节点是用来存放索引数据的。\",\"所以，同样一个 16K 的页，非叶子节点里的每条数据都指向新的页，而新的页有两种可能\",\"如果是叶子节点，那么里面就是一行行的数据\",\"如果是非叶子节点的话，那么就会继续指向新的页\",\"假设\",\"非叶子节点内指向其他页的数量为 x\",\"叶子节点内能容纳的数据行数为 y\",\"B+ 数的层数为 z\",\"如下图中所示，Total =x^(z-1) *y 也就是说总数会等于 x 的 z-1 次方 与 Y 的乘积。\",\"图片\",\"X =？\",\"在文章的开头已经介绍了页的结构，索引也也不例外，都会有 File Header (38 byte)、Page Header (56 Byte)、Infimum + Supermum（26 byte）、File Trailer（8byte）, 再加上页目录，大概 1k 左右。\",\"我们就当做它就是 1K, 那整个页的大小是 16K, 剩下 15k 用于存数据，在索引页中主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。\",\"所以 x=15*1024/12≈1280 行。\",\"Y=？\",\"叶子节点和非叶子节点的结构是一样的，同理，能放数据的空间也是 15k。\",\"但是叶子节点中存放的是真正的行数据，这个影响的因素就会多很多，比如，字段的类型，字段的数量。每行数据占用空间越大，页中所放的行数量就会越少。\",\"这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000 ≈15。\",\"算到这边了，是不是心里已经有谱了啊。\",\"根据上述的公式，Total =x^(z-1) *y，已知 x=1280，y=15：\",\"假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200\",\"假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）\",\"哎呀，妈呀！这不是正好就是文章开头说的最大行数建议值 2000W 嘛！对的，一般 B+ 数的层级最多也就是 3 层。\",\"你试想一下，如果是 4 层，除了查询的时候磁盘 IO 次数会增加，而且这个 Total 值会是多少，大概应该是 3 百多亿吧，也不太合理，所以，3 层应该是比较合理的一个值。\",\"到这里难道就完了？\",\"不。\",\"我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 那么单个数据页最多只能放下 3 条数据。\",\"同样，还是按照 z = 3 的值来计算，那 Total = （1280 ^2） *3 = 4915200 （近 500w）\",\"所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。\",\"MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。\",\"但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。\"]},\"188\":{\"h\":\"总结\",\"t\":[\"MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。\",\"页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。\",\"在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。\",\"索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。\"]},\"189\":{\"h\":\"count(*) 和 count(1) 有什么区别？哪个性能最好？\",\"t\":[\"当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，但是 count 函数传入的参数有很多种，比如 count(1) 、count(*)、count(字段) 等。\",\"到底哪种效率是最好的呢？是不是 count(*) 效率最差？\",\"我曾经以为 count(*) 是效率最差的，因为认知上 selete * from t 会读取所有表中的字段，所以凡事带有 * 字符的就觉得会读取表中所有的字段，当时网上有很多博客也这么说。\",\"但是，当我深入 count 函数的原理后，被啪啪啪的打脸了！\",\"不多说， 发车！\",\"图片\"]},\"190\":{\"h\":\"哪种 count 性能最好？\",\"t\":[\"我先直接说结论：\",\"图片\",\"要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。\"]},\"191\":{\"h\":\"count() 是什么？\",\"t\":[\"count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。\",\"假设 count() 函数的参数是字段名，如下：\",\"select count(name) from t_order; \",\"这条语句是统计「 t_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。\",\"再来假设 count() 函数的参数是数字 1 这个表达式，如下：\",\"select count(1) from t_order; \",\"这条语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。\",\"1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录。\"]},\"192\":{\"h\":\"count(主键字段) 执行过程是怎样的？\",\"t\":[\"在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。\",\"server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。\",\"InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。\",\"用下面这条语句作为例子：\",\"//id 为主键值 select count(id) from t_order; \",\"如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。\",\"图片\",\"但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。\",\"图片\",\"这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。\"]},\"193\":{\"h\":\"count(1) 执行过程是怎样的？\",\"t\":[\"用下面这条语句作为例子：\",\"select count(1) from t_order; \",\"如果表里只有主键索引，没有二级索引时。\",\"图片\",\"那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，但是不会读取记录中的任何字段的值，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。\",\"可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count( 主键字段) 高一点。\",\"但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。\",\"图片\"]},\"194\":{\"h\":\"count(*) 执行过程是怎样的？\",\"t\":[\"看到 * 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？\",\"对于 select * 这条语句来说是这个意思，但是在 count(*) 中并不是这个意思。\",\"count(*) 其实等于 count(0)，也就是说，当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。\",\"图片\",\"所以，count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异。\",\"在 MySQL 5.7 的官方手册中有这么一句话：\",\"InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.\",\"翻译：InnoDB以相同的方式处理SELECT COUNT（*）和SELECT COUNT（1）操作，没有性能差异。\",\"而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。\",\"只有当没有二级索引的时候，才会采用主键索引来进行统计。\"]},\"195\":{\"h\":\"count(字段) 执行过程是怎样的？\",\"t\":[\"count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。\",\"用下面这条语句作为例子：\",\"// name不是索引，普通字段 select count(name) from t_order; \",\"对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。\",\"图片\"]},\"196\":{\"h\":\"小结\",\"t\":[\"count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。\",\"所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。\",\"再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。\"]},\"197\":{\"h\":\"为什么要通过遍历的方式来计数？\",\"t\":[\"你可能会好奇，为什么 count 函数需要通过遍历的方式来统计记录个数？\",\"我前面将的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。\",\"使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。\",\"而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。\",\"举个例子，假设表 t_order 有 100 条记录，现在有两个会话并行以下语句：\",\"图片\",\"在会话 A 和会话 B的最后一个时刻，同时查表 t_order 的记录总个数，可以发现，显示的结果是不一样的。所以，在使用 InnoDB 存储引擎时，就需要扫描表来统计具体的记录。\",\"而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。\"]},\"198\":{\"h\":\"如何优化 count(*)？\",\"t\":[\"如果对一张大表经常用 count(*) 来做统计，其实是很不好的。\",\"比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 select count(*) from t_order 要花费差不多 5 秒！\",\"图片\",\"面对大表的记录统计，我们有没有什么其他更好的办法呢？\"]},\"199\":{\"h\":\"第一种，近似值\",\"t\":[\"如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。\",\"图片\",\"这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。\",\"执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。\",\"图片\"]},\"200\":{\"h\":\"第二种，额外表保存计数值\",\"t\":[\"如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。\",\"当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。\"]},\"201\":{\"h\":\"索引常见面试题\",\"t\":[\"面试中，MySQL 索引相关的问题基本都是一系列问题，都是先从索引的基本原理，再到索引的使用场景，比如：\",\"索引底层使用了什么数据结构和算法？\",\"为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？\",\"什么时候适用索引？\",\"什么时候不需要创建索引？\",\"什么情况下索引会失效？\",\"有什么优化索引的方法？\",\".....\",\"今天就带大家，夯实 MySQL 索引的知识点。\"]},\"202\":{\"h\":\"什么是索引？\",\"t\":[\"当你想查阅书中某个知识的内容，你会选择一页一页的找呢？还是在书的目录去找呢？\",\"傻瓜都知道时间是宝贵的，当然是选择在书的目录去找，找到后再翻到对应的页。书中的目录，就是充当索引 的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。\",\"那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。\",\"所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。\",\"下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：\"]},\"203\":{\"h\":\"索引的分类\",\"t\":[\"你知道索引有哪些吗？大家肯定都能霹雳啪啦地说出聚簇索引、主键索引、二级索引、普通索引、唯一索引、hash索引、B+树索引等等。\",\"然后再问你，你能将这些索引分一下类吗？可能大家就有点模糊了。其实，要对这些索引进行分类，要清楚这些索引的使用和实现方式，然后再针对有相同特点的索引归为一类。\",\"我们可以按照四个角度来分类索引。\",\"按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。\",\"按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。\",\"按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。\",\"按「字段个数」分类：单列索引、联合索引。\",\"接下来，按照这些角度来说说各类索引的特点。\"]},\"204\":{\"h\":\"按数据结构分类\",\"t\":[\"从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。\",\"每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。\",\"InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。\",\"在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：\",\"如果有主键，默认会使用主键作为聚簇索引的索引键（key）；\",\"如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；\",\"在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；\",\"其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引 **。\",\"为了让大家理解 B+Tree 索引的存储和查询的过程，接下来我通过一个简单例子，说明一下 B+Tree 索引在存储数据中的具体实现。\",\"先创建一张商品表，id 为主键，如下：\",\"CREATE TABLE `product` ( `id` int(11) NOT NULL, `product_no` varchar(20) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `price` decimal(10, 2) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; \",\"商品表里，有这些行数据：\",\"这些行数据，存储在 B+Tree 索引时是长什么样子的？\",\"B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放 的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。\",\"主键索引的 B+Tree 如图所示：\",\"主键索引 B+Tree\"]},\"205\":{\"h\":\"通过主键查询商品数据的过程\",\"t\":[\"比如，我们执行了下面这条查询语句，这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：\",\"将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；\",\"在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；\",\"在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。\",\"数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。\",\"B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。\"]},\"206\":{\"h\":\"通过二级索引查询商品数据的过程\",\"t\":[\"主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：\",\"主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；\",\"二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。\",\"我这里将前面的商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图，其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。\",\"二级索引 B+Tree\",\"如果我用 product_no 二级索引查询商品，如下查询语句：\",\"select * from product where product_no = '0002'; \",\"会先检查二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。如下图：\",\"回表\",\"不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再去主键索引中查寻了，比如下面这条查询语句：\",\"select id from product where product_no = '0002'; \",\"这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。\"]},\"207\":{\"h\":\"为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？\",\"t\":[\"前面已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？\",\"之前我也专门写过一篇文章，想详细了解的可以看这篇：「女朋友问我：为什么 MySQL 喜欢 B+ 树？我笑着画了 20 张图 」，这里就简单做个比对。\",\"1、B+Tree vs B Tree\",\"B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。\",\"另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。\",\"2、B+Tree vs 二叉树\",\"对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。\",\"在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。\",\"而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。\",\"3、B+Tree vs Hash\",\"Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。\",\"但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。\"]},\"208\":{\"h\":\"按物理存储分类\",\"t\":[\"从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。\",\"这两个区别在前面也提到了：\",\"主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；\",\"二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。\",\"所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。\"]},\"209\":{\"h\":\"按字段特性分类\",\"t\":[\"从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。\"]},\"210\":{\"h\":\"主键索引\",\"t\":[\"主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。\",\"在创建表时，创建主键索引的方式如下：\",\"CREATE TABLE table_name ( .... PRIMARY KEY (index_column_1) USING BTREE ); \"]},\"211\":{\"h\":\"唯一索引\",\"t\":[\"唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。\",\"在创建表时，创建唯一索引的方式如下：\",\"CREATE TABLE table_name ( .... UNIQUE KEY(index_column_1,index_column_2,...) ); \",\"建表后，如果要创建唯一索引，可以使用这面这条命令：\",\"CREATE UNIQUE INDEX index_name ON table_name(index_column_1,index_column_2,...); \"]},\"212\":{\"h\":\"普通索引\",\"t\":[\"普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。\",\"在创建表时，创建普通索引的方式如下：\",\"CREATE TABLE table_name ( .... INDEX(index_column_1,index_column_2,...) ); \",\"建表后，如果要创建普通索引，可以使用这面这条命令：\",\"CREATE INDEX index_name ON table_name(index_column_1,index_column_2,...); \"]},\"213\":{\"h\":\"前缀索引\",\"t\":[\"前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。\",\"使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。\",\"在创建表时，创建前缀索引的方式如下：\",\"CREATE TABLE table_name( column_list, INDEX(column_name(length)) ); \",\"建表后，如果要创建前缀索引，可以使用这面这条命令：\",\"CREATE INDEX index_name ON table_name(column_name(length)); \"]},\"214\":{\"h\":\"按字段个数分类\",\"t\":[\"从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。\",\"建立在单列上的索引称为单列索引，比如主键索引；\",\"建立在多列上的索引称为联合索引；\"]},\"215\":{\"h\":\"联合索引\",\"t\":[\"通过将多个字段组合成一个索引，该索引就被称为联合索引。\",\"比如，将商品表中的 product_no 和 name 字段组合成联合索引 (product_no, name)，创建联合索引的方式如下：\",\"CREATE INDEX index_product_no_name ON product(product_no, name); \",\"联合索引 (product_no, name) 的 B+Tree 示意图如下：\",\"联合索引\",\"可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。\",\"也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。\",\"因此，使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。\",\"比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：\",\"where a=1；\",\"where a=1 and b=2 and c=3；\",\"where a=1 and b=2；\",\"需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。\",\"但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:\",\"where b=2；\",\"where c=3；\",\"where b=2 and c=3；\",\"上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\",\"我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：\",\"可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行where b = 2 这种查询条件没有办法利用联合索引的，利用索引的前提是索引里的 key 是有序的。\",\"只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。\"]},\"216\":{\"h\":\"联合索引范围查询\",\"t\":[\"联合索引有一些特殊情况，并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询 ，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。\",\"这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。*也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引*。\",\"范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？\",\"接下来，举例几个范围查例子。\",\"Q1: select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\",\"由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。\",\"但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的：\",\"a 字段值为 5 的记录，该记录的 b 字段值为 8；\",\"a 字段值为 6 的记录，该记录的 b 字段值为 10；\",\"a 字段值为 7 的记录，该记录的 b 字段值为 5；\",\"因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。\",\"所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。\",\"因此，Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。\",\"我们也可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，通过 key_len 我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件。\",\"举例个例子 ，a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 这条查询语句执行计划如下，可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，说明 Q1 查询语句使用了 idx_a_b 联合索引。\",\"通过 Q1 查询语句我们可以知道，a 字段使用了 > 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ >）后就停止匹配了，因此 b 字段并没有使用到联合索引。\",\"Q2: select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\",\"Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。\",\"由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 >= 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a>= 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。\",\"虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。\",\"于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。\",\"所以，Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。\",\"我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。\",\"通过 Q2 查询语句我们可以知道，虽然 a 字段使用了 >= 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ >=）后就停止匹配了，b 字段还是可以用到了联合索引的。\",\"Q3: SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\",\"Q3 查询条件中 a BETWEEN 2 AND 8 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and <）。\",\"这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。\",\"我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。\",\"通过 Q3 查询语句我们可以知道，虽然 a 字段使用了 BETWEEN 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ BETWEEN）后就停止匹配了，b 字段还是可以用到了联合索引的。\",\"Q4: SELECT * FROM t_user WHERE name like 'j%' and age = 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？\",\"由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。\",\"所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。注意， j 是闭区间。如下图：\",\"虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。\",\"于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 name = 'j' and age = 22 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：\",\"所以，Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。\",\"我们也可以在执行计划中的 key_len 知道这一点。本次例子中：\",\"name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2，也就是 name 的 key_len 为 122。\",\"age 字段的类型是 int 且不为 NULL，key_len 为 4。\",\"Q4 查询语句的执行计划如下，可以看到 key_len 为 126 字节，name 的 key_len 为 122，age 的 key_len 为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 name 和 age 字段都用到了联合索引进行索引查询。\",\"通过 Q4 查询语句我们可以知道，虽然 name 字段使用了 like 前缀匹配进行范围查询，但是联合索引的最左匹配原则并没有在遇到 name 字段的范围查询（ like 'j%'）后就停止匹配了，age 字段还是可以用到了联合索引的。\",\"综上所示，联合索引的最左匹配原则，在遇到范围查询（如 >、< ）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、< =、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了。\"]},\"217\":{\"h\":\"索引下推\",\"t\":[\"现在我们知道，对于联合索引（a, b），在执行 select * from table where a > 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？\",\"在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。\",\"而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数 **。\",\"当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。\"]},\"218\":{\"h\":\"索引区分度\",\"t\":[\"另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中*建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到*。\",\"区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：\",\"区分度计算公式\",\"比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。\",\"因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是\\\"30%\\\"）很高的时候，它一般会忽略索引，进行全表扫描。\"]},\"219\":{\"h\":\"联合索引进行排序\",\"t\":[\"这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？\",\"select * from order where status = 1 order by create_time asc \",\"有的同学会认为，单独给 status 建立一个索引就可以了。\",\"但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。\",\"因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。\",\"所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。\"]},\"220\":{\"h\":\"什么时候需要 / 不需要创建索引？\",\"t\":[\"索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：\",\"需要占用物理空间，数量越大，占用空间越大；\",\"创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；\",\"会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。\",\"所以，索引不是万能钥匙，它也是根据场景来使用的。\"]},\"221\":{\"h\":\"什么时候适用索引？\",\"t\":[\"字段有唯一性限制的，比如商品编码；\",\"经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。\",\"经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。\"]},\"222\":{\"h\":\"什么时候不需要创建索引？\",\"t\":[\"WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。\",\"字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。\",\"表数据太少的时候，不需要创建索引；\",\"经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。\"]},\"223\":{\"h\":\"有什么优化索引的方法？\",\"t\":[\"这里说一下几种常见优化索引的方法：\",\"前缀索引优化；\",\"覆盖索引优化；\",\"主键索引最好是自增的；\",\"防止索引失效；\"]},\"224\":{\"h\":\"前缀索引优化\",\"t\":[\"前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？\",\"使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\",\"不过，前缀索引有一定的局限性，例如：\",\"order by 就无法使用前缀索引；\",\"无法把前缀索引用作覆盖索引；\"]},\"225\":{\"h\":\"覆盖索引优化\",\"t\":[\"覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。\",\"假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？\",\"我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。\",\"所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。\"]},\"226\":{\"h\":\"主键索引最好是自增的\",\"t\":[\"我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？\",\"InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。\",\"如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。\",\"如果我们使用非自增主键 ，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。\",\"举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：\",\"出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。\",\"而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：\",\"因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。\",\"另外，主键字段的长度不要太大，因为**主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小 **。\"]},\"227\":{\"h\":\"索引最好设置为 NOT NULL\",\"t\":[\"为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：\",\"第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。\",\"第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式COMPACT，会用 1 字节空间存储 NULL 值列表，如下图的黄色部分：\"]},\"228\":{\"h\":\"防止索引失效\",\"t\":[\"用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。\",\"我之前写过索引失效的文章，想详细了解的可以去看这篇文章：谁还没碰过索引失效呢?\",\"这里简单说一下，发生索引失效的情况：\",\"当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；\",\"当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；\",\"联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。\",\"在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\",\"我上面说的是常见的索引失效场景，实际过程中，可能会出现其他的索引失效场景，这时我们就需要查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。\",\"如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。\",\"对于执行计划，参数有：\",\"possible_keys 字段表示可能用到的索引；\",\"key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；\",\"key_len 表示索引的长度；\",\"rows 表示扫描的数据行数。\",\"type 表示数据扫描类型，我们需要重点看这个。\",\"type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：\",\"All（全表扫描）；\",\"index（全索引扫描）；\",\"range（索引范围扫描）；\",\"ref（非唯一索引扫描）；\",\"eq_ref（唯一索引扫描）；\",\"const（结果只有一条的主键或唯一索引扫描）。\",\"在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。\",\"range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，属于范围查找。*从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式*。\",\"ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。\",\"eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。\",\"const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id=1。\",\"需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。\",\"除了关注 type，我们也要关注 extra 显示的结果。\",\"这里说几个重要的参考指标：\",\"Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。\",\"Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。\",\"Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。\"]},\"229\":{\"h\":\"总结\",\"t\":[\"这次主要介绍了索引的原理、分类和使用。我把重点总结在了下面这个表格\",\"完！\"]},\"230\":{\"h\":\"MySQL 使用 like “%x“，索引一定会失效吗？\",\"t\":[\"昨天发了一篇关于索引失效的文章：谁还没碰过索引失效呢\",\"我在文末留了一个有点意思的思考题：\",\"图片\",\"这个思考题其实是出自于，我之前这篇文章「一条 SQL 语句引发的思考 」中留言区一位读者朋友出的问题。\",\"很多读者都在留言区说了自己的想法，也有不少读者私聊我答案到底是什么？\",\"所以，我今晚就跟大家聊聊这个思考题。\"]},\"231\":{\"h\":\"题目一\",\"t\":[\"题目一很简单，相信大家都能分析出答案，我昨天分享的索引失效文章里也提及过。\",\"题目 1 的数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段。\",\"图片\",\"这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：\",\"图片\",\"而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。\",\"图片\"]},\"232\":{\"h\":\"题目二\",\"t\":[\"题目 2 的数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。\",\"图片\",\"针对题目 2 的数据表，第一条和第二条模糊查询语句也是一样可以走索引扫描，第二条查询语句的执行计划如下，Extra 里的 Using index 说明用上了覆盖索引：\",\"图片\",\"我们来看一下第三条查询语句的执行计划（第四条也是一样的结果）：\",\"图片\",\"从执行计划的结果中，可以看到 key=index_name，也就是说用上了二级索引，而且从 Extra 里的 Using index 说明用上了覆盖索引。\",\"这是为什么呢？\",\"首先，这张表的字段没有「非索引」字段，所以 select * 相当于 select id,name，然后这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。\",\"但是执行计划里的 type 是 index，这代表着是通过全扫描二级索引的 B+ 树的方式查询到数据的，也就是遍历了整颗索引树。\",\"而第一和第二条查询语句的执行计划中 type 是 range，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，通过查询比较的方式，快速定位到了数据行。\",\"所以，type=range 的查询效率会比 type=index 的高一些。\",\"为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？\",\"因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。\",\"再加上，这个 select * 不用执行回表操作。\",\"所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。\",\"为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？\",\"加了其他字段后，select * from t_user where name like \\\"%xx\\\"; 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。\",\"所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。\",\"从这个思考题我们知道了，使用左模糊匹配（like \\\"%xx\\\"）并不一定会走全表扫描，关键还是看数据表中的字段。\",\"如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树( type=index)。\",\"再说一个相似，我们都知道联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树( type=index)，比如下图：\",\"图片\",\"就说到这了，下次见啦\"]},\"233\":{\"h\":\"索引失效有哪些？\",\"t\":[\"在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。\",\"但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。\",\"稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低。\",\"今天就来跟大家盘一盘，常见的 6 种会发生索引失效的场景。\",\"不仅会用实验案例给大家说明，也会清楚每个索引失效的原因。\",\"发车！\",\"图片\"]},\"234\":{\"h\":\"索引存储结构长什么样？\",\"t\":[\"我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。\",\"索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。\",\"MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构，至于为什么选择 B+ 树作为索引的数据结构 ，详细的分析可以看我这篇文章：为什么 MySQL 喜欢 B+ 树？\",\"在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。\",\"MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。\",\"虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：\",\"InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；\",\"MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；\",\"接下来，我举个例子，给大家展示下这两种存储引擎的索引存储结构的区别。\",\"这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。\",\"图片\",\"如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：\",\"图片\",\"如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示：\",\"图片\",\"InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。\",\"如果将 name 字段设置为普通索引，那么这个二级索引长下图这样，叶子节点仅存放主键值。\",\"图片\",\"知道了 InnoDB 存储引擎的聚簇索引和二级索引的存储结构后，接下来举几个查询语句，说下查询过程是怎么选择用哪个索引类型的。\",\"在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：\",\"// id 字段为主键索引 select * from t_user where id=1; \",\"在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：\",\"先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；\",\"然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。\",\"上面这个过程叫做回表，如下面这条语句：\",\"// name 字段为二级索引 select * from t_user where name=\\\"林某\\\"; \",\"在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做覆盖索引。如下面这条语句：\",\"// name 字段为二级索引 select id from t_user where name=\\\"林某\\\"; \",\"上面这些查询语句的条件都用到了索引列，所以在查询过程都用上了索引。\",\"但是并不意味着，查询条件用上了索引列，就查询过程就一定都用上索引，接下来我们再一起看看哪些情况会导致索引失效，而发生全表扫描。\",\"首先说明下，下面的实验案例，我使用的 MySQL 版本为 8.0.26。\"]},\"235\":{\"h\":\"对索引使用左或者左右模糊匹配\",\"t\":[\"当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。\",\"比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type=ALL 就代表了全表扫描，而没有走索引。\",\"// name 字段为二级索引 select * from t_user where name like '%林'; \",\"图片\",\"如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type=range 表示走索引扫描，key=index_name 看到实际走了 index_name 索引：\",\"// name 字段为二级索引 select * from t_user where name like '林%'; \",\"图片\",\"为什么 like 关键字左或者左右模糊匹配无法走索引呢？\",\"因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。\",\"举个例子，下面这张二级索引图，是以 name 字段有序排列存储的。\",\"图片\",\"假设我们要查询 name 字段前缀为「林」的数据，也就是 name like '林%'，扫描索引的过程：\",\"首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；\",\"节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；\",\"节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。\",\"如果使用 name like '%林' 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。\",\"想要更详细了解 InnoDB 的 B+ 树查询过程，可以看我写的这篇：B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？\"]},\"236\":{\"h\":\"对索引使用函数\",\"t\":[\"有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。\",\"比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：\",\"// name 为二级索引 select * from t_user where length(name)=6; \",\"图片\",\"为什么对索引使用函数，就无法走索引了呢？\",\"因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\",\"不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\",\"举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。\",\"alter table t_user add key idx_name_length ((length(name))); \",\"然后我再用下面这条查询语句，这时候就会走索引了。\",\"图片\"]},\"237\":{\"h\":\"对索引进行表达式计算\",\"t\":[\"在查询条件中对索引进行表达式计算，也是无法走索引的。\",\"比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：\",\"explain select * from t_user where id + 1 = 10; \",\"图片\",\"但是，如果把查询语句的条件改成 where id = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。\",\"图片\",\"为什么对索引进行表达式计算，就无法走索引了呢？\",\"原因跟对索引使用函数差不多。\",\"因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。\",\"有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 = 10 变成 id = 10 - 1。\",\"是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。\",\"我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。\"]},\"238\":{\"h\":\"对索引隐式类型转换\",\"t\":[\"如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。\",\"我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。\",\"图片\",\"然后我在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。\",\"select * from t_user where phone = 1300000001; \",\"图片\",\"但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。\",\"我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。\",\" explain select * from t_user where id = '1'; \",\"图片\",\"为什么第一个例子会导致索引失效，而第二例子不会呢？\",\"要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。\",\"我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” > 9 的结果来知道MySQL 的数据类型转换规则是什么：\",\"如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；\",\"如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select \\\"10\\\" > \\\"9\\\"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么\\\"10\\\"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。\",\"在 MySQL 中，执行的结果如下图：\",\"图片\",\"上面的结果为 1，说明 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。\",\"前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：\",\"//例子一的查询语句 select * from t_user where phone = 1300000001; \",\"这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：\",\"select * from t_user where CAST(phone AS signed int) = 1300000001; \",\"可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的 **。\",\"例子二中的查询语句，我跟大家说了是会走索引扫描：\",\"//例子二的查询语句 select * from t_user where id = \\\"1\\\"; \",\"这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：\",\"select * from t_user where id = CAST(\\\"1\\\" AS signed int); \",\"可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。\"]},\"239\":{\"h\":\"联合索引非最左匹配\",\"t\":[\"对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。\",\"那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。\",\"创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。\",\"联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\",\"比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：\",\"where a=1；\",\"where a=1 and b=2 and c=3；\",\"where a=1 and b=2；\",\"需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。\",\"但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:\",\"where b=2；\",\"where c=3；\",\"where b=2 and c=3；\",\"有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？\",\"这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。\",\"MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，然后再比对 c 字段的值。\",\"从 MySQL 5.6 之后，有一个索引下推功能，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\",\"大概原理是：截断的字段会被下推到存储引擎层进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。\",\"比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 Extra=Using index condition 使用了索引下推功能。\",\"图片\",\"为什么联合索引不遵循最左匹配原则就会失效？\",\"原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。\",\"也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。\"]},\"240\":{\"h\":\"WHERE 子句中的 OR\",\"t\":[\"在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\",\"举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。\",\"select * from t_user where id = 1 or age = 18; \",\"图片\",\"这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。\",\"要解决办法很简单，将 age 字段设置为索引即可。\",\"图片\",\"可以看到 type=index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描。\"]},\"241\":{\"h\":\"总结\",\"t\":[\"今天给大家介绍了 6 种会发生索引失效的情况：\",\"当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；\",\"当我们在查询条件中对索引列使用函数，就会导致索引失效。\",\"当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。\",\"MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。\",\"联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。\",\"在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\"]},\"242\":{\"h\":\"从数据页的角度看 B+ 树\",\"t\":[\"大家背八股文的时候，都知道 MySQL 里 InnoDB 存储引擎是采用 B+ 树来组织数据的。\",\"这点没错，但是大家知道 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？\",\"这次，我们从数据页的角度看 B+ 树，看看每个节点长啥样。\",\"图片\"]},\"243\":{\"h\":\"InnoDB 是如何存储数据的？\",\"t\":[\"MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。\",\"记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。\",\"因此，InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。\",\"数据库的 I/O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。\",\"数据页包括七个部分，结构如下图：\",\"图片\",\"这 7 个部分的作用如下图：\",\"图片\",\"在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：\",\"图片\",\"采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。\",\"数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。\",\"数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。\",\"因此，数据页中有一个页目录，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。\",\"那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：\",\"图片\",\"页目录创建的过程如下：\",\"将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；\",\"每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）\",\"页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），*每个槽相当于指针指向了不同组的最后一个记录*。\",\"从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以* *我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录 **，无需从最小记录开始遍历整个页中的记录链表。\",\"以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：\",\"先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录；\",\"再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，所以主键为 11 的记录在 3 号槽里；\",\"这里有个问题，「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。\",\"看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？\",\"这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：\",\"第一个分组中的记录只能有 1 条记录；\",\"最后一个分组中的记录条数范围只能在 1-8 条之间；\",\"剩下的分组中记录条数范围只能在 4-8 条之间。\"]},\"244\":{\"h\":\"B+ 树是如何进行查询的？\",\"t\":[\"上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。\",\"但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。\",\"为了解决这个问题，InnoDB 采用了 B+ 树作为索引。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。\",\"InnoDB 里的 B+ 树中的每个节点都是一个数据页，结构示意图如下：\",\"图片\",\"通过上图，我们看出 B+ 树的特点：\",\"只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。\",\"非叶子节点分为不同层次，通过分层来降低每一层的搜索量；\",\"所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；\",\"我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：\",\"从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；\",\"在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；\",\"接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。\",\"可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。\"]},\"245\":{\"h\":\"聚簇索引和二级索引\",\"t\":[\"另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：\",\"聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；\",\"二级索引的叶子节点存放的是主键值，而不是实际数据。\",\"因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。\",\"InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：\",\"如果有主键，默认会使用主键作为聚簇索引的索引键；\",\"如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；\",\"在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；\",\"一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。\",\"二级索引的 B+ 树如下图，数据部分为主键值：\",\"图片\",\"因此，如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。\"]},\"246\":{\"h\":\"总结\",\"t\":[\"InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。\",\"数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。\",\"为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。\",\"如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。\",\"在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。\",\"关于索引的内容还有很多，比如索引失效、索引优化等等，这些内容我下次在讲啦！\"]},\"247\":{\"h\":\"为什么 MySQL 采用 B+ 树作为索引？\",\"t\":[\"「为什么 MySQL 采用 B+ 树作为索引？」这句话，是不是在面试时经常出现。\",\"要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的嘛。\",\"这次，就跟大家一层一层的分析这个问题，图中包含大量的动图来帮助大家理解，相信看完你就拿捏这道题目了！\"]},\"248\":{\"h\":\"怎样的索引的数据结构是好的？\",\"t\":[\"MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。\",\"磁盘是一个慢的离谱的存储设备，有多离谱呢？\",\"人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。\",\"磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。\",\"由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。\",\"所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。\",\"另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。\",\"所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：\",\"能在尽可能少的磁盘的 I/O 操作中完成查询工作；\",\"要能高效地查询某一个记录，也要能高效地执行范围查找；\",\"分析完要求后，我们针对每一个数据结构分析一下。\"]},\"249\":{\"h\":\"什么是二分查找？\",\"t\":[\"索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。\",\"假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用二分查找法，比如下面这张采用二分法的查询过程图：\",\"图片\",\"可以看到，二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。\"]},\"250\":{\"h\":\"什么是二分查找树？\",\"t\":[\"用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。\",\"因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。\",\"其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。\",\"那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？\",\"有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。\",\"请添加图片描述\",\"怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个二叉查找树。\",\"二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点 ，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。\",\"假设，我们查找索引值为 key 的节点：\",\"如果 key 大于根节点，则在右子树中进行查找；\",\"如果 key 小于根节点，则在左子树中进行查找；\",\"如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。\",\"二叉查找树查找某个节点的动图演示如下，比如要查找节点 3 ：\",\"图片\",\"另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。\",\"下面是二叉查找树插入某个节点的动图演示：\",\"请添加图片描述\",\"因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。\",\"那是不是二叉查找树就可以作为索引的数据结构了呢？\",\"不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！\",\"当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)，如下动图演示：\",\"请添加图片描述\",\"由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小 ），也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。\",\"二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn) 升为 O(n)。\",\"而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。\"]},\"251\":{\"h\":\"什么是自平衡二叉树？\",\"t\":[\"为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出平衡二叉查找树（AVL 树）。\",\"主要是在二叉查找树的基础上增加了一些条件约束：每个节点的左子树和右子树的高度差不能超过 1 。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。\",\"下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会维持自平衡：\",\"图片\",\"除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。\",\"下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。\",\"图片\",\"**不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率 **。\",\"比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。\",\"图片\",\"根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成 M 叉树（M>2）呢？\",\"比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。\",\"图片\",\"因此，当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度。\"]},\"252\":{\"h\":\"什么是 B 树\",\"t\":[\"自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。\",\"为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M>2)，从而降低树的高度。\",\"B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。\",\"假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，超过这些要求的话，就会分裂节点，比如下面的的动图：\",\"图片\",\"我们来看看一棵 3 阶的 B 树的查询过程是怎样的？\",\"图片\",\"假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：\",\"与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；\",\"然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；\",\"走到索引为9的节点，然后我们找到了索引值 9 的节点。\",\"可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。\",\"而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。\",\"但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。\",\"而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。\",\"另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。\"]},\"253\":{\"h\":\"什么是 B+ 树？\",\"t\":[\"B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：\",\"图片\",\"B+ 树与 B 树差异的点，主要是以下这几点：\",\"叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；\",\"所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；\",\"非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。\",\"非叶子节点中有多少个子节点，就有多少个索引；\",\"下面通过三个方面，比较下 B+ 和 B 树的性能区别。\"]},\"254\":{\"h\":\"1、单点查询\",\"t\":[\"B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。\",\"但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。\",\"B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。\"]},\"255\":{\"h\":\"2、插入和删除效率\",\"t\":[\"B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快，\",\"比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：\",\"注意，：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为 M 阶，而索引的个数为 M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。但是我在前面介绍 B+ 树与 B+ 树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，主要是 MySQL 用到的 B+ 树就是这个特性。\",\"下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：\",\"甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树根节点的过程：\",\"B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：\",\"B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。\",\"因此，B+ 树的插入和删除效率更高。\"]},\"256\":{\"h\":\"3、范围查询\",\"t\":[\"B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。\",\"因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。\",\"而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。\",\"因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。\"]},\"257\":{\"h\":\"MySQL 中的 B+ 树\",\"t\":[\"MySQL 的存储方式根据存储引擎的不同而不同，我们最常用的就是 Innodb 存储引擎，它就是采用了 B+ 树作为了索引的数据结构。\",\"下图就是 Innodb 里的 B+ 树：\",\"但是 Innodb 使用的 B+ 树有一些特别的点，比如：\",\"B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。\",\"B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。\",\"Innodb 根据索引类型不同，分为聚簇和二级索引。他们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。\",\"因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。\",\"更多关于 Innodb 的 B+ 树，可以看我之前写的这篇：从数据页的角度看 B+ 树。\"]},\"258\":{\"h\":\"总结\",\"t\":[\"MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。\",\"要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。\",\"二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。\",\"为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。\",\"而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。\",\"B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。\",\"但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：\",\"B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。\",\"B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；\",\"B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。\",\"完！\"]},\"259\":{\"h\":\"\"},\"260\":{\"h\":\"常见多表查询方式？\"},\"261\":{\"h\":\"分类\",\"t\":[\"连接查询\",\"内连接（等值连接）\",\"显式内连接\",\"隐式内连接\",\"外连接\",\"左外连接\",\"右外连接\",\"全外连接\",\"自连接\",\"子查询\",\"按照查询结果 \",\"标量子查询(子查询结果为单个值)\",\"列子查询(子查询结果为一列)\",\"行子查询(子查询结果为一行)\",\"表子查询(子查询结果为多行多列)\",\"按照位置 \",\"WHERE之后\",\"FROM之后\",\"SELECT之后\",\"联合查询\",\"union all: 查询出来的结果，仅仅进行简单的合并，并未去重。\",\"union: 联合查询，会对查询出来的结果进行去重处理。\"]},\"262\":{\"h\":\"部分解释\"},\"263\":{\"h\":\"1.内连接\",\"t\":[\"​ 内连接查询的是两张表交集部分的数（只返回两个表中连接字段相等的行。）\",\"显式内连接：使用关键字inner join或者join\",\"select * from table1 inner join table2 on table1.id = table2.id \",\"隐式内连接：使用逗号,连接两张表\",\"select * from table1, table2 where table1.id = table2.id \"]},\"264\":{\"h\":\"2.外连接\",\"t\":[\"​ 左外连接：左外连接查询的是左表的所有数据和两张表交集部分的数据（返回包括左表中的所有记录和右表中连接字段相等的记录）\",\"select * from table1 left outer join table2 on table1.id = table2.id \",\"​ 右外连接：右外连接查询的是右表的所有数据和两张表交集部分的数据（返回包括右表中的所有记录和左表中连接字段相等的记录）\",\"select * from table1 right outer join table2 on table1.id = table2.id \",\"​ 全外连接：返回左右表中所有的记录和左右表中连接字段相等的记录\",\"select * from table1 full outer join table2 on table1.id = table2.id \",\"⚠️注意事项:\",\"​ 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\"]},\"265\":{\"h\":\"3.自连接\",\"t\":[\"​ 顾名思义，就是自己连接自己，也就是把一张表连接查询多次。对于自连接查询，可以是内连接查询，也可以是外连接查询。\",\"select * from table1 t1 inner join table1 t2 on t1.id = t2.id \",\"⚠️注意事项:\",\"​ 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。\"]},\"266\":{\"h\":\"4.子查询\",\"t\":[\"SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\",\"SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); \"]},\"267\":{\"h\":\"\"},\"268\":{\"h\":\"事务是什么\",\"t\":[\"事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\"]},\"269\":{\"h\":\"事务的四大特性？\",\"t\":[\"原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败\",\"一致性：事务执行前后，数据保持一致\",\"隔离性：事务之间互不影响\",\"持久性：事务一旦提交，数据将持久化到数据库\"]},\"270\":{\"h\":\"并行事务导致的问题\",\"t\":[\"脏读：一个事务读取到了另一个事务未提交的数据\",\"不可重复读：一个事务先后读取同一条记录，但两次读取的结果不一致\",\"幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 \\\"幻影\\\"。\"]},\"271\":{\"h\":\"事务的隔离级别\",\"t\":[\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"Read uncommitted\",\"✅\",\"✅\",\"✅\",\"Read committed\",\"❌\",\"✅\",\"✅\",\"Repeatable Read(默认)\",\"❌\",\"❌\",\"✅\",\"Serializable\",\"❌\",\"❌\",\"❌\"]},\"272\":{\"h\":\"事务的隔离级别是靠什么保证的\",\"t\":[\"简单来说：原子性、一致性、持久性是通过redo_log + undo_log实现的，隔离性是通过锁 + MVCC实现的 复杂来说：要想回答这个问题，必须先清楚MySQL的结构，MySQL可分为连接层、服务层、引擎层、存储层。\",\"❗️此处为附图\",\"连接层：负责连接管理、授权认证、安全等等。\",\"服务层：负责查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等等。\",\"引擎层：负责MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，\",\"存储层：将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。\",\"MySQL默认为InnoDB引擎，其存储结构是由 表-段-区-页-行 组成的\",\"❗️这里介绍表-段-区-页-行\",\"❗️这里介绍体系结构\",\"redo_log: 重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。当事务提交之后会把所有修改信息都存到该日志文件中,\\n用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。一般由==重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)\\n==两部分组成，前者是在内存中，后者在磁盘中\"]},\"273\":{\"h\":\"MySQL 死锁了，怎么办？\",\"t\":[\"说个很早之前自己遇到过数据库死锁问题。\",\"有个业务主要逻辑就是新增订单、修改订单、查询订单等操作。然后因为订单是不能重复的，所以当时在新增订单的时候做了幂等性校验，做法就是在新增订单记录之前，先通过 select ... for update 语句查询订单是否存在，如果不存在才插入订单记录。\",\"而正是因为这样的操作，当业务量很大的时候，就可能会出现死锁。\",\"接下来跟大家聊下为什么会发生死锁，以及怎么避免死锁。\"]},\"274\":{\"h\":\"死锁的发生\",\"t\":[\"本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。\",\"接下来，我用实战的方式来带大家看看死锁是怎么发生的。\",\"我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：\",\"CREATE TABLE `t_order` ( `id` int NOT NULL AUTO_INCREMENT, `order_no` int DEFAULT NULL, `create_date` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_order` (`order_no`) USING BTREE ) ENGINE=InnoDB ; \",\"然后，先 t_order 表里现在已经有了 6 条记录：\",\"假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：\",\"可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。\",\"这里在查询记录是否存在的时候，使用了 select ... for update 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。\",\"如果没有使用 select ... for update 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：\"]},\"275\":{\"h\":\"为什么会产生死锁？\",\"t\":[\"可重复读隔离级别下，是存在幻读的问题。\",\"Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁，它是记录锁和间隙锁的组合。\",\"Record Lock，记录锁，锁的是记录本身；\",\"Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。\",\"普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：\",\"begin; //对读取的记录加共享锁 select ... lock in share mode; commit; //锁释放 begin; //对读取的记录加排他锁 select ... for update; commit; //锁释放 \",\"行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。\",\"比如，下面事务 A 查询语句会锁住 (2, +∞] 范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。\",\"next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁，我之前也写一篇加锁规则，详细可以看这篇：MySQL 是怎么加锁的？\",\"需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。\",\"所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞，我有个读者就因为干了这个事情，然后被老板教育了一波，详细可以看这篇：update 没加索引会锁全表？\",\"回到前面死锁的例子。\",\"事务 A 在执行下面这条语句的时候：\",\"select id from t_order where order_no = 1007 for update; \",\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的 next-key 锁；\",\"这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：\",\"如果 LOCK_MODE 为 X，说明是 X 型的 next-key 锁；\",\"如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是 X 型的记录锁；\",\"如果 LOCK_MODE 为 X, GAP，说明是 X 型的间隙锁；\",\"因此，此时事务 A 在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是(1006, +∞]。\",\"next-key 锁的范围 (1006, +∞]，是怎么确定的？\",\"根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。\",\"提示\",\"有的读者问，MySQL 是怎么加锁的？这篇文章讲非唯一索引等值查询时，说「当查询的记录不存在时，加 next-key lock，然后会退化为间隙锁」。为什么上面事务 A 的 next-key lock 并没有退化为间隙锁？\",\"如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no = 1006（不存在），就是 next key lock，如上面事务 A 的情况。\",\"如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no = 1006（不存在），就是间隙锁，比如下图：\",\"当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：\",\"Insert into t_order (order_no, create_date) values (1008, now()); \",\"因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，*而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select ... for update 语句并不会相互影响*。\",\"案例中的事务 A 和事务 B 在执行完后 select ... for update 语句后都持有范围为(1006,+∞]的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。\",\"为什么间隙锁与间隙锁之间是兼容的？\",\"在MySQL官网上还有一段非常关键的描述：\",\"Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from Inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.\",\"间隙锁的意义只在于阻止区间被插入，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁 **，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。\",\"这里的共同间隙包括两种场景：\",\"其一是两个间隙锁的间隙区间完全一样；\",\"其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。\",\"但是有一点要注意，next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\",\"比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。\",\"虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系。X 型的记录锁与 X 型的记录锁是冲突的，比如一个事务执行了 select ... where id = 1 for update，后一个事务在执行这条语句的时候，就会被阻塞的。\",\"但是还要注意！对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。\",\"插入意向锁是什么？\",\"注意！插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁。\",\"在MySQL的官方文档中有以下重要描述：\",\"*An Insert intention lock is a type of gap lock set by Insert operations prior to row Insertion. This lock signals the intent to Insert in such a way that multiple transactions Inserting into the same index gap need not wait for each other if they are not Inserting at the same position within the gap. Suppose that there are index records with values of 4 and\",\"Separate transactions that attempt to Insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with Insert intention locks prior to obtaining the exclusive lock on the Inserted row, but do not block each other because the rows are nonconflicting.*\",\"这段话表明尽管插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作。\",\"如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。\",\"插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。\",\"另外，我补充一点，插入意向锁的生成时机：\",\"每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），现象就是 Insert 语句会被阻塞。\"]},\"276\":{\"h\":\"Insert 语句是怎么加行级锁的？\",\"t\":[\"Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为隐式锁来保护记录的。\",\"什么是隐式锁？\",\"当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。\",\"隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显式锁，这里我们列举两个场景。\",\"如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；\",\"如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；\"]},\"277\":{\"h\":\"1、记录之间加有间隙锁\",\"t\":[\"每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），现象就是 Insert 语句会被阻塞。\",\"举个例子，现在 t_order 表中，只有这些数据，order_no 是二级索引。\",\"现在，事务 A 执行了下面这条语句。\",\"# 事务 A mysql> begin; Query OK, 0 rows affected (0.01 sec) mysql> select * from t_order where order_no = 1006 for update; Empty set (0.01 sec) \",\"接着，我们执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务 A 加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"本次的例子加的是 next-key 锁（记录锁+间隙锁），锁范围是（1005, +∞]。\",\"然后，有个事务 B 在这个间隙锁中，插入了一个记录，那么此时该事务 B 就会被阻塞：\",\"# 事务 B 插入一条记录 mysql> begin; Query OK, 0 rows affected (0.01 sec) mysql> insert into t_order(order_no, create_date) values(1010,now()); ### 阻塞状态。。。。 \",\"接着，我们执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务 B 加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"可以看到，事务 B 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 A 生成的 next-key 锁（记录锁+间隙锁）范围（1005, +∞] 中插入了一条记录，所以事务 B 的插入操作生成了一个插入意向锁（LOCK_MODE: X,INSERT_INTENTION ），锁的状态是等待状态，意味着事务 B 并没有成功获取到插入意向锁，因此事务 B 发生阻塞。\"]},\"278\":{\"h\":\"2、遇到唯一键冲突\",\"t\":[\"如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了S 型的锁。\",\"至于是行级锁的类型是记录锁，还是 next-key 锁，跟是「主键冲突」还是「唯一二级索引冲突」有关系。\",\"如果主键索引重复：\",\"当隔离级别为读已提交时，插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加 S 型记录锁。\",\"当隔离级别是可重复读（默认隔离级别），插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加 S 型记录锁。\",\"如果唯一二级索引列重复：\",\"不论是哪个隔离级别，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录添加 S 型 next-key 锁 。对的，没错，即使是读已提交隔离级别也是加 next-key 锁，这是读已提交隔离级别中为数不多的给记录添加间隙锁的场景。至于为什么要加 next-key 锁，我也没找到合理的解释。\"]},\"279\":{\"h\":\"主键索引冲突\",\"t\":[\"下面举个「主键冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。\",\"t_order 表中的 id 字段为主键索引，并且已经存在 id 值为 5 的记录，此时有个事务，插入了一条 id 为 5 的记录，就会报主键索引冲突的错误。\",\"但是除了报错之外，还做一个很重要的事情，就是对 id 为 5 的这条记录加上了 S 型的记录锁。\",\"可以执行 select * from performance_schema.data_locks\\\\G; 语句，确定事务加了什么锁。\",\"可以看到，主键索引为 5 （LOCK_DATA）的这条记录中加了锁类型为 S 型的记录锁。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是 S 型记录锁的话，LOCK_MODE 会显示 S, REC_NOT_GAP。\",\"所以，在隔离级别是「可重复读」的情况下，如果在插入数据的时候，发生了主键索引冲突，插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加 S 型记录锁。\"]},\"280\":{\"h\":\"唯一二级索引冲突\",\"t\":[\"下面举个「唯一二级索引冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。\",\"t_order 表中的 order_no 字段为唯一二级索引，并且已经存在 order_no 值为 1001 的记录，此时事务 A，插入了 order_no 为 1001 的记录，就出现了报错。\",\"但是除了报错之外，还做一个很重要的事情，就是对 order_no 值为 1001 这条记录加上了 S 型的 next-key 锁。\",\"我们可以执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"可以看到，index_order 二级索引加了 S 型的 next-key 锁，范围是(-∞, 1001]。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是记录锁的话，LOCK_MODE 会显示 S, REC_NOT_GAP。\",\"此时，事务 B 执行了 select * from t_order where order_no = 1001 for update; 就会阻塞，因为这条语句想加 X 型的锁，是与 S 型的锁是冲突的，所以就会被阻塞。\",\"我们也可以从 performance_schema.data_locks 这个表中看到，事务 B 的状态（LOCK_STATUS）是等待状态，加锁的类型 X 型的记录锁（LOCK_MODE: X,REC_NOT_GAP ）。\",\"上面的案例是针对唯一二级索引重复而插入失败的场景。\",\"接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。\",\"现在 t_order 表中，只有这些数据，order_no 为唯一二级索引。\",\"在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时事务 B 的 Insert 语句会发生阻塞。\",\"两个事务的加锁过程：\",\"事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；\",\"接着，事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态。\",\"我们可以执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"先看事务 A 对 order_no 为 1006 的记录加了什么锁？\",\"从下图可以看到，事务 A 对 order_no 为 1006 记录加上了类型为 X 型的记录锁（注意，这个是在执行事务 B 之后才产生的锁，没执行事务 B 之前，该记录还是隐式锁）。\",\"然后看事务 B 想对 order_no 为 1006 的记录加什么锁？\",\"从下图可以看到，事务 B 想对 order_no 为 1006 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态。\",\"从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。\",\"但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会被阻塞，*因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的*，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。\",\"如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。\"]},\"281\":{\"h\":\"如何避免死锁？\",\"t\":[\"死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。\",\"在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：\",\"设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。\",\"当发生超时后，就出现下面这个提示：\",\"图片\",\"开启主动死锁检测 。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。\",\"当检测到死锁后，就会出现下面这个提示：\",\"图片\",\"上面这个两种策略是「当有死锁发生时」的避免方式。\",\"我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。\",\"参考资料：\",\"《MySQL 是怎样运行的？》\",\"http://mysql.taobao.org/monthly/2020/09/06/\"]},\"282\":{\"h\":\"MySQL 是怎么加锁的？\",\"t\":[\"是不是很多人都对 MySQL 加行级锁的规则搞的迷迷糊糊，对记录一会加的是 next-key 锁，一会加是间隙锁，一会又是记录锁。\",\"坦白说，确实还挺复杂的，但是好在我找点了点规律，也知道如何如何用命令分析加了什么类型的行级锁。\",\"之前我写过一篇关于「MySQL 是怎么加行级锁的？」的文章，随着我写 MySQL 锁相关的文章越来越多时，后来发现当时的文章写的不够详细。\",\"为了让大家很清楚的知道 MySQL 是怎么加行级锁的，以及如何用命令分析加了什么行级锁，再加上为了解释清楚为什么 MySQL 要这么加行级锁，所以我重写了这篇文章。\",\"这一重写，就多增加了 1W 多字 + 30 张图，所以完全算是新的文章了。\",\"文章内容比较长，大家可以耐心看下去，看完之后你会有一种突然被顿悟的感觉，因为我自己写完这篇文章后，自己也被自己顿悟了。\"]},\"283\":{\"h\":\"什么 SQL 语句会加行级锁？\",\"t\":[\"InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。\",\"所以，在说 MySQL 是怎么加行级锁的时候，其实是在说 InnoDB 引擎是怎么加行级锁的。\",\"普通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。\",\"如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。\",\"//对读取的记录加共享锁(S型锁) select ... lock in share mode; //对读取的记录加独占锁(X型锁) select ... for update; \",\"上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。\",\"除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。\",\"//对操作的记录加独占锁(X型锁) update table .... where id = 1; //对操作的记录加独占锁(X型锁) delete from table where id = 1; \",\"共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。\"]},\"284\":{\"h\":\"行级锁有哪些种类？\",\"t\":[\"不同隔离级别下，行级锁的种类是不同的。\",\"在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。\",\"在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：\",\"Record Lock，记录锁，也就是仅仅把一条记录锁上；\",\"Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；\",\"Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\",\"接下来，分别介绍这三种行级锁。\"]},\"285\":{\"h\":\"Record Lock\",\"t\":[\"Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\",\"当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\",\"当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\",\"举个例子，当一个事务执行了下面这条语句：\",\"mysql > begin; mysql > select * from t_test where id = 1 for update; \",\"事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，如果这时候其他事务对这条记录进行删除或者更新操作，那么这些操作都会被阻塞。注意，其他事务插入一条 id = 1 的新记录并不会被阻塞，而是会报主键冲突的错误，这是因为主键有唯一性的约束。\",\"img\",\"当事务执行 commit 后，事务过程中生成的锁都会被释放。\"]},\"286\":{\"h\":\"Gap Lock\",\"t\":[\"Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。\",\"假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\",\"img\",\"间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，* *间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的 **。\"]},\"287\":{\"h\":\"Next-Key Lock\",\"t\":[\"Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\",\"假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。\",\"img\",\"所以，next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。\",\"next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\",\"比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。\",\"虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。\"]},\"288\":{\"h\":\"MySQL 是怎么加行级锁的？\",\"t\":[\"行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。\",\"加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间 **。\",\"但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。\",\"那到底是什么场景呢？总结一句，**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成退化成记录锁或间隙锁 **。\",\"这次会以下面这个表结构来进行实验说明：\",\"CREATE TABLE `user` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL, `age` int NOT NULL, PRIMARY KEY (`id`), KEY `index_age` (`age`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; \",\"其中，id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通的列。\",\"表中的有这些行记录：\",\"这次实验环境的 MySQL 版本是 8.0.26，隔离级别是「可重复读」。\",\"不同版本的加锁规则可能是不同的，但是大体上是相同的。\"]},\"289\":{\"h\":\"唯一索引等值查询\",\"t\":[\"当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：\",\"当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。\",\"当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会**退化成「间隙锁」 **。\",\"接下里用两个案例来说明。\"]},\"290\":{\"h\":\"1、记录存在的情况\",\"t\":[\"假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id = 1 for update; +----+--------+-----+ | id | name | age | +----+--------+-----+ | 1 | 路飞 | 19 | +----+--------+-----+ 1 row in set (0.02 sec) \",\"那么，事务 A 会为 id 为 1 的这条记录就会加上 X 型的记录锁。\",\"接下来，如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。\",\"比如，下面这个例子：\",\"因为事务 A 对 id = 1的记录加了 X 型的记录锁，所以事务 B 在修改 id=1 的记录时会被阻塞，事务 C 在删除 id=1 的记录时也会被阻塞。\",\"有什么命令可以分析加了什么锁？\",\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"我们以前面的事务 A 作为例子，分析下下它加了什么锁。\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的记录锁；\",\"这里我们重点关注行级锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。\",\"通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：\",\"如果 LOCK_MODE 为 X，说明是 next-key 锁；\",\"如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；\",\"如果 LOCK_MODE 为 X, GAP，说明是间隙锁；\",\"因此，此时事务 A 在 id = 1 记录的主键索引上加的是记录锁，锁住的范围是 id 为 1 的这条记录。这样其他事务就无法对 id 为 1 的这条记录进行更新和删除操作了。\",\"从这里我们也可以得知，加锁的对象是针对索引，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加 记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。\",\"为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？\",\"原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。\",\"幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要避免幻读就是避免结果集某一条记录被其他事务删除，或者有其他事务插入了一条新记录，这样前后两次查询的结果集就不会出现不相同的情况。\",\"由于主键具有唯一性，所以其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录。这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。\",\"由于对 id = 1 加了记录锁，其他事务无法删除该记录，这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。\"]},\"291\":{\"h\":\"2、记录不存在的情况\",\"t\":[\"假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id = 2 for update; Empty set (0.03 sec) \",\"接下来，通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的间隙锁；\",\"因此，此时事务 A 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。\",\"接下来，如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。\",\"注意，如果其他事务插入的 id = 1 或者 id = 5 的记录话，并不会发生阻塞，而是报主键冲突的错误，因为表中已经存在 id = 1 和 id = 5 的记录了。\",\"比如，下面这个例子：\",\"因为事务 A 在 id = 5 记录的主键索引上加了范围为 (1, 5) 的 X 型间隙锁，所以事务 B 在插入一条 id 为 3 的记录时会被阻塞住，即无法插入 id = 3 的记录。\",\"间隙锁的范围(1, 5) ，是怎么确定的？\",\"根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK_DATA 是 5。\",\"然后锁范围的「左边界」是表中 id 为 5 的上一条记录的 id 值，即 1。\",\"因此，间隙锁的范围(1, 5)。\",\"为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？\",\"原因就是在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读的问题。\",\"为什么 id = 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id = 5 这条记录，但是这次的案例是查询 id = 2 的记录，只要保证前后两次查询 id = 2 的结果集相同，就能避免幻读的问题了，所以即使 id =5 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 5 加间隙锁，避免其他事务插入 id = 2 的新记录就行了。\",\"为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。\"]},\"292\":{\"h\":\"唯一索引范围查询\",\"t\":[\"范围查询和等值查询的加锁规则是不同的。\",\"当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：\",\"情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。\",\"情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中： \",\"当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。\",\"当条件值的记录在表中，如果是「小于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁 **，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。\",\"接下来，通过几个实验，才验证我上面说的结论。\"]},\"293\":{\"h\":\"1、针对「大于或者大于等于」的范围查询\",\"t\":[\"实验一：针对「大于」的范围查询的情况。\",\"假设事务 A 执行了这条范围查询语句：\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id > 15 for update; +----+-----------+-----+ | id | name | age | +----+-----------+-----+ | 20 | 香克斯 | 39 | +----+-----------+-----+ 1 row in set (0.01 sec) \",\"事务 A 加锁变化过程如下：\",\"最开始要找的第一行是 id = 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为 (15, 20] 的 next-key 锁；\",\"由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id = 20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。\",\"停止扫描。\",\"可以得知，事务 A 在主键索引上加了两个 X 型 的 next-key 锁：\",\"在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。\",\"在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图中的分析中，也可以得到事务 A 在主键索引上加了两个 X 型 的next-key 锁：\",\"在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。\",\"在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。\",\"实验二：针对「大于等于」的范围查询的情况。\",\"假设事务 A 执行了这条范围查询语句：\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id >= 15 for update; +----+-----------+-----+ | id | name | age | +----+-----------+-----+ | 15 | 乌索普 | 20 | | 20 | 香克斯 | 39 | +----+-----------+-----+ 2 rows in set (0.00 sec) \",\"事务 A 加锁变化过程如下：\",\"最开始要找的第一行是 id = 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会退化成记录锁 ，也就是仅锁住 id = 15 这一行记录。\",\"由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 20，于是对该主键索引加的是范围为 (15, 20] 的 next-key 锁；\",\"接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。\",\"停止扫描。\",\"可以得知，事务 A 在主键索引上加了三个 X 型 的锁，分别是：\",\"在 id = 15 这条记录的主键索引上，加了记录锁，范围是 id = 15 这一行记录；意味着其他事务无法更新或者删除 id = 15 的这一条记录；\",\"在 id = 20 这条记录的主键索引上，加了 next-key 锁，范围是 (15, 20] 。意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。\",\"在特殊记录（ supremum pseudo-record）的主键索引上，加了 next-key 锁，范围是 (20, +∞] 。意味着其他事务无法插入 id 值大于 20 的这一些新记录。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"通过前面这个实验，我们证明了：\",\"针对「大于等于」条件的唯一索引范围查询的情况下， 如果条件值的记录存在于表中，那么由于查询该条件值的记录是包含一个等值查询的操作，所以该记录的索引中的 next-key 锁会退化成记录锁。\"]},\"294\":{\"h\":\"2、针对「小于或者小于等于」的范围查询\",\"t\":[\"实验一：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。\",\"假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 6）并不存在于表中。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id < 6 for update; +----+--------+-----+ | id | name | age | +----+--------+-----+ | 1 | 路飞 | 19 | | 5 | 索隆 | 21 | +----+--------+-----+ 3 rows in set (0.00 sec) \",\"事务 A 加锁变化过程如下：\",\"最开始要找的第一行是 id = 1，于是对该主键索引加的是范围为 (-∞, 1] 的 next-key 锁；\",\"由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，所以对该主键索引加的是范围为 (1, 5] 的 next-key 锁；\",\"由于扫描到的第二行记录（id = 5），满足 id < 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。\",\"扫描到的第三行是 id = 10，该记录不满足 id < 6 条件的记录，所以 id = 10 这一行记录的锁会退化成间隙锁 ，于是对该主键索引加的是范围为 (5, 10) 的间隙锁。\",\"由于扫描到的第三行记录（id = 10），不满足 id < 6 条件，达到了终止扫描的条件，于是停止扫描。\",\"从上面的分析中，可以得知事务 A 在主键索引上加了三个 X 型的锁：\",\"在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。\",\"在 id = 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。\",\"在 id = 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图中的分析中，也可以得知事务 A 在主键索引加的三个锁，就是我们前面分析出那三个锁。\",\"虽然这次范围查询的条件是「小于」，但是查询条件值的记录不存在于表中（ id 为 6 的记录不在表中），所以如果事务 A 的范围查询的条件改成 <= 6 的话，加的锁还是和范围查询条件为 < 6 是一样的。 大家自己也验证下这个结论。\",\"因此，针对「小于或者小于等于」的唯一索引范围查询，如果条件值的记录不在表中，那么不管是「小于」还是「小于等于」的范围查询，扫描到终止范围查询的记录时，该记录中索引的 next-key 锁会退化成间隙锁，其他扫描的记录，则是在这些记录的索引上加 next-key 锁。\",\"实验二：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。\",\"假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 5）存在于表中。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where id <= 5 for update; +----+--------+-----+ | id | name | age | +----+--------+-----+ | 1 | 路飞 | 19 | | 5 | 索隆 | 21 | +----+--------+-----+ 2 rows in set (0.00 sec) \",\"事务 A 加锁变化过程如下：\",\"最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；\",\"由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，于是对该记录加的是范围为 (1, 5] 的 next-key 锁。\",\"由于主键索引具有唯一性，不会存在两个 id = 5 的记录，所以不会再继续扫描，于是停止扫描。\",\"从上面的分析中，可以得到事务 A 在主键索引上加了 2 个 X 型的锁：\",\"在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁。意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。\",\"在 id = 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁。意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图中的分析中，可以得到事务 A 在主键索引上加了两个 X 型 next-key 锁，分别是：\",\"在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁；\",\"在 id = 5 这条记录的主键索引上，加了范围为(1, 5 ] 的 next-key 锁。\",\"实验三：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。\",\"如果事务 A 的查询语句是小于的范围查询，且查询条件值的记录（id 为 5）存在于表中。\",\"select * from user where id < 5 for update; \",\"事务 A 加锁变化过程如下：\",\"最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；\",\"由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id < 5 条件的记录，于是* *该记录的锁会退化为间隙锁，锁范围是 (1,5)**。\",\"由于找到了第一条不满足 id < 5 条件的记录，于是停止扫描。\",\"可以得知，此时事务 A 在主键索引上加了两种 X 型锁：\",\"在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。\",\"在 id = 5 这条记录的主键索引上，加了范围为 (1,5) 的间隙锁，意味着其他事务无法插入 id 值为 2、3、4 的这一些新记录。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图中的分析中，可以得到事务 A 在主键索引上加了 **X 型的范围为 (-∞, 1] 的 next-key 锁，和 X 型的范围为 (1, 5) 的间隙锁 **。\",\"因此，通过前面这三个实验，可以得知。\",\"在针对「小于或者小于等于」的唯一索引（主键索引）范围查询时，存在这两种情况会将索引的 next-key 锁会退化成间隙锁的：\",\"当条件值的记录「不在」表中时，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。\",\"当条件值的记录「在」表中时： \",\"如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会退化成间隙锁 ，其他扫描到的记录，都是在这些记录的主键索引上，加 next-key 锁。\",\"如果是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁「不会」退化成间隙锁，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。\"]},\"295\":{\"h\":\"非唯一索引等值查询\",\"t\":[\"当我们用非唯一索引进行等值查询的时候，* *因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁 **。\",\"针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：\",\"当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是* *非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁 **。\",\"当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。\",\"接下里用两个实验来说明。\"]},\"296\":{\"h\":\"1、记录不存在的情况\",\"t\":[\"实验一：针对非唯一索引等值查询时，查询的值不存在的情况。\",\"先来说说非唯一索引等值查询时，查询的记录不存在的情况，因为这个比较简单。\",\"假设事务 A 对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where age = 25 for update; Empty set (0.00 sec) \",\"事务 A 加锁变化过程如下：\",\"定位到第一条不符合查询条件的二级索引记录，即扫描到 age = 39，于是该二级索引的 next-key 锁会退化成间隙锁，范围是 (22, 39)。\",\"停止查询\",\"事务 A 在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。意味着其他事务无法插入 age 值为 23、24、25、26、....、38 这些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图的分析，可以看到，事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age ），加了范围为 (22, 39) 的 X 型间隙锁。\",\"此时，如果有其他事务插入了 age 值为 23、24、25、26、....、38 这些新记录，那么这些插入语句都会发生阻塞。不过对于插入 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，接下来我们就说！\",\"当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age = 22 或者 age = 39 记录的语句成功？又是什么情况下，插入 age = 22 或者 age = 39 记录时的语句会被阻塞？\",\"我们先要清楚，什么情况下插入语句会发生阻塞。\",\"插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞。\",\"在分析二级索引的间隙锁是否可以成功插入记录时，我们要先要知道二级索引树是如何存放记录的？\",\"二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。\",\"基于前面的实验，事务 A 是在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。\",\"插入 age = 22 记录的成功和失败的情况分别如下：\",\"当其他事务插入一条 age = 22，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 10、age = 22 的记录，该记录的二级索引上没有间隙锁，所以这条插入语句可以执行成功。\",\"当其他事务插入一条 age = 22，id = 12 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功。\",\"插入 age = 39 记录的成功和失败的情况分别如下：\",\"当其他事务插入一条 age = 39，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功。\",\"当其他事务插入一条 age = 39，id = 21 的记录的时候，在二级索引树上定位到插入的位置，而*该位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以插入成功*。\",\"所以，**当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age = 22 或者 age = 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功 **。\",\"知道了这个结论之后，我们再回过头看，非唯一索引等值查询时，查询的记录不存在时，执行select * from performance_schema.data_locks\\\\G; 输出的结果。\",\"在前面分析输出结果的时候，我说的结论是：「事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age ），加了范围为 (22, 39) 的 X 型间隙锁」。这个结论其实还不够准确，因为只考虑了 LOCK_DATA 第一个数值（39），没有考虑 LOCK_DATA 第二个数值（20）。\",\"那 LOCK_DATA：39，20 是什么意思？\",\"LOCK_DATA 第一个数值，也就是 39， 它代表的是 age 值。从前面我们也知道了，LOCK_DATA 第一个数值是 next-key 锁和间隙锁*锁住的范围的右边界值*。\",\"LOCK_DATA 第二个数值，也就是 20， 它代表的是 id 值。\",\"之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (22, 39) 间隙锁的时候，其他事务是否可以插入 age = 39 新记录」的问题，还需要考虑插入记录的 id 值。而 LOCK_DATA 的第二个数值，就是说明在插入 age = 39 新记录时，哪些范围的 id 值是不可以插入的。\",\"因此， LOCK_DATA：39，20 + LOCK_MODE : X, GAP 的意思是，事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age ），加了 age 值范围为 (22, 39) 的 X 型间隙锁，**同时针对其他事务插入 age 值为 39 的新记录时，不允许插入的新记录的 id 值小于 20 ** 。如果插入的新记录的 id 值大于 20，则可以插入成功。\",\"但是我们无法从select * from performance_schema.data_locks\\\\G; 输出的结果分析出「在插入 age =22 新记录时，哪些范围的 id 值是可以插入成功的」，这时候就**得自己画出二级索引的 B+ 树的结构，然后确定插入位置后，看下该位置的下一条记录是否存在间隙锁，如果存在间隙锁，则无法插入成功，如果不存在间隙锁，则可以插入成功 **。\"]},\"297\":{\"h\":\"2、记录存在的情况\",\"t\":[\"实验二：针对非唯一索引等值查询时，查询的值存在的情况。\",\"假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age = 22 的记录。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where age = 22 for update; +----+--------+-----+ | id | name | age | +----+--------+-----+ | 10 | 山治 | 22 | +----+--------+-----+ 1 row in set (0.00 sec) \",\"事务 A 加锁变化过程如下：\",\"由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age = 22，于是对该二级索引记录加上范围为 (21, 22] 的 next-key 锁。同时，因为 age = 22 符合查询条件，于是对 age = 22 的记录的主键索引加上记录锁，即对 id = 10 这一行加记录锁。\",\"接着继续扫描，扫描到的第二行是 age = 39，该记录是第一个不符合条件的二级索引记录，所以该二级索引的 next-key 锁会**退化成间隙锁 **，范围是 (22, 39)。\",\"停止查询。\",\"可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：\",\"主键索引： \",\"在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。\",\"二级索引（非唯一索引）： \",\"在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于插入 age = 20 和 age = 21 新记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。\",\"在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。\",\"我们也可以通过 select * from performance_schema.data_locks\\\\G; 这条语句来看看事务 A 加了什么锁。\",\"输出结果如下，我这里只截取了行级锁的内容。\",\"从上图的分析，可以看到，事务 A 对二级索引（INDEX_NAME: index_age ）加了两个 X 型锁，分别是：\",\"在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，针对是否可以插入 age = 21 和 age = 22 的新记录，分析如下： \",\"是否可以插入 age = 21 的新记录，还要看插入的新记录的 id 值，**如果插入 age = 21 新记录的 id 值小于 5，那么就可以插入成功 **，因为此时插入的位置的下一条记录是 id = 5，age = 21 的记录，该记录的二级索引上没有间隙锁。如果插入 age = 21 新记录的 id 值大于 5，那么就无法插入成功，因为此时插入的位置的下一条记录是 id = 20，age = 39 的记录，该记录的二级索引上有间隙锁。\",\"是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 22, 10 可以得知，其他事务插入 age 值为 22 的新记录时，如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞；如果插入的新记录的 id 大于 10，还要看该新记录插入的位置的下一条记录是否有间隙锁，如果没有间隙锁则可以插入成功，如果有间隙锁，则无法插入成功。\",\"在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录，针对是否可以插入 age = 22 和 age = 39 的新记录，分析如下： \",\"是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，如果插入 age = 22 新记录的 id 值小于 10，那么插入语句会被阻塞，无法插入，因为此时插入的位置的下一条记录是 id = 10，age = 22 的记录，该记录的二级索引上有间隙锁（ age = 22 这条记录的二级索引上有 next-key 锁）。如果插入 age = 21 新记录的 id 值大于 10，也无法插入 ，因为此时插入的位置的下一条记录是 id = 20，age = 39 的记录，该记录的二级索引上有间隙锁。\",\"是否可以插入 age = 39 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 39, 20 可以得知，其他事务插入 age 值为 39 的新记录时，**如果插入的新记录的 id 值小于 20，那么插入语句会发生阻塞，如果插入的新记录的 id 大于 20，则可以插入成功 **。\",\"同时，事务 A 还对主键索引（INDEX_NAME: PRIMARY ）加了X 型的记录锁：\",\"在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。\",\"为什么这个实验案例中，需要在二级索引索引上加范围 (22, 39) 的间隙锁？\",\"要找到这个问题的答案，我们要明白 MySQL 在可重复读的隔离级别场景下，为什么要引入间隙锁？其实是为了避免幻读现象的发生。\",\"如果这个实验案例中：\",\"select * from user where age = 22 for update; \",\"如果事务 A 不在二级索引索引上加范围 (22, 39) 的间隙锁，只在二级索引索引上加范围为 (21, 22] 的 next-key 锁的话，那么就会有幻读的问题。\",\"前面我也说过，在非唯一索引上加了范围为 (21, 22] 的 next-key 锁，是无法完全锁住 age = 22 新记录的插入，因为对于是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 22, 10 可以得知，其他事务插入 age 值为 22 的新记录时，如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞，如果插入的新记录的 id 值大于 10，则可以插入成功。\",\"也就是说，只在二级索引索引（非唯一索引）上加范围为 (21, 22] 的 next-key 锁，其他事务是有可能插入 age 值为 22 的新记录的（比如插入一个 age = 22，id = 12 的新记录），那么如果事务 A 再一次查询 age = 22 的记录的时候，前后两次查询 age = 22 的结果集就不一样了，这时就发生了幻读的现象。\",\"那么当在 age = 39 这条记录的二级索引索引上加了范围为 (22, 39) 的间隙锁后，其他事务是无法插入一个 age = 22，id = 12 的新记录，因为当其他事务插入一条 age = 22，id = 12 的新记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功，这样就避免幻读现象的发生。\",\"所以，为了避免幻读现象的发生，就需要在二级索引索引上加范围 (22, 39) 的间隙锁。\"]},\"298\":{\"h\":\"非唯一索引范围查询\",\"t\":[\"非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况 **，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。\",\"就带大家简单分析一下，事务 A 的这条范围查询语句：\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from user where age >= 22 for update; +----+-----------+-----+ | id | name | age | +----+-----------+-----+ | 10 | 山治 | 22 | | 20 | 香克斯 | 39 | +----+-----------+-----+ 2 rows in set (0.01 sec) \",\"事务 A 的加锁变化：\",\"最开始要找的第一行是 age = 22，虽然范围查询语句包含等值查询，但是这里不是唯一索引范围查询，所以是不会发生退化锁的现象，因此对该二级索引记录加 next-key 锁，范围是 (21, 22]。同时，对 age = 22 这条记录的主键索引加记录锁，即对 id = 10 这一行记录的主键索引加记录锁。\",\"由于是范围查询，接着继续扫描已经存在的二级索引记录。扫面的第二行是 age = 39 的二级索引记录，于是对该二级索引记录加 next-key 锁，范围是 (22, 39]，同时，对 age = 39 这条记录的主键索引加记录锁，即对 id = 20 这一行记录的主键索引加记录锁。\",\"虽然我们看见表中最后一条二级索引记录是 age = 39 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该二级索引记录加的是范围为 (39, +∞] 的 next-key 锁。\",\"停止查询\",\"可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：\",\"主键索引（id 列）： \",\"在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。\",\"在 id = 20 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 20 的这一行记录。\",\"二级索引（age 列）： \",\"在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于是否可以插入 age = 21 和 age = 22 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。\",\"在 age = 39 这条记录的二级索引上，加了范围为 (22, 39] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 39 的这一些记录，也无法插入 age 值为 23、24、25、...、38 的这一些新记录。不过对于是否可以插入 age = 22 和 age = 39 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。\",\"在特殊的记录（supremum pseudo-record）的二级索引上，加了范围为 (39, +∞] 的 next-key 锁，意味着其他事务无法插入 age 值大于 39 的这些新记录。\",\"在 age >= 22 的范围查询中，明明查询 age = 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age = 22 记录的二级索引上的 next-key 锁退化为记录锁？\",\"因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age = 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。\"]},\"299\":{\"h\":\"没有加索引的查询\",\"t\":[\"前面的案例，我们的查询语句都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。\",\"如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。\",\"不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。\",\"因此，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。\"]},\"300\":{\"h\":\"总结\",\"t\":[\"这次我以 MySQL 8.0.26 版本，在可重复读隔离级别之下，做了几个实验，让大家了解了唯一索引和非唯一索引的行级锁的加锁规则。\",\"我这里总结下， MySQL 行级锁的加锁规则。\",\"唯一索引等值查询：\",\"当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。\",\"当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会**退化成「间隙锁」 **。\",\"非唯一索引等值查询：\",\"当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。\",\"当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。\",\"非唯一索引和主键索引的范围查询的加锁规则不同之处在于：\",\"唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。\",\"非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。\",\"其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。\",\"还有一件很重要的事情，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，*如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了*，这是挺严重的问题。\",\"最后附上「@一只小铭」同学总结的流程图。\",\"唯一索引加锁的流程图：\",\"非唯一索引加锁的流程图：\",\"就说到这啦， 我们下次见啦！\"]},\"301\":{\"h\":\"MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？\",\"t\":[\"昨天有位读者在美团二面的时候，被问到关于幻读的问题：\",\"面试官反问的大概意思是，MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？\",\"答案是可以的。\",\"接下来，通过几个小实验来证明这个结论吧，顺便再帮大家复习一下记录锁+间隙锁。\"]},\"302\":{\"h\":\"什么是幻读？\",\"t\":[\"首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:\",\"The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.\",\"翻译：当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。\",\"举个例子，假设一个事务在 T1 时刻和 T2 时刻分别执行了下面查询语句，途中没有执行其他任何语句：\",\"SELECT * FROM t_test WHERE id > 100; \",\"只要 T1 和 T2 时刻执行产生的结果集是不相同的，那就发生了幻读的问题，比如：\",\"T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 6 条行记录，那就发生了幻读的问题。\",\"T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 4 条行记录，也是发生了幻读的问题。\",\"MySQL 是怎么解决幻读的？\",\"MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 ），解决的方案有两种：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读 ，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\"]},\"303\":{\"h\":\"实验验证\",\"t\":[\"接下来，来验证「 MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读问题」的结论。\",\"实验环境：MySQL 8.0 版本，可重复读隔离级。\",\"现在有一张用户表（t_user），表里只有一个主键索引，表里有以下行数据：\",\"现在有一个 A 事务执行了一条查询语句，查询到年龄大于 20 岁的用户共有 6 条行记录。\",\"然后， B 事务执行了一条删除 id = 2 的语句：\",\"此时，B 事务的删除语句就陷入了等待状态，说明是无法进行删除的。\",\"因此，MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读问题。\"]},\"304\":{\"h\":\"加锁分析\",\"t\":[\"问题来了，A 事务在执行 select ... for update 语句时，具体加了什么锁呢？\",\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"输出的内容很多，共有 11 行信息，我删减了一些不重要的信息：\",\"从上面输出的信息可以看到，共加了两种不同粒度的锁，分别是：\",\"表锁（LOCK_TYPE: TABLE）：X 类型的意向锁；\",\"行锁（LOCK_TYPE: RECORD）：X 类型的 next-key 锁；\",\"这里我们重点关注「行锁」，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思：\",\"如果 LOCK_MODE 为 X，说明是 next-key 锁；\",\"如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；\",\"如果 LOCK_MODE 为 X, GAP，说明是间隙锁；\",\"然后通过 LOCK_DATA 信息，可以确认 next-key 锁的范围，具体怎么确定呢？\",\"根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，而锁范围的最左值为 LOCK_DATA 的上一条记录的值。\",\"因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了 10 个 next-key 锁，如下：\",\"X 型的 next-key 锁，范围：(-∞, 1]\",\"X 型的 next-key 锁，范围：(1, 2]\",\"X 型的 next-key 锁，范围：(2, 3]\",\"X 型的 next-key 锁，范围：(3, 4]\",\"X 型的 next-key 锁，范围：(4, 5]\",\"X 型的 next-key 锁，范围：(5, 6]\",\"X 型的 next-key 锁，范围：(6, 7]\",\"X 型的 next-key 锁，范围：(7, 8]\",\"X 型的 next-key 锁，范围：(8, 9]\",\"X 型的 next-key 锁，范围：(9, +∞]\",\"这相当于把整个表给锁住了，其他事务在对该表进行增、删、改操作的时候都会被阻塞。\",\"只有在事务 A 提交了事务，事务 A 执行过程中产生的锁才会被释放。\",\"为什么只是查询年龄 20 岁以上行记录，而把整个表给锁住了呢？\",\"这是因为事务 A 的这条查询语句是全表扫描，锁是在遍历索引的时候加上的，并不是针对输出的结果加锁。\",\"因此，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。\",\"如果对 age 建立索引，事务 A 这条查询会加什么锁呢？\",\"接下来，我对 age 字段建立索引，然后再执行这条查询语句：\",\"接下来，继续通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"具体的信息，我就不打印了，我直接说结论吧。\",\"因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。\",\"主键索引会加如下的锁：\",\"X 型的记录锁，锁住 id = 2 的记录；\",\"X 型的记录锁，锁住 id = 3 的记录；\",\"X 型的记录锁，锁住 id = 5 的记录；\",\"X 型的记录锁，锁住 id = 6 的记录；\",\"X 型的记录锁，锁住 id = 7 的记录；\",\"X 型的记录锁，锁住 id = 8 的记录；\",\"分析 age 索引加锁的范围时，要先对 age 字段进行排序。\",\"age 索引加的锁：\",\"X 型的 next-key lock，锁住 age 范围 (19, 21] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (21, 21] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (21, 23] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (23, 23] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (23, 39] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (39, 43] 的记录；\",\"X 型的 next-key lock，锁住 age 范围 (43, +∞] 的记录；\",\"化简一下，age 索引 next-key 锁的范围是 (19, +∞]。\",\"可以看到，对 age 字段建立了索引后，查询语句是索引查询，并不会全表扫描，因此不会把整张表给锁住。\",\"总结一下，在对 age 字段建立索引后，事务 A 在执行下面这条查询语句后，主键索引和 age 索引会加下图中的锁。\",\"事务 A 加上锁后，事务 B、C、D、E 在执行以下语句都会被阻塞。\"]},\"305\":{\"h\":\"总结\",\"t\":[\"在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。\",\"有一点要注意的是，在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。\",\"完！\"]},\"306\":{\"h\":\"MySQL 有哪些锁？\",\"t\":[\"这次，来说说 MySQL 的锁，主要是 Q&A 的形式，看起来会比较轻松。\",\"不多 BB 了，发车！\",\"在 MySQL 里，根据加锁的范围，可以分为全局锁、表级锁和行锁三类。\"]},\"307\":{\"h\":\"全局锁\",\"t\":[\"全局锁是怎么用的？\",\"要使用全局锁，则要执行这条命令：\",\"flush tables with read lock \",\"执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：\",\"对数据的增删改操作，比如 insert、delete、update等语句；\",\"对表结构的更改操作，比如 alter table、drop table 等语句。\",\"如果要释放全局锁，则要执行这条命令：\",\"unlock tables \",\"当然，当会话断开了，全局锁会被自动释放。\",\"全局锁应用场景是什么？\",\"全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。\",\"举个例子大家就知道了。\",\"在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。\",\"如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更新，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。\",\"那么，有可能出现这样的顺序：\",\"先备份了用户表的数据；\",\"然后有用户发起了购买商品的操作；\",\"接着再备份商品表的数据。\",\"也就是在备份用户表和商品表之间，有用户购买了商品。\",\"这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。\",\"所以，在全库逻辑备份期间，加上全局锁，就不会出现上面这种情况了。\",\"加全局锁又会带来什么缺点呢？\",\"加上全局锁，意味着整个数据库都是只读状态。\",\"那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\",\"既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？\",\"有的，如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。\",\"因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。\",\"备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。\",\"InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。\",\"但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。\"]},\"308\":{\"h\":\"表级锁\",\"t\":[\"MySQL 表级锁有哪些？具体怎么用的。\",\"MySQL 里面表级别的锁有这几种：\",\"表锁；\",\"元数据锁（MDL）;\",\"意向锁；\",\"AUTO-INC 锁；\"]},\"309\":{\"h\":\"表锁\",\"t\":[\"先来说说表锁。\",\"如果我们想对学生表（t_student）加表锁，可以使用下面的命令：\",\"//表级别的共享锁，也就是读锁； lock tables t_student read; //表级别的独占锁，也就是写锁； lock tables t_student write; \",\"需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。\",\"也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。\",\"要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：\",\"unlock tables \",\"另外，当会话退出后，也会释放所有表锁。\",\"不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，**InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁 **。\"]},\"310\":{\"h\":\"元数据锁\",\"t\":[\"再来说说元数据锁（MDL）。\",\"我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：\",\"对一张表进行 CRUD 操作时，加的是 MDL 读锁；\",\"对一张表做结构变更操作的时候，加的是 MDL 写锁；\",\"MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。\",\"当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。\",\"反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。\",\"MDL 不需要显示调用，那它是在什么时候释放的?\",\"MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。\",\"那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：\",\"首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；\",\"然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；\",\"接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，\",\"那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。\",\"为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？\",\"这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。\",\"所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以，考虑 kill 掉这个长事务，然后再做表结构的变更。\"]},\"311\":{\"h\":\"意向锁\",\"t\":[\"接着，说说意向锁。\",\"在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；\",\"在使用 InnoDB 引擎的表里对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；\",\"也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。\",\"而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。\",\"不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：\",\"//先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先在表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update; \",\"意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。\",\"表锁和行锁是满足读读共享、读写互斥、写写互斥的。\",\"如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。\",\"那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。\",\"所以，意向锁的目的是为了快速判断表里是否有记录被加锁。\"]},\"312\":{\"h\":\"AUTO-INC 锁\",\"t\":[\"表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。\",\"之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。\",\"AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。\",\"在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。\",\"那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。\",\"但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。\",\"因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。\",\"一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，*然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁*。\",\"InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。\",\"当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；\",\"当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。\",\"当 innodb_autoinc_lock_mode = 1： \",\"普通 insert 语句，自增锁在申请之后就马上释放；\",\"类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；\",\"当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。\",\"举个例子，考虑下面场景：\",\"session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后两个 session 同时执行向表 t2 中插入数据。\",\"如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：\",\"session B 先插入了两个记录，(1,1,1)、(2,2,2)；\",\"然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；\",\"之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。\",\"可以看到，session B 的 insert 语句，生成的 id 不连续。\",\"当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。\",\"但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。\",\"要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。\",\"所以，当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题。\"]},\"313\":{\"h\":\"行级锁\",\"t\":[\"InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。\",\"前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。\",\"//对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update; \",\"上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。\",\"共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。\",\"行级锁的类型主要有三类：\",\"Record Lock，记录锁，也就是仅仅把一条记录锁上；\",\"Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；\",\"Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\"]},\"314\":{\"h\":\"Record Lock\",\"t\":[\"Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\",\"当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\",\"当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\",\"举个例子，当一个事务执行了下面这条语句：\",\"mysql > begin; mysql > select * from t_test where id = 1 for update; \",\"就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。\",\"当事务执行 commit 后，事务过程中生成的锁都会被释放。\"]},\"315\":{\"h\":\"Gap Lock\",\"t\":[\"Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。\",\"假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\",\"间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，* *间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的 **。\"]},\"316\":{\"h\":\"Next-Key Lock\",\"t\":[\"Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\",\"假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。\",\"所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。\",\"next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\",\"比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。\",\"虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。\"]},\"317\":{\"h\":\"插入意向锁\",\"t\":[\"一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。\",\"如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁 ，表明有事务想在某个区间插入新记录，但是现在处于等待状态。\",\"举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。\",\"当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。\",\"插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。\",\"如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。\",\"插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。\",\"参考资料：\",\"《MySQL技术内幕：innodb》\",\"《MySQL实战45讲》\",\"《从根儿上理解MySQL》\"]},\"318\":{\"h\":\"字节面试：加了什么锁，导致死锁的？\",\"t\":[\"之前收到读者面试字节时，被问到一个关于 MySQL 的问题。\",\"如果对 MySQL 加锁机制比较熟悉的同学，应该一眼就能看出会发生死锁，但是具体加了什么锁而导致死锁，是需要我们具体分析的。\",\"接下来，就跟聊聊上面两个事务执行 SQL 语句的过程中，加了什么锁，从而导致死锁的。\"]},\"319\":{\"h\":\"准备工作\",\"t\":[\"先创建一张 t_student 表，假设除了 id 字段，其他字段都是普通字段。\",\"CREATE TABLE `t_student` ( `id` int NOT NULL, `no` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `age` int DEFAULT NULL, `score` int DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \",\"然后，插入相关的数据后，t_student 表中的记录如下：\"]},\"320\":{\"h\":\"开始实验\",\"t\":[\"在实验开始前，先说明下实验环境：\",\"MySQL 版本：8.0.26\",\"隔离级别：可重复读（RR）\",\"启动两个事务，按照题目的 SQL 执行顺序，过程如下表格：\",\"可以看到，事务 A 和 事务 B 都在执行 insert 语句后，都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。\"]},\"321\":{\"h\":\"为什么会发生死锁？\",\"t\":[\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"接下来，针对每一条 SQL 语句分析具体加了什么锁。\"]},\"322\":{\"h\":\"Time 1 阶段加锁分析\",\"t\":[\"Time 1 阶段，事务 A 执行以下语句：\",\"# 事务 A mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> update t_student set score = 100 where id = 25; Query OK, 0 rows affected (0.01 sec) Rows matched: 0 Changed: 0 Warnings: 0 \",\"然后执行 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务 A 此时加了什么锁。\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的间隙锁；\",\"这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：\",\"如果 LOCK_MODE 为 X，说明是 next-key 锁；\",\"如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；\",\"如果 LOCK_MODE 为 X, GAP，说明是间隙锁；\",\"因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加的是间隙锁，锁范围是(20, 30)。\",\"间隙锁的范围(20, 30) ，是怎么确定的？\",\"根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 30。\",\"然后锁范围的最左值是 t_student 表中 id 为 30 的上一条记录的 id 值，即 20。\",\"因此，间隙锁的范围(20, 30)。\"]},\"323\":{\"h\":\"Time 2 阶段加锁分析\",\"t\":[\"Time 2 阶段，事务 B 执行以下语句：\",\"# 事务 B mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> update t_student set score = 100 where id = 26; Query OK, 0 rows affected (0.01 sec) Rows matched: 0 Changed: 0 Warnings: 0 \",\"然后执行 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务 B 此时加了什么锁。\",\"从上图可以看到，行锁是 X 类型的间隙锁，间隙锁的范围是(20, 30)。\",\"事务 A 和 事务 B 的间隙锁范围都是一样的，为什么不会冲突？\",\"两个事务的间隙锁之间是相互兼容的，不会产生冲突。\",\"在MySQL官网上还有一段非常关键的描述：\",\"Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from Inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.\",\"间隙锁的意义只在于阻止区间被插入，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁 **，共享（S型）和排他（X型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。\"]},\"324\":{\"h\":\"Time 3 阶段加锁分析\",\"t\":[\"Time 3，事务 A 插入了一条记录：\",\"# Time 3 阶段，事务 A 插入了一条记录 mysql> insert into t_student(id, no, name, age,score) value (25, 'S0025', 'sony', 28, 90); /// 阻塞等待...... \",\"此时，事务 A 就陷入了等待状态。\",\"然后执行 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务 A 在获取什么锁而导致被阻塞。\",\"可以看到，事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 (20, 30)）中插入了一条记录，所以事务 A 的插入操作生成了一个插入意向锁（LOCK_MODE:INSERT_INTENTION）。\",\"插入意向锁是什么？\",\"注意！插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁。\",\"在MySQL的官方文档中有以下重要描述：\",\"*An Insert intention lock is a type of gap lock set by Insert operations prior to row Insertion. This lock signals the intent to Insert in such a way that multiple transactions Inserting into the same index gap need not wait for each other if they are not Inserting at the same position within the gap. Suppose that there are index records with values of 4 and\",\"Separate transactions that attempt to Insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with Insert intention locks prior to obtaining the exclusive lock on the Inserted row, but do not block each other because the rows are nonconflicting.*\",\"这段话表明尽管插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作。\",\"如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。\",\"插入意向锁与间隙锁的另一个非常重要的差别是：* *尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的 **。\",\"另外，我补充一点，插入意向锁的生成时机：\",\"每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），现象就是 Insert 语句会被阻塞。\"]},\"325\":{\"h\":\"Time 4 阶段加锁分析\",\"t\":[\"Time 4，事务 B 插入了一条记录：\",\"# Time 4 阶段，事务 B 插入了一条记录 mysql> insert into t_student(id, no, name, age,score) value (26, 'S0026', 'ace', 28, 90); /// 阻塞等待...... \",\"此时，事务 B 就陷入了等待状态。\",\"然后执行 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务 B 在获取什么锁而导致被阻塞。\",\"可以看到，事务 B 在生成插入意向锁时而导致被阻塞，这是因为事务 B 向事务 A 生成的范围为 (20, 30) 的间隙锁插入了一条记录，而插入意向锁和间隙锁是冲突的，所以事务 B 在获取插入意向锁时就陷入了等待状态。\",\"最后回答，为什么会发生死锁？\",\"本次案例中，事务 A 和事务 B 在执行完后 update 语句后都持有范围为(20, 30） 的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：*互斥、占有且等待、不可强占用、循环等待*，因此发生了死锁。\"]},\"326\":{\"h\":\"总结\",\"t\":[\"两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。\",\"在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。\",\"如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：互斥、占有且等待、不可强占用、循环等待，因此发生了死锁。\"]},\"327\":{\"h\":\"读者问答\"},\"328\":{\"h\":\"update 没加索引会锁全表？\",\"t\":[\"昨晚在群划水的时候，看到有位读者说了这么一件事。\",\"大概就是，在线上执行一条 update 语句修改数据库数据的时候，where 条件没有带上索引，导致业务直接崩了，被老板教训了一波\",\"这次我们就来看看：\",\"为什么会发生这种的事故？\",\"又该如何避免这种事故的发生？\",\"说个前提，接下来说的案例都是基于 InnoDB 存储引擎，且事务的隔离级别是可重复读。\"]},\"329\":{\"h\":\"为什么会发生这种的事故？\",\"t\":[\"InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。\",\"因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。\",\"当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。\",\"在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。\",\"比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。\",\"这里举个例子，这里有一张数据库表，其中 id 为主键索引。\",\"假设有两个事务的执行顺序如下：\",\"在这里插入图片描述\",\"可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id = 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。\",\"但是，**在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了 **。\",\"假设有两个事务的执行顺序如下：\",\"可以看到，这次事务 B 的 update 语句被阻塞了。\",\"这是因为事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。\",\"因此，当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 select ... from 语句，其他语句都会被锁住不能执行，业务会因此停滞，接下来等着你的，就是老板的挨骂。\",\"那 update 语句的 where 带上索引就能避免全表记录加锁了吗？\",\"并不是。\",\"关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。\",\"提示\",\"网上很多资料说，update 没加锁索引会加表锁，这是不对的。\",\"Innodb 源码里面在扫描记录的时候，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，所以大家误以为加了表锁。\"]},\"330\":{\"h\":\"如何避免这种事故的发生？\",\"t\":[\"我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。\",\"官方的解释： If set to 1, MySQL aborts UPDATE or DELETE statements that do not use a key in the WHERE clause or a LIMIT clause. ( Specifically, UPDATE statements must have a WHERE clause that uses a key or a LIMIT clause, or both. DELETE statements must have both.) This makes it possible to catch UPDATE or DELETE statements where keys are not used properly and that would probably change or delete a large number of rows. The default value is 0.\",\"大致的意思是，当 sql_safe_updates 设置为 1 时。\",\"update 语句必须满足如下条件之一才能执行成功：\",\"使用 where，并且 where 条件中必须有索引列；\",\"使用 limit；\",\"同时使用 where 和 limit，此时 where 条件中可以没有索引列；\",\"delete 语句必须满足以下条件能执行成功：\",\"同时使用 where 和 limit，此时 where 条件中可以没有索引列；\",\"如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。\"]},\"331\":{\"h\":\"总结\",\"t\":[\"不要小看一条 update 语句，在生产机上使用不当可能会导致业务停滞，甚至崩溃。\",\"当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。\",\"我们可以打开 MySQL sql_safe_updates 参数，这样可以预防 update 操作时 where 条件没有带上索引列。\",\"如果发现即使在 where 条件中带上了索引列，优化器走的还是全表扫描，这时我们就要使用 force index([index_name]) 可以告诉优化器使用哪个索引。\",\"这次就说到这啦，下次要小心点，别再被老板挨骂啦。\"]},\"332\":{\"h\":\"\",\"t\":[\"redo log、binlog、undolog 正在赶稿的路上。。。。。\"]},\"333\":{\"h\":\"MySQL 日志：undo log、redo log、binlog 有什么用？\",\"t\":[\"大家好，我是小林。\",\"从这篇「执行一条 SQL 查询语句，期间发生了什么？ 」中，我们知道了一条查询语句经历的过程，这属于「读」一条记录的过程，如下图：\",\"查询语句执行流程\",\"那么，执行一条 update 语句，期间发生了什么？，比如这一条 update 语句：\",\"UPDATE t_user SET name = 'xiaolin' WHERE id = 1; \",\"查询语句的那一套流程，更新语句也是同样会走一遍：\",\"客户端先通过连接器建立连接，连接器自会判断用户身份；\",\"因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；\",\"解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；\",\"预处理器会判断表和字段是否存在；\",\"优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；\",\"执行器负责具体执行，找到这一行，然后更新。\",\"不过，更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：\",\"undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。\",\"redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；\",\"binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；\",\"所以这次就带着这个问题，看看这三种日志是怎么工作的。\"]},\"334\":{\"h\":\"为什么需要 undo log？\",\"t\":[\"我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会隐式开启事务 来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。\",\"执行一条语句是否自动提交事务，是由 autocommit 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。\",\"那么，考虑一个问题。一个事务在执行过程中，在还没有提交事务之前，如果MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？\",\"如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。\",\"实现这一机制就是 undo log（回滚日志），它保证了事务的 ACID 特性 中的原子性（Atomicity）。\",\"undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：\",\"回滚事务\",\"每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：\",\"在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；\",\"在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；\",\"在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。\",\"在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。\",\"不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查。\",\"一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：\",\"通过 trx_id 可以知道该记录是被哪个事务修改的；\",\"通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；\",\"版本链如下图：\",\"版本链\",\"另外，undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。\",\"对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：\",\"「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。\",\"这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。具体的实现可以看我这篇文章：事务隔离级别是怎么实现的？\",\"因此，undo log 两大作用：\",\"实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。\",\"实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。\"]},\"335\":{\"h\":\"为什么需要 Buffer Pool？\",\"t\":[\"MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？\",\"当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。\",\"为此，Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\",\"Buffer Poo\",\"有了 Buffer Pool 后：\",\"当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。\",\"当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\"]},\"336\":{\"h\":\"Buffer Pool 缓存什么？\",\"t\":[\"InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。\",\"在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。\",\"所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。\",\"Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。\",\"Undo 页是记录什么？\",\"开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\",\"查询一条记录，就只需要缓冲一条记录吗？\",\"不是的。\",\"当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。\",\"关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案：换一个角度看 B+ 树\"]},\"337\":{\"h\":\"为什么需要 redo log ？\",\"t\":[\"Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。\",\"为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。\",\"后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 **WAL （Write-Ahead Logging）技术 **。\",\"WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。\",\"过程如下图：\",\"什么是 redo log？\",\"redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新 ，每当执行一个事务就会产生这样的一条或者多条物理日志。\",\"在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。\",\"当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。\",\"被修改 Undo 页面，需要记录对应 redo log 吗？\",\"需要的。\",\"开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\",\"不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。\",\"redo log 和 undo log 区别在哪？\",\"这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：\",\"redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；\",\"undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；\",\"事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：\",\"事务恢复\",\"所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 *crash-safe*（崩溃恢复）。可以看出来， redo log 保证了事务四大特性中的持久性。\",\"redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？\",\"写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是*随机写*。\",\"磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。\",\"针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。\",\"可以说这是 WAL 技术的另外一个优点：MySQL 的写操作从磁盘的「随机写」变成了「顺序写」，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。\",\"至此， 针对为什么需要 redo log 这个问题我们有两个答案：\",\"实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；\",\"将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。\",\"产生的 redo log 是直接写入磁盘的吗？\",\"不是的。\",\"实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。\",\"所以，redo log 也有自己的缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：\",\"事务恢复\",\"redo log buffer 默认大小 16 MB，可以通过 innodb_log_Buffer_size 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。\"]},\"338\":{\"h\":\"redo log 什么时候刷盘？\",\"t\":[\"缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？\",\"主要有下面几个时机：\",\"MySQL 正常关闭时；\",\"当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\",\"InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\",\"每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。\",\"innodb_flush_log_at_trx_commit 参数控制的是什么？\",\"单独执行一个更新语句的时候，InnoDB 引擎会自己启动一个事务，在执行更新语句的过程中，生成的 redo log 先写入到 redo log buffer 中，然后等事务提交的时候，再将缓存在 redo log buffer 中的 redo log 按组的方式「顺序写」到磁盘。\",\"上面这种 redo log 刷盘时机是在事务提交的时候，这个默认的行为。\",\"除此之外，InnoDB 还提供了另外两种策略，由参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：\",\"当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\",\"当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。\",\"当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看这篇 ），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。\",\"我画了一个图，方便大家理解：\",\"innodb_flush_log_at_trx_commit 为 0 和 2 的时候，什么时候才将 redo log 写入磁盘？\",\"InnoDB 的后台线程每隔 1 秒：\",\"针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 write() 写到操作系统的 Page Cache，然后调用 fsync() 持久化到磁盘。所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失;\",\"针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。**所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失 **。\",\"加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：\",\"这三个参数的应用场景是什么？\",\"这三个参数的数据安全性和写入性能的比较如下：\",\"数据安全性：参数 1 > 参数 2 > 参数 0\",\"写入性能：参数 0 > 参数 2> 参数 1\",\"所以，数据安全性和写入性能是熊掌不可得兼的，要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性。\",\"在一些对数据安全性要求比较高的场景中，显然 innodb_flush_log_at_trx_commit 参数需要设置为 1。\",\"在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I/O 操作。\",\"安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方面比参数 1 高。\"]},\"339\":{\"h\":\"redo log 文件写满了怎么办？\",\"t\":[\"默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：ib_logfile0 和 ib_logfile1 。\",\"重做日志文件组\",\"在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。\",\"重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。\",\"所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。\",\"重做日志文件组写入过程\",\"我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。\",\"redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 check point 表示当前要擦除的位置，如下图：\",\"图中的：\",\"write pos 和 check point 的移动都是顺时针方向；\",\"write pos ～ check point 之间的部分（图中的红色部分），用来记录新的更新操作；\",\"check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；\",\"如果 write pos 追上了 check point，就意味着 **redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，check point 就会往后移动（图中顺时针） **，然后 MySQL 恢复正常运行，继续执行新的更新操作。\",\"所以，一次 check point 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。\"]},\"340\":{\"h\":\"为什么需要 binlog ？\",\"t\":[\"前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。\",\"MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。\",\"binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。\",\"为什么有了 binlog， 还要有 redo log？\",\"这个问题跟 MySQL 的时间线有关系。\",\"最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。\",\"而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。\"]},\"341\":{\"h\":\"redo log 和 binlog 有什么区别？\",\"t\":[\"这两个日志有四个区别。\",\"1、适用对象不同：\",\"binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；\",\"redo log 是 Innodb 存储引擎实现的日志；\",\"2、文件格式不同：\",\"binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下： \",\"STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；\",\"ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；\",\"MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；\",\"redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；\",\"3、写入方式不同：\",\"binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\",\"redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。\",\"4、用途不同：\",\"binlog 用于备份恢复、主从复制；\",\"redo log 用于掉电等故障恢复。\",\"如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？\",\"不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。\",\"因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。\",\"binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。\"]},\"342\":{\"h\":\"主从复制是怎么实现？\",\"t\":[\"MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。\",\"这个过程一般是异步的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。\",\"MySQL 主从复制过程\",\"MySQL 集群的主从复制过程梳理成 3 个阶段：\",\"写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。\",\"同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。\",\"回放 Binlog：回放 binlog，并更新存储引擎中的数据。\",\"具体详细过程如下：\",\"MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。\",\"从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。\",\"从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。\",\"在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。\",\"MySQL 主从架构\",\"从库是不是越多越好？\",\"不是的。\",\"因为从库数量增加，从库连接上来的 I/O 线程也比较多，**主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽 **。\",\"所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。\",\"MySQL 主从复制还有哪些模型？\",\"主要有三种：\",\"同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。\",\"异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。\",\"半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种 **半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险 **。\"]},\"343\":{\"h\":\"binlog 什么时候刷盘？\",\"t\":[\"事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。\",\"MySQL 给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。\",\"什么时候 binlog cache 会写到 binlog 文件？\",\"在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：\",\"binlog cach\",\"虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：\",\"图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。\",\"图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。\",\"MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：\",\"sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；\",\"sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；\",\"sync_binlog =N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。\",\"在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。\",\"而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。\",\"如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。\",\"三个日志讲完了，至此我们可以先小结下，update 语句的执行过程。\",\"当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。\",\"具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:\",\"执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： \",\"如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\",\"如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\",\"执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： \",\"如果一样的话就不进行后续更新流程；\",\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\",\"开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\",\"InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\",\"至此，一条记录更新完了。\",\"在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\",\"事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。\"]},\"344\":{\"h\":\"为什么需要两阶段提交？\",\"t\":[\"事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\",\"举个例子，假设 id = 1 这行数据的字段 name 的值原本是 'jay'，然后执行 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：\",\"如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；\",\"如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；\",\"可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。\",\"MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决 ，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。\",\"两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」 ，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。\",\"举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？\",\"准备阶段：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。\",\"提交阶段：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。\"]},\"345\":{\"h\":\"两阶段提交的过程是怎样的？\",\"t\":[\"在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了内部 XA 事务（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。\",\"当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交，如下图：\",\"两阶段提交\",\"从图中可看出，事务的提交过程有两个阶段，就是将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog ，具体如下：\",\"prepare 阶段：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；\",\"commit 阶段：把 XID 写入到 binlog，然后将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件，所以 commit 状态也是会刷盘的）；\"]},\"346\":{\"h\":\"异常重启会出现什么现象？\",\"t\":[\"我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：\",\"时刻 A 与时刻 B\",\"不管是时刻 A（已经 redo log，还没写入 binlog），还是时刻 B （已经写入 redo log 和 binlog，还没写入 commit 标识）崩溃，此时的 redo log 都处于 prepare 状态。\",\"在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：\",\"如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。对应时刻 A 崩溃恢复的情况。\",\"如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务。对应时刻 B 崩溃恢复的情况。\",\"可以看到，对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。\",\"所以说，两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。\",\"处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?\",\"binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。\",\"所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。\",\"事务没提交的时候，redo log 会被持久化到磁盘吗？\",\"会的。\",\"事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。\",\"也就是说，事务没提交的时候，redo log 也是可能被持久化到磁盘的。\",\"有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？\",\"放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。\",\"所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。\"]},\"347\":{\"h\":\"两阶段提交有什么问题？\",\"t\":[\"两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：\",\"磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。\",\"锁竞争激烈 ：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。\",\"为什么两阶段提交的磁盘 I/O 次数会很高？\",\"binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：\",\"当 sync_binlog = 1 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；\",\"当 innodb_flush_log_at_trx_commit = 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；\",\"可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会至少调用 2 次刷盘操作，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。\",\"为什么锁竞争激烈？\",\"在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。\",\"通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。\"]},\"348\":{\"h\":\"组提交\",\"t\":[\"MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。\",\"引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：\",\"flush 阶段：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；\",\"sync 阶段：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；\",\"commit 阶段：各个事务按顺序做 InnoDB commit 操作；\",\"上面的每个阶段都有一个队列，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。\",\"每个阶段都有一个队列\",\"对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，*锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率*。\",\"有 binlog 组提交，那有 redo log 组提交吗？\",\"这个要看 MySQL 版本，MySQL 5.6 没有 redo log 组提交，MySQL 5.7 有 redo log 组提交。\",\"在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。\",\"所以在 MySQL 5.7 版本中，做了个改进，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段。\",\"这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。\",\"接下来介绍每个阶段的过程，注意下面的过程针对的是“双 1” 配置（sync_binlog 和 innodb_flush_log_at_trx_commit 都配置为 1）。\",\"flush 阶段\",\"第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower ：\",\"接着，获取队列中的事务组，由绿色事务组的 Leader 对 rodo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘：\",\"完成了 prepare 阶段后，将绿色这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。\",\"从上面这个过程，可以知道 flush 阶段队列的作用是用于支撑 redo log 的组提交。\",\"如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。\",\"sync 阶段\",\"绿色这一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是会等待一段时间 ，这个等待的时长由 Binlog_group_commit_sync_delay 参数控制，目的是为了组合更多事务的 binlog，然后再一起刷盘，如下过程：\",\"不过，在等待的过程中，如果事务的数量提前达到了 Binlog_group_commit_sync_no_delay_count 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘，如下图：\",\"从上面的过程，可以知道 sync 阶段队列的作用是用于支持 binlog 的组提交。\",\"如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：\",\"binlog_group_commit_sync_delay= N，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。\",\"binlog_group_commit_sync_no_delay_count = N，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。\",\"如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL会在重启后通过 redo log 刷盘的数据继续进行事务的提交。\",\"commit 阶段\",\"最后进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。\",\"commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。\"]},\"349\":{\"h\":\"MySQL 磁盘 I/O 很高，有什么优化的方法？\",\"t\":[\"现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：\",\"设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。\",\"将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。\",\"将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。\"]},\"350\":{\"h\":\"总结\",\"t\":[\"具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:\",\"执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： \",\"如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\",\"如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\",\"执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： \",\"如果一样的话就不进行后续更新流程；\",\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\",\"开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\",\"InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\",\"至此，一条记录更新完了。\",\"在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\",\"事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）： \",\"prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；\",\"commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；\",\"至此，一条更新语句执行完成。\",\"参考资料：\",\"《MySQL 45 讲》\",\"《MySQL 是怎样运行的？》\",\"https://developer.aliyun.com/article/617776\",\"http://mysql.taobao.org/monthly/2021/10/01/\",\"https://www.cnblogs.com/Neeo/articles/13883976.html\",\"https://www.cnblogs.com/mengxinJ/p/14211427.html\"]},\"351\":{\"h\":\"事务隔离级别是怎么实现的？\",\"t\":[\"这是我的钱包，共有 100 万元。\",\"图片\",\"今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？\",\"转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：\",\"图片\",\"可以看到这个转账的过程涉及到了两次修改数据库的操作。\",\"假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说这 100 万消失了！\",\"要解决这个问题，就要保证转账业务里的所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据。\",\"数据库中的「事务（Transaction）」就能达到这样的效果。\",\"我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。\",\"没错，今天就来图解 MySQL 事务啦，开车！\"]},\"352\":{\"h\":\"事务有哪些特性？\",\"t\":[\"事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。\",\"不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。\",\"事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：\",\"原子性（Atomicity） ：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。\",\"一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。\",\"隔离性（Isolation） ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。\",\"持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\",\"InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？\",\"持久性是通过 redo log （重做日志）来保证的；\",\"原子性是通过 undo log（回滚日志） 来保证的；\",\"隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；\",\"一致性则是通过持久性+原子性+隔离性来保证；\",\"这次将重点介绍事务的隔离性，这也是面试时最常问的知识的点。\",\"为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。\"]},\"353\":{\"h\":\"并行事务会引发什么问题？\",\"t\":[\"MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。\",\"那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。\",\"接下来，通过举例子给大家说明，这些问题是如何发生的。\"]},\"354\":{\"h\":\"脏读\",\"t\":[\"如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。\",\"举个栗子。\",\"假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。\",\"图片\",\"因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。\"]},\"355\":{\"h\":\"不可重复读\",\"t\":[\"在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。\",\"举个栗子。\",\"假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，**在这过程中如果事务B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。 **\",\"图片\"]},\"356\":{\"h\":\"幻读\",\"t\":[\"**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。 **\",\"举个栗子。\",\"假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务B也按相同的搜索条件也是查询出了 5 条记录。\",\"图片\",\"接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。\",\"然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，**发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。 **\"]},\"357\":{\"h\":\"事务的隔离级别有哪些？\",\"t\":[\"前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程度的影响。\",\"脏读：读到其他事务未提交的数据；\",\"不可重复读：前后读取的数据不一致；\",\"幻读：前后读取的记录数量不一致。\",\"这三个现象的严重性排序如下：\",\"图片\",\"SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：\",\"读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；\",\"读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；\",\"可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；\",\"串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；\",\"按隔离水平高低排序如下：\",\"图片\",\"针对不同的隔离级别，并发事务时可能发生的现象也会不同。\",\"图片\",\"也就是说：\",\"在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；\",\"在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；\",\"在「可重复读」隔离级别下，可能发生幻读现象，但是不可能发生脏读和不可重复读现象；\",\"在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。\",\"所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。\",\"不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。\",\"MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。\",\"**MySQL InnoDB引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 **，解决的方案有两种：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读 ，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读 ，因为当执行select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\",\"接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：\",\"图片\",\"在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：\",\"在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；\",\"在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；\",\"在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；\",\"在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。\",\"这四种隔离级别具体是如何实现的呢？\",\"对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；\",\"对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；\",\"对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 ReadView来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 ReadView，然后整个事务期间都在用这个 Read View。\",\"注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：\",\"第一种：begin/start transaction 命令；\",\"第二种：start transaction with consistent snapshot 命令；\",\"这两种开启事务的命令，事务的启动时机是不同的：\",\"执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；\",\"执行了 start transaction with consistent snapshot 命令，就会马上启动事务。\",\"接下来详细说下，Read View 在 MVCC 里如何工作的？\"]},\"358\":{\"h\":\"Read View 在 MVCC 里如何工作的？\",\"t\":[\"我们需要了解两个知识：\",\"Read View 中四个字段作用；\",\"聚簇索引记录中两个跟事务有关的隐藏列；\",\"那 Read View 到底是个什么东西？\",\"Read View 有四个重要的字段：\",\"m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务 **。\",\"min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。\",\"max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；\",\"creator_trx_id ：指的是创建该 Read View 的事务的事务 id。\",\"知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。\",\"假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：\",\"图片\",\"对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：\",\"trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；\",\"roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录 **，于是就可以通过它找到修改前的记录。\",\"在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：\",\"一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：\",\"如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前 已经提交的事务生成的，所以该版本的记录对当前事务可见。\",\"如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后 才启动的事务生成的，所以该版本的记录对当前事务不可见。\",\"如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中： \",\"如果记录的 trx_id 在m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。\",\"如果记录的 trx_id 不在m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见 **。\",\"这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。\"]},\"359\":{\"h\":\"可重复读是如何工作的？\",\"t\":[\"可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。\",\"假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：\",\"事务 A 和 事务 B 的 Read View 具体内容如下：\",\"在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。\",\"在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，活跃的事务 id 中最小的事务 id 是事务 A，下一个事务 id 应该是 53。\",\"接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：\",\"事务 B 读取小林的账户余额记录，读到余额是 100 万；\",\"事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；\",\"事务 B 读取小林的账户余额记录，读到余额还是 100 万；\",\"事务 A 提交事务；\",\"事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；\",\"接下来，跟大家具体分析下。\",\"事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的，也就是事务 B 可以获取到这条记录。\",\"接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成版本链，如下图：\",\"你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。\",\"然后事务 B 第二次去读取该记录，发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 可见的第一条记录（trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值，或者trx_id在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，但是不在 m_ids 范围内），所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。\",\"最后，当事物 A 提交事务后，由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录。\",\"就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。\"]},\"360\":{\"h\":\"读提交是如何工作的？\",\"t\":[\"读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。\",\"也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。\",\"假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：\",\"事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\",\"事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；\",\"事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\",\"事务 A 提交事务；\",\"事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；\",\"那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：\",\"我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？\",\"事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明**这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录 **。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 可见的第一条记录（trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值，或者trx_id在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，但是不在 m_ids 范围内），所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。\",\"我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？\",\"在事务 A 提交后，由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View，此时事务 B 第三次读取数据时创建的 Read View 如下：\",\"事务 B 在找到小林这条记录时，会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的。\",\"正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\"]},\"361\":{\"h\":\"总结\",\"t\":[\"事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。\",\"当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。\",\"要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。\",\"而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 ），解决的方案有两种：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读 ，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\",\"对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：\",\"「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。\",\"这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。\",\"在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。\"]},\"362\":{\"h\":\"MySQL 可重复读隔离级别，完全解决幻读了吗？\",\"t\":[\"我在上一篇文章提到，MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读 ，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\",\"这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。\",\"这次，就跟大家好好聊这个问题。\"]},\"363\":{\"h\":\"什么是幻读？\",\"t\":[\"首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:\",\"The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.\",\"翻译：当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。\",\"举个例子，假设一个事务在 T1 时刻和 T2 时刻分别执行了下面查询语句，途中没有执行其他任何语句：\",\"SELECT * FROM t_test WHERE id > 100; \",\"只要 T1 和 T2 时刻执行产生的结果集是不相同的，那就发生了幻读的问题，比如：\",\"T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 6 条行记录，那就发生了幻读的问题。\",\"T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 4 条行记录，也是发生了幻读的问题。\"]},\"364\":{\"h\":\"快照读是如何避免幻读的？\",\"t\":[\"可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，* *后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的 **，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"做个实验，数据库表 t_stu 如下，其中 id 为主键。\",\"然后在可重复读隔离级别下，有两个事务的执行顺序如下：\",\"从这个实验结果可以看到，即使事务 B 中途插入了一条记录，事务 A 前后两次查询的结果集都是一样的，并没有出现所谓的幻读现象。\"]},\"365\":{\"h\":\"当前读是如何避免幻读的？\",\"t\":[\"MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。\",\"这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。\",\"另外，select ... for update 这种查询语句是当前读，每次执行的时候都是读取最新的数据。\",\"接下来，我们假设select ... for update当前读是不会加锁的（实际上是会加锁的），在做一遍实验。\",\"这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。\",\"所以，Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁。\",\"假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\",\"举个具体例子，场景如下：\",\"事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。\",\"然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。\"]},\"366\":{\"h\":\"幻读被完全解决了吗？\",\"t\":[\"可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。\",\"我举例一个可重复读隔离级别发生幻读现象的场景。\"]},\"367\":{\"h\":\"第一个发生幻读现象的场景\",\"t\":[\"还是以这张表作为例子：\",\"事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。\",\"# 事务 A mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from t_stu where id = 5; Empty set (0.01 sec) \",\"然后事务 B 插入一条 id = 5 的记录，并且提交了事务。\",\"# 事务 B mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> insert into t_stu values(5, '小美', 18); Query OK, 1 row affected (0.00 sec) mysql> commit; Query OK, 0 rows affected (0.00 sec) \",\"此时，事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景。\",\"# 事务 A mysql> update t_stu set name = '小林coding' where id = 5; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql> select * from t_stu where id = 5; +----+--------------+------+ | id | name | age | +----+--------------+------+ | 5 | 小林coding | 18 | +----+--------------+------+ 1 row in set (0.00 sec) \",\"整个发生幻读的时序图如下：\",\"在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。\",\"因为这种特殊现象的存在，所以我们认为 MySQL Innodb 中的 MVCC 并不能完全避免幻读现象。\"]},\"368\":{\"h\":\"第二个发生幻读现象的场景\",\"t\":[\"除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。\",\"T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。\",\"T2 时刻：事务 B 往t_test表中插入一个 id= 200 的记录并提交；\",\"T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。\",\"要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句 ，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。\"]},\"369\":{\"h\":\"总结\",\"t\":[\"MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。\",\"针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。\",\"我举例了两个发生幻读场景的例子。\",\"第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\",\"第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\",\"所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。\",\"要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。\"]},\"370\":{\"h\":\"Redis分布式缓存\",\"t\":[\"单机Redis存在的问题\"]},\"371\":{\"h\":\"一、Redis持久化\",\"t\":[\"Redis有两种持久化方案：\",\"RDB持久化\",\"AOF持久化\"]},\"372\":{\"h\":\"1.1.RDB持久化\",\"t\":[\"RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\"]},\"373\":{\"h\":\"1.1.1.执行时机\",\"t\":[\"RDB持久化在四种情况下会执行：\",\"执行save命令\",\"执行bgsave命令\",\"Redis停机时\",\"触发RDB条件时\",\"1）save命令\",\"执行下面的命令，可以立即执行一次RDB：\",\"save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\",\"2）bgsave命令\",\"下面的命令可以异步执行RDB：\",\"这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。\",\"3）停机时\",\"Redis停机时会执行一次save命令，实现RDB持久化。\",\"4）触发RDB条件\",\"Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\",\"# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \\\"\\\" 则表示禁用RDB save 900 1 save 300 10 save 60 10000 \",\"RDB的其它配置也可以在redis.conf文件中设置：\",\"# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ \"]},\"374\":{\"h\":\"1.1.2.RDB原理\",\"t\":[\"bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。\",\"fork采用的是copy-on-write技术：\",\"当主进程执行读操作时，访问共享内存；\",\"当主进程执行写操作时，则会拷贝一份数据，执行写操作。\"]},\"375\":{\"h\":\"1.1.3.小结\",\"t\":[\"RDB方式bgsave的基本流程？\",\"fork主进程得到一个子进程，共享内存空间\",\"子进程读取内存数据并写入新的RDB文件\",\"用新RDB文件替换旧的RDB文件\",\"RDB会在什么时候执行？save 60 1000代表什么含义？\",\"默认是服务停止时\",\"代表60秒内至少执行1000次修改则触发RDB\",\"RDB的缺点？\",\"RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\",\"fork子进程、压缩、写出RDB文件都比较耗时\"]},\"376\":{\"h\":\"1.2.AOF持久化\"},\"377\":{\"h\":\"1.2.1.AOF原理\",\"t\":[\"AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\"]},\"378\":{\"h\":\"1.2.2.AOF配置\",\"t\":[\"AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\",\"# 是否开启AOF功能，默认是no appendonly yes # AOF文件的名称 appendfilename \\\"appendonly.aof\\\" \",\"AOF的命令记录的频率也可以通过redis.conf文件来配：\",\"# 表示每执行一次写命令，立即记录到AOF文件 appendfsync always # 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 appendfsync everysec # 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 appendfsync no \",\"三种策略对比：\"]},\"379\":{\"h\":\"1.2.3.AOF文件重写\",\"t\":[\"因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\",\"如图，AOF原本有三个命令，但是set num 123 和 set num 666都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。\",\"所以重写命令后，AOF文件内容就是：mset name jack num 666\",\"Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\",\"# AOF文件比上次文件 增长超过多少百分比则触发重写 auto-aof-rewrite-percentage 100 # AOF文件体积最小多大以上才触发重写 auto-aof-rewrite-min-size 64mb \"]},\"380\":{\"h\":\"1.3.RDB与AOF对比\",\"t\":[\"RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。\"]},\"381\":{\"h\":\"二、Redis主从\"},\"382\":{\"h\":\"2.1.搭建主从架构\",\"t\":[\"单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。\"]},\"383\":{\"h\":\"2.2.主从数据同步原理\"},\"384\":{\"h\":\"2.2.1.全量同步\",\"t\":[\"主从第一次建立连接时，会执行全量同步，将master节点的所有数据都拷贝给slave节点，流程：\",\"这里有一个问题，master如何得知salve是第一次来连接呢？？\",\"有几个概念，可以作为判断依据：\",\"Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid\",\"offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。\",\"因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。\",\"因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。\",\"master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。\",\"master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。\",\"因此，master判断一个节点是否是第一次同步的依据，就是看replid是否一致。\",\"如图：\",\"完整流程描述：\",\"slave节点请求增量同步\",\"master节点判断replid，发现不一致，拒绝增量同步\",\"master将完整内存数据生成RDB，发送RDB到slave\",\"slave清空本地数据，加载master的RDB\",\"master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave\",\"slave执行接收到的命令，保持与master之间的同步\"]},\"385\":{\"h\":\"2.2.2.增量同步\",\"t\":[\"全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做增量同步。\",\"什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：\",\"那么master怎么知道slave与自己的数据差异在哪里呢?\"]},\"386\":{\"h\":\"2.2.3.repl_backlog原理\",\"t\":[\"master怎么知道slave与自己的数据差异在哪里呢?\",\"这就要说到全量同步时的repl_baklog文件了。\",\"这个文件是一个固定大小的数组，只不过数组是环形，也就是说角标到达数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。\",\"repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：\",\"slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。\",\"随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：\",\"直到数组被填满：\",\"此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。\",\"但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：\",\"如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：\",\"棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。\"]},\"387\":{\"h\":\"2.3.主从同步优化\",\"t\":[\"主从同步可以保证主从数据的一致性，非常重要。\",\"可以从以下几个方面来优化Redis主从就集群：\",\"在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。\",\"Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO\",\"适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步\",\"限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力\",\"主从从架构图：\"]},\"388\":{\"h\":\"2.4.小结\",\"t\":[\"简述全量同步和增量同步区别？\",\"全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。\",\"增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave\",\"什么时候执行全量同步？\",\"slave节点第一次连接master节点时\",\"slave节点断开时间太久，repl_baklog中的offset已经被覆盖时\",\"什么时候执行增量同步？\",\"slave节点断开又恢复，并且在repl_baklog中能找到offset时\"]},\"389\":{\"h\":\"三、Redis哨兵\",\"t\":[\"Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。\"]},\"390\":{\"h\":\"3.1.哨兵原理\"},\"391\":{\"h\":\"3.1.1.集群结构和作用\",\"t\":[\"哨兵的结构如图：\",\"哨兵的作用如下：\",\"监控：Sentinel 会不断检查您的master和slave是否按预期工作\",\"自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主\",\"通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端\"]},\"392\":{\"h\":\"3.1.2.集群监控原理\",\"t\":[\"Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\",\"•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。\",\"•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。\"]},\"393\":{\"h\":\"3.1.3.集群故障恢复原理\",\"t\":[\"一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：\",\"首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\",\"然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举\",\"如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\",\"最后是判断slave节点的运行id大小，越小优先级越高。\",\"当选出一个新的master后，该如何实现切换呢？\",\"流程如下：\",\"sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master\",\"sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。\",\"最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点\"]},\"394\":{\"h\":\"3.1.4.小结\",\"t\":[\"Sentinel的三个作用是什么？\",\"监控\",\"故障转移\",\"通知\",\"Sentinel如何判断一个redis实例是否健康？\",\"每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线\",\"如果大多数sentinel都认为实例主观下线，则判定服务下线\",\"故障转移步骤有哪些？\",\"首先选定一个slave作为新的master，执行slaveof no one\",\"然后让所有节点都执行slaveof 新master\",\"修改故障节点配置，添加slaveof 新master\"]},\"395\":{\"h\":\"3.2.RedisTemplate\",\"t\":[\"在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。\",\"下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。\"]},\"396\":{\"h\":\"3.2.1.引入依赖\",\"t\":[\"在项目的pom文件中引入依赖：\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"其他代码略\"]},\"397\":{\"h\":\"3.2.2.配置Redis地址\",\"t\":[\"然后在配置文件application.yml中指定redis的sentinel相关信息：\",\"spring: redis: sentinel: master: mymaster nodes: - 192.168.150.101:27001 - 192.168.150.101:27002 - 192.168.150.101:27003 \"]},\"398\":{\"h\":\"3.2.3.配置读写分离\",\"t\":[\"在项目的启动类中，添加一个新的bean：\",\"@Bean public LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){ return clientConfigurationBuilder -> clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED); } \",\"这个bean中配置的就是读写策略，包括四种：\",\"MASTER：从主节点读取\",\"MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica\",\"REPLICA：从slave（replica）节点读取\",\"REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master\"]},\"399\":{\"h\":\"四、Redis分片集群\"},\"400\":{\"h\":\"4.1.搭建分片集群\",\"t\":[\"主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\",\"海量数据存储问题\",\"高并发写的问题\",\"使用分片集群可以解决上述问题，如图:\",\"分片集群特征：\",\"集群中有多个master，每个master保存不同数据\",\"每个master都可以有多个slave节点\",\"master之间通过ping监测彼此健康状态\",\"客户端请求可以访问集群任意节点，最终都会被转发到正确节点\"]},\"401\":{\"h\":\"4.2.散列插槽\"},\"402\":{\"h\":\"4.2.1.插槽原理\",\"t\":[\"Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：\",\"数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：\",\"key中包含\\\"{}\\\"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分\",\"key中不包含“{}”，整个key都是有效部分\",\"例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。\",\"如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。\",\"到了7003后，执行get num时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点\"]},\"403\":{\"h\":\"4.2.1.小结\",\"t\":[\"Redis如何判断某个key应该在哪个实例？\",\"将16384个插槽分配到不同的实例\",\"根据key的有效部分计算哈希值，对16384取余\",\"余数作为插槽，寻找插槽所在实例即可\",\"如何将同一类数据固定的保存在同一个Redis实例？\",\"这一类数据使用相同的有效部分，例如key都以{typeId}为前缀\"]},\"404\":{\"h\":\"4.3.集群伸缩\",\"t\":[\"redis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：\",\"比如，添加节点的命令：\"]},\"405\":{\"h\":\"4.3.1.需求分析\",\"t\":[\"需求：向集群中添加一个新的master节点，并向其中存储 num = 10\",\"启动一个新的redis实例，端口为7004\",\"添加7004到之前的集群，并作为一个master节点\",\"给7004节点分配插槽，使得num这个key可以存储到7004实例\",\"这里需要两个新的功能：\",\"添加一个节点到集群中\",\"将部分插槽分配到新插槽\"]},\"406\":{\"h\":\"4.3.2.创建新的redis实例\",\"t\":[\"创建一个文件夹：\",\"mkdir 7004 \",\"拷贝配置文件：\",\"cp redis.conf /7004 \",\"修改配置文件：\",\"sed /s/6379/7004/g 7004/redis.conf \",\"启动\",\"redis-server 7004/redis.conf \"]},\"407\":{\"h\":\"4.3.3.添加新节点到redis\",\"t\":[\"添加节点的语法如下：\",\"执行命令：\",\"redis-cli --cluster add-node 192.168.150.101:7004 192.168.150.101:7001 \",\"通过命令查看集群状态：\",\"redis-cli -p 7001 cluster nodes \",\"如图，7004加入了集群，并且默认是一个master节点：\",\"但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上\"]},\"408\":{\"h\":\"4.3.4.转移插槽\",\"t\":[\"我们要将num存储到7004节点，因此需要先看看num的插槽是多少：\",\"如上图所示，num的插槽为2765.\",\"我们可以将0~3000的插槽从7001转移到7004，命令格式如下：\",\"具体命令如下：\",\"建立连接：\",\"得到下面的反馈：\",\"询问要移动多少个插槽，我们计划是3000个：\",\"新的问题来了：\",\"那个node来接收这些插槽？？\",\"显然是7004，那么7004节点的id是多少呢？\",\"复制这个id，然后拷贝到刚才的控制台后：\",\"这里询问，你的插槽是从哪里移动过来的？\",\"all：代表全部，也就是三个节点各转移一部分\",\"具体的id：目标节点的id\",\"done：没有了\",\"这里我们要从7001获取，因此填写7001的id：\",\"填完后，点击done，这样插槽转移就准备好了：\",\"确认要转移吗？输入yes：\",\"然后，通过命令查看结果：\",\"可以看到：\",\"目的达成。\"]},\"409\":{\"h\":\"4.4.故障转移\",\"t\":[\"集群初识状态是这样的：\",\"其中7001、7002、7003都是master，我们计划让7002宕机。\"]},\"410\":{\"h\":\"4.4.1.自动故障转移\",\"t\":[\"当集群中有一个master宕机会发生什么呢？\",\"直接停止一个redis实例，例如7002：\",\"redis-cli -p 7002 shutdown \",\"1）首先是该实例与其它实例失去连接\",\"2）然后是疑似宕机：\",\"3）最后是确定下线，自动提升一个slave为新的master：\",\"4）当7002再次启动，就会变为一个slave节点了：\"]},\"411\":{\"h\":\"4.4.2.手动故障转移\",\"t\":[\"利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：\",\"这种failover命令可以指定三种模式：\",\"缺省：默认的流程，如图1~6歩\",\"force：省略了对offset的一致性校验\",\"takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见\",\"案例需求：在7002这个slave节点执行手动故障转移，重新夺回master地位\",\"步骤如下：\",\"1）利用redis-cli连接7002这个节点\",\"2）执行cluster failover命令\",\"如图：\",\"效果：\"]},\"412\":{\"h\":\"4.5.RedisTemplate访问分片集群\",\"t\":[\"RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：\",\"1）引入redis的starter依赖\",\"2）配置分片集群地址\",\"3）配置读写分离\",\"与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：\",\"spring: redis: cluster: nodes: - 192.168.150.101:7001 - 192.168.150.101:7002 - 192.168.150.101:7003 - 192.168.150.101:8001 - 192.168.150.101:8002 - 192.168.150.101:8003 \"]},\"413\":{\"h\":\"多级缓存\"},\"414\":{\"h\":\"一、什么是多级缓存\",\"t\":[\"传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：\",\"存在下面的问题：\",\"请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈\",\"Redis缓存失效时，会对数据库产生冲击\",\"多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：\",\"浏览器访问静态资源时，优先读取浏览器本地缓存\",\"访问非静态资源（ajax查询数据）时，访问服务端\",\"请求到达Nginx后，优先读取Nginx本地缓存\",\"如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）\",\"如果Redis查询未命中，则查询Tomcat\",\"请求进入Tomcat后，优先查询JVM进程缓存\",\"如果JVM进程缓存未命中，则查询数据库\",\"在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个反向代理服务器，而是一个编写业务的Web服务器了。\",\"因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：\",\"另外，我们的Tomcat服务将来也会部署为集群模式：\",\"可见，多级缓存的关键有两个：\",\"一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询\",\"另一个就是在Tomcat中实现JVM进程缓存\",\"其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。\"]},\"415\":{\"h\":\"二、JVM进程缓存\"},\"416\":{\"h\":\"2.1.初识Caffeine\",\"t\":[\"缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：\",\"分布式缓存，例如Redis： \",\"优点：存储容量更大、可靠性更好、可以在集群间共享\",\"缺点：访问缓存有网络开销\",\"场景：缓存数据量较大、可靠性要求较高、需要在集群间共享\",\"进程本地缓存，例如HashMap、GuavaCache： \",\"优点：读取本地内存，没有网络开销，速度更快\",\"缺点：存储容量有限、可靠性较低、无法共享\",\"场景：性能要求较高，缓存数据量较小\",\"我们今天会利用Caffeine框架来实现JVM进程缓存。\",\"Caffeine是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：https://github.com/ben-manes/caffeine\",\"Caffeine的性能非常好，下图是官方给出的性能对比：\",\"可以看到Caffeine的性能遥遥领先！\",\"缓存使用的基本API：\",\"@Test void testBasicOps() { // 构建cache对象 Cache<String, String> cache = Caffeine.newBuilder().build(); // 存数据 cache.put(\\\"gf\\\", \\\"迪丽热巴\\\"); // 取数据 String gf = cache.getIfPresent(\\\"gf\\\"); System.out.println(\\\"gf = \\\" + gf); // 取数据，包含两个参数： // 参数一：缓存的key // 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑 // 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式 String defaultGF = cache.get(\\\"defaultGF\\\", key -> { // 根据key去数据库查询数据 return \\\"柳岩\\\"; }); System.out.println(\\\"defaultGF = \\\" + defaultGF); } \",\"Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。\",\"Caffeine提供了三种缓存驱逐策略：\",\"基于容量：设置缓存的数量上限\",\"// 创建缓存对象 Cache<String, String> cache = Caffeine.newBuilder() .maximumSize(1) // 设置缓存大小上限为 1 .build(); \",\"基于时间：设置缓存的有效时间\",\"// 创建缓存对象 Cache<String, String> cache = Caffeine.newBuilder() // 设置缓存有效期为 10 秒，从最后一次写入开始计时 .expireAfterWrite(Duration.ofSeconds(10)) .build(); \",\"基于引用：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。\",\"注意：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。\"]},\"417\":{\"h\":\"2.2.实现JVM进程缓存\"},\"418\":{\"h\":\"2.2.1.需求\",\"t\":[\"利用Caffeine实现下列需求：\",\"给根据id查询商品的业务添加缓存，缓存未命中时查询数据库\",\"给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库\",\"缓存初始大小为100\",\"缓存上限为10000\"]},\"419\":{\"h\":\"2.2.2.实现\",\"t\":[\"首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。\",\"在item-service包下定义CaffeineConfig类：\",\"package com.heima.item.config; import com.github.benmanes.caffeine.cache.Cache; import com.github.benmanes.caffeine.cache.Caffeine; import com.heima.item.pojo.Item; import com.heima.item.pojo.ItemStock; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class CaffeineConfig { @Bean public Cache<Long, Item> itemCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } @Bean public Cache<Long, ItemStock> stockCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } } \",\"然后，修改item-service包下的ItemController类，添加缓存逻辑：\",\"@RestController @RequestMapping(\\\"item\\\") public class ItemController { @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; @Autowired private Cache<Long, Item> itemCache; @Autowired private Cache<Long, ItemStock> stockCache; // ...其它略 @GetMapping(\\\"/{id}\\\") public Item findById(@PathVariable(\\\"id\\\") Long id) { return itemCache.get(id, key -> itemService.query() .ne(\\\"status\\\", 3).eq(\\\"id\\\", key) .one() ); } @GetMapping(\\\"/stock/{id}\\\") public ItemStock findStockById(@PathVariable(\\\"id\\\") Long id) { return stockCache.get(id, key -> stockService.getById(key)); } } \"]},\"420\":{\"h\":\"三、Lua语法入门\",\"t\":[\"Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。\"]},\"421\":{\"h\":\"3.1.初识Lua\",\"t\":[\"Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：https://www.lua.org/\",\"Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。\",\"Nginx本身也是C语言开发，因此也允许基于Lua做拓展。\"]},\"422\":{\"h\":\"3.1.Hello·World\",\"t\":[\"CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。\",\"1）在Linux虚拟机的任意目录下，新建一个hello.lua文件\",\"2）添加下面的内容\",\"print(\\\"Hello World!\\\") \",\"3）运行\"]},\"423\":{\"h\":\"3.2.变量和循环\",\"t\":[\"学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。\"]},\"424\":{\"h\":\"3.2.1.Lua的数据类型\",\"t\":[\"Lua中支持的常见数据类型包括：\",\"另外，Lua提供了type()函数来判断一个变量的数据类型：\"]},\"425\":{\"h\":\"3.2.2.声明变量\",\"t\":[\"Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：\",\"-- 声明字符串，可以用单引号或双引号， local str = 'hello' -- 字符串拼接可以使用 .. local str2 = 'hello' .. 'world' -- 声明数字 local num = 21 -- 声明布尔类型 local flag = true \",\"Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：\",\"-- 声明数组 ，key为角标的 table local arr = {'java', 'python', 'lua'} -- 声明table，类似java的map local map = {name='Jack', age=21} \",\"Lua中的数组角标是从1开始，访问的时候与Java中类似：\",\"-- 访问数组，lua数组的角标从1开始 print(arr[1]) \",\"Lua中的table可以用key来访问：\",\"-- 访问table print(map['name']) print(map.name) \"]},\"426\":{\"h\":\"3.2.3.循环\",\"t\":[\"对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。\",\"遍历数组：\",\"-- 声明数组 key为索引的 table local arr = {'java', 'python', 'lua'} -- 遍历数组 for index,value in ipairs(arr) do print(index, value) end \",\"遍历普通table\",\"-- 声明map，也就是table local map = {name='Jack', age=21} -- 遍历table for key,value in pairs(map) do print(key, value) end \"]},\"427\":{\"h\":\"3.3.条件控制、函数\",\"t\":[\"Lua中的条件控制和函数声明与Java类似。\"]},\"428\":{\"h\":\"3.3.1.函数\",\"t\":[\"定义函数的语法：\",\"function 函数名( argument1, argument2..., argumentn) -- 函数体 return 返回值 end \",\"例如，定义一个函数，用来打印数组：\",\"function printArr(arr) for index, value in ipairs(arr) do print(value) end end \"]},\"429\":{\"h\":\"3.3.2.条件控制\",\"t\":[\"类似Java的条件控制，例如if、else语法：\",\"if(布尔表达式) then --[ 布尔表达式为 true 时执行该语句块 --] else --[ 布尔表达式为 false 时执行该语句块 --] end \",\"与java不同，布尔表达式中的逻辑运算是基于英文单词：\"]},\"430\":{\"h\":\"3.3.3.案例\",\"t\":[\"需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息\",\"function printArr(arr) if not arr then print('数组不能为空！') end for index, value in ipairs(arr) do print(value) end end \"]},\"431\":{\"h\":\"四、实现多级缓存\",\"t\":[\"多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。\"]},\"432\":{\"h\":\"4.1.安装OpenResty\",\"t\":[\"OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：\",\"具备Nginx的完整功能\",\"基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块\",\"允许使用Lua自定义业务逻辑、自定义库\",\"官方网站： https://openresty.org/cn/\"]},\"433\":{\"h\":\"4.2.OpenResty快速入门\",\"t\":[\"我们希望达到的多级缓存架构如图：\",\"其中：\",\"windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群\",\"OpenResty集群用来编写多级缓存业务\"]},\"434\":{\"h\":\"4.2.1.反向代理流程\",\"t\":[\"现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。\",\"这个请求如下：\",\"请求地址是localhost，端口是80，就被windows上安装的Nginx服务给接收到了。然后代理给了OpenResty集群：\",\"我们需要在OpenResty中编写业务，查询商品数据并返回到浏览器。\",\"但是这次，我们先在OpenResty接收请求，返回假的商品数据。\"]},\"435\":{\"h\":\"4.2.2.OpenResty监听请求\",\"t\":[\"OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：\",\"1）添加对OpenResty的Lua模块的加载\",\"修改/usr/local/openresty/nginx/conf/nginx.conf文件，在其中的http下面，添加下面代码：\",\"#lua 模块 lua_package_path \\\"/usr/local/openresty/lualib/?.lua;;\\\"; #c模块 lua_package_cpath \\\"/usr/local/openresty/lualib/?.so;;\\\"; \",\"2）监听/api/item路径\",\"修改/usr/local/openresty/nginx/conf/nginx.conf文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：\",\"location /api/item { # 默认的响应类型 default_type application/json; # 响应结果由lua/item.lua文件来决定 content_by_lua_file lua/item.lua; } \",\"这个监听，就类似于SpringMVC中的@GetMapping(\\\"/api/item\\\")做路径映射。\",\"而content_by_lua_file lua/item.lua则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。\"]},\"436\":{\"h\":\"4.2.3.编写item.lua\",\"t\":[\"1）在/usr/loca/openresty/nginx目录创建文件夹：lua\",\"2）在/usr/loca/openresty/nginx/lua文件夹下，新建文件：item.lua\",\"3）编写item.lua，返回假数据\",\"item.lua中，利用ngx.say()函数返回数据到Response中\",\"ngx.say('{\\\"id\\\":10001,\\\"name\\\":\\\"SALSA AIR\\\",\\\"title\\\":\\\"RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4\\\",\\\"price\\\":17900,\\\"image\\\":\\\"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp\\\",\\\"category\\\":\\\"拉杆箱\\\",\\\"brand\\\":\\\"RIMOWA\\\",\\\"spec\\\":\\\"\\\",\\\"status\\\":1,\\\"createTime\\\":\\\"2019-04-30T16:00:00.000+00:00\\\",\\\"updateTime\\\":\\\"2019-04-30T16:00:00.000+00:00\\\",\\\"stock\\\":2999,\\\"sold\\\":31290}') \",\"4）重新加载配置\",\"nginx -s reload \",\"刷新商品页面：http://localhost/item.html?id=1001，即可看到效果：\"]},\"437\":{\"h\":\"4.3.请求参数处理\",\"t\":[\"上一节中，我们在OpenResty接收前端请求，但是返回的是假数据。\",\"要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。\",\"那么如何获取前端传递的商品参数呢？\"]},\"438\":{\"h\":\"4.3.1.获取参数的API\",\"t\":[\"OpenResty中提供了一些API用来获取不同类型的前端请求参数：\"]},\"439\":{\"h\":\"4.3.2.获取参数并返回\",\"t\":[\"在前端发起的ajax请求如图：\",\"可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID\",\"1）获取商品id\",\"修改/usr/loca/openresty/nginx/nginx.conf文件中监听/api/item的代码，利用正则表达式获取ID：\",\"location ~ /api/item/(\\\\d+) { # 默认的响应类型 default_type application/json; # 响应结果由lua/item.lua文件来决定 content_by_lua_file lua/item.lua; } \",\"2）拼接ID并返回\",\"修改/usr/loca/openresty/nginx/lua/item.lua文件，获取id并拼接到结果中返回：\",\"-- 获取商品id local id = ngx.var[1] -- 拼接并返回 ngx.say('{\\\"id\\\":' .. id .. ',\\\"name\\\":\\\"SALSA AIR\\\",\\\"title\\\":\\\"RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4\\\",\\\"price\\\":17900,\\\"image\\\":\\\"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp\\\",\\\"category\\\":\\\"拉杆箱\\\",\\\"brand\\\":\\\"RIMOWA\\\",\\\"spec\\\":\\\"\\\",\\\"status\\\":1,\\\"createTime\\\":\\\"2019-04-30T16:00:00.000+00:00\\\",\\\"updateTime\\\":\\\"2019-04-30T16:00:00.000+00:00\\\",\\\"stock\\\":2999,\\\"sold\\\":31290}') \",\"3）重新加载并测试\",\"运行命令以重新加载OpenResty配置：\",\"nginx -s reload \",\"刷新页面可以看到结果中已经带上了ID：\"]},\"440\":{\"h\":\"4.4.查询Tomcat\",\"t\":[\"拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：\",\"需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。\"]},\"441\":{\"h\":\"4.4.1.发送http请求的API\",\"t\":[\"nginx提供了内部API用以发送http请求：\",\"local resp = ngx.location.capture(\\\"/path\\\",{ method = ngx.HTTP_GET, -- 请求方式 args = {a=1,b=2}, -- get方式传参数 }) \",\"返回的响应内容包括：\",\"resp.status：响应状态码\",\"resp.header：响应头，是一个table\",\"resp.body：响应体，就是响应数据\",\"注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。\",\"但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：\",\" location /path { # 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态 proxy_pass http://192.168.150.1:8081; } \",\"原理如图：\"]},\"442\":{\"h\":\"4.4.2.封装http工具\",\"t\":[\"下面，我们封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat。\",\"1）添加反向代理，到windows的Java服务\",\"因为item-service中的接口都是/item开头，所以我们监听/item路径，代理到windows上的tomcat服务。\",\"修改 /usr/local/openresty/nginx/conf/nginx.conf文件，添加一个location：\",\"location /item { proxy_pass http://192.168.150.1:8081; } \",\"以后，只要我们调用ngx.location.capture(\\\"/item\\\")，就一定能发送请求到windows的tomcat服务。\",\"2）封装工具类\",\"之前我们说过，OpenResty启动时会加载以下两个目录中的工具文件：\",\"所以，自定义的http工具也需要放到这个目录下。\",\"在/usr/local/openresty/lualib目录下，新建一个common.lua文件：\",\"vi /usr/local/openresty/lualib/common.lua \",\"内容如下:\",\"-- 封装函数，发送http请求，并解析响应 local function read_http(path, params) local resp = ngx.location.capture(path,{ method = ngx.HTTP_GET, args = params, }) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR, \\\"http请求查询失败, path: \\\", path , \\\", args: \\\", args) ngx.exit(404) end return resp.body end -- 将方法导出 local _M = { read_http = read_http } return _M \",\"这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。\",\"使用的时候，可以利用require('common')来导入该函数库，这里的common是函数库的文件名。\",\"3）实现商品查询\",\"最后，我们修改/usr/local/openresty/lua/item.lua文件，利用刚刚封装的函数库实现对tomcat的查询：\",\"-- 引入自定义common工具模块，返回值是common中返回的 _M local common = require(\\\"common\\\") -- 从 common中获取read_http这个函数 local read_http = common.read_http -- 获取路径参数 local id = ngx.var[1] -- 根据id查询商品 local itemJSON = read_http(\\\"/item/\\\".. id, nil) -- 根据id查询商品库存 local itemStockJSON = read_http(\\\"/item/stock/\\\".. id, nil) \",\"这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json：\",\"这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。\"]},\"443\":{\"h\":\"4.4.3.CJSON工具类\",\"t\":[\"OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。\",\"官方地址： https://github.com/openresty/lua-cjson/\",\"1）引入cjson模块：\",\"local cjson = require \\\"cjson\\\" \",\"2）序列化：\",\"local obj = { name = 'jack', age = 21 } -- 把 table 序列化为 json local json = cjson.encode(obj) \",\"3）反序列化：\",\"local json = '{\\\"name\\\": \\\"jack\\\", \\\"age\\\": 21}' -- 反序列化 json为 table local obj = cjson.decode(json); print(obj.name) \"]},\"444\":{\"h\":\"4.4.4.实现Tomcat查询\",\"t\":[\"下面，我们修改之前的item.lua中的业务，添加json处理功能：\",\"-- 导入common函数库 local common = require('common') local read_http = common.read_http -- 导入cjson库 local cjson = require('cjson') -- 获取路径参数 local id = ngx.var[1] -- 根据id查询商品 local itemJSON = read_http(\\\"/item/\\\".. id, nil) -- 根据id查询商品库存 local itemStockJSON = read_http(\\\"/item/stock/\\\".. id, nil) -- JSON转化为lua的table local item = cjson.decode(itemJSON) local stock = cjson.decode(stockJSON) -- 组合数据 item.stock = stock.stock item.sold = stock.sold -- 把item序列化为json 返回结果 ngx.say(cjson.encode(item)) \"]},\"445\":{\"h\":\"4.4.5.基于ID负载均衡\",\"t\":[\"刚才的代码中，我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式：\",\"因此，OpenResty需要对tomcat集群做负载均衡。\",\"而默认的负载均衡规则是轮询模式，当我们查询/item/10001时：\",\"第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存\",\"第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库\",\"...\",\"你看，因为轮询的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。\",\"怎么办？\",\"如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。\",\"也就是说，我们需要根据商品id做负载均衡，而不是轮询。\"]},\"446\":{\"h\":\"1）原理\",\"t\":[\"nginx提供了基于请求路径做负载均衡的算法：\",\"nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。\",\"例如：\",\"我们的请求路径是 /item/10001\",\"tomcat总数为2台（8081、8082）\",\"对请求路径/item/1001做hash运算求余的结果为1\",\"则访问第一个tomcat服务，也就是8081\",\"只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。\"]},\"447\":{\"h\":\"2）实现\",\"t\":[\"修改/usr/local/openresty/nginx/conf/nginx.conf文件，实现基于ID做负载均衡。\",\"首先，定义tomcat集群，并设置基于路径做负载均衡：\",\"upstream tomcat-cluster { hash $request_uri; server 192.168.150.1:8081; server 192.168.150.1:8082; } \",\"然后，修改对tomcat服务的反向代理，目标指向tomcat集群：\",\"location /item { proxy_pass http://tomcat-cluster; } \",\"重新加载OpenResty\",\"nginx -s reload \"]},\"448\":{\"h\":\"4.5.Redis缓存预热\",\"t\":[\"Redis缓存会面临冷启动问题：\",\"冷启动：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。\",\"缓存预热：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。\",\"我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。\",\"1）利用Docker安装Redis\",\"docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes \",\"2）在item-service服务中引入Redis依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"3）配置Redis地址\",\"spring: redis: host: 192.168.150.101 \",\"4）编写初始化类\",\"缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。\",\"这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。\",\"package com.heima.item.config; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.heima.item.pojo.Item; import com.heima.item.pojo.ItemStock; import com.heima.item.service.IItemService; import com.heima.item.service.IItemStockService; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; import java.util.List; @Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate redisTemplate; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 // 1.查询商品信息 List<Item> itemList = itemService.list(); // 2.放入缓存 for (Item item : itemList) { // 2.1.item序列化为JSON String json = MAPPER.writeValueAsString(item); // 2.2.存入redis redisTemplate.opsForValue().set(\\\"item:id:\\\" + item.getId(), json); } // 3.查询商品库存信息 List<ItemStock> stockList = stockService.list(); // 4.放入缓存 for (ItemStock stock : stockList) { // 2.1.item序列化为JSON String json = MAPPER.writeValueAsString(stock); // 2.2.存入redis redisTemplate.opsForValue().set(\\\"item:stock:id:\\\" + stock.getId(), json); } } } \"]},\"449\":{\"h\":\"4.6.查询Redis缓存\",\"t\":[\"现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：\",\"当请求进入OpenResty之后：\",\"优先查询Redis缓存\",\"如果Redis缓存未命中，再查询Tomcat\"]},\"450\":{\"h\":\"4.6.1.封装Redis工具\",\"t\":[\"OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。\",\"修改/usr/local/openresty/lualib/common.lua文件：\",\"1）引入Redis模块，并初始化Redis对象\",\"-- 导入redis local redis = require('resty.redis') -- 初始化redis local red = redis:new() red:set_timeouts(1000, 1000, 1000) \",\"2）封装函数，用来释放Redis连接，其实是放入连接池\",\"-- 关闭redis连接的工具方法，其实是放入连接池 local function close_redis(red) local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒 local pool_size = 100 --连接池大小 local ok, err = red:set_keepalive(pool_max_idle_time, pool_size) if not ok then ngx.log(ngx.ERR, \\\"放入redis连接池失败: \\\", err) end end \",\"3）封装函数，根据key查询Redis数据\",\"-- 查询redis的方法 ip和port是redis地址，key是查询的key local function read_redis(ip, port, key) -- 获取一个连接 local ok, err = red:connect(ip, port) if not ok then ngx.log(ngx.ERR, \\\"连接redis失败 : \\\", err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR, \\\"查询Redis失败: \\\", err, \\\", key = \\\" , key) end --得到的数据为空处理 if resp == ngx.null then resp = nil ngx.log(ngx.ERR, \\\"查询Redis数据为空, key = \\\", key) end close_redis(red) return resp end \",\"4）导出\",\"-- 将方法导出 local _M = { read_http = read_http, read_redis = read_redis } return _M \",\"完整的common.lua：\",\"-- 导入redis local redis = require('resty.redis') -- 初始化redis local red = redis:new() red:set_timeouts(1000, 1000, 1000) -- 关闭redis连接的工具方法，其实是放入连接池 local function close_redis(red) local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒 local pool_size = 100 --连接池大小 local ok, err = red:set_keepalive(pool_max_idle_time, pool_size) if not ok then ngx.log(ngx.ERR, \\\"放入redis连接池失败: \\\", err) end end -- 查询redis的方法 ip和port是redis地址，key是查询的key local function read_redis(ip, port, key) -- 获取一个连接 local ok, err = red:connect(ip, port) if not ok then ngx.log(ngx.ERR, \\\"连接redis失败 : \\\", err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR, \\\"查询Redis失败: \\\", err, \\\", key = \\\" , key) end --得到的数据为空处理 if resp == ngx.null then resp = nil ngx.log(ngx.ERR, \\\"查询Redis数据为空, key = \\\", key) end close_redis(red) return resp end -- 封装函数，发送http请求，并解析响应 local function read_http(path, params) local resp = ngx.location.capture(path,{ method = ngx.HTTP_GET, args = params, }) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR, \\\"http查询失败, path: \\\", path , \\\", args: \\\", args) ngx.exit(404) end return resp.body end -- 将方法导出 local _M = { read_http = read_http, read_redis = read_redis } return _M \"]},\"451\":{\"h\":\"4.6.2.实现Redis查询\",\"t\":[\"接下来，我们就可以去修改item.lua文件，实现对Redis的查询了。\",\"查询逻辑是：\",\"根据id查询Redis\",\"如果查询失败则继续查询Tomcat\",\"将查询结果返回\",\"1）修改/usr/local/openresty/lua/item.lua文件，添加一个查询函数：\",\"-- 导入common函数库 local common = require('common') local read_http = common.read_http local read_redis = common.read_redis -- 封装查询函数 function read_data(key, path, params) -- 查询本地缓存 local val = read_redis(\\\"127.0.0.1\\\", 6379, key) -- 判断查询结果 if not val then ngx.log(ngx.ERR, \\\"redis查询失败，尝试查询http， key: \\\", key) -- redis查询失败，去查询http val = read_http(path, params) end -- 返回数据 return val end \",\"2）而后修改商品查询、库存查询的业务：\",\"3）完整的item.lua代码：\",\"-- 导入common函数库 local common = require('common') local read_http = common.read_http local read_redis = common.read_redis -- 导入cjson库 local cjson = require('cjson') -- 封装查询函数 function read_data(key, path, params) -- 查询本地缓存 local val = read_redis(\\\"127.0.0.1\\\", 6379, key) -- 判断查询结果 if not val then ngx.log(ngx.ERR, \\\"redis查询失败，尝试查询http， key: \\\", key) -- redis查询失败，去查询http val = read_http(path, params) end -- 返回数据 return val end -- 获取路径参数 local id = ngx.var[1] -- 查询商品信息 local itemJSON = read_data(\\\"item:id:\\\" .. id, \\\"/item/\\\" .. id, nil) -- 查询库存信息 local stockJSON = read_data(\\\"item:stock:id:\\\" .. id, \\\"/item/stock/\\\" .. id, nil) -- JSON转化为lua的table local item = cjson.decode(itemJSON) local stock = cjson.decode(stockJSON) -- 组合数据 item.stock = stock.stock item.sold = stock.sold -- 把item序列化为json 返回结果 ngx.say(cjson.encode(item)) \"]},\"452\":{\"h\":\"4.7.Nginx本地缓存\",\"t\":[\"现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：\"]},\"453\":{\"h\":\"4.7.1.本地缓存API\",\"t\":[\"OpenResty为Nginx提供了shard dict的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。\",\"1）开启共享字典，在nginx.conf的http下添加配置：\",\" # 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m lua_shared_dict item_cache 150m; \",\"2）操作共享字典：\",\"-- 获取本地缓存对象 local item_cache = ngx.shared.item_cache -- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期 item_cache:set('key', 'value', 1000) -- 读取 local val = item_cache:get('key') \"]},\"454\":{\"h\":\"4.7.2.实现本地缓存查询\",\"t\":[\"1）修改/usr/local/openresty/lua/item.lua文件，修改read_data查询函数，添加本地缓存逻辑：\",\"-- 导入共享词典，本地缓存 local item_cache = ngx.shared.item_cache -- 封装查询函数 function read_data(key, expire, path, params) -- 查询本地缓存 local val = item_cache:get(key) if not val then ngx.log(ngx.ERR, \\\"本地缓存查询失败，尝试查询Redis， key: \\\", key) -- 查询redis val = read_redis(\\\"127.0.0.1\\\", 6379, key) -- 判断查询结果 if not val then ngx.log(ngx.ERR, \\\"redis查询失败，尝试查询http， key: \\\", key) -- redis查询失败，去查询http val = read_http(path, params) end end -- 查询成功，把数据写入本地缓存 item_cache:set(key, val, expire) -- 返回数据 return val end \",\"2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：\",\"其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。\",\"这里给商品基本信息设置超时时间为30分钟，库存为1分钟。\",\"因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。\",\"3）完整的item.lua文件：\",\"-- 导入common函数库 local common = require('common') local read_http = common.read_http local read_redis = common.read_redis -- 导入cjson库 local cjson = require('cjson') -- 导入共享词典，本地缓存 local item_cache = ngx.shared.item_cache -- 封装查询函数 function read_data(key, expire, path, params) -- 查询本地缓存 local val = item_cache:get(key) if not val then ngx.log(ngx.ERR, \\\"本地缓存查询失败，尝试查询Redis， key: \\\", key) -- 查询redis val = read_redis(\\\"127.0.0.1\\\", 6379, key) -- 判断查询结果 if not val then ngx.log(ngx.ERR, \\\"redis查询失败，尝试查询http， key: \\\", key) -- redis查询失败，去查询http val = read_http(path, params) end end -- 查询成功，把数据写入本地缓存 item_cache:set(key, val, expire) -- 返回数据 return val end -- 获取路径参数 local id = ngx.var[1] -- 查询商品信息 local itemJSON = read_data(\\\"item:id:\\\" .. id, 1800, \\\"/item/\\\" .. id, nil) -- 查询库存信息 local stockJSON = read_data(\\\"item:stock:id:\\\" .. id, 60, \\\"/item/stock/\\\" .. id, nil) -- JSON转化为lua的table local item = cjson.decode(itemJSON) local stock = cjson.decode(stockJSON) -- 组合数据 item.stock = stock.stock item.sold = stock.sold -- 把item序列化为json 返回结果 ngx.say(cjson.encode(item)) \"]},\"455\":{\"h\":\"五、缓存同步\",\"t\":[\"大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。\",\"所以我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。\"]},\"456\":{\"h\":\"5.1.数据同步策略\",\"t\":[\"缓存数据同步的常见方式有三种：\",\"设置有效期：给缓存设置有效期，到期后自动删除。再次查询时更新\",\"优势：简单、方便\",\"缺点：时效性差，缓存过期之前可能不一致\",\"场景：更新频率较低，时效性要求低的业务\",\"同步双写：在修改数据库的同时，直接修改缓存\",\"优势：时效性强，缓存与数据库强一致\",\"缺点：有代码侵入，耦合度高；\",\"场景：对一致性、时效性要求较高的缓存数据\",\"**异步通知：**修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据\",\"优势：低耦合，可以同时通知多个缓存服务\",\"缺点：时效性一般，可能存在中间不一致状态\",\"场景：时效性要求一般，有多个服务需要同步\",\"而异步实现又可以基于MQ或者Canal来实现：\",\"1）基于MQ的异步通知：\",\"解读：\",\"商品服务完成对数据的修改后，只需要发送一条消息到MQ中。\",\"缓存服务监听MQ消息，然后完成对缓存的更新\",\"依然有少量的代码侵入。\",\"2）基于Canal的通知\",\"解读：\",\"商品服务完成商品修改后，业务直接结束，没有任何代码侵入\",\"Canal监听MySQL变化，当发现变化后，立即通知缓存服务\",\"缓存服务接收到canal通知，更新缓存\",\"代码零侵入\"]},\"457\":{\"h\":\"5.2.安装Canal\"},\"458\":{\"h\":\"5.2.1.认识Canal\",\"t\":[\"Canal [kə'næl]，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&消费。GitHub的地址：https://github.com/alibaba/canal\",\"Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：\",\"1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events\",\"2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)\",\"3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据\",\"而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。\"]},\"459\":{\"h\":\"5.2.监听Canal\",\"t\":[\"Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。\",\"我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。\",\"不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：https://github.com/NormanGyllenhaal/canal-client\",\"与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。\"]},\"460\":{\"h\":\"5.2.1.引入依赖：\",\"t\":[\"<dependency> <groupId>top.javatool</groupId> <artifactId>canal-spring-boot-starter</artifactId> <version>1.2.1-RELEASE</version> </dependency> \"]},\"461\":{\"h\":\"5.2.2.编写配置：\",\"t\":[\"canal: destination: heima # canal的集群名字，要与安装canal时设置的名称一致 server: 192.168.150.101:11111 # canal服务地址 \"]},\"462\":{\"h\":\"5.2.3.修改Item实体类\",\"t\":[\"通过@Id、@Column、等注解完成Item与数据库表字段的映射：\",\"package com.heima.item.pojo; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import lombok.Data; import org.springframework.data.annotation.Id; import org.springframework.data.annotation.Transient; import javax.persistence.Column; import java.util.Date; @Data @TableName(\\\"tb_item\\\") public class Item { @TableId(type = IdType.AUTO) @Id private Long id;//商品id @Column(name = \\\"name\\\") private String name;//商品名称 private String title;//商品标题 private Long price;//价格（分） private String image;//商品图片 private String category;//分类名称 private String brand;//品牌名称 private String spec;//规格 private Integer status;//商品状态 1-正常，2-下架 private Date createTime;//创建时间 private Date updateTime;//更新时间 @TableField(exist = false) @Transient private Integer stock; @TableField(exist = false) @Transient private Integer sold; } \"]},\"463\":{\"h\":\"5.3.4.编写监听器\",\"t\":[\"通过实现EntryHandler<T>接口编写监听器，监听Canal消息。注意两点：\",\"实现类通过@CanalTable(\\\"tb_item\\\")指定监听的表信息\",\"EntryHandler的泛型是与表对应的实体类\",\"package com.heima.item.canal; import com.github.benmanes.caffeine.cache.Cache; import com.heima.item.config.RedisHandler; import com.heima.item.pojo.Item; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import top.javatool.canal.client.annotation.CanalTable; import top.javatool.canal.client.handler.EntryHandler; @CanalTable(\\\"tb_item\\\") @Component public class ItemHandler implements EntryHandler<Item> { @Autowired private RedisHandler redisHandler; @Autowired private Cache<Long, Item> itemCache; @Override public void insert(Item item) { // 写数据到JVM进程缓存 itemCache.put(item.getId(), item); // 写数据到redis redisHandler.saveItem(item); } @Override public void update(Item before, Item after) { // 写数据到JVM进程缓存 itemCache.put(after.getId(), after); // 写数据到redis redisHandler.saveItem(after); } @Override public void delete(Item item) { // 删除数据到JVM进程缓存 itemCache.invalidate(item.getId()); // 删除数据到redis redisHandler.deleteItemById(item.getId()); } } \",\"在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：\",\"package com.heima.item.config; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.heima.item.pojo.Item; import com.heima.item.pojo.ItemStock; import com.heima.item.service.IItemService; import com.heima.item.service.IItemStockService; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; import java.util.List; @Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate redisTemplate; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 // 1.查询商品信息 List<Item> itemList = itemService.list(); // 2.放入缓存 for (Item item : itemList) { // 2.1.item序列化为JSON String json = MAPPER.writeValueAsString(item); // 2.2.存入redis redisTemplate.opsForValue().set(\\\"item:id:\\\" + item.getId(), json); } // 3.查询商品库存信息 List<ItemStock> stockList = stockService.list(); // 4.放入缓存 for (ItemStock stock : stockList) { // 2.1.item序列化为JSON String json = MAPPER.writeValueAsString(stock); // 2.2.存入redis redisTemplate.opsForValue().set(\\\"item:stock:id:\\\" + stock.getId(), json); } } public void saveItem(Item item) { try { String json = MAPPER.writeValueAsString(item); redisTemplate.opsForValue().set(\\\"item:id:\\\" + item.getId(), json); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } public void deleteItemById(Long id) { redisTemplate.delete(\\\"item:id:\\\" + id); } } \"]},\"464\":{\"h\":\"概览\"},\"465\":{\"c\":[\"Java\"]},\"466\":{\"c\":[\"Java\"]},\"467\":{\"h\":\"Collection接口\"},\"468\":{\"c\":[\"Java\"]},\"469\":{\"c\":[\"Java\"]},\"470\":{\"h\":\"Map接口\"},\"471\":{\"h\":\"HashMap\"},\"472\":{\"h\":\"1.HashMap的底层实现是什么？\",\"t\":[\"JDK1.8之前：数组 + 链表\",\"即拉链法，也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的 值加到链表中即可。\",\"JDK1.8之后：数组 + （链表 | 红黑树）\"]},\"473\":{\"h\":\"2.树化与退化\",\"t\":[\"树化规则：当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化\",\"退化规则：\",\"数组扩容时，会重新计算索引位置，也就是原本的树结构可能会变，如果重新计算后的树元素个数 <= 6 则会退化为链表\",\"移除树节点时，如果root、root.left、root.right、root.left.left有一个为 null ，退化为链表\",\"树化的意义是什么？\",\"红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略\",\"为什么一上来不树化？\",\"哈希表的查找、更新的时间复杂度是 O(1) ，而红黑树的查找、更新的时间复杂度是 O(log2​n) ，TreeNode 占用空间也比普通Node 的大，如非必要，尽量还是使用链表\",\"树化应是偶然情况，是保底策略\",\"为什么树化的阈值是8？\",\"按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小提高了计算效率。table.length * 3/4可以被优化为((table.length >> 2) << 2) - (table.length >> 2) == table.length - (table.length >> 2), JAVA的位运算比乘除的效率更高, 所以取3/4在保证hash冲突小的情况下兼顾了效率;\",\"扩容时如何重新计算索引位置？\",\"hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap\"]},\"474\":{\"h\":\"3.索引计算规则\",\"t\":[\"一共分为3步：\",\"计算对象的 hashCode()\",\"扰动计算(h = key.hashCode()) ^ (h >>> 16)\",\"上面的结果 & (capacity – 1) 得到索引\",\"hashCode()都有了，为什么还要提供hash方法（为什么还要进行扰动计算）？\",\"简单来说就是混合了原哈希值中的高位和低位，增大了随机性，可参考JDK 源码中 HashMap 的 hash 方法原理是什么？\"]},\"475\":{\"h\":\"4.扩容流程\",\"t\":[\"默认容量为16\",\"数组容量为什么必须是2的n次幂？\",\"只有2的幂次方在减1的时候，才会出现01111这样的值。\",\"2的n次幂有什么好坏处？\",\"数组容量不是2的n次幂可不可以\",\"如果追求效率，应该用2的n次幂作为容量，这样可以保证最高位为1，这样可以通过位运算来计算hash值，而不是用取模运算，效率更高。\",\"如果追求hash分布性，应该用质数作为容量，这样可以保证hash值分布更均匀，减少hash冲突，提高效率。\"]},\"476\":{\"c\":[\"Java\"]},\"477\":{\"c\":[\"Java\"]},\"478\":{\"h\":\"Java反射机制与策略模式\",\"t\":[\"该文章偏基础，如果您已掌握以下几个问题，请查看更多感兴趣文章~\",\"获取Class实例的方式有哪些\",\"谈谈你对Class类的理解\",\"什么时候会发生类初始化\",\"创建Class对应运行时类的对象时需要注意什么\",\"在工程或module的src目录下有名为”jdbc.properties”的配置文件，文件内容为：name=Tom。如何在程序中通过代码获取Tom这个变量值。请使用代码实现。\",\"双亲委派机制\",\"动态代理\",\"策略模式+反射去除冗余if\"]},\"479\":{\"h\":\"一、反射的概述\"},\"480\":{\"h\":\"1.关于反射的理解\",\"t\":[\"Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\",\"加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为： 反射\",\"框架 = 反射 + 注解 + 设计模式。\",\"动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是 在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。\",\"静态语言:与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++\",\"Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。\"]},\"481\":{\"h\":\"2.体会反射机制的“动态性”\",\"t\":[\"在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。\",\"类的加载过程\"]},\"482\":{\"h\":\"二、 Class类\"},\"483\":{\"h\":\"2.1 Class类的理解\",\"t\":[\"类加载的过程：程序经过javac命令以后，会生成一个或者多个字节码文件(.class结尾) ，然后我们使用java命令对某个字节码文件进行解释运行，这就相当于将某个字节码加载到内存中，这个过程就称为类的加载。\",\"加载到内存中的类，我们就称为 运行时类。\",\"Class本身也是一个类，Class 对象只能由系统建立对象\",\"一个加载的类在 JVM 中只会有一个Class实例\",\"一个Class对象对应的是一个加载到JVM中的一个.class文件\"]},\"484\":{\"h\":\"2.2 获取Class实例的几种方式\"},\"485\":{\"h\":\"① 调用运行时类的属性： .class\",\"t\":[\"Class clazz1 = Person.class; \"]},\"486\":{\"h\":\"②通过运行时类的对象，调用 getClass()\",\"t\":[\"Person p1 = new Person(); Class clazz2 = p1.getClass(); \"]},\"487\":{\"h\":\"③调用Class的静态方法： forName(String classPath\",\"t\":[\"Class clazz3 = Class.forName(\\\"com.monster.java.Person\\\"); \"]},\"488\":{\"h\":\"④使用类的加载器： ClassLoader\",\"t\":[\"ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(\\\"com.atguigu.java.Person\\\"); \"]},\"489\":{\"h\":\"2.3 总结：创建类的对象的方式\",\"t\":[\"new + 构造器\",\"要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。\",\"通过反射\"]},\"490\":{\"h\":\"2.4 Class实例可以是哪些结构的说明\",\"t\":[\"class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\",\"interface：接口\",\"[]：数组\",\"enum：枚举\",\"annotation：注解@interface\",\"primitive type：基本数据类型\",\"void\"]},\"491\":{\"h\":\"三、了解ClassLoader\"},\"492\":{\"h\":\"3.1 类的加载过程\",\"t\":[\"类的加载过程\",\"类的加载过程\",\"加载 ：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。\",\"链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。\",\"​ 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题\",\"​ 准备：正式为类变量（static）分配内存并 设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配\",\"​ 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程\",\"初始化：\",\"执行类构造器<clinit>()方法的过程。类构造器<clinit>() 是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）；\",\"当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化\",\"虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步\",\"问题：什么时候会发生类初始化 ?\",\"类的主动引用 （ 一定会发生类的初始化 ） \",\"当虚拟机启动，先初始化main方法所在的类\",\"new一个类的对象\",\"调用类的静态成员（除了final常量）和静态方法\",\"使用java.lang.reflect包的方法对类进行反射调用\",\"当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类\",\"**类的被动引用 **（ 不会发生类的初始化 ） \",\"当访问一个静态域时，只有真正声明这个域的类才会被初始化,当通过子类引用父类的静态变量，不会导致子类初始化\",\"通过数组定义类引用，不会触发此类的初始化\",\"引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\"]},\"493\":{\"h\":\"3.2 类的加载器的作用\",\"t\":[\"类加载器 ，顾名思义，就是加载类到内存中。换点专业的话来说，将class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构 ，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口\",\"类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载一段时间（也就是缓存一段时间）。不过JVM垃圾回收机制可以回收这些Class对象。\"]},\"494\":{\"h\":\"3.3 类的加载器的分类\",\"t\":[\"类的加载过程\",\"双亲委派机制：当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。\",\"我们来看一下源码，重要步骤的注释说明已经写在了对应位置：\",\"双亲委派机制的作用：\",\"防止重复加载同一个.class。简单而言，向上一级询问是否加载过了，如果加载过了就不用再加载一遍。保证数据安全\",\"保证核心.class不能被篡改（沙箱安全机制）。简单而言，如果有人想想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（当一个类需要加载的时候，最先去尝试加载的就BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入\"]},\"495\":{\"h\":\"3.4 Java类编译、运行的执行的流程\",\"t\":[\"类的加载过程\"]},\"496\":{\"h\":\"3.5 使用Classloader加载src目录下的配置文件\",\"t\":[\" @Test public void test2() throws Exception { Properties pros = new Properties(); //此时的文件默认在当前的module下。 //读取配置文件的方式一： // FileInputStream fis = new FileInputStream(\\\"jdbc.properties\\\"); // FileInputStream fis = new FileInputStream(\\\"src\\\\\\\\jdbc1.properties\\\"); // pros.load(fis); //读取配置文件的方式二：使用ClassLoader //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\\\"jdbc1.properties\\\"); pros.load(is); String user = pros.getProperty(\\\"user\\\"); String password = pros.getProperty(\\\"password\\\"); System.out.println(\\\"user = \\\" + user + \\\",password = \\\" + password); } \"]},\"497\":{\"h\":\"四、反射应用\"},\"498\":{\"h\":\"4.1 创建运行时类的对象\",\"t\":[\"Class<Person> clazz = Person.class; Person obj = clazz.newInstance(); \",\"newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。\",\"Java空参构造\",\"我们来看下**newInstance()**的源码，它对运行时类的构造函数进行了查找，并且限制了Member.DECLARED（值为1） ，而1要求了构造器的权限，如下图所示。\",\"Java空参构造\",\"因此要想此方法正常的创建运行时类的对象，要求：\",\"运行时类必须提供空参的构造器\",\"空参的构造器的访问权限得够。通常，设置为public。\",\"那么此时有个问题，为什么在javabean中要求提供一个public的空参构造器\",\"便于通过反射，创建运行时类的对象\",\"便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器\",\"此处要注意一点，并不是没有无参的构造器就不能创建对象。\"]},\"499\":{\"h\":\"4.2 获取运行时类的完整结构\",\"t\":[\"我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等\",\"@Test public void test1(){ Class clazz = Person.class; //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); //getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性 Field[] declaredFields = clazz.getDeclaredFields(); //getMethods():获取当前运行时类及其所父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); //getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法 Method[] declaredMethods = clazz.getDeclaredMethods(); //getConstructors():获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); //getDeclaredConstructors():获取当前运行时类中声明的所的构造器 Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); //获取运行时类的父类 Class superclass = clazz.getSuperclass(); //获取运行时类的带泛型的父类 Type genericSuperclass = clazz.getGenericSuperclass(); //获取运行时类实现的接口 Class[] interfaces = clazz.getInterfaces(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); //获取运行时类所在的包 Package pack = clazz.getPackage(); //获取运行时类声明的注解 Annotation[] annotations = clazz.getAnnotations(); //获取运行时类的带泛型的父类的泛型 Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = paramType.getActualTypeArguments(); // System.out.println(actualTypeArguments[0].getTypeName()); System.out.println(((Class)actualTypeArguments[0]).getName()); } \"]},\"500\":{\"h\":\"4.3 调用运行时类的指定结构\"},\"501\":{\"h\":\"①调用指定的属性\",\"t\":[\" //创建运行时类的对象 Class clazz = Person.class; Person p = (Person) clazz.newInstance(); //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(\\\"name\\\"); //2.保证当前属性是可访问的 name.setAccessible(true); //3.获取、设置指定对象的此属性值 name.set(p,\\\"Tom\\\"); \"]},\"502\":{\"h\":\"② 调用指定的方法\",\"t\":[\" Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); /* 1.获取指定的某个方法 getDeclaredMethod():参数1 ：指明获取的方法的名称 参数2：指明获取的方法的形参列表 */ Method show = clazz.getDeclaredMethod(\\\"show\\\", String.class); // 2.保证当前方法是可访问的 show.setAccessible(true); /* 3. 调用方法的invoke():参数1：方法的调用者 参数2：给方法形参赋值的实参 invoke()的返回值即为对应类中调用的方法的返回值。 */ Object returnValue = show.invoke(p,\\\"CHN\\\"); //String nation = p.show(\\\"CHN\\\"); System.out.println(\\\"*************如何调用静态方法*****************\\\"); Method showDesc = clazz.getDeclaredMethod(\\\"showDesc\\\"); showDesc.setAccessible(true); //如果调用的运行时类中的方法没返回值，则此invoke()返回null Object returnVal = showDesc.invoke(Person.class); System.out.println(returnVal);//null \"]},\"503\":{\"h\":\"③ 调用指定的构造器\",\"t\":[\" Class clazz = Person.class; // private Person(String name) /* 1.获取指定的构造器getDeclaredConstructor():参数：指明构造器的参数列表 */ Constructor constructor = clazz.getDeclaredConstructor(String.class); //2.保证此构造器是可访问的 constructor.setAccessible(true); //3.调用此构造器创建运行时类的对象 Person per = (Person) constructor.newInstance(\\\"Tom\\\"); System.out.println(per); \"]},\"504\":{\"h\":\"4.4 动态代理\"},\"505\":{\"h\":\"① 代理模式的原理\",\"t\":[\"使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。\"]},\"506\":{\"h\":\"② 静态代理\",\"t\":[\"代码举例说明：实现Runnable接口的方法创建多线程\",\"Class MyThread implements Runnable{} //相当于被代理类 Class Thread implements Runnable{} //相当于代理类 main(){ MyThread t = new MyThread(); Thread thread = new Thread(t); thread.start();//启动线程；调用线程的run() } \",\"再简单举一个例子，赵老板（被代理类）有个秘书叫做钱秘书（代理类 ），钱秘书负责安排赵老板的事情，比如今天开会，明天出差等等。某天，孙老板想要约赵老板出去谈生意，于是便联系了钱秘书，跟钱秘书商榷好在3天后跟赵老板商谈要是，最后钱秘书5个小时后将这件事询问了赵老板意见并回电话告诉孙老板三天后见（被代理类的调用要通过代理类，代理类可以决定什么时候将方法转到原始对象上）。\",\"看完这个例子，感觉代理也不错如此嘛，但是仔细想一想，如果某天赵老板新招了个李秘书，李秘书负责a方面，赵秘书负责b方面，那赵老板是不是告诉每个人自己新加了一个秘书叫李秘书，负责a方面，电话巴拉巴拉，a方面有事找李秘书巴拉巴拉，而李秘书是不是也要在接到预约赵老板a方面事情的电话时说自己不负责这方面呢。这也正是静态代理的缺点\",\"静态代理的缺点\",\"代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。\",\"每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。\"]},\"507\":{\"h\":\"③ 动态代理\",\"t\":[\"深入理解动态代理的思想\",\"既然我们知道了静态代理的缺点，即当下有两个问题需要我们去解决\",\"问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。\",\"问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a\",\"还是通过赵老板的例子来说明，对于这两个问题，一个公司前台就完美解决了这个问题，也即赵老板的信息跟公司前台的电话是绑定的，也就是当我想预约赵老板的时候，先打给前台，前台询问你想找a方面的业务还是b方面的业务，然后帮你转接到负责这个业务的赵老板的秘书那里。\",\"说道这里，想必你也已经理解了这个思想，其实这也就是动态代理的核心思想\",\"动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。\",\"动态代理相关API\",\"代码实现动态代理\",\"声明一个接口，即钱秘书和李秘书共同的职责，安排负责事情\",\"interface Human{ String getBelief(); void deal(String someThing); } \",\"实现被代理类(赵老板)\",\"class BossZhao implements Human{ @Override public String getBelief() { return \\\"我是赵老板\\\"; } @Override public void deal(String someThing) { System.out.println(\\\"我正在处理\\\" + someThing); } } \",\"通过赵老板的信息拿到公司前台的电话，并被告知联系哪个秘书，与某个秘书进行商谈\",\"class ProxyFactory{ //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj){//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); } } \",\"秘书告知赵老板做某件事\",\"class MyInvocationHandler implements InvocationHandler{ private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj){ this.obj = obj; } //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()。解决问题二 //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; } } \",\"进行测试\",\"public class ProxyTest { public static void main(String[] args) { BossZhao bossZhao = new BossZhao(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(bossZhao); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief);//输出结果：我是赵老板 proxyInstance.deal(\\\"a方面的事情\\\");//输出结果：我正在处理a方面的事情 } } \",\"不难想到，如果在执行目标方法之前、之后插入一些通用处理，那不就变成了AOP吗。\",\"Java空参构造\"]},\"508\":{\"h\":\"五、反射实战：利用反射+策略模式去除过多的if\",\"t\":[\"策略模式详细介绍请移步观看\",\"最近学习了一些设计模式以后，在实际的生产应用中总想着尝试用上一些设计模式，正好上次遇到了一个要分7个if判断的场景，经过权衡，最终决定采用反射+策略模式来去除过多的if判断。大致的思想为，先定义一个接口抽取出抽象方法，然后把每个if中的逻辑抽取出到各实现类中，接着将各实现类放入到枚举类中，最后根据要求通过反射查找相应的策略执行相应的逻辑。\",\"定义一个接口抽取出抽象方法\",\"public interface RecordStrategy { /** * 策略方法-根据id获取更多的信息 * 通过id去查询信息，封装到对应的VO里面并返回 */ Object moreInformation(String id); } \",\"把每个if中的逻辑抽取出到各实现类中\",\"//这里只展示其中一个实现类 public class AlarmPassStrategy implements RecordStrategy{ @Override public Object moreInformation(String id) { //具体业务 } } \",\"将各实现类放入到枚举类中\",\"/** * 事项策略枚举类 */ public enum RecordEnum { CLEAR_ALARM_PASS(\\\"4-3\\\", AlarmPassStrategy.class); /** * 存储事项类型（matterType - taskType） */ private String type; /** * 对应事项类型具体的策略实现类 */ private Class clazz; RecordEnum(String type, Class clazz) { this.type = type; this.clazz = clazz; } public String getType() { return type; } public Class getClazz() { return clazz; } } \",\"根据要求通过反射查找相应的策略执行相应的逻辑\",\"/** * 策略管理类，通过反射动态获取额外数据 */ public class StrategyManager { public static Map<String, Object> executeStrategy(BaseRecordCommonVO commonVO) { Map<String, Object> resultMap = new HashMap<>(); // 组装类型 如3-1代表xxx Integer matterType = commonVO.getMatterType(); Integer taskType = commonVO.getTaskType(); String type = matterType + \\\"-\\\" + taskType; // 得到对应的策略类 Class clazz = StrategySingleton.getInstance().getStrategy(type); if (clazz == null) { return resultMap; } // 获取任务id（通过任务id去获取额外信息） String taskId = commonVO.getTaskId(); try { Method method = clazz.getDeclaredMethod(\\\"moreInformation\\\", String.class); method.setAccessible(true); Object instance = clazz.newInstance(); Object result = method.invoke(instance, taskId); resultMap.put(\\\"defaultMap\\\", result); } catch (Exception e) { e.printStackTrace(); } return resultMap; } } \",\"本文参考文章或视频\",\"通俗易懂的双亲委派机制\",\"java双亲委派机制及作用\",\"尚硅谷java基础\",\"我是Monster，与你一起成长，那~下篇文章见O(∩_∩)O！\"]},\"509\":{\"c\":[\"Java\"]},\"510\":{\"c\":[\"Java\",\"面向对象\"]},\"511\":{\"h\":\"JUC01\"},\"512\":{\"c\":[\"Java\"]},\"513\":{\"c\":[\"Java\",\"JUC\"]},\"514\":{\"h\":\"垃圾回收相关知识\"},\"515\":{\"h\":\"1.如何判断对象可以回收\"},\"516\":{\"h\":\"引用计数法\",\"t\":[\"优点: 原理简单，判断效率高\",\"其效率高体现在\",\"回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收\",\"在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误\",\"区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象\",\"弊端:\",\"循环引用时，两个对象的计数都为1，导致两个对象都无法被释放，会引发内存泄漏\",\"每次对象被引用时，都需要去更新计数器，有一点时间开销\",\"浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。\"]},\"517\":{\"h\":\"可达性分析算法\",\"t\":[\"也可以称为根搜索算法、追踪性垃圾收集\",\"原理: 通过 GC Roots 作为起始点进行搜索（GC Roots 是一组活跃的引用，不是对象，放在 GC Roots Set 集合）\",\"能够到达到的对象都是存活的（只有能够被根对象集合直接或者间接连接的对象才是存活对象），换言之该对象是可达的\",\"如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。\",\"可以作为GC Root的对象\",\"虚拟机栈（栈帧中的本地变量表）中引用的对象。- 方法区中类静态属性引用的对象，例如字符串常量池（string Table）里的引用\",\"方法区中常量引用的对象\",\"本地方法栈中JNI（即一般说的Native方法）引用的对象\",\"同步锁 synchronized 持有的对象\",\"...(详见书本3.2.2)\"]},\"518\":{\"h\":\"2.引用类型\"},\"519\":{\"h\":\"强引用\",\"t\":[\"被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收\",\"强引用可以直接访问目标对象\",\"虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象\",\"强引用可能导致内存泄漏\",\"// 使用 new 一个新对象的方式来创建强引用 Object obj=new Object(); \"]},\"520\":{\"h\":\"软引用\",\"t\":[\"被软引用关联的对象只有在内存不够的情况下才会被回收\",\"// 使用 SoftReference 类来创建软引用 // list是强引用，而SoftReference和byte数组则是软引用 List<SoftReference<byte[]>>list=new ArrayList<>(); SoftReference<byte[]>ref=new SoftReference<>(new byte[4*1024*1024]); \",\"软引用一般和引用队列ReferenceQueue（也可以不和引用队列）联合使用（目的是清理软引用），使用的思路为：\",\"如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中\",\"当JVM内存不够时，将该队列从队头的元素进行出队，即虚拟机会尽可能优先回收长时间闲置不用的软引用对象，对那些刚构建的或刚使用过的\\\" 较新的\\\"软对象会被虚拟机尽可能保留。\",\" ReferenceQueue<String> referenceQueue=new ReferenceQueue<>(); String str=new String(\\\"abc\\\"); SoftReference<String> softReference=new SoftReference<>(str,referenceQueue); str=null; // 软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。 System.gc(); // 所以这里还是能获取到abc System.out.println(softReference.get()); // abc // 手动清理软引用 Reference<?extends String> reference=referenceQueue.poll(); System.out.println(reference); //null // 当JVM内存不足时，JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收： if(JVM内存不足){ // 将软引用中的对象引用置为null str=null; // 通知垃圾回收器进行回收 System.gc(); } \",\"应用场景：内存敏感的高速缓存\"]},\"521\":{\"h\":\"弱引用\",\"t\":[\"被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。\",\"// 使用 WeakReference 类来实现弱引用 String str=new String(\\\"abc\\\"); WeakReference<String> weakReference=new WeakReference<>(str); str=null; \",\"弱引用的使用和软引用类似，也是和引用队列ReferenceQueue联合使用（也可以不和引用队列联合使用）\"]},\"522\":{\"h\":\"虚引用\",\"t\":[\"虚引用顾名思义，就是形同虚设。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象\",\"如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收\",\"为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知\",\"必须配合引用队列使用\",\" String str=new String(\\\"abc\\\"); ReferenceQueue queue=new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr=new PhantomReference(str,queue); \",\"应用场景: 直接内存释放\",\"如上图，如果B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象放入引用队列中，然后调用它的clean方法来释放直接内存（详见内存结构->直接内存章节）\",\"// ByteBuffer使用了实现类DirectByteBuffer // DirectByteBuffer其构造函数使用了Cleaner类，而Cleaner类为虚引用 public class Cleaner extends PhantomReference<Object> { } \"]},\"523\":{\"h\":\"终结器引用\",\"t\":[\"所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了\",\"必须配合引用队列使用\",\"懒得写，详见书本3.2.4\"]},\"524\":{\"h\":\"3.垃圾回收算法\"},\"525\":{\"h\":\"理论：分代收集\",\"t\":[\"详细介绍请参考书本3.3.1分代收集理论\",\"Java堆一般会分为新生代和老年代两个区域，分别对这两个区域按照实际情况采取适当的收集算法。\"]},\"526\":{\"h\":\"三种回收算法的对比\",\"t\":[\"Mark-Sweep\",\"Mark-Compact\",\"Copying\",\"速度\",\"中等\",\"最慢\",\"最快\",\"空间开销\",\"少（但会堆积碎片）\",\"少（不堆积碎片）\",\"通常需要活对象的 2 倍大小（不堆积碎片）\",\"移动对象\",\"否\",\"是\",\"是\"]},\"527\":{\"h\":\"标记-清除\",\"t\":[\"定义：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间\",\"这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接覆盖这段内存\",\"缺点：\",\"执行效率不稳定，效率随对象数量增长而降低\",\"容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢\"]},\"528\":{\"h\":\"标记-整理\",\"t\":[\"让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\",\"缺点：如果在老年代这种每次回收都有大量对象存活的区域，移动存活对象是种极大负担，同时也会触发STW\"]},\"529\":{\"h\":\"标记-复制\",\"t\":[\"流程：\",\"将内存分为等大小的两个区域，FROM和TO（TO中为空）\",\"先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象\",\"交换FROM和TO\",\"优点：避免内存碎片的问题\",\"缺点：占用双倍的内存空间（浪费了一半空间）。\"]},\"530\":{\"h\":\"4.HotSpot算法细节\",\"t\":[\"参考链接：\",\"理解Java的强引用、软引用、弱引用和虚引用\"]},\"531\":{\"c\":[\"Java\"]},\"532\":{\"c\":[\"Java\",\"JVM\"]},\"533\":{\"h\":\"JVM概述\"},\"534\":{\"h\":\"JVM整体架构\"},\"535\":{\"c\":[\"Java\"]},\"536\":{\"c\":[\"Java\",\"JVM\"]},\"537\":{\"h\":\"内存结构相关知识\"},\"538\":{\"h\":\"内存概述\",\"t\":[\"内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区\",\"JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行\"]},\"539\":{\"h\":\"程序计数器\",\"t\":[\"作用：用于保存JVM中下一条所要执行的指令的地址\",\"特点\",\"线程私有\",\"CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码\",\"程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\",\"不会存在内存溢出\"]},\"540\":{\"c\":[\"Java\"]},\"541\":{\"c\":[\"Java\",\"JVM\"]},\"542\":{\"h\":\"Interview\"},\"543\":{\"h\":\"Tool\"},\"544\":{\"h\":\"Author\"},\"545\":{\"h\":\"About\"},\"546\":{\"h\":\"Plan\"},\"547\":{\"h\":\"Recollect\"},\"548\":{\"h\":\"Advance\"},\"549\":{\"h\":\"Github\"},\"550\":{\"h\":\"Ai\"},\"551\":{\"h\":\"Network\"},\"552\":{\"h\":\"Computer\"},\"553\":{\"h\":\"Os\"},\"554\":{\"h\":\"Base\"},\"555\":{\"h\":\"Index\"},\"556\":{\"h\":\"Interview\"},\"557\":{\"h\":\"Lock\"},\"558\":{\"h\":\"Transaction\"},\"559\":{\"h\":\"Senior\"},\"560\":{\"h\":\"4.plus\"},\"561\":{\"h\":\"Data Structure\"},\"562\":{\"h\":\"Jihe\"},\"563\":{\"h\":\"Base\"},\"564\":{\"h\":\"Java\"},\"565\":{\"h\":\"Object Oriented\"},\"566\":{\"h\":\"Juc\"},\"567\":{\"h\":\"Senior\"},\"568\":{\"h\":\"Jvm\"}},\"dirtCount\":0,\"index\":[[\"承载着操作系统和应用程序的实时运行\",{\"1\":{\"538\":1}}],[\"容易产生大量的内存碎片\",{\"1\":{\"527\":1}}],[\"清除\",{\"0\":{\"527\":1}}],[\"移动存活对象是种极大负担\",{\"1\":{\"528\":1}}],[\"移动对象\",{\"1\":{\"526\":1}}],[\"移除树节点时\",{\"1\":{\"473\":1}}],[\"倍大小\",{\"1\":{\"526\":1}}],[\"垃圾回收算法\",{\"0\":{\"524\":1}}],[\"垃圾回收相关知识\",{\"0\":{\"514\":1}}],[\"懒得写\",{\"1\":{\"523\":1}}],[\"弱引用和虚引用\",{\"1\":{\"530\":1}}],[\"弱引用的使用和软引用类似\",{\"1\":{\"521\":1}}],[\"弱引用\",{\"0\":{\"521\":1}}],[\"较新的\",{\"1\":{\"520\":1}}],[\"较取值为\",{\"1\":{\"338\":1}}],[\"软对象会被虚拟机尽可能保留\",{\"1\":{\"520\":1}}],[\"软引用对象是在jvm内存不够的时候才会被回收\",{\"1\":{\"520\":1}}],[\"软引用一般和引用队列referencequeue\",{\"1\":{\"520\":1}}],[\"软引用\",{\"0\":{\"520\":1},\"1\":{\"530\":1}}],[\"软件密集系统的制品的开放方法\",{\"1\":{\"58\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"517\":1}}],[\"仍然在运行时进行计数器的统计\",{\"1\":{\"516\":1}}],[\"仍然不能停止\",{\"1\":{\"228\":1}}],[\"浪费了一半空间\",{\"1\":{\"529\":1}}],[\"浪费\",{\"1\":{\"516\":1}}],[\"弊端\",{\"1\":{\"516\":1}}],[\"∩\",{\"1\":{\"508\":2}}],[\"尚硅谷java基础\",{\"1\":{\"508\":1}}],[\"尚硅谷nginx\",{\"1\":{\"49\":1}}],[\"秘书告知赵老板做某件事\",{\"1\":{\"507\":1}}],[\"深入理解动态代理的思想\",{\"1\":{\"507\":1}}],[\"电话巴拉巴拉\",{\"1\":{\"506\":1}}],[\"电梯运行的三种状态\",{\"1\":{\"85\":1}}],[\"赵秘书负责b方面\",{\"1\":{\"506\":1}}],[\"赵老板\",{\"1\":{\"506\":1,\"507\":1}}],[\"李秘书负责a方面\",{\"1\":{\"506\":1}}],[\"李刚\",{\"1\":{\"89\":1}}],[\"孙老板想要约赵老板出去谈生意\",{\"1\":{\"506\":1}}],[\"钱秘书负责安排赵老板的事情\",{\"1\":{\"506\":1}}],[\"父类的泛型\",{\"1\":{\"499\":1}}],[\"父类\",{\"1\":{\"499\":1}}],[\"父用例\",{\"1\":{\"61\":1}}],[\"便于子类继承此运行时类时\",{\"1\":{\"498\":1}}],[\"便于通过反射\",{\"1\":{\"498\":1}}],[\"便于范围查询\",{\"1\":{\"244\":1}}],[\"篡改它的实现\",{\"1\":{\"494\":1}}],[\"篡改风险\",{\"1\":{\"103\":1}}],[\"沙箱安全机制\",{\"1\":{\"494\":1}}],[\"递归这个操作\",{\"1\":{\"494\":1}}],[\"替换为直接引用\",{\"1\":{\"492\":1}}],[\"虚引用顾名思义\",{\"1\":{\"522\":1}}],[\"虚引用\",{\"0\":{\"522\":1}}],[\"虚拟机宁愿抛出\",{\"1\":{\"519\":1}}],[\"虚拟机栈\",{\"1\":{\"517\":1}}],[\"虚拟机会保证一个类的<clinit>\",{\"1\":{\"492\":1}}],[\"虚拟机常量池内的符号引用\",{\"1\":{\"492\":1}}],[\"虚线箭头+extend字样\",{\"1\":{\"63\":1}}],[\"虚线箭头+include字样\",{\"1\":{\"62\":1}}],[\"枚举\",{\"1\":{\"490\":1}}],[\"匿名内部类\",{\"1\":{\"490\":1}}],[\"静态代理的缺点\",{\"1\":{\"506\":1}}],[\"静态代理\",{\"0\":{\"506\":1}}],[\"静态内部类\",{\"1\":{\"490\":1}}],[\"静态语言\",{\"1\":{\"480\":1}}],[\"外部类\",{\"1\":{\"490\":1}}],[\"外连接\",{\"0\":{\"264\":1},\"1\":{\"261\":1}}],[\"体会反射机制的\",{\"0\":{\"481\":1}}],[\"体现的是一种组织关系\",{\"1\":{\"86\":1}}],[\"框架\",{\"1\":{\"480\":1}}],[\"透过这个镜子看到类的结构\",{\"1\":{\"480\":1}}],[\"透视\",{\"1\":{\"110\":1}}],[\"谈谈你对class类的理解\",{\"1\":{\"478\":1}}],[\"扰动计算\",{\"1\":{\"474\":1}}],[\"旧位置\",{\"1\":{\"473\":1}}],[\"旧的数据只要是绿色的\",{\"1\":{\"386\":1}}],[\"扩容流程\",{\"0\":{\"475\":1}}],[\"扩容时如何重新计算索引位置\",{\"1\":{\"473\":1}}],[\"扩展性极高的动态\",{\"1\":{\"432\":1}}],[\"扩展为表上的所有列\",{\"1\":{\"144\":1}}],[\"长度超过\",{\"1\":{\"473\":1}}],[\"长连接\",{\"1\":{\"139\":1}}],[\"哈希表的查找\",{\"1\":{\"473\":1}}],[\"哈哈\",{\"1\":{\"181\":1}}],[\"攻击\",{\"1\":{\"473\":1}}],[\"红黑树用来避免\",{\"1\":{\"473\":1}}],[\"红黑树\",{\"1\":{\"472\":1}}],[\"概览\",{\"0\":{\"464\":1}}],[\"概念模型就是用来描述这种需求\",{\"1\":{\"89\":1}}],[\"规格\",{\"1\":{\"462\":1}}],[\"规定除了\",{\"1\":{\"165\":1}}],[\"品牌名称\",{\"1\":{\"462\":1}}],[\"沟渠\",{\"1\":{\"458\":1}}],[\"译意为水道\",{\"1\":{\"458\":1}}],[\"认识canal\",{\"0\":{\"458\":1}}],[\"认为空闲时\",{\"1\":{\"179\":1}}],[\"低耦合\",{\"1\":{\"456\":1}}],[\"低级调度\",{\"1\":{\"134\":1}}],[\"低级的共享方式\",{\"1\":{\"122\":1}}],[\"耦合度高\",{\"1\":{\"456\":1}}],[\"五\",{\"0\":{\"455\":1,\"508\":1}}],[\"尝试查询redis\",{\"1\":{\"454\":2}}],[\"尝试查询http\",{\"1\":{\"451\":2,\"454\":2}}],[\"过期后nginx缓存会自动删除\",{\"1\":{\"454\":1}}],[\"过期时间\",{\"1\":{\"453\":1}}],[\"过程中不加锁\",{\"1\":{\"276\":1}}],[\"过程中加了什么锁\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":2,\"321\":1}}],[\"过程中\",{\"1\":{\"252\":1}}],[\"过程如下图\",{\"1\":{\"337\":1}}],[\"过程如下表格\",{\"1\":{\"320\":1}}],[\"过程如下\",{\"1\":{\"149\":1,\"274\":1}}],[\"放在\",{\"1\":{\"517\":1}}],[\"放入redis连接池失败\",{\"1\":{\"450\":2}}],[\"放入缓存\",{\"1\":{\"448\":2,\"463\":2}}],[\"放心\",{\"1\":{\"346\":1}}],[\"初始化\",{\"1\":{\"492\":1}}],[\"初始化redis\",{\"1\":{\"450\":2}}],[\"初始化缓存\",{\"1\":{\"448\":1,\"463\":1}}],[\"初识lua\",{\"0\":{\"421\":1}}],[\"初识caffeine\",{\"0\":{\"416\":1}}],[\"冷启动\",{\"1\":{\"448\":1}}],[\"导出\",{\"1\":{\"450\":1}}],[\"导入共享词典\",{\"1\":{\"454\":2}}],[\"导入redis\",{\"1\":{\"450\":2}}],[\"导入cjson库\",{\"1\":{\"444\":1,\"451\":1,\"454\":1}}],[\"导入common函数库\",{\"1\":{\"444\":1,\"451\":2,\"454\":1}}],[\"导致两个对象都无法被释放\",{\"1\":{\"516\":1}}],[\"导致master的offset远远超过了slave的offset\",{\"1\":{\"386\":1}}],[\"导致业务直接崩了\",{\"1\":{\"328\":1}}],[\"导致扫描是全表扫描\",{\"1\":{\"299\":1}}],[\"导致无法插入\",{\"1\":{\"290\":1}}],[\"导致死锁\",{\"1\":{\"275\":1}}],[\"导致死锁的\",{\"0\":{\"318\":1},\"1\":{\"96\":1}}],[\"导致索引结构不紧凑\",{\"1\":{\"226\":1}}],[\"导致内存无法存储其索引\",{\"1\":{\"187\":1}}],[\"导致数据库操作抖动\",{\"1\":{\"179\":1}}],[\"导致大量热数据被淘汰了\",{\"1\":{\"178\":1}}],[\"序列化为\",{\"1\":{\"443\":1}}],[\"序列化\",{\"1\":{\"443\":1}}],[\"封装到对应的vo里面并返回\",{\"1\":{\"508\":1}}],[\"封装查询函数\",{\"1\":{\"451\":2,\"454\":2}}],[\"封装redis工具\",{\"0\":{\"450\":1}}],[\"封装函数\",{\"1\":{\"442\":1,\"450\":3}}],[\"封装工具类\",{\"1\":{\"442\":1}}],[\"封装http工具\",{\"0\":{\"442\":1}}],[\"拼接并返回\",{\"1\":{\"439\":1}}],[\"拼接id并返回\",{\"1\":{\"439\":1}}],[\"拉杆箱\",{\"1\":{\"436\":1,\"439\":1}}],[\"响应体\",{\"1\":{\"441\":1}}],[\"响应头\",{\"1\":{\"441\":1}}],[\"响应状态码\",{\"1\":{\"441\":1}}],[\"响应结果由lua\",{\"1\":{\"435\":1,\"439\":1}}],[\"响应时间短的优先分配\",{\"1\":{\"41\":1}}],[\"集合\",{\"1\":{\"517\":1}}],[\"集成了大量精良的\",{\"1\":{\"432\":1}}],[\"集群初识状态是这样的\",{\"1\":{\"409\":1}}],[\"集群伸缩\",{\"0\":{\"404\":1}}],[\"集群中有多个master\",{\"1\":{\"400\":1}}],[\"集群故障恢复原理\",{\"0\":{\"393\":1}}],[\"集群监控原理\",{\"0\":{\"392\":1}}],[\"集群结构和作用\",{\"0\":{\"391\":1}}],[\"集群结构\",{\"1\":{\"342\":1}}],[\"集群的主从复制过程梳理成\",{\"1\":{\"342\":1}}],[\"布尔表达式中的逻辑运算是基于英文单词\",{\"1\":{\"429\":1}}],[\"布尔表达式为\",{\"1\":{\"429\":2}}],[\"布尔表达式\",{\"1\":{\"429\":1}}],[\"遍历table\",{\"1\":{\"426\":1}}],[\"遍历普通table\",{\"1\":{\"426\":1}}],[\"遍历数组\",{\"1\":{\"426\":2}}],[\"声明一个接口\",{\"1\":{\"507\":1}}],[\"声明map\",{\"1\":{\"426\":1}}],[\"声明table\",{\"1\":{\"425\":1}}],[\"声明数组\",{\"1\":{\"425\":1,\"426\":1}}],[\"声明数字\",{\"1\":{\"425\":1}}],[\"声明布尔类型\",{\"1\":{\"425\":1}}],[\"声明字符串\",{\"1\":{\"425\":1}}],[\"声明变量\",{\"0\":{\"425\":1}}],[\"游戏插件等\",{\"1\":{\"421\":1}}],[\"官方地址\",{\"1\":{\"443\":1}}],[\"官方网站\",{\"1\":{\"432\":1}}],[\"官方的解释\",{\"1\":{\"330\":1}}],[\"官网\",{\"1\":{\"421\":1}}],[\"柳岩\",{\"1\":{\"416\":1}}],[\"迪丽热巴\",{\"1\":{\"416\":1}}],[\"场景\",{\"1\":{\"416\":2,\"456\":3}}],[\"场景如下\",{\"1\":{\"365\":1}}],[\"减轻tomcat压力\",{\"1\":{\"414\":1}}],[\"减少hash冲突\",{\"1\":{\"475\":1}}],[\"减少数据库的压力\",{\"1\":{\"416\":1}}],[\"减少master压力\",{\"1\":{\"387\":1}}],[\"减少rdb导致的过多磁盘io\",{\"1\":{\"387\":1}}],[\"减少回表次数\",{\"1\":{\"217\":1,\"239\":2}}],[\"减少编写程序中的错误\",{\"1\":{\"58\":1}}],[\"减少与服务器之前的请求和流量\",{\"1\":{\"42\":1}}],[\"效果\",{\"1\":{\"411\":1}}],[\"效率随对象数量增长而降低\",{\"1\":{\"527\":1}}],[\"效率更高\",{\"1\":{\"475\":1}}],[\"效率不错\",{\"1\":{\"228\":1}}],[\"效率低\",{\"1\":{\"228\":1}}],[\"效率是很低的\",{\"1\":{\"228\":1}}],[\"效率最差\",{\"1\":{\"189\":1}}],[\"效率会非常低\",{\"1\":{\"155\":1,\"243\":1}}],[\"忽略master状态和其它master的意见\",{\"1\":{\"411\":1}}],[\"忽略数据一致性\",{\"1\":{\"411\":1}}],[\"省略了对offset的一致性校验\",{\"1\":{\"411\":1}}],[\"缺省\",{\"1\":{\"411\":1}}],[\"缺点\",{\"1\":{\"130\":2,\"416\":2,\"456\":3,\"527\":1,\"528\":1,\"529\":1}}],[\"切换到执行cluster\",{\"1\":{\"411\":1}}],[\"手动清理软引用\",{\"1\":{\"520\":1}}],[\"手动故障转移\",{\"0\":{\"411\":1}}],[\"手机号\",{\"1\":{\"89\":1}}],[\"填完后\",{\"1\":{\"408\":1}}],[\"询问要移动多少个插槽\",{\"1\":{\"408\":1}}],[\"拷贝配置文件\",{\"1\":{\"406\":1}}],[\"寻找插槽所在实例即可\",{\"1\":{\"403\":1}}],[\"余数是几\",{\"1\":{\"446\":1}}],[\"余数作为插槽\",{\"1\":{\"403\":1}}],[\"余额\",{\"1\":{\"357\":4}}],[\"插槽原理\",{\"0\":{\"402\":1}}],[\"插入新记录而导致事务\",{\"1\":{\"365\":1}}],[\"插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录添加\",{\"1\":{\"278\":1}}],[\"插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加\",{\"1\":{\"278\":2,\"279\":1}}],[\"插入语句就会被阻塞\",{\"1\":{\"326\":1}}],[\"插入语句在插入一条记录之前\",{\"1\":{\"296\":1}}],[\"插入相关的数据后\",{\"1\":{\"319\":1}}],[\"插入操作就会发生阻塞\",{\"1\":{\"317\":1}}],[\"插入两条记录\",{\"1\":{\"312\":1}}],[\"插入\",{\"1\":{\"296\":4}}],[\"插入的纪录了\",{\"1\":{\"367\":1}}],[\"插入的记录\",{\"1\":{\"365\":1,\"369\":1}}],[\"插入的位置的下一条记录是谁\",{\"1\":{\"296\":1}}],[\"插入的\",{\"1\":{\"280\":1}}],[\"插入了\",{\"1\":{\"280\":1,\"312\":1}}],[\"插入了一条余额超过\",{\"1\":{\"356\":1}}],[\"插入了一条记录\",{\"1\":{\"324\":2,\"325\":2}}],[\"插入了一条\",{\"1\":{\"279\":1}}],[\"插入了一个与\",{\"1\":{\"278\":1}}],[\"插入了一个记录\",{\"1\":{\"277\":1}}],[\"插入一条\",{\"1\":{\"367\":1}}],[\"插入一条记录\",{\"1\":{\"277\":1}}],[\"插入一条数据\",{\"1\":{\"182\":1}}],[\"插入意向锁和间隙锁之间是冲突的\",{\"1\":{\"324\":1}}],[\"插入意向锁名字里虽然有意向锁这三个字\",{\"1\":{\"324\":1}}],[\"插入意向锁名字虽然有意向锁\",{\"1\":{\"275\":1,\"317\":1}}],[\"插入意向锁的生成时机\",{\"1\":{\"275\":1,\"324\":1}}],[\"插入意向锁如果不在间隙锁区间内则是可以的\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"插入意向锁与间隙锁的另一个非常重要的差别是\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"插入意向锁确实是一种特殊的间隙锁\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"插入意向锁\",{\"0\":{\"317\":1},\"1\":{\"275\":2,\"317\":2,\"324\":2}}],[\"插入意向锁是什么\",{\"1\":{\"275\":1,\"324\":1}}],[\"插入可能存在节点的分裂\",{\"1\":{\"255\":1}}],[\"插入和删除效率\",{\"0\":{\"255\":1}}],[\"插入缓存\",{\"1\":{\"174\":1,\"336\":1}}],[\"散列插槽\",{\"0\":{\"401\":1}}],[\"海量数据存储问题\",{\"1\":{\"400\":1}}],[\"搭建分片集群\",{\"0\":{\"400\":1}}],[\"搭建主从架构\",{\"0\":{\"382\":1}}],[\"四\",{\"0\":{\"399\":1,\"431\":1,\"497\":1}}],[\"四次挥手\",{\"1\":{\"139\":2}}],[\"添加本地缓存逻辑\",{\"1\":{\"454\":1}}],[\"添加json处理功能\",{\"1\":{\"444\":1}}],[\"添加反向代理\",{\"1\":{\"442\":1}}],[\"添加对\",{\"1\":{\"435\":1}}],[\"添加对openresty的lua模块的加载\",{\"1\":{\"435\":1}}],[\"添加下面代码\",{\"1\":{\"435\":1}}],[\"添加下面的内容\",{\"1\":{\"422\":1}}],[\"添加缓存逻辑\",{\"1\":{\"419\":1}}],[\"添加节点的语法如下\",{\"1\":{\"407\":1}}],[\"添加节点的命令\",{\"1\":{\"404\":1}}],[\"添加新节点到redis\",{\"0\":{\"407\":1}}],[\"添加一个查询函数\",{\"1\":{\"451\":1}}],[\"添加一个location\",{\"1\":{\"442\":1}}],[\"添加一个节点到集群中\",{\"1\":{\"405\":1}}],[\"添加一个新的bean\",{\"1\":{\"398\":1}}],[\"添加7004到之前的集群\",{\"1\":{\"405\":1}}],[\"添加slaveof\",{\"1\":{\"394\":1}}],[\"及时更新连接信息\",{\"1\":{\"395\":1}}],[\"故障转移步骤有哪些\",{\"1\":{\"394\":1}}],[\"故障转移\",{\"0\":{\"409\":1},\"1\":{\"394\":1}}],[\"客观下线\",{\"1\":{\"392\":1}}],[\"客户中收到证书后使用内置\",{\"1\":{\"108\":1}}],[\"客户端请求可以访问集群任意节点\",{\"1\":{\"400\":1}}],[\"客户端先通过连接器建立连接\",{\"1\":{\"333\":1}}],[\"客户端就会直接读取\",{\"1\":{\"172\":1,\"335\":1}}],[\"客户端就可以向\",{\"1\":{\"140\":1}}],[\"客户端主动重置连接\",{\"1\":{\"139\":1}}],[\"客户端也会认定此证书非法\",{\"1\":{\"108\":1}}],[\"客户端拿到证书后也用同样的摘要算法对证书明文计算摘要\",{\"1\":{\"108\":1}}],[\"客户端验签的话就会快得多\",{\"1\":{\"108\":1}}],[\"客户端验签就需要很长的时间\",{\"1\":{\"108\":1}}],[\"客户端验验签也需要把签名解密\",{\"1\":{\"108\":1}}],[\"客户端下载\",{\"1\":{\"91\":1}}],[\"客户端发送一个请求首先要经过\",{\"1\":{\"45\":1}}],[\"逐个发送给slave\",{\"1\":{\"388\":1}}],[\"却发现自己的offset都没有了\",{\"1\":{\"386\":1}}],[\"却不能保证两者的提交顺序一致\",{\"1\":{\"347\":1}}],[\"棕色框中的红色部分\",{\"1\":{\"386\":1}}],[\"拒绝增量同步\",{\"1\":{\"384\":1}}],[\"拒绝的ip\",{\"1\":{\"32\":1}}],[\"偏移量\",{\"1\":{\"384\":1}}],[\"偏移量的地方做了aaa\",{\"1\":{\"337\":1,\"341\":1}}],[\"压缩\",{\"1\":{\"375\":1}}],[\"压缩也会消耗cpu\",{\"1\":{\"373\":1}}],[\"停机时\",{\"1\":{\"373\":1}}],[\"停止扫描\",{\"1\":{\"293\":2}}],[\"停止查询\",{\"1\":{\"148\":1,\"296\":1,\"297\":1,\"298\":1}}],[\"停止\",{\"1\":{\"31\":2,\"34\":1,\"35\":1}}],[\"马上执行\",{\"1\":{\"368\":1,\"369\":1}}],[\"快照文件称为rdb文件\",{\"1\":{\"372\":1}}],[\"快照读语句\",{\"1\":{\"368\":1}}],[\"快照读是如何避免幻读的\",{\"0\":{\"364\":1}}],[\"快速找到对应的章节的页数\",{\"1\":{\"243\":1}}],[\"快速定位到了数据行\",{\"1\":{\"232\":1}}],[\"沿着\",{\"1\":{\"360\":1}}],[\"紧接着事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"活跃的事务\",{\"1\":{\"359\":1}}],[\"活跃事务的事务\",{\"1\":{\"359\":1}}],[\"活跃事务\",{\"1\":{\"358\":3}}],[\"活动名称\",{\"1\":{\"88\":1}}],[\"活动图描述活动的顺序\",{\"1\":{\"88\":1}}],[\"活动图\",{\"0\":{\"88\":1}}],[\"活动5部分组成\",{\"1\":{\"87\":1}}],[\"活动维度\",{\"1\":{\"58\":1}}],[\"活动的相互作用\",{\"1\":{\"54\":1}}],[\"理解java的强引用\",{\"1\":{\"530\":1}}],[\"理解成一个数据快照\",{\"1\":{\"357\":1}}],[\"理论\",{\"0\":{\"525\":1}}],[\"理论上只要记录在\",{\"1\":{\"341\":1}}],[\"串行化\",{\"1\":{\"357\":7,\"361\":1}}],[\"串成一个链表\",{\"1\":{\"334\":1}}],[\"均为\",{\"1\":{\"352\":1}}],[\"均使用cpu版本\",{\"1\":{\"100\":1}}],[\"未提交事务修改过的数据\",{\"1\":{\"354\":1}}],[\"未提前加载至内存\",{\"1\":{\"187\":1}}],[\"未增加的情况\",{\"1\":{\"352\":1}}],[\"扣除了\",{\"1\":{\"352\":1}}],[\"消费\",{\"1\":{\"458\":1}}],[\"消费者购买商品这个事务\",{\"1\":{\"352\":1}}],[\"消费者的钱也没花出去\",{\"1\":{\"352\":1}}],[\"消息发送进程指明接收进程的id\",{\"1\":{\"123\":1}}],[\"消息发送者通过消息把信号传递给消息的接收者\",{\"1\":{\"81\":1}}],[\"消息传递\",{\"0\":{\"123\":1}}],[\"消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法\",{\"1\":{\"108\":1}}],[\"消息的发送者把控制传递给消息的接收者\",{\"1\":{\"81\":1}}],[\"消息的传递一般有以下几种方式\",{\"1\":{\"81\":1}}],[\"消息\",{\"1\":{\"79\":1,\"81\":1,\"86\":1}}],[\"购买失败时\",{\"1\":{\"352\":1}}],[\"购买成功时\",{\"1\":{\"352\":1}}],[\"专门用来缓存文件数据的\",{\"1\":{\"349\":1}}],[\"专门有一门学科\",{\"1\":{\"58\":1}}],[\"早被写入到\",{\"1\":{\"349\":1}}],[\"额外的故意等待\",{\"1\":{\"349\":1}}],[\"额外表保存计数值\",{\"0\":{\"200\":1}}],[\"延迟\",{\"1\":{\"349\":2}}],[\"微妙后\",{\"1\":{\"348\":1}}],[\"绿色这一组事务的\",{\"1\":{\"348\":1}}],[\"落盘\",{\"1\":{\"347\":1}}],[\"双亲委派机制的作用\",{\"1\":{\"494\":1}}],[\"双亲委派机制\",{\"1\":{\"478\":1,\"494\":1}}],[\"双\",{\"1\":{\"348\":1}}],[\"双1\",{\"1\":{\"347\":1}}],[\"双向链表\",{\"1\":{\"257\":1}}],[\"碰到处于\",{\"1\":{\"346\":1}}],[\"宣布比赛正式开始\",{\"1\":{\"344\":1}}],[\"裁判\",{\"1\":{\"344\":4}}],[\"影响从库的数据\",{\"1\":{\"344\":1}}],[\"影响主库的数据\",{\"1\":{\"344\":1}}],[\"影响查询性能\",{\"1\":{\"188\":1}}],[\"丢失了这条更新语句\",{\"1\":{\"344\":1}}],[\"突然宕机了\",{\"1\":{\"344\":2}}],[\"刷新页面可以看到结果中已经带上了id\",{\"1\":{\"439\":1}}],[\"刷新商品页面\",{\"1\":{\"436\":1}}],[\"刷新到磁盘\",{\"1\":{\"345\":1,\"350\":1}}],[\"刷新到硬盘\",{\"1\":{\"343\":1,\"345\":1,\"350\":2}}],[\"刷盘的时机\",{\"1\":{\"349\":3}}],[\"刷盘的数据继续进行事务的提交\",{\"1\":{\"348\":1}}],[\"刷盘操作\",{\"1\":{\"348\":1}}],[\"刷盘操作合并成一个\",{\"1\":{\"348\":1}}],[\"刷盘\",{\"1\":{\"347\":4,\"348\":5}}],[\"刷盘时机是在事务提交的时候\",{\"1\":{\"338\":1}}],[\"刷入到磁盘\",{\"1\":{\"345\":1,\"350\":1}}],[\"刷入到磁盘之后\",{\"1\":{\"344\":2}}],[\"刷到磁盘上的频率\",{\"1\":{\"343\":1}}],[\"升高\",{\"1\":{\"343\":1}}],[\"升为\",{\"1\":{\"250\":1}}],[\"兼顾了异步复制和同步复制的优点\",{\"1\":{\"342\":1}}],[\"兼容的正则表达式库\",{\"1\":{\"26\":1}}],[\"介于两者之间\",{\"1\":{\"342\":1}}],[\"半同步复制的方式\",{\"1\":{\"342\":1}}],[\"半同步复制\",{\"1\":{\"342\":1}}],[\"套数据库\",{\"1\":{\"342\":1}}],[\"格式如下\",{\"1\":{\"373\":1}}],[\"格式下只会记录一个\",{\"1\":{\"341\":1}}],[\"格式都有一个\",{\"1\":{\"334\":1}}],[\"入\",{\"1\":{\"340\":1}}],[\"恢复数据\",{\"1\":{\"372\":1}}],[\"恢复出来的库\",{\"1\":{\"346\":1}}],[\"恢复正常运行\",{\"1\":{\"339\":1}}],[\"恢复事务\",{\"1\":{\"337\":1}}],[\"适当提高repl\",{\"1\":{\"387\":1}}],[\"适当设置\",{\"1\":{\"339\":1}}],[\"适用对象不同\",{\"1\":{\"341\":1}}],[\"适合使用\",{\"1\":{\"256\":1}}],[\"适合\",{\"1\":{\"207\":1}}],[\"追踪性垃圾收集\",{\"1\":{\"517\":1}}],[\"追赶master的offset\",{\"1\":{\"386\":1}}],[\"追加文件\",{\"1\":{\"377\":1}}],[\"追上了\",{\"1\":{\"339\":1}}],[\"追求卓越\",{\"1\":{\"1\":1}}],[\"待落盘的脏数据页记录\",{\"1\":{\"339\":1}}],[\"～\",{\"1\":{\"339\":2}}],[\"强引用可能导致内存泄漏\",{\"1\":{\"519\":1}}],[\"强引用可以直接访问目标对象\",{\"1\":{\"519\":1}}],[\"强引用\",{\"0\":{\"519\":1}}],[\"强\",{\"1\":{\"338\":1}}],[\"牺牲数据安全性\",{\"1\":{\"338\":1}}],[\"牺牲性能\",{\"1\":{\"338\":1}}],[\"调用以后\",{\"1\":{\"523\":1}}],[\"调用方法a时\",{\"1\":{\"507\":1}}],[\"调用方法的invoke\",{\"1\":{\"502\":1}}],[\"调用线程的run\",{\"1\":{\"506\":1}}],[\"调用此构造器创建运行时类的对象\",{\"1\":{\"503\":1}}],[\"调用此方法\",{\"1\":{\"498\":1,\"507\":1}}],[\"调用指定的构造器\",{\"0\":{\"503\":1}}],[\"调用指定的方法\",{\"0\":{\"502\":1}}],[\"调用运行时类的指定结构\",{\"0\":{\"500\":1}}],[\"调用运行时类的属性\",{\"0\":{\"485\":1}}],[\"调用类的静态成员\",{\"1\":{\"492\":1}}],[\"调用引擎的提交事务接口\",{\"1\":{\"348\":1}}],[\"调用\",{\"0\":{\"486\":1},\"1\":{\"338\":1,\"348\":1}}],[\"调度的基本准则\",{\"0\":{\"136\":1}}],[\"调度的概念\",{\"0\":{\"134\":1}}],[\"留在\",{\"1\":{\"338\":1}}],[\"崩溃了\",{\"1\":{\"346\":1}}],[\"崩溃\",{\"1\":{\"346\":1}}],[\"崩溃恢复的情况\",{\"1\":{\"346\":2}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"344\":1}}],[\"崩溃恢复\",{\"1\":{\"337\":1}}],[\"崩溃后\",{\"1\":{\"334\":1}}],[\"技术的另外一个优点\",{\"1\":{\"337\":1}}],[\"技术指的是\",{\"1\":{\"337\":1}}],[\"技术\",{\"1\":{\"337\":2,\"343\":1,\"350\":1}}],[\"万修改成了\",{\"1\":{\"360\":1}}],[\"万修改为\",{\"1\":{\"357\":1}}],[\"万并提交了事务\",{\"1\":{\"359\":1}}],[\"万时\",{\"1\":{\"357\":1}}],[\"万了\",{\"1\":{\"357\":1}}],[\"万余额的账号个数就变为\",{\"1\":{\"356\":1}}],[\"万的这条记录\",{\"1\":{\"359\":2,\"360\":1}}],[\"万的账号\",{\"1\":{\"356\":1}}],[\"万的记录\",{\"1\":{\"356\":2,\"357\":1,\"358\":1}}],[\"万的过程是有下面这几个步骤组成的\",{\"1\":{\"351\":1}}],[\"万消失了\",{\"1\":{\"351\":1}}],[\"万\",{\"1\":{\"351\":2,\"357\":7,\"359\":5,\"360\":4}}],[\"万元\",{\"1\":{\"351\":2}}],[\"万一断电重启\",{\"1\":{\"337\":1}}],[\"万条记录\",{\"1\":{\"198\":1}}],[\"去查询http\",{\"1\":{\"451\":2,\"454\":2}}],[\"去\",{\"1\":{\"346\":1}}],[\"去读\",{\"1\":{\"342\":1}}],[\"去读取对应长度的数据\",{\"1\":{\"161\":1}}],[\"去定位到某条具体的记录\",{\"1\":{\"336\":1}}],[\"产生的\",{\"1\":{\"334\":1,\"337\":2}}],[\"产生的摘要必然不同\",{\"1\":{\"108\":1}}],[\"增大了随机性\",{\"1\":{\"474\":1}}],[\"增大它的大小可以让\",{\"1\":{\"337\":1}}],[\"增量同步\",{\"0\":{\"385\":1},\"1\":{\"388\":1}}],[\"增长超过多少百分比则触发重写\",{\"1\":{\"379\":1}}],[\"增删改\",{\"1\":{\"334\":4}}],[\"增加并发度\",{\"1\":{\"126\":1}}],[\"归档日志\",{\"1\":{\"333\":2}}],[\"归纳为用户\",{\"1\":{\"61\":1}}],[\"归纳\",{\"0\":{\"61\":1},\"1\":{\"59\":2}}],[\"触发rdb条件\",{\"1\":{\"373\":1}}],[\"触发rdb条件时\",{\"1\":{\"373\":1}}],[\"触发了全表扫描\",{\"1\":{\"329\":1}}],[\"触发器\",{\"1\":{\"138\":1,\"272\":1}}],[\"昨晚在群划水的时候\",{\"1\":{\"328\":1}}],[\"昨天有位读者在美团二面的时候\",{\"1\":{\"301\":1}}],[\"昨天发了一篇关于索引失效的文章\",{\"1\":{\"230\":1}}],[\"往t\",{\"1\":{\"368\":1}}],[\"往表\",{\"1\":{\"312\":1}}],[\"往事务\",{\"1\":{\"275\":1}}],[\"修饰的字段加上轻量级锁\",{\"1\":{\"312\":1}}],[\"修饰的字段的值是连续递增的\",{\"1\":{\"312\":1}}],[\"修饰的字段赋值递增的值\",{\"1\":{\"312\":1}}],[\"修改read\",{\"1\":{\"454\":1}}],[\"修改对tomcat服务的反向代理\",{\"1\":{\"447\":1}}],[\"修改item实体类\",{\"0\":{\"462\":1}}],[\"修改item\",{\"1\":{\"419\":1,\"454\":1}}],[\"修改配置文件\",{\"1\":{\"406\":1}}],[\"修改故障节点配置\",{\"1\":{\"394\":1}}],[\"修改的数据\",{\"1\":{\"360\":2}}],[\"修改数据库时发送事件通知\",{\"1\":{\"456\":1}}],[\"修改数据\",{\"1\":{\"360\":1}}],[\"修改了该记录\",{\"1\":{\"359\":1}}],[\"修改了表字段\",{\"1\":{\"310\":1}}],[\"修改余额后\",{\"1\":{\"357\":2}}],[\"修改\",{\"1\":{\"334\":2,\"435\":2,\"439\":2,\"442\":1,\"447\":1,\"450\":1,\"451\":1,\"454\":1}}],[\"修改订单\",{\"1\":{\"273\":1}}],[\"修改订单审核状态等\",{\"1\":{\"53\":1}}],[\"修改时间\",{\"1\":{\"182\":1,\"183\":1}}],[\"修改完成后\",{\"1\":{\"139\":1}}],[\"修改keepalived的配置文件keepalived\",{\"1\":{\"43\":1}}],[\"掉这个长事务\",{\"1\":{\"310\":1}}],[\"队列中写锁获取优先级高于读锁\",{\"1\":{\"310\":1}}],[\"阻塞等待\",{\"1\":{\"324\":1,\"325\":1}}],[\"阻塞后\",{\"1\":{\"310\":1}}],[\"阻塞状态\",{\"1\":{\"277\":1}}],[\"释放间隙锁的时刻\",{\"1\":{\"317\":1}}],[\"释放\",{\"1\":{\"310\":2}}],[\"释放了锁\",{\"1\":{\"280\":1}}],[\"牛逼的地方在于实现了颗粒度更细的行级锁\",{\"1\":{\"309\":1}}],[\"意向独占锁\",{\"1\":{\"311\":2}}],[\"意向共享锁和意向独占锁是表级锁\",{\"1\":{\"311\":1}}],[\"意向共享锁\",{\"1\":{\"311\":1}}],[\"意向锁的目的是为了快速判断表里是否有记录被加锁\",{\"1\":{\"311\":1}}],[\"意向锁\",{\"0\":{\"311\":1},\"1\":{\"308\":1,\"311\":2}}],[\"意味着性能越差\",{\"1\":{\"361\":1}}],[\"意味着写入到了操作系统的文件缓存\",{\"1\":{\"338\":1,\"349\":1}}],[\"意味着\",{\"1\":{\"312\":1}}],[\"意味着整个数据库都是只读状态\",{\"1\":{\"307\":1}}],[\"意味着其他事务无法更新或者删除\",{\"1\":{\"293\":1,\"297\":4,\"298\":4}}],[\"意味着其他事务无法插入\",{\"1\":{\"293\":3,\"294\":2,\"296\":1,\"297\":2,\"298\":1}}],[\"意味着其他事务即无法更新或者删除\",{\"1\":{\"293\":3,\"294\":5}}],[\"意味着其搜索复杂度为\",{\"1\":{\"207\":1}}],[\"意味着事务\",{\"1\":{\"277\":1}}],[\"意味着磁盘\",{\"1\":{\"252\":1}}],[\"意味着需要磁盘\",{\"1\":{\"250\":1}}],[\"意味着数据\",{\"1\":{\"248\":1}}],[\"意味着数据库每次读写都是以\",{\"1\":{\"155\":1,\"243\":1}}],[\"意味着二级索引的叶子节点越小\",{\"1\":{\"226\":1}}],[\"意味着最大能允许存储\",{\"1\":{\"165\":1}}],[\"业务直接结束\",{\"1\":{\"456\":1}}],[\"业务会因此停滞\",{\"1\":{\"329\":1}}],[\"业务只能读数据\",{\"1\":{\"307\":1}}],[\"业务流程图\",{\"1\":{\"53\":1}}],[\"反射实战\",{\"0\":{\"508\":1}}],[\"反射应用\",{\"0\":{\"497\":1}}],[\"反射机制允许程序在执行期借助于reflection\",{\"1\":{\"480\":1}}],[\"反射\",{\"1\":{\"480\":3}}],[\"反射的概述\",{\"0\":{\"479\":1}}],[\"反序列化\",{\"1\":{\"443\":2}}],[\"反之\",{\"1\":{\"310\":1}}],[\"反而商品表中该商品的库存被减少了\",{\"1\":{\"307\":1}}],[\"反向代理流程\",{\"0\":{\"434\":1}}],[\"反向代理\",{\"0\":{\"22\":1},\"1\":{\"22\":1,\"45\":1}}],[\"化简一下\",{\"1\":{\"304\":1}}],[\"岁以上行记录\",{\"1\":{\"304\":1}}],[\"岁的用户共有\",{\"1\":{\"303\":1}}],[\"详见内存结构\",{\"1\":{\"522\":1}}],[\"详见书本3\",{\"1\":{\"517\":1,\"523\":1}}],[\"详见这篇文章\",{\"1\":{\"302\":1,\"357\":1,\"361\":1}}],[\"详细介绍请参考书本3\",{\"1\":{\"525\":1}}],[\"详细可以看这篇\",{\"1\":{\"275\":2}}],[\"详细的分析可以看我这篇文章\",{\"1\":{\"234\":1}}],[\"详细过程可以参考开启多个tomcat\",{\"1\":{\"37\":1}}],[\"详细过程可参考linux下安装tomcat\",{\"1\":{\"35\":1}}],[\"途中没有执行其他任何语句\",{\"1\":{\"302\":1,\"363\":1}}],[\"顺着\",{\"1\":{\"334\":1}}],[\"顺便再帮大家复习一下记录锁+间隙锁\",{\"1\":{\"301\":1}}],[\"顺序写\",{\"1\":{\"337\":4,\"338\":1}}],[\"顺序\",{\"1\":{\"312\":1}}],[\"顺序组成单向链表\",{\"1\":{\"243\":1}}],[\"顺序图的组成元素\",{\"1\":{\"79\":1}}],[\"顺序图\",{\"0\":{\"79\":1,\"83\":1,\"84\":1},\"1\":{\"79\":1,\"80\":1,\"83\":1,\"87\":1}}],[\"顺序结构\",{\"1\":{\"56\":2}}],[\"删\",{\"1\":{\"299\":1,\"304\":1,\"305\":1}}],[\"删除数据到redis\",{\"1\":{\"463\":1}}],[\"删除数据到jvm进程缓存\",{\"1\":{\"463\":1}}],[\"删除\",{\"1\":{\"334\":2}}],[\"删除操作\",{\"1\":{\"311\":1}}],[\"删除的效率都更高\",{\"1\":{\"258\":1}}],[\"删除节点的时候非常复杂\",{\"1\":{\"255\":1}}],[\"删除非常方便\",{\"1\":{\"243\":1}}],[\"删除记录的时候\",{\"1\":{\"163\":1}}],[\"删除bug分支\",{\"1\":{\"15\":1}}],[\"扫面的第二行是\",{\"1\":{\"298\":1}}],[\"扫描到第一条不符合条件的二级索引记录\",{\"1\":{\"295\":1,\"300\":1}}],[\"扫描到的第三行是\",{\"1\":{\"294\":1}}],[\"扫描到的第二行是\",{\"1\":{\"293\":1,\"294\":3,\"297\":1}}],[\"扫描到了特殊记录\",{\"1\":{\"293\":1}}],[\"扫描到终止范围查询的记录时\",{\"1\":{\"292\":3,\"294\":4}}],[\"扫描索引的过程\",{\"1\":{\"235\":1}}],[\"扫描叶子节点\",{\"1\":{\"156\":1}}],[\"山治\",{\"1\":{\"297\":1,\"298\":1}}],[\"达到了终止扫描的条件\",{\"1\":{\"294\":1}}],[\"达到释放内存的效果\",{\"1\":{\"139\":1}}],[\"索隆\",{\"1\":{\"294\":2}}],[\"索引计算规则\",{\"0\":{\"474\":1}}],[\"索引会加下图中的锁\",{\"1\":{\"304\":1}}],[\"索引加的锁\",{\"1\":{\"304\":1}}],[\"索引加锁的范围时\",{\"1\":{\"304\":1}}],[\"索引数据最好能按顺序排列\",{\"1\":{\"249\":1}}],[\"索引+记录\",{\"1\":{\"248\":1,\"252\":1,\"253\":1}}],[\"索引优化等等\",{\"1\":{\"246\":1}}],[\"索引覆盖\",{\"1\":{\"245\":1,\"246\":1}}],[\"索引又可以分成聚簇索引和非聚簇索引\",{\"1\":{\"245\":1}}],[\"索引字段并没有用任何函数\",{\"1\":{\"238\":1}}],[\"索引特性增加了函数索引\",{\"1\":{\"236\":1}}],[\"索引值\",{\"1\":{\"235\":1}}],[\"索引值+主键值\",{\"1\":{\"232\":1}}],[\"索引存储结构长什么样\",{\"0\":{\"234\":1}}],[\"索引范围扫描\",{\"1\":{\"228\":1}}],[\"索引统计和值比较都更复杂\",{\"1\":{\"227\":1}}],[\"索引列+主键值\",{\"1\":{\"232\":1}}],[\"索引列存在\",{\"1\":{\"227\":1}}],[\"索引列要设置为\",{\"1\":{\"227\":1}}],[\"索引列的值必须唯一\",{\"1\":{\"211\":1}}],[\"索引列的值不允许有空值\",{\"1\":{\"210\":1}}],[\"索引最好设置为\",{\"0\":{\"227\":1}}],[\"索引最大的好处是提高查询速度\",{\"1\":{\"220\":1}}],[\"索引不是万能钥匙\",{\"1\":{\"220\":1}}],[\"索引区分度\",{\"0\":{\"218\":1}}],[\"索引分为单列索引\",{\"1\":{\"214\":1}}],[\"索引分为主键索引\",{\"1\":{\"209\":1}}],[\"索引分为聚簇索引\",{\"1\":{\"208\":1}}],[\"索引要比\",{\"1\":{\"207\":1}}],[\"索引结构的优势在哪儿\",{\"1\":{\"207\":1}}],[\"索引结构不会影响单表最大行数\",{\"1\":{\"188\":1}}],[\"索引时是长什么样子的\",{\"1\":{\"204\":1}}],[\"索引在存储数据中的具体实现\",{\"1\":{\"204\":1}}],[\"索引类型也是\",{\"1\":{\"204\":1}}],[\"索引\",{\"1\":{\"204\":4,\"234\":1,\"235\":1,\"272\":1,\"304\":2}}],[\"索引和数据就是位于存储引擎中\",{\"1\":{\"202\":1}}],[\"索引的\",{\"1\":{\"298\":1,\"300\":2}}],[\"索引的存储结构跟\",{\"1\":{\"234\":1}}],[\"索引的存储和查询的过程\",{\"1\":{\"204\":1}}],[\"索引的作用会越来越明显\",{\"1\":{\"228\":1}}],[\"索引的价值是快速定位\",{\"1\":{\"222\":1}}],[\"索引的分类\",{\"0\":{\"203\":1}}],[\"索引的定义就是帮助存储引擎快速获取数据的一种数据结构\",{\"1\":{\"202\":1}}],[\"索引的知识点\",{\"1\":{\"201\":1}}],[\"索引的数据结构\",{\"0\":{\"186\":1},\"1\":{\"248\":1}}],[\"索引底层使用了什么数据结构和算法\",{\"1\":{\"201\":1}}],[\"索引相关的问题基本都是一系列问题\",{\"1\":{\"201\":1}}],[\"索引也也不例外\",{\"1\":{\"187\":1}}],[\"索引页\",{\"1\":{\"174\":1,\"186\":2,\"336\":1}}],[\"索引段\",{\"1\":{\"157\":1}}],[\"索引段和回滚段等\",{\"1\":{\"157\":1}}],[\"索引等信息单独存储在一个独占表空间\",{\"1\":{\"152\":1}}],[\"索引下推能够减少二级索引在查询时的回表操作\",{\"1\":{\"149\":1}}],[\"索引下推\",{\"0\":{\"149\":1,\"217\":1},\"1\":{\"146\":1}}],[\"索引一定会失效吗\",{\"0\":{\"230\":1},\"1\":{\"96\":1}}],[\"索引失效有哪些\",{\"0\":{\"233\":1},\"1\":{\"96\":1}}],[\"索引常见面试题\",{\"0\":{\"201\":1},\"1\":{\"96\":1,\"149\":1}}],[\"索引篇\",{\"1\":{\"96\":1}}],[\"乌索普\",{\"1\":{\"293\":1}}],[\"香克斯\",{\"1\":{\"293\":2,\"298\":1}}],[\"路飞\",{\"1\":{\"290\":1,\"294\":2}}],[\"路径规范\",{\"0\":{\"57\":1}}],[\"退化为链表\",{\"1\":{\"473\":1}}],[\"退化为间隙锁或者记录锁\",{\"1\":{\"300\":1}}],[\"退化规则\",{\"1\":{\"473\":1}}],[\"退化成间隙锁\",{\"1\":{\"294\":1,\"297\":1}}],[\"退化成\",{\"1\":{\"289\":1,\"300\":1}}],[\"退出循环\",{\"1\":{\"148\":1}}],[\"满足了死锁的四个条件\",{\"1\":{\"325\":1,\"326\":1}}],[\"满足\",{\"1\":{\"294\":1}}],[\"满足写写互斥\",{\"1\":{\"283\":1,\"313\":1}}],[\"满足读读共享\",{\"1\":{\"283\":1,\"313\":1}}],[\"独占表锁\",{\"1\":{\"311\":2}}],[\"独占锁\",{\"1\":{\"283\":1,\"311\":1,\"313\":1}}],[\"独立的进程\",{\"1\":{\"46\":1}}],[\"读已提交\",{\"1\":{\"361\":1}}],[\"读不到事务\",{\"1\":{\"360\":1}}],[\"读未提交\",{\"1\":{\"357\":4}}],[\"读到的记录都是小林余额是\",{\"1\":{\"359\":1}}],[\"读到余额依然还是\",{\"1\":{\"359\":1}}],[\"读到余额还是\",{\"1\":{\"359\":1}}],[\"读到余额是\",{\"1\":{\"359\":1}}],[\"读到其他事务未提交的数据\",{\"1\":{\"357\":1}}],[\"读到\",{\"1\":{\"354\":1}}],[\"读提交隔离级别是在每次读取数据时\",{\"1\":{\"360\":1}}],[\"读提交是如何工作的\",{\"0\":{\"360\":1}}],[\"读提交\",{\"1\":{\"334\":2,\"357\":6,\"360\":1,\"361\":2}}],[\"读\",{\"1\":{\"333\":1}}],[\"读者问答\",{\"0\":{\"327\":1}}],[\"读读\",{\"1\":{\"310\":1}}],[\"读锁还在占用着\",{\"1\":{\"310\":1}}],[\"读锁\",{\"1\":{\"310\":6}}],[\"读写互斥\",{\"1\":{\"283\":2,\"311\":1,\"313\":2}}],[\"读取配置文件的方式二\",{\"1\":{\"496\":1}}],[\"读取配置文件的方式一\",{\"1\":{\"496\":1}}],[\"读取\",{\"1\":{\"453\":1}}],[\"读取本地内存\",{\"1\":{\"416\":1}}],[\"读取数据时创建的\",{\"1\":{\"360\":1}}],[\"读取数据\",{\"1\":{\"360\":3}}],[\"读取数据的时候才能根据这个\",{\"1\":{\"161\":1}}],[\"读取小林的账户余额记录\",{\"1\":{\"359\":3}}],[\"读取到的余额数据是刚才事务\",{\"1\":{\"354\":1}}],[\"读取到一条记录\",{\"1\":{\"193\":1}}],[\"读取一条记录\",{\"1\":{\"192\":1}}],[\"读取页里的记录\",{\"1\":{\"178\":1}}],[\"文档是怎么定义幻读\",{\"1\":{\"302\":1,\"363\":1}}],[\"文章内容比较长\",{\"1\":{\"282\":1}}],[\"文件内容为\",{\"1\":{\"478\":1}}],[\"文件保存的路径目录\",{\"1\":{\"373\":1}}],[\"文件保存的是全量的日志\",{\"1\":{\"341\":1}}],[\"文件后\",{\"1\":{\"348\":1}}],[\"文件做\",{\"1\":{\"348\":1}}],[\"文件中\",{\"1\":{\"343\":2}}],[\"文件里擦除\",{\"1\":{\"341\":1}}],[\"文件是循环写\",{\"1\":{\"341\":1}}],[\"文件是记录了所有数据库表结构变更和表数据修改的日志\",{\"1\":{\"340\":1}}],[\"文件恢复数据\",{\"1\":{\"341\":1}}],[\"文件恢复数据吗\",{\"1\":{\"341\":1}}],[\"文件恢复\",{\"1\":{\"341\":2}}],[\"文件过大\",{\"1\":{\"341\":1}}],[\"文件格式不同\",{\"1\":{\"341\":1}}],[\"文件满了\",{\"1\":{\"339\":1}}],[\"文件也被写满时\",{\"1\":{\"339\":1}}],[\"文件被写满的时候\",{\"1\":{\"339\":1}}],[\"文件组成\",{\"1\":{\"339\":1}}],[\"文件写满了怎么办\",{\"0\":{\"339\":1}}],[\"文件名\",{\"1\":{\"152\":2}}],[\"文件\",{\"1\":{\"152\":2,\"338\":2,\"339\":3,\"340\":1,\"343\":4,\"345\":1,\"346\":1,\"348\":2,\"349\":2,\"350\":2,\"374\":1}}],[\"文件备份\",{\"1\":{\"91\":1}}],[\"文件temp\",{\"1\":{\"34\":1}}],[\"文件扩展名与文件类型映射表\",{\"1\":{\"32\":1}}],[\"坦白说\",{\"1\":{\"282\":1}}],[\"占有且等待\",{\"1\":{\"281\":1,\"325\":1,\"326\":1}}],[\"占用双倍的内存空间\",{\"1\":{\"529\":1}}],[\"占用空间也比普通node\",{\"1\":{\"473\":1}}],[\"占用空间越大\",{\"1\":{\"220\":1}}],[\"占用的字节数之和\",{\"1\":{\"166\":1}}],[\"占用的字节数\",{\"1\":{\"166\":2}}],[\"占用的字节长度加起来不能超过\",{\"1\":{\"165\":1}}],[\"占用\",{\"1\":{\"164\":3}}],[\"占用了woker的几个连接数\",{\"1\":{\"49\":1}}],[\"互斥\",{\"1\":{\"281\":1,\"325\":1,\"326\":1}}],[\"处于\",{\"1\":{\"346\":1}}],[\"处于等待状态\",{\"1\":{\"280\":1}}],[\"处理方式是有差异的\",{\"1\":{\"216\":1}}],[\"处理机调度是对处理机进行分配\",{\"1\":{\"134\":1}}],[\"处理机调度\",{\"0\":{\"133\":1}}],[\"处理\",{\"1\":{\"83\":1,\"337\":1}}],[\"处理消息\",{\"1\":{\"79\":1,\"80\":1}}],[\"处理器是带阴影的立方体\",{\"1\":{\"75\":1}}],[\"处理框\",{\"1\":{\"58\":1}}],[\"处理流程须以单一入口和单一出口绘制\",{\"1\":{\"57\":1}}],[\"遇到唯一键冲突\",{\"0\":{\"278\":1}}],[\"尽量还是使用链表\",{\"1\":{\"473\":1}}],[\"尽量在数据表上建立二级索引\",{\"1\":{\"196\":1}}],[\"尽可能避免全量同步\",{\"1\":{\"387\":1}}],[\"尽管\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"型锁\",{\"1\":{\"294\":1,\"297\":1}}],[\"型间隙锁\",{\"1\":{\"286\":1,\"291\":1,\"296\":3,\"315\":1}}],[\"型间隙锁和\",{\"1\":{\"286\":1,\"315\":1}}],[\"型\",{\"1\":{\"278\":1,\"280\":2,\"293\":3,\"294\":1}}],[\"型记录锁后\",{\"1\":{\"285\":2,\"314\":2}}],[\"型记录锁的话\",{\"1\":{\"279\":1}}],[\"型记录锁\",{\"1\":{\"278\":2,\"279\":1,\"285\":4,\"314\":4}}],[\"型关系\",{\"1\":{\"275\":2,\"287\":1,\"316\":1}}],[\"型与\",{\"1\":{\"275\":2,\"280\":1,\"285\":4,\"287\":1,\"314\":4,\"316\":1}}],[\"型的范围为\",{\"1\":{\"294\":2}}],[\"型的锁是冲突的\",{\"1\":{\"280\":2}}],[\"型的锁\",{\"1\":{\"278\":1,\"280\":1,\"294\":2,\"297\":1,\"298\":1}}],[\"型的间隙锁\",{\"1\":{\"275\":1,\"296\":2}}],[\"型的记录锁是冲突的\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"型的记录锁与\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"型的记录锁\",{\"1\":{\"275\":1,\"279\":2,\"280\":5,\"285\":1,\"290\":3,\"297\":1,\"304\":6,\"314\":1}}],[\"型的\",{\"1\":{\"275\":6,\"280\":4,\"287\":4,\"304\":17,\"316\":4}}],[\"间隙\",{\"1\":{\"329\":1}}],[\"间隙锁的时候\",{\"1\":{\"296\":1}}],[\"间隙锁的范围是\",{\"1\":{\"323\":1}}],[\"间隙锁的范围\",{\"1\":{\"291\":2,\"322\":2}}],[\"间隙锁的意义只在于阻止区间被插入\",{\"1\":{\"275\":1,\"323\":1}}],[\"间隙锁之间是兼容的\",{\"1\":{\"286\":1,\"315\":1}}],[\"间隙锁虽然存在\",{\"1\":{\"286\":1,\"315\":1}}],[\"间隙锁\",{\"1\":{\"275\":1,\"284\":1,\"286\":1,\"289\":1,\"291\":1,\"300\":1,\"313\":1,\"315\":1,\"317\":1,\"329\":1,\"365\":1}}],[\"间接地通信\",{\"1\":{\"123\":1}}],[\"间接通信方式\",{\"1\":{\"123\":1}}],[\"死锁的四个必要条件\",{\"1\":{\"281\":1}}],[\"死锁的发生\",{\"0\":{\"274\":1}}],[\"死锁了\",{\"0\":{\"273\":1},\"1\":{\"96\":1}}],[\"于表中的\",{\"1\":{\"290\":1,\"291\":1}}],[\"于在刷新脏页到磁盘\",{\"1\":{\"272\":1}}],[\"于是便联系了钱秘书\",{\"1\":{\"506\":1}}],[\"于是最新记录和旧版本记录通过链表的方式串起来\",{\"1\":{\"359\":1}}],[\"于是事务\",{\"1\":{\"357\":1}}],[\"于是事物\",{\"1\":{\"317\":1,\"365\":1}}],[\"于是对\",{\"1\":{\"297\":1}}],[\"于是对该二级索引记录加\",{\"1\":{\"298\":1}}],[\"于是对该二级索引记录加上范围为\",{\"1\":{\"297\":1}}],[\"于是对该记录加的是范围为\",{\"1\":{\"294\":3}}],[\"于是对该主键索引加的是范围为\",{\"1\":{\"293\":2,\"294\":2}}],[\"于是非唯一索引等值查询的过程是一个扫描的过程\",{\"1\":{\"297\":1,\"300\":1}}],[\"于是该二级索引的\",{\"1\":{\"296\":1}}],[\"于是停止扫描\",{\"1\":{\"294\":3}}],[\"于是锁就释放了\",{\"1\":{\"281\":1}}],[\"于是可以通过二分查找法的方式进行检索从而提高效率\",{\"1\":{\"246\":1}}],[\"于是就发生了幻读\",{\"1\":{\"367\":1}}],[\"于是就可以通过它找到修改前的记录\",{\"1\":{\"358\":1}}],[\"于是就可以走索引查询了\",{\"1\":{\"237\":1}}],[\"于是就会被锁住\",{\"1\":{\"357\":1}}],[\"于是就会对所有记录加上\",{\"1\":{\"329\":1}}],[\"于是就会对每一条记录的索引上都会加\",{\"1\":{\"299\":1}}],[\"于是就造成了循环等待\",{\"1\":{\"275\":1,\"325\":1,\"326\":1}}],[\"于是就只能通过全表扫描的方式来查询\",{\"1\":{\"235\":1}}],[\"于是就读取该行数据\",{\"1\":{\"235\":1}}],[\"于是就往叶子节点查询\",{\"1\":{\"235\":1}}],[\"于是就设计出\",{\"1\":{\"177\":1}}],[\"于是\",{\"1\":{\"216\":2,\"294\":1,\"295\":1}}],[\"于是在进行索引扫描的时候\",{\"1\":{\"216\":3}}],[\"于是将此页数据加载至内存进行一一对比\",{\"1\":{\"187\":1}}],[\"❗️这里介绍体系结构\",{\"1\":{\"272\":1}}],[\"❗️这里介绍表\",{\"1\":{\"272\":1}}],[\"❗️此处为附图\",{\"1\":{\"272\":1}}],[\"慢查询日志等\",{\"1\":{\"272\":1}}],[\"错误\",{\"1\":{\"516\":1}}],[\"错误日志\",{\"1\":{\"272\":1}}],[\"错误页\",{\"1\":{\"32\":1}}],[\"负责a方面\",{\"1\":{\"506\":1}}],[\"负责mysql中数据的存储和提取\",{\"1\":{\"272\":1}}],[\"负责查询解析\",{\"1\":{\"272\":1}}],[\"负责连接管理\",{\"1\":{\"272\":1}}],[\"负载分配策略\",{\"0\":{\"41\":1}}],[\"负载均衡效果\",{\"1\":{\"40\":1}}],[\"负载均衡\",{\"0\":{\"23\":1}}],[\"❌\",{\"1\":{\"271\":6}}],[\"✅\",{\"1\":{\"271\":6}}],[\"隔离级别使用\",{\"1\":{\"365\":1}}],[\"隔离级别会影响性能\",{\"1\":{\"357\":1}}],[\"隔离级别来避免幻读现象的发生\",{\"1\":{\"357\":1}}],[\"隔离级别下在事务期间读到的记录都是事务启动前的记录\",{\"1\":{\"359\":1}}],[\"隔离级别下\",{\"1\":{\"357\":9}}],[\"隔离级别下的幻读问题\",{\"1\":{\"275\":1}}],[\"隔离级别越高\",{\"1\":{\"357\":1,\"361\":1}}],[\"隔离级别的事务来说\",{\"1\":{\"334\":1,\"357\":3,\"361\":1}}],[\"隔离级别是在\",{\"1\":{\"357\":1}}],[\"隔离级别是在每个\",{\"1\":{\"334\":1,\"361\":1}}],[\"隔离级别是启动事务时生成一个\",{\"1\":{\"334\":1,\"361\":1}}],[\"隔离级别是\",{\"1\":{\"288\":1,\"357\":1}}],[\"隔离级别为可重复读\",{\"1\":{\"274\":1}}],[\"隔离级别\",{\"1\":{\"271\":1,\"320\":1}}],[\"隔离性是通过\",{\"1\":{\"352\":1}}],[\"隔离性是通过锁\",{\"1\":{\"272\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"352\":1}}],[\"隔离性\",{\"1\":{\"269\":1,\"352\":1,\"361\":1}}],[\"幻像\",{\"1\":{\"302\":1,\"363\":1}}],[\"幻影\",{\"1\":{\"270\":1}}],[\"幻读就是发生在这种违和的场景\",{\"1\":{\"367\":1}}],[\"幻读被完全解决了吗\",{\"0\":{\"366\":1}}],[\"幻读这些问题\",{\"1\":{\"361\":1}}],[\"幻读的定义就是\",{\"1\":{\"290\":1}}],[\"幻读\",{\"0\":{\"356\":1},\"1\":{\"270\":1,\"271\":1,\"353\":1,\"356\":1,\"357\":2}}],[\"好像出现了\",{\"1\":{\"270\":1}}],[\"好了\",{\"1\":{\"138\":1,\"151\":1,\"152\":1,\"157\":1}}],[\"脏读\",{\"0\":{\"354\":1},\"1\":{\"270\":1,\"271\":1,\"354\":1,\"357\":3}}],[\"脏页链表\",{\"1\":{\"180\":1}}],[\"脏页需要被刷入磁盘\",{\"1\":{\"179\":1}}],[\"脏页什么时候会被刷入磁盘\",{\"0\":{\"179\":1}}],[\"脏页同时存在于\",{\"1\":{\"178\":1}}],[\"脏页\",{\"1\":{\"178\":1}}],[\"统一写\",{\"1\":{\"340\":1}}],[\"统一建模语言\",{\"1\":{\"58\":1}}],[\"统提交或撤销操作请求\",{\"1\":{\"268\":1}}],[\"必须配合引用队列使用\",{\"1\":{\"522\":1,\"523\":1}}],[\"必须根据前端传递来的商品id\",{\"1\":{\"437\":1}}],[\"必须向master声明自己的replication\",{\"1\":{\"384\":1}}],[\"必须在事务提交之后\",{\"1\":{\"346\":1}}],[\"必须保持一致才能保证主从数据一致\",{\"1\":{\"344\":1}}],[\"必须保证在任务一开始就对它有详细而确切的了解\",{\"1\":{\"58\":1}}],[\"必须先清楚mysql的结构\",{\"1\":{\"272\":1}}],[\"必须要为表起别名\",{\"1\":{\"265\":1}}],[\"顾名思义\",{\"1\":{\"265\":1,\"493\":1}}],[\"顾客\",{\"1\":{\"54\":1}}],[\"左边界\",{\"1\":{\"291\":1}}],[\"左外连接和右外连接是可以相互替换的\",{\"1\":{\"264\":1}}],[\"左外连接查询的是左表的所有数据和两张表交集部分的数据\",{\"1\":{\"264\":1}}],[\"左外连接\",{\"1\":{\"261\":1,\"264\":1}}],[\"左右\",{\"1\":{\"187\":1}}],[\"隐式锁\",{\"1\":{\"280\":2}}],[\"隐式锁就是在\",{\"1\":{\"276\":1}}],[\"隐式锁是\",{\"1\":{\"276\":1}}],[\"隐式内连接\",{\"1\":{\"261\":1,\"263\":1}}],[\"隐藏列的值就变成了事务\",{\"1\":{\"367\":1}}],[\"隐藏列里\",{\"1\":{\"358\":1}}],[\"隐藏列来作为隐式锁来保护记录的\",{\"1\":{\"276\":1}}],[\"隐藏字段\",{\"1\":{\"164\":1}}],[\"隐藏字段了\",{\"1\":{\"164\":1}}],[\"隐藏了真实服务器ip地址\",{\"1\":{\"22\":1}}],[\"随着不断有数据写入\",{\"1\":{\"386\":1}}],[\"随着记录在repl\",{\"1\":{\"384\":1}}],[\"随着我写\",{\"1\":{\"282\":1}}],[\"随着元素的增多\",{\"1\":{\"258\":1}}],[\"随机写\",{\"1\":{\"337\":5}}],[\"随机\",{\"1\":{\"156\":1}}],[\"降低为\",{\"1\":{\"258\":1}}],[\"降低原来单个服务器的压力\",{\"1\":{\"24\":1}}],[\"硬盘是一个非常慢的存储设备\",{\"1\":{\"258\":1}}],[\"日的节点\",{\"1\":{\"256\":1}}],[\"日所在的叶子节点\",{\"1\":{\"256\":1}}],[\"日之间的订单\",{\"1\":{\"256\":1}}],[\"日和\",{\"1\":{\"256\":1}}],[\"日志中\",{\"1\":{\"358\":1}}],[\"日志与\",{\"1\":{\"345\":1}}],[\"日志丢失的风险\",{\"1\":{\"343\":1}}],[\"日志空间大小是固定\",{\"1\":{\"341\":1}}],[\"日志只能用于归档\",{\"1\":{\"340\":1}}],[\"日志的文件名叫\",{\"1\":{\"339\":1}}],[\"日志的大小\",{\"1\":{\"179\":1,\"180\":1}}],[\"日志文件里面\",{\"1\":{\"334\":1}}],[\"日志格式要设置为\",{\"1\":{\"312\":1}}],[\"日志\",{\"0\":{\"333\":1},\"1\":{\"272\":1,\"342\":2,\"343\":1,\"349\":1,\"350\":1}}],[\"日志满了的情况下\",{\"1\":{\"179\":1}}],[\"日志让\",{\"1\":{\"179\":1}}],[\"日志页\",{\"1\":{\"155\":1}}],[\"日志篇\",{\"1\":{\"96\":1}}],[\"日志定义等绝大多数功能\",{\"1\":{\"32\":1}}],[\"月12\",{\"1\":{\"256\":1}}],[\"月\",{\"1\":{\"256\":3}}],[\"仅靠间隙锁就能避免幻读的问题\",{\"1\":{\"291\":1}}],[\"仅靠记录锁也能避免幻读的问题\",{\"1\":{\"290\":1}}],[\"仅仅进行简单的合并\",{\"1\":{\"261\":1}}],[\"仅存放索引\",{\"1\":{\"254\":1,\"258\":1}}],[\"仅用来存放目录项作为索引\",{\"1\":{\"244\":1}}],[\"或锁机制来保证的\",{\"1\":{\"352\":1}}],[\"或最小\",{\"1\":{\"253\":1}}],[\"或者在空闲时间完成对失效数据的驱逐\",{\"1\":{\"416\":1}}],[\"或者trx\",{\"1\":{\"359\":1,\"360\":1}}],[\"或者用这个\",{\"1\":{\"346\":1}}],[\"或者记录锁\",{\"1\":{\"329\":1}}],[\"或者查询语句没有走索引查询\",{\"1\":{\"299\":1}}],[\"或者有其他事务插入了一条新记录\",{\"1\":{\"290\":1}}],[\"或者是唯一索引的非唯一性前缀\",{\"1\":{\"228\":1}}],[\"或者\",{\"1\":{\"109\":1,\"182\":1,\"199\":1,\"228\":1,\"235\":1,\"241\":1,\"283\":1,\"291\":1,\"296\":3,\"313\":1,\"341\":1}}],[\"或者打了借条但没有签名\",{\"1\":{\"104\":1}}],[\"或者仅仅是为你的日常生活带来一丝灵感\",{\"1\":{\"1\":1}}],[\"走到索引为9的节点\",{\"1\":{\"252\":1}}],[\"阶\",{\"1\":{\"255\":1}}],[\"阶的\",{\"1\":{\"252\":4}}],[\"阶段队列的作用是承接\",{\"1\":{\"348\":1}}],[\"阶段队列的作用是用于支持\",{\"1\":{\"348\":1}}],[\"阶段队列的作用是用于支撑\",{\"1\":{\"348\":1}}],[\"阶段后\",{\"1\":{\"348\":1}}],[\"阶段之前\",{\"1\":{\"348\":1}}],[\"阶段之前做的\",{\"1\":{\"144\":1}}],[\"阶段之中\",{\"1\":{\"348\":1}}],[\"阶段融合在了\",{\"1\":{\"348\":1}}],[\"阶段不再让事务各自执行\",{\"1\":{\"348\":1}}],[\"阶段不变\",{\"1\":{\"348\":1}}],[\"阶段拆分为三个过程\",{\"1\":{\"348\":1}}],[\"阶段结束才能释放锁\",{\"1\":{\"347\":1}}],[\"阶段的事务\",{\"1\":{\"348\":1}}],[\"阶段的\",{\"1\":{\"346\":2,\"348\":1}}],[\"阶段和\",{\"1\":{\"344\":1}}],[\"阶段加锁分析\",{\"0\":{\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"阶段做了\",{\"1\":{\"144\":1}}],[\"阶段调用的\",{\"1\":{\"144\":1}}],[\"阶段中报错\",{\"1\":{\"144\":1}}],[\"阶段\",{\"1\":{\"143\":3,\"144\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"344\":3,\"345\":2,\"347\":1,\"348\":11,\"350\":2}}],[\"阶段维度\",{\"1\":{\"58\":1}}],[\"称为临键锁\",{\"1\":{\"287\":1,\"316\":1}}],[\"称为间隙锁\",{\"1\":{\"286\":1,\"315\":1}}],[\"称为记录锁\",{\"1\":{\"285\":1,\"314\":1}}],[\"称为嵌套查询\",{\"1\":{\"266\":1}}],[\"称为\",{\"1\":{\"252\":1}}],[\"称为流程图\",{\"1\":{\"58\":1}}],[\"越大说明数据越新\",{\"1\":{\"393\":1}}],[\"越大的时候\",{\"1\":{\"251\":1}}],[\"越小优先级越高\",{\"1\":{\"393\":2}}],[\"越靠前的字段被用于索引过滤的概率越高\",{\"1\":{\"218\":1}}],[\"叉树的高度会远小于二叉树的高度\",{\"1\":{\"251\":1}}],[\"叉树\",{\"1\":{\"251\":1}}],[\"右边界\",{\"1\":{\"291\":1}}],[\"右外连接查询的是右表的所有数据和两张表交集部分的数据\",{\"1\":{\"264\":1}}],[\"右外连接\",{\"1\":{\"261\":1,\"264\":1}}],[\"右子树的所有节点都大于这个节点\",{\"1\":{\"250\":1}}],[\"右侧节点最小\",{\"1\":{\"187\":1}}],[\"扇区的大小只有\",{\"1\":{\"248\":1}}],[\"磁盘\",{\"0\":{\"349\":1},\"1\":{\"347\":1,\"349\":1}}],[\"磁盘读写的最小单位是扇区\",{\"1\":{\"248\":1}}],[\"磁盘中读取的速度比从内存中读取的速度要慢上万倍\",{\"1\":{\"248\":1}}],[\"磁盘是一个慢的离谱的存储设备\",{\"1\":{\"248\":1}}],[\"磁盘的话不值钱\",{\"1\":{\"373\":1}}],[\"磁盘的\",{\"1\":{\"244\":1,\"337\":1}}],[\"怎样的索引的数据结构是好的\",{\"0\":{\"248\":1}}],[\"怎么变成走的是全表扫描呢\",{\"1\":{\"232\":1}}],[\"怎么解决出现\",{\"1\":{\"178\":1}}],[\"怎么解决预读失效而导致缓存命中率降低的问题\",{\"1\":{\"178\":1}}],[\"怎么解决长连接占用内存的问题\",{\"1\":{\"139\":1}}],[\"怎么知道\",{\"1\":{\"151\":1,\"169\":1}}],[\"怎么样\",{\"1\":{\"150\":1,\"250\":1}}],[\"怎么证明这些证书被\",{\"1\":{\"109\":1}}],[\"怎么把公钥安全地传输给\",{\"1\":{\"107\":1}}],[\"怎么办呢\",{\"1\":{\"109\":1}}],[\"怎么办\",{\"0\":{\"273\":1},\"1\":{\"96\":1,\"445\":1}}],[\"范围为\",{\"1\":{\"365\":1}}],[\"范围内\",{\"1\":{\"359\":2,\"360\":2}}],[\"范围是\",{\"1\":{\"280\":1,\"293\":3,\"296\":3,\"297\":1,\"298\":2}}],[\"范围\",{\"1\":{\"277\":1,\"304\":17,\"324\":1}}],[\"范围的记录\",{\"1\":{\"275\":1}}],[\"范围之间\",{\"1\":{\"244\":1}}],[\"范围查询时\",{\"1\":{\"294\":1}}],[\"范围查询和等值查询的加锁规则是不同的\",{\"1\":{\"292\":1}}],[\"范围查询效率不如\",{\"1\":{\"256\":1,\"258\":1}}],[\"范围查询有很多种\",{\"1\":{\"216\":1}}],[\"范围查询\",{\"0\":{\"256\":1},\"1\":{\"216\":1}}],[\"矮胖\",{\"1\":{\"244\":1,\"254\":1,\"258\":1}}],[\"取数据\",{\"1\":{\"416\":2}}],[\"取出该条记录的信息即为我们想要查找的内容\",{\"1\":{\"243\":1}}],[\"取消服务日志\",{\"1\":{\"32\":1}}],[\"槽号\",{\"1\":{\"244\":2}}],[\"槽内的记录就只有几条\",{\"1\":{\"243\":1}}],[\"槽\",{\"1\":{\"243\":1}}],[\"槽对应的值都是这个组的主键最大的记录\",{\"1\":{\"243\":1}}],[\"槽的中间位是\",{\"1\":{\"243\":1}}],[\"槽相当于分组记录的索引\",{\"1\":{\"243\":1}}],[\"截断的字段会被下推到存储引擎层进行条件判断\",{\"1\":{\"239\":1}}],[\"例子二的查询语句\",{\"1\":{\"238\":1}}],[\"例子二中的查询语句\",{\"1\":{\"238\":1}}],[\"例子一的查询语句\",{\"1\":{\"238\":1}}],[\"例如字符串常量池\",{\"1\":{\"517\":1}}],[\"例如新的函数\",{\"1\":{\"480\":1}}],[\"例如if\",{\"1\":{\"429\":1}}],[\"例如游戏开发\",{\"1\":{\"421\":1}}],[\"例如hashmap\",{\"1\":{\"416\":1}}],[\"例如redis\",{\"1\":{\"416\":1}}],[\"例如7002\",{\"1\":{\"410\":1}}],[\"例如key都以\",{\"1\":{\"403\":1}}],[\"例如插入数据11\",{\"1\":{\"226\":1}}],[\"例如列出解题的数学公式或联立方程式\",{\"1\":{\"58\":1}}],[\"例如在软件\",{\"1\":{\"7\":1}}],[\"例如\",{\"1\":{\"7\":1,\"41\":2,\"58\":1,\"66\":1,\"89\":1,\"224\":1,\"302\":1,\"363\":1,\"402\":1,\"428\":1,\"446\":1,\"492\":1}}],[\"周林\",{\"1\":{\"235\":1}}],[\"张林\",{\"1\":{\"235\":1}}],[\"张图\",{\"1\":{\"207\":1,\"282\":1}}],[\"张图彻底弄懂\",{\"0\":{\"101\":1}}],[\"陈林\",{\"1\":{\"235\":1}}],[\"首节点查询比较\",{\"1\":{\"235\":1}}],[\"首先是该实例与其它实例失去连接\",{\"1\":{\"410\":1}}],[\"首先是修改\",{\"1\":{\"172\":1,\"179\":1}}],[\"首先选定一个slave作为新的master\",{\"1\":{\"394\":1}}],[\"首先会判断slave节点与master节点断开时间长短\",{\"1\":{\"393\":1}}],[\"首先要记录相应的\",{\"1\":{\"336\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"首先来看看\",{\"1\":{\"302\":1,\"363\":1}}],[\"首先我们要知道\",{\"1\":{\"238\":1}}],[\"首先我们先想想数据库单表行数最大多大\",{\"1\":{\"183\":1}}],[\"首先说明下\",{\"1\":{\"234\":1}}],[\"首先\",{\"1\":{\"232\":1,\"310\":1,\"419\":1,\"447\":1}}],[\"首先看页号\",{\"1\":{\"187\":1}}],[\"首先它是一个非叶子节点\",{\"1\":{\"186\":1}}],[\"首先使用一些摘要算法\",{\"1\":{\"108\":1}}],[\"林这个字的拼音大小比首节点的第一个索引值中的陈字大\",{\"1\":{\"235\":1}}],[\"林\",{\"1\":{\"235\":6}}],[\"林某\",{\"1\":{\"234\":2}}],[\"至少还有一个从库有最新的数据\",{\"1\":{\"342\":1}}],[\"至少满足以下要求\",{\"1\":{\"248\":1}}],[\"至于为什么要加\",{\"1\":{\"278\":1}}],[\"至于为什么选择\",{\"1\":{\"234\":1}}],[\"至于是行级锁的类型是记录锁\",{\"1\":{\"278\":1}}],[\"至此我们可以先小结下\",{\"1\":{\"343\":1}}],[\"至此\",{\"1\":{\"139\":1,\"147\":1,\"148\":1,\"187\":1,\"337\":1,\"343\":1,\"350\":2}}],[\"种隔离级别\",{\"1\":{\"357\":1}}],[\"种隔离级别的支持不一样\",{\"1\":{\"357\":1}}],[\"种格式类型\",{\"1\":{\"341\":1}}],[\"种会发生索引失效的情况\",{\"1\":{\"241\":1}}],[\"种会发生索引失效的场景\",{\"1\":{\"233\":1}}],[\"种行格式\",{\"1\":{\"158\":1}}],[\"稍不注意\",{\"1\":{\"233\":1}}],[\"题目二\",{\"0\":{\"232\":1}}],[\"题目\",{\"1\":{\"231\":1,\"232\":1}}],[\"题目一很简单\",{\"1\":{\"231\":1}}],[\"题目一\",{\"0\":{\"231\":1}}],[\"属于行级别锁\",{\"1\":{\"317\":1}}],[\"属于范围查找\",{\"1\":{\"228\":1}}],[\"属性实现的\",{\"1\":{\"312\":1}}],[\"属性2\",{\"1\":{\"89\":1}}],[\"属性1\",{\"1\":{\"89\":1}}],[\"属性\",{\"1\":{\"89\":2}}],[\"属性和联系的方法\",{\"1\":{\"89\":1}}],[\"谁还没碰过索引失效呢\",{\"1\":{\"228\":1,\"230\":1}}],[\"造成存储空间的浪费\",{\"1\":{\"226\":1}}],[\"出现页分裂时\",{\"1\":{\"226\":1}}],[\"出现了半成功状态\",{\"1\":{\"344\":1}}],[\"出现了幻读现象\",{\"1\":{\"298\":1}}],[\"出现了\",{\"1\":{\"217\":1}}],[\"价格\",{\"1\":{\"225\":2,\"462\":1}}],[\"排好序的\",{\"1\":{\"219\":1}}],[\"排序\",{\"1\":{\"215\":3,\"219\":1}}],[\"筛选后的数据就是按照\",{\"1\":{\"219\":1}}],[\"惯用的百分比界线是\",{\"1\":{\"218\":1}}],[\"性别的区分度就很小\",{\"1\":{\"218\":1}}],[\"性能较差\",{\"1\":{\"416\":1}}],[\"性能要求较高\",{\"1\":{\"416\":1}}],[\"性能效率就越低\",{\"1\":{\"357\":1}}],[\"性能不佳\",{\"1\":{\"347\":1}}],[\"性能\",{\"1\":{\"337\":1}}],[\"性能会受到影响\",{\"1\":{\"226\":1}}],[\"性能没有什么差异\",{\"1\":{\"194\":1}}],[\"性能最好\",{\"0\":{\"190\":1}}],[\"性能就会急剧下降\",{\"1\":{\"178\":1}}],[\"性能高的特点\",{\"1\":{\"106\":1}}],[\"性能是其最重要的考量\",{\"1\":{\"20\":1}}],[\"除此之外\",{\"1\":{\"338\":1}}],[\"除以\",{\"1\":{\"218\":1}}],[\"除了final常量\",{\"1\":{\"492\":1}}],[\"除了上面这一种场景会发生幻读现象之外\",{\"1\":{\"368\":1}}],[\"除了上面这两条锁定读语句会加行级锁之外\",{\"1\":{\"283\":1}}],[\"除了自己的更新记录总是可见之外\",{\"1\":{\"358\":1}}],[\"除了平衡二叉查找树\",{\"1\":{\"251\":1}}],[\"除了关注\",{\"1\":{\"228\":1}}],[\"除了查询的时候磁盘\",{\"1\":{\"187\":1}}],[\"除了要把页放入到\",{\"1\":{\"178\":1}}],[\"除了能提高读性能\",{\"1\":{\"177\":1}}],[\"除了能应解锁前面这道面试题\",{\"1\":{\"151\":1}}],[\"除了缓存\",{\"1\":{\"174\":1,\"336\":1}}],[\"除了类\",{\"1\":{\"66\":1}}],[\"除了符号规划\",{\"1\":{\"57\":1}}],[\"综上所示\",{\"1\":{\"216\":1}}],[\"边界值\",{\"1\":{\"216\":3}}],[\"唯一二级索引冲突\",{\"0\":{\"280\":1},\"1\":{\"278\":1,\"280\":1}}],[\"唯一的区别就是\",{\"1\":{\"216\":1}}],[\"唯一索引加锁的流程图\",{\"1\":{\"300\":1}}],[\"唯一索引在满足一些条件的时候\",{\"1\":{\"300\":1}}],[\"唯一索引范围查询\",{\"0\":{\"292\":1}}],[\"唯一索引等值查询\",{\"0\":{\"289\":1},\"1\":{\"300\":1}}],[\"唯一索引扫描\",{\"1\":{\"228\":1}}],[\"唯一索引建立在\",{\"1\":{\"211\":1}}],[\"唯一索引\",{\"0\":{\"211\":1},\"1\":{\"203\":2,\"209\":1,\"288\":1}}],[\"∞\",{\"1\":{\"216\":1,\"280\":1,\"294\":8,\"304\":1}}],[\"局部内部类\",{\"1\":{\"490\":1}}],[\"局部相对有序的\",{\"1\":{\"215\":1}}],[\"局部性原理还是成立的\",{\"1\":{\"178\":1}}],[\"子进程读取内存数据并写入新的rdb文件\",{\"1\":{\"375\":1}}],[\"子进程共享主进程的内存数据\",{\"1\":{\"374\":1}}],[\"子查询结果为多行多列\",{\"1\":{\"261\":1}}],[\"子查询结果为一行\",{\"1\":{\"261\":1}}],[\"子查询结果为一列\",{\"1\":{\"261\":1}}],[\"子查询结果为单个值\",{\"1\":{\"261\":1}}],[\"子查询\",{\"0\":{\"266\":1},\"1\":{\"261\":1}}],[\"子节点\",{\"1\":{\"252\":1}}],[\"子句中的\",{\"0\":{\"240\":1}}],[\"子句中使用\",{\"1\":{\"228\":1}}],[\"子句中\",{\"1\":{\"228\":1,\"240\":1,\"241\":1}}],[\"子句的顺序并不重要\",{\"1\":{\"215\":1,\"239\":1}}],[\"子系统\",{\"1\":{\"73\":1}}],[\"示意图如下\",{\"1\":{\"215\":1}}],[\"示例配置文件\",{\"1\":{\"32\":1}}],[\"示例图如下\",{\"1\":{\"6\":1}}],[\"复制\",{\"0\":{\"529\":1}}],[\"复制这个id\",{\"1\":{\"408\":1}}],[\"复制成功\",{\"1\":{\"342\":1}}],[\"复制到所有从库上\",{\"1\":{\"342\":1}}],[\"复制的过程就是将\",{\"1\":{\"342\":1}}],[\"复合索引\",{\"1\":{\"214\":1}}],[\"复杂来说\",{\"1\":{\"272\":1}}],[\"复杂度\",{\"1\":{\"197\":1}}],[\"复杂系统进行建模方面\",{\"1\":{\"58\":1}}],[\"既能提升并发性\",{\"1\":{\"312\":1}}],[\"既不要求字段为主键\",{\"1\":{\"212\":1}}],[\"既然我们知道了静态代理的缺点\",{\"1\":{\"507\":1}}],[\"既然只依靠\",{\"1\":{\"340\":1}}],[\"既然备份数据库数据的时候\",{\"1\":{\"307\":1}}],[\"既然断开连接后就会释放连接占用的内存资源\",{\"1\":{\"139\":1}}],[\"既然顶级\",{\"1\":{\"109\":1}}],[\"既然是加密的\",{\"1\":{\"108\":1}}],[\"既然要加密\",{\"1\":{\"106\":1}}],[\"既然\",{\"1\":{\"106\":1}}],[\"搜索复杂度为\",{\"1\":{\"207\":1}}],[\"喜欢\",{\"1\":{\"207\":1,\"234\":1}}],[\"女朋友问我\",{\"1\":{\"207\":1}}],[\"覆盖索引是指\",{\"1\":{\"225\":1}}],[\"覆盖索引优化\",{\"0\":{\"225\":1},\"1\":{\"223\":1}}],[\"覆盖索引\",{\"1\":{\"206\":1}}],[\"商品状态\",{\"1\":{\"462\":1}}],[\"商品图片\",{\"1\":{\"462\":1}}],[\"商品标题\",{\"1\":{\"462\":1}}],[\"商品名称\",{\"1\":{\"462\":1}}],[\"商品服务完成商品修改后\",{\"1\":{\"456\":1}}],[\"商品服务完成对数据的修改后\",{\"1\":{\"456\":1}}],[\"商品详情页使用的是假的商品数据\",{\"1\":{\"434\":1}}],[\"商品到手\",{\"1\":{\"352\":1}}],[\"商品id\",{\"1\":{\"225\":1,\"462\":1}}],[\"商品编码\",{\"1\":{\"206\":2}}],[\"商品表里\",{\"1\":{\"204\":1}}],[\"辅助索引\",{\"1\":{\"203\":1,\"208\":1,\"245\":1}}],[\"形成版本链\",{\"1\":{\"359\":1}}],[\"形成的扫描区间是\",{\"1\":{\"216\":1}}],[\"形成该扫描区间的边界条件是\",{\"1\":{\"216\":1}}],[\"形成一个链表\",{\"1\":{\"204\":1}}],[\"形象的说就是索引是数据的目录\",{\"1\":{\"202\":1}}],[\"形式保存在内存中的\",{\"1\":{\"140\":1}}],[\"书中的目录\",{\"1\":{\"202\":1}}],[\"傻瓜都知道时间是宝贵的\",{\"1\":{\"202\":1}}],[\"夯实\",{\"1\":{\"201\":1}}],[\"跟钱秘书商榷好在3天后跟赵老板商谈要是\",{\"1\":{\"506\":1}}],[\"跟大家具体分析下\",{\"1\":{\"359\":1}}],[\"跟大家说一下执行器和存储引擎的交互过程\",{\"1\":{\"146\":1}}],[\"跟本文不太相关\",{\"1\":{\"345\":1}}],[\"跟是\",{\"1\":{\"278\":1}}],[\"跟\",{\"1\":{\"197\":1}}],[\"显示锁\",{\"1\":{\"280\":1}}],[\"显示的结果\",{\"1\":{\"228\":1}}],[\"显示的结果是不一样的\",{\"1\":{\"197\":1}}],[\"显式内连接\",{\"1\":{\"261\":1,\"263\":1}}],[\"显然是7004\",{\"1\":{\"408\":1}}],[\"显然是为了解决这三大风险而存在的\",{\"1\":{\"103\":1}}],[\"显然\",{\"1\":{\"338\":1}}],[\"显然不是什么阿猫阿狗的本本都可称为学历\",{\"1\":{\"108\":1}}],[\"翻译\",{\"1\":{\"194\":1,\"302\":1,\"363\":1}}],[\"高并发写的问题\",{\"1\":{\"400\":1}}],[\"高并发读的问题\",{\"1\":{\"400\":1}}],[\"高\",{\"1\":{\"338\":1}}],[\"高效的多\",{\"1\":{\"337\":1}}],[\"高效定位数据\",{\"1\":{\"249\":1}}],[\"高出不少\",{\"1\":{\"207\":1}}],[\"高一点\",{\"1\":{\"193\":1}}],[\"高级调度\",{\"1\":{\"134\":1}}],[\"高级共享方式\",{\"1\":{\"122\":1}}],[\"高级篇\",{\"1\":{\"97\":1}}],[\"少\",{\"1\":{\"526\":2}}],[\"少一个步骤\",{\"1\":{\"193\":1}}],[\"少量的增加\",{\"1\":{\"182\":1}}],[\"成员内部类\",{\"1\":{\"490\":1}}],[\"成员\",{\"1\":{\"490\":1}}],[\"成本太高了\",{\"1\":{\"385\":1}}],[\"成本小\",{\"1\":{\"192\":1}}],[\"成本比遍历聚簇索引的\",{\"1\":{\"192\":1}}],[\"成为了\",{\"1\":{\"138\":1}}],[\"聚簇索引记录中两个跟事务有关的隐藏列\",{\"1\":{\"358\":1}}],[\"聚簇索引和二级索引\",{\"0\":{\"245\":1}}],[\"聚簇索引\",{\"1\":{\"203\":1,\"234\":4}}],[\"聚簇索引的叶子节点存放的是实际数据\",{\"1\":{\"192\":1,\"234\":1,\"245\":1,\"257\":1}}],[\"聚合关系是关联关系的一种\",{\"1\":{\"66\":1}}],[\"聚合关系\",{\"1\":{\"66\":1}}],[\"变成了\",{\"1\":{\"337\":2}}],[\"变成\",{\"1\":{\"237\":1}}],[\"变量和循环\",{\"0\":{\"423\":1}}],[\"变量\",{\"1\":{\"197\":1}}],[\"变量加\",{\"1\":{\"192\":1,\"193\":1}}],[\"变量的值发送给客户端\",{\"1\":{\"192\":1}}],[\"变长字段长度\",{\"1\":{\"166\":6}}],[\"变长字段长度列表\",{\"0\":{\"161\":1},\"1\":{\"160\":1,\"161\":11,\"166\":7,\"169\":1}}],[\"变长字段字节数列表所占用的字节数\",{\"1\":{\"167\":1,\"169\":3}}],[\"变长字段字节数列表\",{\"1\":{\"161\":1}}],[\"变长字段的真实数据占用的字节数\",{\"1\":{\"161\":1}}],[\"变长字段实际存储的数据的长度\",{\"1\":{\"161\":1}}],[\"哪些记录可以被覆盖的过程\",{\"1\":{\"339\":1}}],[\"哪些记录可以被擦除\",{\"1\":{\"339\":1}}],[\"哪些范围的\",{\"1\":{\"296\":2}}],[\"哪个记录分组\",{\"1\":{\"243\":1,\"244\":1}}],[\"哪个性能最好\",{\"0\":{\"189\":1},\"1\":{\"96\":1}}],[\"哪一个字段用到了联合索引的\",{\"1\":{\"216\":4}}],[\"哪种\",{\"0\":{\"190\":1}}],[\"习惯都会使用\",{\"1\":{\"189\":1}}],[\"足够的情况下\",{\"1\":{\"187\":1}}],[\"近似值\",{\"0\":{\"199\":1}}],[\"近\",{\"1\":{\"187\":1}}],[\"近年来各大公司对信息安全传输越来越重视\",{\"1\":{\"102\":1}}],[\"百多亿吧\",{\"1\":{\"187\":1}}],[\"嘛\",{\"1\":{\"187\":1}}],[\"妈呀\",{\"1\":{\"187\":1}}],[\"哎呀\",{\"1\":{\"187\":1}}],[\"约束\",{\"1\":{\"227\":1}}],[\"约\",{\"1\":{\"187\":1}}],[\"算到这边了\",{\"1\":{\"187\":1}}],[\"算法通常是将最近查询的数据放到\",{\"1\":{\"180\":1}}],[\"算法无法避免下面这两个问题\",{\"1\":{\"178\":1}}],[\"算法并没有被\",{\"1\":{\"178\":1}}],[\"算法的实现思路是这样的\",{\"1\":{\"178\":1}}],[\"算法\",{\"1\":{\"58\":1,\"178\":3}}],[\"≈15\",{\"1\":{\"187\":1}}],[\"条行记录\",{\"1\":{\"302\":4,\"303\":1,\"363\":4}}],[\"条之间\",{\"1\":{\"243\":2}}],[\"条记录\",{\"1\":{\"197\":1,\"243\":1,\"274\":1,\"356\":1,\"368\":2}}],[\"条数据\",{\"1\":{\"187\":1}}],[\"条\",{\"1\":{\"187\":1,\"356\":2}}],[\"条件控制\",{\"0\":{\"427\":1,\"429\":1}}],[\"条件带上了索引列\",{\"1\":{\"330\":1}}],[\"条件中的\",{\"1\":{\"333\":1}}],[\"条件中带上了索引列\",{\"1\":{\"331\":2}}],[\"条件中可以没有索引列\",{\"1\":{\"330\":2}}],[\"条件中必须有索引列\",{\"1\":{\"330\":1}}],[\"条件使用了唯一索引\",{\"1\":{\"329\":1}}],[\"条件没有索引列\",{\"1\":{\"329\":1}}],[\"条件没有使用索引\",{\"1\":{\"329\":1}}],[\"条件没有带上索引列\",{\"1\":{\"331\":1}}],[\"条件没有带上索引\",{\"1\":{\"328\":1}}],[\"条件没有用到索引列\",{\"1\":{\"275\":1}}],[\"条件减少需要扫描的二级索引记录范围\",{\"1\":{\"216\":2}}],[\"条件位置\",{\"1\":{\"216\":2}}],[\"条件的记录\",{\"1\":{\"294\":3}}],[\"条件的唯一索引范围查询的情况下\",{\"1\":{\"293\":1}}],[\"条件的范围查询\",{\"1\":{\"292\":3,\"294\":3}}],[\"条件的二级索引记录的范围里\",{\"1\":{\"216\":2}}],[\"条件的二级索引记录肯定是相邻\",{\"1\":{\"216\":2}}],[\"条件的第一条记录时开始扫描\",{\"1\":{\"216\":1}}],[\"条件的第一条记录开始扫描\",{\"1\":{\"216\":1}}],[\"条件的第一条记录\",{\"1\":{\"216\":2}}],[\"条件语句之后\",{\"1\":{\"197\":1}}],[\"条件\",{\"1\":{\"182\":1,\"222\":1,\"294\":2}}],[\"条件二\",{\"1\":{\"166\":1}}],[\"条件一\",{\"1\":{\"166\":1}}],[\"条件等等\",{\"1\":{\"142\":1}}],[\"叶子节点之间构成一个有序链表\",{\"1\":{\"253\":1}}],[\"叶子节点\",{\"1\":{\"253\":1}}],[\"叶子节点仅存放主键值\",{\"1\":{\"234\":1}}],[\"叶子节点采用的是双链表连接\",{\"1\":{\"207\":1}}],[\"叶子节点存储的数据是主键值\",{\"1\":{\"206\":1}}],[\"叶子节点存放的是实际的行数据\",{\"1\":{\"188\":1}}],[\"叶子节点才存放数据\",{\"1\":{\"204\":1}}],[\"叶子节点和非叶子节点的数据结构是一样的\",{\"1\":{\"188\":1}}],[\"叶子节点和非叶子节点的结构是一样的\",{\"1\":{\"187\":1}}],[\"叶子节点内能容纳的数据行数为\",{\"1\":{\"187\":1}}],[\"剩下的就是\",{\"1\":{\"343\":1}}],[\"剩下的分组中记录条数范围只能在\",{\"1\":{\"243\":1}}],[\"剩下\",{\"1\":{\"187\":1}}],[\"肯定需要有缓存的清除策略\",{\"1\":{\"416\":1}}],[\"肯定无法走索引\",{\"1\":{\"239\":1}}],[\"肯定就往右侧节点继续查找\",{\"1\":{\"187\":1}}],[\"肯定是程序有\",{\"1\":{\"46\":1}}],[\"假如我们需要查找一条记录\",{\"1\":{\"185\":1}}],[\"假设你要\",{\"1\":{\"365\":1}}],[\"假设在账户余额表插入一条小林余额为\",{\"1\":{\"358\":1}}],[\"假设在执行第三步骤之后\",{\"1\":{\"351\":1}}],[\"假设我向你转账\",{\"1\":{\"351\":1}}],[\"假设我们在上图一棵\",{\"1\":{\"252\":1}}],[\"假设我们现在用数组来存储索引\",{\"1\":{\"249\":1}}],[\"假设我们要查询\",{\"1\":{\"235\":1}}],[\"假设我们只需要查询商品的名称\",{\"1\":{\"225\":1}}],[\"假设每个\",{\"1\":{\"339\":1}}],[\"假设有\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"假设有两个事务的执行顺序如下\",{\"1\":{\"329\":2}}],[\"假设有一个长度为\",{\"1\":{\"178\":1}}],[\"假设除了\",{\"1\":{\"319\":1}}],[\"假设不加全局锁的场景\",{\"1\":{\"307\":1}}],[\"假设一个事务在\",{\"1\":{\"302\":1,\"363\":1}}],[\"假设一个节点的大小\",{\"1\":{\"250\":1}}],[\"假设事务\",{\"1\":{\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"317\":1,\"359\":1,\"360\":1}}],[\"假设这时有两事务\",{\"1\":{\"274\":1}}],[\"假设某个数据页中的数据是1\",{\"1\":{\"226\":1}}],[\"假设字段的值分布均匀\",{\"1\":{\"218\":1}}],[\"假设表\",{\"1\":{\"197\":1}}],[\"假设需要批量扫描\",{\"1\":{\"178\":1}}],[\"假设\",{\"1\":{\"178\":1,\"187\":3,\"191\":1,\"250\":1,\"252\":1,\"286\":1,\"287\":1,\"315\":1,\"316\":1,\"344\":1,\"365\":1}}],[\"假设执行了这条查询语句\",{\"1\":{\"145\":1}}],[\"按泊松分布\",{\"1\":{\"473\":1}}],[\"按顺序执行了以下操作\",{\"1\":{\"359\":1}}],[\"按顺序存放的\",{\"1\":{\"296\":1}}],[\"按隔离水平高低排序如下\",{\"1\":{\"357\":1}}],[\"按组的方式\",{\"1\":{\"338\":1}}],[\"按ascii码\",{\"1\":{\"238\":1}}],[\"按字段个数分类\",{\"0\":{\"214\":1}}],[\"按字段特性分类\",{\"0\":{\"209\":1}}],[\"按物理存储分类\",{\"0\":{\"208\":1}}],[\"按数据结构分类\",{\"0\":{\"204\":1}}],[\"按照顺序一页一页写肯定比写一个字都要找到对应页写快得多\",{\"1\":{\"337\":1}}],[\"按照题目的\",{\"1\":{\"320\":1}}],[\"按照位置\",{\"1\":{\"261\":1}}],[\"按照查询结果\",{\"1\":{\"261\":1}}],[\"按照这些角度来说说各类索引的特点\",{\"1\":{\"203\":1}}],[\"按照一秒新增一条记录的速度\",{\"1\":{\"183\":1}}],[\"按\",{\"1\":{\"203\":4}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"41\":1}}],[\"亿\",{\"1\":{\"183\":1}}],[\"亿图图示\",{\"1\":{\"70\":1}}],[\"亿图图示官方\",{\"1\":{\"52\":1}}],[\"难以想象这个的多大了\",{\"1\":{\"183\":1}}],[\"难道这就是铁律吗\",{\"1\":{\"182\":1}}],[\"难怪查询速度慢\",{\"1\":{\"181\":1}}],[\"某天\",{\"1\":{\"506\":1}}],[\"某天发现了一个线上bug\",{\"1\":{\"10\":1}}],[\"某一个值去控制增加的数据量即可\",{\"1\":{\"182\":1}}],[\"次刷盘操作\",{\"1\":{\"347\":1}}],[\"次的磁盘\",{\"1\":{\"207\":1}}],[\"次数会很高\",{\"1\":{\"347\":1}}],[\"次数会增加\",{\"1\":{\"187\":1}}],[\"次数高\",{\"1\":{\"347\":1}}],[\"次数\",{\"1\":{\"252\":1}}],[\"次数越多\",{\"1\":{\"248\":1}}],[\"次数更少\",{\"1\":{\"244\":1}}],[\"次数要更多\",{\"1\":{\"207\":1}}],[\"次数下\",{\"1\":{\"207\":1}}],[\"次磁盘\",{\"1\":{\"205\":1,\"252\":1}}],[\"次方\",{\"1\":{\"187\":1}}],[\"次方约等于\",{\"1\":{\"182\":2}}],[\"次就是\",{\"1\":{\"182\":1}}],[\"次\",{\"1\":{\"182\":1,\"205\":1,\"243\":1,\"251\":1}}],[\"伪列\",{\"1\":{\"182\":1}}],[\"利用反射+策略模式去除过多的if\",{\"0\":{\"508\":1}}],[\"利用docker安装redis\",{\"1\":{\"448\":1}}],[\"利用刚刚封装的函数库实现对tomcat的查询\",{\"1\":{\"442\":1}}],[\"利用正则表达式获取id\",{\"1\":{\"439\":1}}],[\"利用ngx\",{\"1\":{\"436\":1}}],[\"利用caffeine实现下列需求\",{\"1\":{\"418\":1}}],[\"利用cluster\",{\"1\":{\"411\":1}}],[\"利用gc来回收缓存数据\",{\"1\":{\"416\":1}}],[\"利用redis\",{\"1\":{\"411\":1}}],[\"利用它的唯一性来保证订单表不会出现重复的订单\",{\"1\":{\"281\":1}}],[\"利用索引的前提是索引里的\",{\"1\":{\"215\":1}}],[\"利用\",{\"1\":{\"182\":1}}],[\"利用了回滚段实现了多版本查询数据\",{\"1\":{\"157\":1}}],[\"原理简单\",{\"1\":{\"516\":1}}],[\"原理\",{\"0\":{\"446\":1},\"1\":{\"517\":1}}],[\"原理如图\",{\"1\":{\"441\":1}}],[\"原生的\",{\"1\":{\"352\":1}}],[\"原子性是通过\",{\"1\":{\"352\":1}}],[\"原子性\",{\"1\":{\"269\":1,\"272\":1,\"352\":1}}],[\"原因就是在唯一索引等值查询并且查询记录不存在的场景下\",{\"1\":{\"291\":1}}],[\"原因就是在唯一索引等值查询并且查询记录存在的场景下\",{\"1\":{\"290\":1}}],[\"原因有两个\",{\"1\":{\"342\":1}}],[\"原因有\",{\"1\":{\"258\":1}}],[\"原因是\",{\"1\":{\"239\":1}}],[\"原因跟对索引使用函数差不多\",{\"1\":{\"237\":1}}],[\"原文链接\",{\"1\":{\"181\":1}}],[\"原本在\",{\"1\":{\"178\":1}}],[\"原本\",{\"1\":{\"178\":1}}],[\"码试试\",{\"1\":{\"181\":1}}],[\"码\",{\"1\":{\"181\":1}}],[\"群里只讨论技术\",{\"1\":{\"181\":1}}],[\"阈值也可以在redis\",{\"1\":{\"379\":1}}],[\"阈值\",{\"1\":{\"180\":1}}],[\"点击done\",{\"1\":{\"408\":1}}],[\"点击前往查看最新动态\",{\"1\":{\"98\":1}}],[\"点优化\",{\"1\":{\"180\":1}}],[\"偶尔\",{\"1\":{\"179\":1,\"180\":1}}],[\"监控\",{\"1\":{\"391\":1,\"394\":1}}],[\"监控后\",{\"1\":{\"179\":1,\"180\":1}}],[\"监听canal消息\",{\"1\":{\"463\":1}}],[\"监听canal通知消息\",{\"1\":{\"459\":1}}],[\"监听canal\",{\"0\":{\"459\":1}}],[\"监听\",{\"1\":{\"435\":1}}],[\"监听地址\",{\"1\":{\"32\":1,\"38\":1}}],[\"监听端口\",{\"1\":{\"32\":1}}],[\"拥有了崩溃恢复能力\",{\"1\":{\"179\":1}}],[\"宕机了\",{\"1\":{\"179\":1}}],[\"针对不同的隔离级别\",{\"1\":{\"357\":1}}],[\"针对参数\",{\"1\":{\"338\":2}}],[\"针对为什么需要\",{\"1\":{\"337\":1}}],[\"针对每一条\",{\"1\":{\"321\":1}}],[\"针对当前读的语句会对索引加记录锁+间隙锁\",{\"1\":{\"305\":1}}],[\"针对当前读\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1,\"369\":1}}],[\"针对快照读\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1,\"369\":1}}],[\"针对是否可以插入\",{\"1\":{\"297\":2}}],[\"针对非唯一索引等值查询时\",{\"1\":{\"295\":1,\"296\":1,\"297\":1}}],[\"针对书中内容的每个章节设立了一个目录\",{\"1\":{\"243\":1}}],[\"针对题目\",{\"1\":{\"232\":1}}],[\"针对针对下面这条\",{\"1\":{\"219\":1}}],[\"针对\",{\"0\":{\"293\":1,\"294\":1},\"1\":{\"178\":1,\"292\":2,\"293\":3,\"294\":3,\"337\":1}}],[\"针对交互在某特定时刻各对象的状态\",{\"1\":{\"72\":1}}],[\"与你一起成长\",{\"1\":{\"508\":1}}],[\"与某个秘书进行商谈\",{\"1\":{\"507\":1}}],[\"与动态语言相对应的\",{\"1\":{\"480\":1}}],[\"与springboot完美整合\",{\"1\":{\"459\":1}}],[\"与java不同\",{\"1\":{\"429\":1}}],[\"与哨兵模式相比\",{\"1\":{\"412\":1}}],[\"与master建立连接时\",{\"1\":{\"384\":1}}],[\"与时刻\",{\"1\":{\"346\":1}}],[\"与主库的值不一致性\",{\"1\":{\"344\":2}}],[\"与根节点的索引\",{\"1\":{\"252\":1}}],[\"与根节点的索引数据\",{\"1\":{\"205\":1}}],[\"与\",{\"1\":{\"178\":1,\"187\":1,\"216\":1}}],[\"与客户端进行\",{\"1\":{\"139\":1}}],[\"像前面这种全表扫描的查询\",{\"1\":{\"178\":1}}],[\"立即通知缓存服务\",{\"1\":{\"456\":1}}],[\"立即记录到aof文件\",{\"1\":{\"378\":1}}],[\"立即使用此location处理请求\",{\"1\":{\"39\":1}}],[\"立刻被访问了\",{\"1\":{\"178\":1}}],[\"给堆内存腾出相应的空间\",{\"1\":{\"527\":1}}],[\"给方法形参赋值的实参\",{\"1\":{\"502\":1}}],[\"给缓存设置有效期\",{\"1\":{\"456\":1}}],[\"给根据id查询商品库存的业务添加缓存\",{\"1\":{\"418\":1}}],[\"给根据id查询商品的业务添加缓存\",{\"1\":{\"418\":1}}],[\"给7004节点分配插槽\",{\"1\":{\"405\":1}}],[\"给用户\",{\"1\":{\"352\":1}}],[\"给\",{\"1\":{\"343\":1}}],[\"给大家展示下这两种存储引擎的索引存储结构的区别\",{\"1\":{\"234\":1}}],[\"给大家举个例子\",{\"1\":{\"178\":1}}],[\"给出的搜索结果条数是一个大概值\",{\"1\":{\"199\":1}}],[\"给客户端\",{\"1\":{\"140\":1}}],[\"划分这三种情况\",{\"1\":{\"358\":1}}],[\"划分这两个区域后\",{\"1\":{\"178\":1}}],[\"划分了\",{\"1\":{\"178\":1}}],[\"靠近当前被访问数据的数据\",{\"1\":{\"178\":1}}],[\"靠谱吗\",{\"0\":{\"181\":1},\"1\":{\"96\":1}}],[\"污染而导致缓存命中率下降的问题\",{\"1\":{\"178\":1}}],[\"污染并不只是查询语句查询出了大量的数据才出现的问题\",{\"1\":{\"178\":1}}],[\"污染的问题\",{\"1\":{\"178\":3}}],[\"污染\",{\"1\":{\"178\":4}}],[\"预读的页就只需要加入到\",{\"1\":{\"178\":1}}],[\"预读失效\",{\"1\":{\"178\":1}}],[\"预处理阶段\",{\"1\":{\"150\":1}}],[\"预处理器会判断表和字段是否存在\",{\"1\":{\"333\":1}}],[\"预处理器\",{\"0\":{\"144\":1},\"1\":{\"138\":1}}],[\"已有的函数可以被删除或是其他结构上的变化\",{\"1\":{\"480\":1}}],[\"已有的记录的主键或者唯一二级索引列值相同\",{\"1\":{\"278\":1}}],[\"已经提交的事务生成的\",{\"1\":{\"358\":1}}],[\"已经被持久化磁盘了\",{\"1\":{\"346\":1}}],[\"已经被修改\",{\"1\":{\"178\":1}}],[\"已经写入了\",{\"1\":{\"346\":1}}],[\"已经写入\",{\"1\":{\"346\":1}}],[\"已经\",{\"1\":{\"346\":1}}],[\"已经刷入磁盘的数据都会从\",{\"1\":{\"341\":1}}],[\"已经持久化\",{\"1\":{\"337\":1}}],[\"已经对表加了一个范围\",{\"1\":{\"317\":1}}],[\"已经插入\",{\"1\":{\"280\":1}}],[\"已经存在\",{\"1\":{\"270\":1}}],[\"已删除\",{\"1\":{\"243\":1}}],[\"已删除该模块\",{\"1\":{\"150\":1}}],[\"已知\",{\"1\":{\"187\":1}}],[\"已被使用\",{\"1\":{\"178\":1}}],[\"干到\",{\"1\":{\"181\":1}}],[\"干净页\",{\"1\":{\"178\":1}}],[\"干货\",{\"1\":{\"70\":1}}],[\"到期后自动删除\",{\"1\":{\"456\":1}}],[\"到windows的java服务\",{\"1\":{\"442\":1}}],[\"到了7003后\",{\"1\":{\"402\":1}}],[\"到磁盘\",{\"1\":{\"338\":1}}],[\"到备库执行的时候\",{\"1\":{\"312\":1}}],[\"到主键索引读取数据行\",{\"1\":{\"239\":1}}],[\"到\",{\"1\":{\"217\":1}}],[\"到这里难道就完了\",{\"1\":{\"187\":1}}],[\"到这里我们可以知道\",{\"1\":{\"178\":1}}],[\"到底是个什么东西\",{\"1\":{\"358\":1}}],[\"到底是哪一张表的字段\",{\"1\":{\"265\":1}}],[\"到底是它是如何确保信息安全传输的\",{\"1\":{\"102\":1}}],[\"到底哪种效率是最好的呢\",{\"1\":{\"189\":1}}],[\"到底解决了什么问题\",{\"1\":{\"103\":1}}],[\"号槽里\",{\"1\":{\"243\":1}}],[\"号槽里最大的记录为\",{\"1\":{\"243\":1}}],[\"号槽后继续搜索记录\",{\"1\":{\"243\":1}}],[\"号和\",{\"1\":{\"243\":1}}],[\"号为\",{\"1\":{\"205\":1}}],[\"号页都被淘汰了\",{\"1\":{\"178\":1}}],[\"号页被预读后\",{\"1\":{\"178\":1}}],[\"号页一直不会被访问\",{\"1\":{\"178\":1}}],[\"号页加入到头部\",{\"1\":{\"178\":1}}],[\"号页不在\",{\"1\":{\"178\":1}}],[\"号页\",{\"1\":{\"178\":2}}],[\"号页移动到头部即可\",{\"1\":{\"178\":1}}],[\"号页在\",{\"1\":{\"178\":1}}],[\"号的页\",{\"1\":{\"178\":1}}],[\"尾节点地址\",{\"1\":{\"176\":1}}],[\"控制块\",{\"1\":{\"176\":1}}],[\"控制块也是占有内存空间的\",{\"1\":{\"174\":1}}],[\"控制块信息包括\",{\"1\":{\"174\":1}}],[\"控制的\",{\"1\":{\"152\":1,\"178\":1}}],[\"锁粒度减小了\",{\"1\":{\"348\":1}}],[\"锁就只针对每个队列进行保护\",{\"1\":{\"348\":1}}],[\"锁就会被释放\",{\"1\":{\"275\":1,\"283\":1,\"313\":1}}],[\"锁来保证事务提交的顺序\",{\"1\":{\"347\":1}}],[\"锁竞争激烈\",{\"1\":{\"347\":1}}],[\"锁再对大量数据进行插入的时候\",{\"1\":{\"312\":1}}],[\"锁实现的\",{\"1\":{\"312\":1}}],[\"锁住\",{\"1\":{\"304\":13}}],[\"锁住的范围的右边界值\",{\"1\":{\"296\":1}}],[\"锁住的范围是\",{\"1\":{\"290\":1,\"291\":1}}],[\"锁住的是一条记录\",{\"1\":{\"285\":1,\"314\":1}}],[\"锁住的就是一个点\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"锁是特殊的表锁机制\",{\"1\":{\"312\":1}}],[\"锁是在遍历索引的时候加上的\",{\"1\":{\"304\":1}}],[\"锁是加在索引上的而非行上\",{\"1\":{\"329\":1}}],[\"锁是加在索引上的\",{\"1\":{\"291\":1}}],[\"锁范围内插入了一条记录\",{\"1\":{\"302\":1,\"361\":1,\"362\":1}}],[\"锁范围是\",{\"1\":{\"275\":1,\"277\":1,\"294\":1,\"322\":1}}],[\"锁退化为记录锁\",{\"1\":{\"298\":1}}],[\"锁会\",{\"1\":{\"297\":1}}],[\"锁会退化成间隙锁的\",{\"1\":{\"294\":1}}],[\"锁会退化成间隙锁\",{\"1\":{\"292\":2,\"294\":3,\"295\":2,\"296\":1,\"300\":2}}],[\"锁会退化成记录锁\",{\"1\":{\"292\":1,\"293\":2,\"329\":1}}],[\"锁不是再一个事务提交后才释放\",{\"1\":{\"312\":1}}],[\"锁不会退化成间隙锁\",{\"1\":{\"292\":1}}],[\"锁不兼容\",{\"1\":{\"285\":3,\"314\":3}}],[\"锁之间是互斥关系\",{\"1\":{\"290\":1}}],[\"锁之分的\",{\"1\":{\"285\":1,\"314\":1}}],[\"锁兼容\",{\"1\":{\"285\":1,\"314\":1}}],[\"锁和间隙锁\",{\"1\":{\"296\":1}}],[\"锁和\",{\"1\":{\"285\":1,\"290\":1,\"314\":1}}],[\"锁定一个范围\",{\"1\":{\"284\":2,\"287\":1,\"313\":2,\"316\":1}}],[\"锁相关的文章越来越多时\",{\"1\":{\"282\":1}}],[\"锁时会遇到锁冲突\",{\"1\":{\"280\":1}}],[\"锁或者间隙锁\",{\"1\":{\"275\":1,\"291\":1,\"304\":1,\"322\":1}}],[\"锁释放掉\",{\"1\":{\"312\":1}}],[\"锁释放\",{\"1\":{\"275\":2}}],[\"锁的过程中\",{\"1\":{\"312\":1}}],[\"锁的操作会形成一个队列\",{\"1\":{\"310\":1}}],[\"锁的话\",{\"1\":{\"297\":1}}],[\"锁的状态是等待状态\",{\"1\":{\"277\":1}}],[\"锁的范围是\",{\"1\":{\"304\":1}}],[\"锁的范围\",{\"1\":{\"275\":3,\"304\":1}}],[\"锁的加锁规则其实挺复杂的\",{\"1\":{\"275\":1}}],[\"锁的就是两个值之间的空隙\",{\"1\":{\"275\":1}}],[\"锁的是记录本身\",{\"1\":{\"275\":1}}],[\"锁\",{\"0\":{\"312\":1},\"1\":{\"275\":6,\"277\":2,\"278\":4,\"280\":5,\"282\":1,\"290\":2,\"292\":4,\"293\":12,\"294\":19,\"295\":1,\"297\":6,\"298\":7,\"299\":3,\"300\":2,\"304\":14,\"305\":1,\"308\":1,\"312\":3,\"322\":2,\"329\":5,\"361\":1}}],[\"锁信息等等\",{\"1\":{\"174\":1,\"336\":1}}],[\"锁篇\",{\"1\":{\"96\":1}}],[\"刚才的代码中\",{\"1\":{\"445\":1}}],[\"刚才得到的数据就是过期的数据\",{\"1\":{\"354\":1}}],[\"刚刚上面说到了数据的新增的过程\",{\"1\":{\"185\":1}}],[\"刚启动的时候\",{\"1\":{\"174\":1,\"336\":1}}],[\"刚好这个表有更新操作\",{\"1\":{\"140\":1}}],[\"且事务的隔离级别是可重复读\",{\"1\":{\"328\":1}}],[\"且表中存在\",{\"1\":{\"297\":1}}],[\"且表中不存在\",{\"1\":{\"296\":1}}],[\"且查询条件值的记录\",{\"1\":{\"294\":1}}],[\"且锁的类型都是独占锁\",{\"1\":{\"283\":1}}],[\"且锁类型为\",{\"1\":{\"280\":1}}],[\"且功能相同\",{\"1\":{\"275\":1,\"323\":1}}],[\"且由于数据在物理上只会保存一份\",{\"1\":{\"245\":1,\"257\":1}}],[\"且主键值是有序的\",{\"1\":{\"244\":1,\"246\":1}}],[\"且数据页满了\",{\"1\":{\"226\":1}}],[\"且不为\",{\"1\":{\"216\":2}}],[\"且\",{\"1\":{\"178\":1,\"180\":1,\"228\":1,\"402\":1}}],[\"且允许为\",{\"1\":{\"169\":1}}],[\"且是默认使用\",{\"1\":{\"138\":1}}],[\"溢出的数据会存放到\",{\"1\":{\"168\":1}}],[\"溢出页\",{\"1\":{\"168\":4,\"169\":2}}],[\"溢出页等等\",{\"1\":{\"155\":1}}],[\"情况下更安全\",{\"1\":{\"338\":1}}],[\"情况二\",{\"1\":{\"292\":1}}],[\"情况一\",{\"1\":{\"292\":1}}],[\"情况\",{\"1\":{\"166\":1}}],[\"创建虚引用\",{\"1\":{\"522\":1}}],[\"创建对应的运行时类的对象\",{\"1\":{\"498\":1}}],[\"创建运行时类的对象\",{\"0\":{\"498\":1},\"1\":{\"498\":1,\"501\":1,\"502\":1}}],[\"创建xxx对象\",{\"1\":{\"489\":1}}],[\"创建类的对象的方式\",{\"0\":{\"489\":1}}],[\"创建class对应运行时类的对象时需要注意什么\",{\"1\":{\"478\":1}}],[\"创建缓存对象\",{\"1\":{\"416\":2}}],[\"创建一个文件夹\",{\"1\":{\"406\":1}}],[\"创建新的redis实例\",{\"0\":{\"406\":1}}],[\"创建\",{\"1\":{\"360\":3}}],[\"创建联合索引时\",{\"1\":{\"239\":1}}],[\"创建联合索引的方式如下\",{\"1\":{\"215\":1}}],[\"创建的主键索引默认使用的是\",{\"1\":{\"234\":1}}],[\"创建的主键索引和二级索引默认使用的是\",{\"1\":{\"204\":1}}],[\"创建主键索引默认为聚簇索引\",{\"1\":{\"226\":1}}],[\"创建主键索引的方式如下\",{\"1\":{\"210\":1}}],[\"创建索引和维护索引要耗费时间\",{\"1\":{\"220\":1}}],[\"创建前缀索引的方式如下\",{\"1\":{\"213\":1}}],[\"创建普通索引的方式如下\",{\"1\":{\"212\":1}}],[\"创建唯一索引的方式如下\",{\"1\":{\"211\":1}}],[\"创建时间\",{\"1\":{\"182\":1,\"183\":1,\"462\":1}}],[\"创建成功了\",{\"1\":{\"166\":1}}],[\"创建失败了\",{\"1\":{\"166\":1}}],[\"符合查询条件\",{\"1\":{\"297\":1}}],[\"符合最左匹配吗\",{\"1\":{\"239\":1}}],[\"符合条件二\",{\"1\":{\"166\":1}}],[\"符号扩展为表上的所有列\",{\"1\":{\"150\":1}}],[\"符号\",{\"1\":{\"144\":1}}],[\"符号大小需要保持一致\",{\"1\":{\"57\":1}}],[\"符号规范\",{\"0\":{\"55\":1}}],[\"限制一个master上的slave节点数量\",{\"1\":{\"387\":1}}],[\"限制最大为\",{\"1\":{\"165\":1}}],[\"限制多\",{\"1\":{\"122\":1}}],[\"机制来实现主从集群的自动故障恢复\",{\"1\":{\"389\":1}}],[\"机制\",{\"1\":{\"164\":2,\"348\":1}}],[\"机密性\",{\"1\":{\"104\":2}}],[\"位于lru\",{\"1\":{\"178\":1}}],[\"位于\",{\"1\":{\"178\":1}}],[\"位\",{\"1\":{\"162\":1,\"183\":1}}],[\"吗\",{\"1\":{\"161\":1,\"162\":1,\"166\":1,\"337\":1}}],[\"十六进制\",{\"1\":{\"161\":2}}],[\"真正的执行更新记录的操作\",{\"1\":{\"343\":1,\"350\":1}}],[\"真实数据占用的字节数\",{\"1\":{\"166\":1}}],[\"真实数据占用的字节数是\",{\"1\":{\"161\":2}}],[\"真实数据\",{\"1\":{\"161\":1,\"163\":1,\"166\":1}}],[\"真的挺瘦的\",{\"1\":{\"95\":1}}],[\"`score`\",{\"1\":{\"319\":1}}],[\"`no`\",{\"1\":{\"319\":1}}],[\"`name`\",{\"1\":{\"161\":1,\"166\":1,\"204\":1,\"288\":1,\"319\":1}}],[\"`user`\",{\"1\":{\"288\":1}}],[\"`index\",{\"1\":{\"274\":1,\"288\":1}}],[\"`id`\",{\"1\":{\"161\":2,\"204\":2,\"274\":2,\"288\":2,\"319\":2}}],[\"`create\",{\"1\":{\"274\":1}}],[\"`order\",{\"1\":{\"274\":2}}],[\"`age`\",{\"1\":{\"161\":1,\"288\":2,\"319\":1}}],[\"`price`\",{\"1\":{\"204\":1}}],[\"`product\",{\"1\":{\"204\":1}}],[\"`product`\",{\"1\":{\"204\":1}}],[\"`phone`\",{\"1\":{\"161\":1}}],[\"`ps\",{\"1\":{\"43\":1}}],[\"`t\",{\"1\":{\"161\":1,\"274\":1,\"319\":1}}],[\"弄懂了\",{\"1\":{\"158\":1}}],[\"差不多\",{\"1\":{\"158\":1,\"228\":1}}],[\"回收没有延迟性\",{\"1\":{\"516\":1}}],[\"回答没有准备好\",{\"1\":{\"344\":1}}],[\"回放\",{\"1\":{\"342\":2}}],[\"回滚事务\",{\"1\":{\"334\":1,\"337\":1}}],[\"回滚日志\",{\"1\":{\"333\":2,\"334\":1,\"352\":1}}],[\"回滚段\",{\"1\":{\"157\":1}}],[\"回表\",{\"1\":{\"206\":2,\"245\":1,\"246\":1}}],[\"回到前面死锁的例子\",{\"1\":{\"275\":1}}],[\"回到\",{\"1\":{\"108\":1}}],[\"段一般分为数据段\",{\"1\":{\"157\":1}}],[\"段是由多个区\",{\"1\":{\"157\":1}}],[\"段\",{\"0\":{\"157\":1},\"1\":{\"272\":2}}],[\"总共\",{\"1\":{\"352\":3}}],[\"总共查询了三个页\",{\"1\":{\"187\":1}}],[\"总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧\",{\"1\":{\"176\":1}}],[\"总之知道表中的记录存储在\",{\"1\":{\"155\":1}}],[\"总结一下\",{\"1\":{\"304\":1}}],[\"总结一句\",{\"1\":{\"288\":1}}],[\"总结\",{\"0\":{\"110\":1,\"150\":1,\"169\":1,\"180\":1,\"188\":1,\"229\":1,\"241\":1,\"246\":1,\"258\":1,\"300\":1,\"305\":1,\"326\":1,\"331\":1,\"350\":1,\"361\":1,\"369\":1,\"489\":1}}],[\"换言之该对象是可达的\",{\"1\":{\"517\":1}}],[\"换点专业的话来说\",{\"1\":{\"493\":1}}],[\"换一个角度看\",{\"1\":{\"155\":1,\"174\":1,\"336\":1}}],[\"换句话说\",{\"1\":{\"58\":1}}],[\"记录错误信息\",{\"1\":{\"442\":1,\"450\":1}}],[\"记录在\",{\"1\":{\"358\":1}}],[\"记录数量\",{\"1\":{\"356\":1}}],[\"记录行数据最终被修改成什么样了\",{\"1\":{\"341\":1}}],[\"记录进行擦除\",{\"1\":{\"339\":1}}],[\"记录了此次事务\",{\"1\":{\"337\":2}}],[\"记录了某个数据页做了什么修改\",{\"1\":{\"337\":1}}],[\"记录中的两个隐藏列\",{\"1\":{\"334\":1,\"361\":1}}],[\"记录时的语句会被阻塞\",{\"1\":{\"296\":1}}],[\"记录上的主键索引的锁不可以是\",{\"1\":{\"291\":1}}],[\"记录不存在的情况\",{\"0\":{\"291\":1,\"296\":1}}],[\"记录存在的情况\",{\"0\":{\"290\":1,\"297\":1}}],[\"记录加上了类型为\",{\"1\":{\"280\":1}}],[\"记录之间加有间隙锁\",{\"0\":{\"277\":1}}],[\"记录锁和间隙锁的组合\",{\"1\":{\"329\":1}}],[\"记录锁无法防止插入\",{\"1\":{\"298\":1}}],[\"记录锁后\",{\"1\":{\"290\":1}}],[\"记录锁+间隙锁可以防止删除操作而导致的幻读问题\",{\"1\":{\"303\":2}}],[\"记录锁+间隙锁可以防止删除操作而导致的幻读吗\",{\"0\":{\"301\":1},\"1\":{\"96\":1,\"301\":1}}],[\"记录锁+间隙锁\",{\"1\":{\"277\":2,\"302\":1,\"357\":1,\"361\":1,\"362\":1,\"369\":1}}],[\"记录锁\",{\"1\":{\"275\":1,\"284\":1,\"289\":1,\"300\":1,\"313\":1,\"329\":1}}],[\"记录节点\",{\"1\":{\"252\":2}}],[\"记录\",{\"1\":{\"243\":1,\"252\":1,\"287\":1,\"316\":1}}],[\"记录真实数据部分除了我们定义的字段\",{\"1\":{\"164\":1}}],[\"记录与记录之间是通过链表组织的\",{\"1\":{\"163\":1}}],[\"记录头信息中包含的内容很多\",{\"1\":{\"163\":1}}],[\"记录头信息\",{\"0\":{\"163\":1},\"1\":{\"160\":1,\"161\":2,\"163\":1}}],[\"记录的字段\",{\"1\":{\"359\":1}}],[\"记录的是在某个数据页做了什么修改\",{\"1\":{\"341\":1}}],[\"记录的是更新之前的值\",{\"1\":{\"337\":1}}],[\"记录的是更新之后的值\",{\"1\":{\"337\":1}}],[\"记录的是事务提交时数据页的物理修改\",{\"1\":{\"272\":1}}],[\"记录的顺序要么先记\",{\"1\":{\"312\":1}}],[\"记录的成功和失败的情况分别如下\",{\"1\":{\"296\":2}}],[\"记录的语句就是原始语句\",{\"1\":{\"312\":1}}],[\"记录的语句是否可以执行成功\",{\"1\":{\"296\":1}}],[\"记录的语句成功\",{\"1\":{\"296\":1}}],[\"记录的语句\",{\"1\":{\"296\":2,\"297\":1}}],[\"记录的二级索引上的\",{\"1\":{\"298\":1}}],[\"记录的二级索引上\",{\"1\":{\"296\":5}}],[\"记录的主键索引上加了范围为\",{\"1\":{\"291\":1}}],[\"记录的主键索引上加的是间隙锁\",{\"1\":{\"291\":1}}],[\"记录的主键索引上加的是记录锁\",{\"1\":{\"290\":1}}],[\"记录的估算值\",{\"1\":{\"199\":1}}],[\"记录的真实数据处不会存储该列的一部分数据\",{\"1\":{\"168\":1,\"169\":1}}],[\"记录的真实数据\",{\"0\":{\"164\":1},\"1\":{\"159\":1}}],[\"记录的额外信息包含\",{\"1\":{\"160\":1}}],[\"记录的额外信息\",{\"0\":{\"160\":1},\"1\":{\"159\":1}}],[\"记录是按照行来存储的\",{\"1\":{\"155\":1,\"243\":1}}],[\"页面最终需要的是把两个json拼接为一个json\",{\"1\":{\"442\":1}}],[\"页面后\",{\"1\":{\"337\":1,\"343\":1,\"350\":1}}],[\"页面\",{\"1\":{\"336\":1,\"337\":2,\"343\":1,\"350\":1}}],[\"页面流程图\",{\"1\":{\"54\":1}}],[\"页16\",{\"1\":{\"244\":2}}],[\"页30\",{\"1\":{\"244\":1}}],[\"页目录\",{\"1\":{\"336\":1}}],[\"页目录存储各个槽\",{\"1\":{\"246\":1}}],[\"页目录就是由多个槽组成的\",{\"1\":{\"243\":1}}],[\"页目录用来存储每组最后一条记录的地址偏移量\",{\"1\":{\"243\":1}}],[\"页目录创建的过程如下\",{\"1\":{\"243\":1}}],[\"页目录与记录的关系如下图\",{\"1\":{\"243\":1}}],[\"页分裂还有可能会造成大量的内存碎片\",{\"1\":{\"226\":1}}],[\"页码\",{\"1\":{\"188\":1}}],[\"页尾\",{\"1\":{\"188\":1}}],[\"页头\",{\"1\":{\"188\":1}}],[\"页在磁盘中不一定是连续的\",{\"1\":{\"188\":1}}],[\"页中所放的行数量就会越少\",{\"1\":{\"187\":1}}],[\"页的空间是\",{\"1\":{\"188\":1}}],[\"页的数据结构\",{\"0\":{\"185\":1}}],[\"页的类型有很多\",{\"1\":{\"155\":1}}],[\"页被访问\",{\"1\":{\"180\":1}}],[\"页被访问时\",{\"1\":{\"180\":1}}],[\"页号地址两部分\",{\"1\":{\"186\":1}}],[\"页号\",{\"1\":{\"174\":1,\"186\":1,\"187\":2}}],[\"页是记录什么\",{\"1\":{\"336\":1}}],[\"页是\",{\"1\":{\"155\":1}}],[\"页\",{\"0\":{\"155\":1},\"1\":{\"153\":1,\"155\":1,\"174\":3,\"272\":2,\"336\":3}}],[\"区分度计算公式\",{\"1\":{\"218\":1}}],[\"区分度就是某个字段\",{\"1\":{\"218\":1}}],[\"区域性\",{\"1\":{\"516\":1}}],[\"区域比例\",{\"1\":{\"180\":1}}],[\"区域比例是\",{\"1\":{\"178\":1}}],[\"区域和\",{\"1\":{\"180\":1}}],[\"区域前面\",{\"1\":{\"178\":1}}],[\"区域节点频繁移动到头部\",{\"1\":{\"178\":1}}],[\"区域其实做了一个优化\",{\"1\":{\"178\":1}}],[\"区域停留时间超过\",{\"1\":{\"178\":1,\"180\":1}}],[\"区域移动到\",{\"1\":{\"178\":1}}],[\"区域移除\",{\"1\":{\"178\":1}}],[\"区域条件增加了一个停留在\",{\"1\":{\"178\":1}}],[\"区域里的热点数据不会被替换掉\",{\"1\":{\"178\":1}}],[\"区域就是热点数据\",{\"1\":{\"178\":1}}],[\"区域避免了预读失效带来的影响\",{\"1\":{\"178\":1}}],[\"区域的缓存页进行第一次访问时\",{\"1\":{\"178\":1}}],[\"区域的时间判断\",{\"1\":{\"178\":1}}],[\"区域的门槛\",{\"1\":{\"178\":1}}],[\"区域的热点数据\",{\"1\":{\"178\":1}}],[\"区域的热点数据都会被替换掉\",{\"1\":{\"178\":1}}],[\"区域的数据更早被淘汰出去\",{\"1\":{\"178\":1}}],[\"区域的位置\",{\"1\":{\"178\":1}}],[\"区域的头部\",{\"1\":{\"178\":6}}],[\"区域末尾的页\",{\"1\":{\"178\":2}}],[\"区域头部\",{\"1\":{\"178\":5}}],[\"区域占比\",{\"1\":{\"178\":2}}],[\"区域占整个\",{\"1\":{\"178\":1}}],[\"区域中的热点数据\",{\"1\":{\"178\":1}}],[\"区域与\",{\"1\":{\"178\":1}}],[\"区域则是在后半部分\",{\"1\":{\"178\":1}}],[\"区域在\",{\"1\":{\"178\":1}}],[\"区域\",{\"1\":{\"178\":5,\"180\":4}}],[\"区别在哪\",{\"1\":{\"337\":1}}],[\"区别在于数据页记录的是真实的行数据而不是页地址\",{\"1\":{\"186\":1}}],[\"区别在于\",{\"1\":{\"177\":1,\"188\":1}}],[\"区别如下\",{\"1\":{\"206\":1,\"341\":1}}],[\"区别于节点\",{\"1\":{\"75\":1}}],[\"区\",{\"0\":{\"156\":1},\"1\":{\"153\":1,\"184\":1,\"272\":2}}],[\"若遇到哈希冲突\",{\"1\":{\"472\":1}}],[\"若超过指定数量\",{\"1\":{\"392\":1}}],[\"若设置了参数\",{\"1\":{\"152\":1}}],[\"若流程足够清晰\",{\"1\":{\"57\":1}}],[\"该对象就可以被垃圾回收了\",{\"1\":{\"523\":1}}],[\"该文章偏基础\",{\"1\":{\"478\":1}}],[\"该文件是用来保存每个表的元数据信息的\",{\"1\":{\"152\":1}}],[\"该服务内部没有jvm缓存\",{\"1\":{\"445\":1}}],[\"该如何实现切换呢\",{\"1\":{\"393\":1}}],[\"该情况\",{\"1\":{\"352\":1}}],[\"该事务对数据库所做的修改将永久生效\",{\"1\":{\"351\":1}}],[\"该模式下在事务提交时不会主动触发写入磁盘的操作\",{\"1\":{\"338\":1}}],[\"该页的内存数据和磁盘上的数据已经不一致\",{\"1\":{\"335\":1}}],[\"该位置的下一条记录不存在\",{\"1\":{\"296\":1}}],[\"该二级索引的\",{\"1\":{\"295\":2,\"300\":2}}],[\"该特殊的记录的名字叫\",{\"1\":{\"293\":1,\"298\":1}}],[\"该记录是第一个不符合条件的二级索引记录\",{\"1\":{\"297\":1}}],[\"该记录是第一条不满足\",{\"1\":{\"294\":1}}],[\"该记录中索引的\",{\"1\":{\"294\":1}}],[\"该记录不满足\",{\"1\":{\"294\":1}}],[\"该记录还是隐式锁\",{\"1\":{\"280\":1}}],[\"该记录的整个示意图如下\",{\"1\":{\"358\":1}}],[\"该记录的二级索引上有间隙锁\",{\"1\":{\"297\":3}}],[\"该记录的二级索引上没有间隙锁\",{\"1\":{\"296\":1,\"297\":1}}],[\"该记录的主键索引中的\",{\"1\":{\"294\":3}}],[\"该记录的锁会退化为间隙锁\",{\"1\":{\"294\":1}}],[\"该记录的索引\",{\"1\":{\"292\":1}}],[\"该记录的索引的\",{\"1\":{\"292\":2}}],[\"该记录的索引中的\",{\"1\":{\"290\":1}}],[\"该记录的\",{\"1\":{\"216\":3}}],[\"该锁只用于并发插入操作\",{\"1\":{\"275\":1,\"324\":1}}],[\"该联合索引的\",{\"1\":{\"215\":1}}],[\"该索引就被称为联合索引\",{\"1\":{\"215\":1}}],[\"该函数作用是统计符合查询条件的记录中\",{\"1\":{\"191\":1}}],[\"该算法的思路是\",{\"1\":{\"178\":1}}],[\"该头节点包含链表的头节点地址\",{\"1\":{\"176\":1}}],[\"该\",{\"1\":{\"152\":1}}],[\"该跨职能流程图是展示了商城运营流程和负责各个子流程的功能单位\",{\"1\":{\"58\":1}}],[\"目标指向tomcat集群\",{\"1\":{\"447\":1}}],[\"目标节点的id\",{\"1\":{\"408\":1}}],[\"目前可以在启动时将所有数据都放入缓存中\",{\"1\":{\"448\":1}}],[\"目前spring内部的缓存使用的就是caffeine\",{\"1\":{\"416\":1}}],[\"目前已经更新好的文章\",{\"1\":{\"96\":1}}],[\"目的是清理软引用\",{\"1\":{\"520\":1}}],[\"目的是为了组合更多事务的\",{\"1\":{\"348\":1}}],[\"目的是为了避免幻读\",{\"1\":{\"284\":1}}],[\"目的是为了解决可重复读隔离级别下幻读的现象\",{\"1\":{\"286\":1,\"315\":1}}],[\"目的是为了解决批量数据访问\",{\"1\":{\"180\":1}}],[\"目的是为了解决预读失效的问题\",{\"1\":{\"180\":1}}],[\"目的是为了减少磁盘\",{\"1\":{\"178\":1}}],[\"目的达成\",{\"1\":{\"408\":1}}],[\"目的为了防止事务执行的过程中\",{\"1\":{\"274\":1}}],[\"目录\",{\"1\":{\"152\":1}}],[\"目录里面创建一个以\",{\"1\":{\"152\":1}}],[\"话不多说\",{\"1\":{\"151\":1}}],[\"值加到链表中即可\",{\"1\":{\"472\":1}}],[\"值在\",{\"1\":{\"358\":1}}],[\"值小于\",{\"1\":{\"296\":1,\"297\":5,\"358\":1}}],[\"值范围为\",{\"1\":{\"296\":1}}],[\"值大于等于\",{\"1\":{\"358\":1}}],[\"值大于\",{\"1\":{\"293\":3,\"296\":1,\"297\":3,\"298\":1}}],[\"值为1\",{\"1\":{\"498\":1}}],[\"值为\",{\"1\":{\"279\":1,\"280\":4,\"291\":1,\"293\":3,\"294\":4,\"296\":3,\"297\":6,\"298\":1,\"359\":1}}],[\"值是否在\",{\"1\":{\"359\":1,\"360\":1}}],[\"值是可以插入成功的\",{\"1\":{\"296\":1}}],[\"值是不可以插入的\",{\"1\":{\"296\":1}}],[\"值是一个没意义的值\",{\"1\":{\"227\":1}}],[\"值是大于100的\",{\"1\":{\"207\":1}}],[\"值是\",{\"1\":{\"206\":1}}],[\"值是怎么存放的\",{\"1\":{\"169\":1}}],[\"值的唯一列作为聚簇索引的索引键\",{\"1\":{\"204\":1,\"245\":1}}],[\"值的列\",{\"1\":{\"162\":1}}],[\"值就是\",{\"1\":{\"197\":1}}],[\"值判断是否为\",{\"1\":{\"192\":1}}],[\"值会是多少\",{\"1\":{\"187\":1}}],[\"值会占用空间吗\",{\"1\":{\"151\":1}}],[\"值并不会存储在行格式中的真实数据部分\",{\"1\":{\"169\":1}}],[\"值都放到记录的真实数据中会比较浪费空间\",{\"1\":{\"162\":1}}],[\"值\",{\"1\":{\"162\":4,\"186\":1,\"192\":1,\"215\":1,\"291\":1,\"296\":3,\"297\":5,\"298\":2,\"322\":1,\"358\":4,\"359\":2,\"360\":1}}],[\"值列表至少占用\",{\"1\":{\"162\":1}}],[\"值列表了\",{\"1\":{\"162\":1}}],[\"值列表也不是必须的\",{\"1\":{\"162\":1}}],[\"值列表都填充完毕后\",{\"1\":{\"162\":1}}],[\"值列表用十六进制表示是\",{\"1\":{\"162\":2}}],[\"值列表的\",{\"1\":{\"162\":1}}],[\"值列表的信息也需要逆序存放\",{\"1\":{\"161\":1}}],[\"值列表是怎样存储的\",{\"1\":{\"162\":1}}],[\"值列表必须用整数个字节的位表示\",{\"1\":{\"162\":1}}],[\"值列表\",{\"0\":{\"162\":1},\"1\":{\"160\":1,\"162\":4,\"166\":6,\"227\":1}}],[\"值越大\",{\"1\":{\"32\":1}}],[\"知道了\",{\"1\":{\"234\":1,\"358\":1}}],[\"知道了这个结论之后\",{\"1\":{\"296\":1}}],[\"知道了这个前提\",{\"1\":{\"296\":1}}],[\"知道了这个前提之后\",{\"1\":{\"165\":1}}],[\"知道了这个之后\",{\"1\":{\"151\":1}}],[\"知道这一点\",{\"1\":{\"216\":4}}],[\"知识整理\",{\"1\":{\"49\":1}}],[\"知识来源\",{\"1\":{\"49\":1}}],[\"节省了很多回表操作\",{\"1\":{\"149\":1}}],[\"节点读取\",{\"1\":{\"398\":2}}],[\"节点的过程\",{\"1\":{\"255\":2}}],[\"节点4的第一个索引值的前缀符合林字\",{\"1\":{\"235\":1}}],[\"节点2的第一个索引值中的陈字的拼音大小比林字小\",{\"1\":{\"235\":1}}],[\"节点之间的连线表示系统之间进行交互的通信路径\",{\"1\":{\"77\":1}}],[\"节点是存在与运行时的代表计算机资源的物理元素\",{\"1\":{\"75\":1}}],[\"节点实例的名称会有下划线\",{\"1\":{\"75\":1}}],[\"节点实例\",{\"0\":{\"75\":1}}],[\"节点\",{\"0\":{\"75\":1},\"1\":{\"73\":1,\"235\":2}}],[\"里除了普通查询是快照读\",{\"1\":{\"365\":1}}],[\"里如何工作的\",{\"0\":{\"358\":1},\"1\":{\"357\":1}}],[\"里并没有\",{\"1\":{\"340\":1}}],[\"里插入\",{\"1\":{\"275\":1}}],[\"里用不到的字段\",{\"1\":{\"222\":1}}],[\"里的引用\",{\"1\":{\"517\":1}}],[\"里的完整事务写入到\",{\"1\":{\"343\":1}}],[\"里的脏页数据持久化到磁盘\",{\"1\":{\"337\":1}}],[\"里的信息\",{\"1\":{\"334\":1}}],[\"里的字段\",{\"1\":{\"334\":1,\"361\":1}}],[\"里的数据\",{\"1\":{\"334\":2}}],[\"里的记录数据对我们是没用的\",{\"1\":{\"252\":1}}],[\"里的记录数据会从磁盘加载到内存\",{\"1\":{\"252\":1}}],[\"里的\",{\"1\":{\"232\":2,\"244\":1,\"257\":1,\"330\":1,\"338\":5,\"346\":1,\"347\":2,\"349\":2}}],[\"里的所有页都替换出去\",{\"1\":{\"178\":1}}],[\"里的时间尽可能长\",{\"1\":{\"178\":1}}],[\"里的时间要尽可能的短\",{\"1\":{\"178\":1}}],[\"里的内容是\",{\"1\":{\"161\":2}}],[\"里有三种页和链表来管理数据\",{\"1\":{\"178\":1}}],[\"里有一张名为\",{\"1\":{\"152\":1}}],[\"里不需要保存值为\",{\"1\":{\"161\":1}}],[\"里面有一条账户余额为\",{\"1\":{\"357\":1}}],[\"里面记录了这条更新语句\",{\"1\":{\"344\":1}}],[\"里面记录的是主库分配的自增值\",{\"1\":{\"312\":1}}],[\"里面没有记录这条更新语句\",{\"1\":{\"344\":1}}],[\"里面表级别的锁有这几种\",{\"1\":{\"308\":1}}],[\"里面\",{\"1\":{\"161\":1,\"343\":1,\"350\":1}}],[\"里面就行\",{\"1\":{\"155\":1}}],[\"里\",{\"1\":{\"149\":1,\"152\":1,\"178\":4,\"216\":1,\"242\":1,\"306\":1,\"334\":1,\"343\":1}}],[\"里查找缓存数据\",{\"1\":{\"140\":1}}],[\"虽然没有提交事务\",{\"1\":{\"357\":1}}],[\"虽然没有输入\",{\"1\":{\"334\":1}}],[\"虽然支持\",{\"1\":{\"357\":1}}],[\"虽然每个线程有自己\",{\"1\":{\"343\":1}}],[\"虽然参数\",{\"1\":{\"338\":1}}],[\"虽然脏页数据没有持久化\",{\"1\":{\"337\":1}}],[\"虽然我们看见表中最后一条二级索引记录是\",{\"1\":{\"298\":1}}],[\"虽然我们看见表中最后一条记录是\",{\"1\":{\"293\":1}}],[\"虽然范围查询语句包含等值查询\",{\"1\":{\"298\":1}}],[\"虽然这次范围查询的条件是\",{\"1\":{\"294\":1}}],[\"虽然相同范围的间隙锁是多个事务相互兼容的\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"虽然查询的结果没问题\",{\"1\":{\"233\":1}}],[\"虽然在符合前缀为\",{\"1\":{\"216\":1}}],[\"虽然在符合\",{\"1\":{\"216\":1}}],[\"虽然数据表中\",{\"1\":{\"184\":1}}],[\"虽然通过划分\",{\"1\":{\"178\":1}}],[\"虽然说\",{\"1\":{\"172\":1}}],[\"虽然\",{\"1\":{\"149\":1,\"216\":3,\"234\":1}}],[\"获取任务id\",{\"1\":{\"508\":1}}],[\"获取指定的构造器getdeclaredconstructor\",{\"1\":{\"503\":1}}],[\"获取指定的某个方法\",{\"1\":{\"502\":1}}],[\"获取\",{\"1\":{\"501\":1}}],[\"获取运行时类中指定变量名的属性\",{\"1\":{\"501\":1}}],[\"获取运行时类声明的注解\",{\"1\":{\"499\":1}}],[\"获取运行时类所在的包\",{\"1\":{\"499\":1}}],[\"获取运行时类实现的接口\",{\"1\":{\"499\":1}}],[\"获取运行时类的带泛型的父类的泛型\",{\"1\":{\"499\":1}}],[\"获取运行时类的带泛型的父类\",{\"1\":{\"499\":1}}],[\"获取运行时类的父类实现的接口\",{\"1\":{\"499\":1}}],[\"获取运行时类的父类\",{\"1\":{\"499\":1}}],[\"获取运行时类的完整结构\",{\"0\":{\"499\":1}}],[\"获取当前运行时类中声明为public的构造器\",{\"1\":{\"499\":1}}],[\"获取当前运行时类中声明的所的构造器\",{\"1\":{\"499\":1}}],[\"获取当前运行时类中声明的所方法\",{\"1\":{\"499\":1}}],[\"获取当前运行时类中声明的所有属性\",{\"1\":{\"499\":1}}],[\"获取当前运行时类及其所父类中声明为public权限的方法\",{\"1\":{\"499\":1}}],[\"获取当前运行时类及其父类中声明为public访问权限的属性\",{\"1\":{\"499\":1}}],[\"获取对应的运行时类中所有的属性\",{\"1\":{\"499\":1}}],[\"获取class实例的几种方式\",{\"0\":{\"484\":1}}],[\"获取class实例的方式有哪些\",{\"1\":{\"478\":1}}],[\"获取本地缓存对象\",{\"1\":{\"453\":1}}],[\"获取一个连接\",{\"1\":{\"450\":2}}],[\"获取路径参数\",{\"1\":{\"442\":1,\"444\":1,\"451\":1,\"454\":1}}],[\"获取id并拼接到结果中返回\",{\"1\":{\"439\":1}}],[\"获取商品id\",{\"1\":{\"439\":2}}],[\"获取参数并返回\",{\"0\":{\"439\":1}}],[\"获取参数的api\",{\"0\":{\"438\":1}}],[\"获取队列中的事务组\",{\"1\":{\"348\":1}}],[\"获取到主键值后\",{\"1\":{\"208\":1}}],[\"获取主键值后\",{\"1\":{\"232\":1}}],[\"获取主键值\",{\"1\":{\"149\":2,\"234\":1}}],[\"获得认证的证书由于都是\",{\"1\":{\"108\":1}}],[\"<<\",{\"1\":{\"473\":1}}],[\"<version>1\",{\"1\":{\"460\":1}}],[\"<artifactid>canal\",{\"1\":{\"460\":1}}],[\"<artifactid>spring\",{\"1\":{\"396\":1,\"448\":1}}],[\"<groupid>top\",{\"1\":{\"460\":1}}],[\"<groupid>org\",{\"1\":{\"396\":1,\"448\":1}}],[\"<dependency>\",{\"1\":{\"396\":1,\"448\":1,\"460\":1}}],[\"<=\",{\"1\":{\"167\":1,\"169\":1,\"294\":2,\"473\":1}}],[\"<\",{\"1\":{\"149\":1,\"216\":3,\"228\":1,\"243\":1,\"294\":8,\"396\":1,\"448\":1,\"460\":1}}],[\"<some\",{\"1\":{\"15\":1}}],[\"联合使用\",{\"1\":{\"520\":1}}],[\"联合查询\",{\"1\":{\"261\":2}}],[\"联合索引里的\",{\"1\":{\"239\":1}}],[\"联合索引非最左匹配\",{\"0\":{\"239\":1}}],[\"联合索引要能正确使用需要遵循最左匹配原则\",{\"1\":{\"228\":1,\"239\":1,\"241\":1}}],[\"联合索引进行排序\",{\"0\":{\"219\":1}}],[\"联合索引的最左匹配原则\",{\"1\":{\"216\":1}}],[\"联合索引的最左匹配原则在遇到\",{\"1\":{\"216\":1}}],[\"联合索引的最左匹配原则会一直向右匹配直到遇到\",{\"1\":{\"216\":1}}],[\"联合索引的非叶子节点用两个字段的值作为\",{\"1\":{\"215\":1}}],[\"联合索引有一些特殊情况\",{\"1\":{\"216\":1}}],[\"联合索引范围查询\",{\"0\":{\"216\":1}}],[\"联合索引就会失效\",{\"1\":{\"215\":1,\"239\":1}}],[\"联合索引会失效\",{\"1\":{\"215\":1}}],[\"联合索引查询的\",{\"1\":{\"215\":1}}],[\"联合索引\",{\"0\":{\"215\":1},\"1\":{\"203\":1,\"214\":1,\"215\":4,\"216\":5,\"239\":1}}],[\"联合索引当遇到范围查询\",{\"1\":{\"149\":1}}],[\"联系与属性之间用直线相连\",{\"1\":{\"90\":1}}],[\"联系\",{\"1\":{\"89\":1}}],[\"推出的查询优化策略\",{\"1\":{\"149\":1}}],[\"推荐观看b站黑马程序员的redis教程\",{\"1\":{\"97\":1}}],[\"推荐使用processon\",{\"1\":{\"91\":1}}],[\"推荐使用draw\",{\"1\":{\"91\":1}}],[\"推荐\",{\"1\":{\"28\":1}}],[\"循环引用时\",{\"1\":{\"516\":1}}],[\"循环等待\",{\"1\":{\"281\":1,\"325\":1,\"326\":1}}],[\"循环遍历的对象就二级索引了\",{\"1\":{\"193\":1}}],[\"循环遍历的对象就不是聚簇索引\",{\"1\":{\"192\":1}}],[\"循环遍历聚簇索引\",{\"1\":{\"192\":1,\"193\":1}}],[\"循环\",{\"0\":{\"426\":1},\"1\":{\"147\":1,\"148\":1}}],[\"循环结构又可细分为以下两种形式\",{\"1\":{\"56\":1}}],[\"循环结构又称为重复结构\",{\"1\":{\"56\":1}}],[\"循环结构\",{\"1\":{\"56\":1}}],[\"交换from和to\",{\"1\":{\"529\":1}}],[\"交给存储引擎层去处理了\",{\"1\":{\"149\":1}}],[\"交给存储引擎\",{\"1\":{\"147\":1}}],[\"交互是以数据行为单位的\",{\"1\":{\"146\":1}}],[\"引用类型\",{\"0\":{\"518\":1}}],[\"引用的对象\",{\"1\":{\"517\":1}}],[\"引用计数法\",{\"0\":{\"516\":1}}],[\"引用常量不会触发此类的初始化\",{\"1\":{\"492\":1}}],[\"引擎通过什么技术来保证事务的这四个特性的呢\",{\"1\":{\"352\":1}}],[\"引擎就不支持事务\",{\"1\":{\"352\":1}}],[\"引擎就会先更新内存\",{\"1\":{\"337\":1}}],[\"引擎它是支持事务的\",{\"1\":{\"352\":1}}],[\"引擎会自己启动一个事务\",{\"1\":{\"338\":1}}],[\"引擎会在适当的时候\",{\"1\":{\"337\":1}}],[\"引擎对一条记录进行操作\",{\"1\":{\"334\":1}}],[\"引擎是支持事务的\",{\"1\":{\"361\":1}}],[\"引擎是支持行级锁的\",{\"1\":{\"283\":1,\"313\":1}}],[\"引擎是怎么加行级锁的\",{\"1\":{\"283\":1}}],[\"引擎\",{\"1\":{\"283\":1,\"340\":1}}],[\"引擎并不支持行级锁\",{\"1\":{\"283\":1,\"313\":1}}],[\"引擎为了解决\",{\"1\":{\"275\":1,\"365\":1}}],[\"引擎层实现的\",{\"1\":{\"361\":1}}],[\"引擎层\",{\"1\":{\"272\":2}}],[\"引擎时\",{\"1\":{\"197\":1}}],[\"引擎的可重复读隔离级别\",{\"1\":{\"369\":1}}],[\"引擎的默认隔离级别是可重复读\",{\"1\":{\"361\":1}}],[\"引擎的默认隔离级别\",{\"1\":{\"357\":1}}],[\"引擎的默认隔离级别虽然是\",{\"1\":{\"302\":1,\"361\":1,\"362\":1}}],[\"引擎的表里对某些记录加上\",{\"1\":{\"311\":2}}],[\"引擎的表使用表锁\",{\"1\":{\"309\":1}}],[\"引擎的\",{\"1\":{\"184\":1}}],[\"引擎全扫描的接口\",{\"1\":{\"148\":2}}],[\"引擎索引查询的接口\",{\"1\":{\"147\":1}}],[\"引入redis模块\",{\"1\":{\"450\":1}}],[\"引入redis的starter依赖\",{\"1\":{\"412\":1}}],[\"引入cjson模块\",{\"1\":{\"443\":1}}],[\"引入自定义common工具模块\",{\"1\":{\"442\":1}}],[\"引入依赖\",{\"0\":{\"396\":1,\"460\":1}}],[\"引入的索引下推优化\",{\"1\":{\"217\":1}}],[\"引入了组提交机制后\",{\"1\":{\"348\":1}}],[\"引入了\",{\"1\":{\"179\":1,\"348\":1}}],[\"引入线程后的变化\",{\"0\":{\"127\":1}}],[\"引入线程的目的是\",{\"1\":{\"126\":1}}],[\"引入进程的目的是\",{\"1\":{\"126\":1}}],[\"经常更新的字段不用创建索引\",{\"1\":{\"222\":1}}],[\"经常用于\",{\"1\":{\"221\":2}}],[\"经历完优化器后\",{\"1\":{\"146\":1}}],[\"经过权衡\",{\"1\":{\"508\":1}}],[\"经过这一番折腾\",{\"1\":{\"178\":1}}],[\"经过预处理阶段后\",{\"1\":{\"145\":1}}],[\"经过解析器后\",{\"1\":{\"143\":1}}],[\"经过几次开会讨论\",{\"1\":{\"53\":1}}],[\">直接内存章节\",{\"1\":{\"522\":1}}],[\">ref=new\",{\"1\":{\"520\":1}}],[\">>list=new\",{\"1\":{\"520\":1}}],[\">>>\",{\"1\":{\"474\":1}}],[\">>\",{\"1\":{\"473\":3}}],[\">=64\",{\"1\":{\"473\":1}}],[\">=\",{\"1\":{\"216\":7,\"293\":1,\"298\":2}}],[\">\",{\"1\":{\"145\":1,\"149\":4,\"182\":1,\"216\":11,\"217\":1,\"228\":1,\"238\":3,\"243\":1,\"285\":2,\"293\":1,\"302\":1,\"314\":2,\"338\":3,\"363\":1,\"368\":2,\"398\":1,\"416\":1,\"419\":2}}],[\"很高的现象\",{\"1\":{\"349\":1}}],[\"很高的时候\",{\"1\":{\"218\":1}}],[\"很高\",{\"0\":{\"349\":1}}],[\"很多读者都在留言区说了自己的想法\",{\"1\":{\"230\":1}}],[\"很多缓冲页其实只会被访问一次\",{\"1\":{\"178\":1}}],[\"很明显并不是\",{\"1\":{\"193\":1}}],[\"很快也能看懂\",{\"1\":{\"158\":1}}],[\"很显然这条查询语句是覆盖索引\",{\"1\":{\"145\":1}}],[\"很简单\",{\"1\":{\"145\":1}}],[\"很难跟踪每个步骤的负责人\",{\"1\":{\"58\":1}}],[\"报错表不存在时的函数调用栈\",{\"1\":{\"144\":1}}],[\"老哥帮我分析的\",{\"1\":{\"144\":1}}],[\"别再被老板挨骂啦\",{\"1\":{\"331\":1}}],[\"别急\",{\"1\":{\"142\":1}}],[\"别的线程还可以继续执行\",{\"1\":{\"130\":1}}],[\"讲\",{\"1\":{\"142\":1,\"150\":1,\"350\":1}}],[\"讲明白\",{\"1\":{\"102\":1}}],[\"写数据到redis\",{\"1\":{\"463\":2}}],[\"写数据到jvm进程缓存\",{\"1\":{\"463\":2}}],[\"写命令执行完先放入aof缓冲区\",{\"1\":{\"378\":2}}],[\"写出rdb文件都比较耗时\",{\"1\":{\"375\":1}}],[\"写成功了\",{\"1\":{\"346\":1}}],[\"写成功为事务提交成功的标识\",{\"1\":{\"346\":1}}],[\"写成了\",{\"1\":{\"142\":1}}],[\"写满一个文件\",{\"1\":{\"341\":1}}],[\"写到暂存日志中\",{\"1\":{\"342\":1}}],[\"写到末尾就又回到开头\",{\"1\":{\"339\":1}}],[\"写到操作系统的\",{\"1\":{\"338\":1}}],[\"写到\",{\"1\":{\"338\":1,\"343\":1,\"349\":1}}],[\"写入文件\",{\"1\":{\"348\":1}}],[\"写入到\",{\"1\":{\"345\":2,\"348\":1}}],[\"写入方式不同\",{\"1\":{\"341\":1}}],[\"写入性能\",{\"1\":{\"338\":1}}],[\"写入磁盘\",{\"1\":{\"338\":1}}],[\"写入磁盘的性能\",{\"1\":{\"337\":1}}],[\"写入磁盘的开销更小\",{\"1\":{\"337\":1}}],[\"写入\",{\"1\":{\"337\":1,\"342\":1,\"348\":1}}],[\"写写互斥的\",{\"1\":{\"311\":1}}],[\"写锁等待\",{\"1\":{\"310\":1}}],[\"写锁\",{\"1\":{\"310\":6}}],[\"写进程将阻塞\",{\"1\":{\"124\":1}}],[\"字符小\",{\"1\":{\"238\":1}}],[\"字符比\",{\"1\":{\"238\":1}}],[\"字符比较\",{\"1\":{\"238\":1}}],[\"字符和\",{\"1\":{\"238\":1}}],[\"字符的组合\",{\"1\":{\"238\":1}}],[\"字符的就觉得会读取表中所有的字段\",{\"1\":{\"189\":1}}],[\"字符串拼接可以使用\",{\"1\":{\"425\":1}}],[\"字符串相当于\",{\"1\":{\"238\":1}}],[\"字符串比较大小是逐位从高位到低位逐个比较\",{\"1\":{\"238\":1}}],[\"字符串\",{\"1\":{\"238\":2}}],[\"字符集下\",{\"1\":{\"166\":1}}],[\"字符集为\",{\"1\":{\"166\":1,\"169\":1}}],[\"字符集\",{\"1\":{\"165\":1,\"216\":1}}],[\"字符集是\",{\"1\":{\"161\":1,\"166\":1}}],[\"字节码操作获得类似动态语言的特性\",{\"1\":{\"480\":1}}],[\"字节存储指向溢出页的地址\",{\"1\":{\"168\":1,\"169\":1}}],[\"字节表示\",{\"1\":{\"166\":2}}],[\"字节来表示\",{\"1\":{\"166\":2}}],[\"字节的数据\",{\"1\":{\"165\":1,\"166\":1,\"169\":1}}],[\"字节的\",{\"1\":{\"162\":1}}],[\"字节的空间\",{\"1\":{\"162\":1,\"169\":1}}],[\"字节空间存储\",{\"1\":{\"227\":1}}],[\"字节空间的\",{\"1\":{\"162\":1}}],[\"字节空间吗\",{\"1\":{\"162\":1}}],[\"字节空间\",{\"1\":{\"162\":1,\"169\":1}}],[\"字节\",{\"1\":{\"161\":3,\"165\":2,\"166\":3,\"216\":6}}],[\"字节面试\",{\"0\":{\"318\":1},\"1\":{\"96\":1}}],[\"字段还是旧值\",{\"1\":{\"344\":1}}],[\"字段还是可以用到了联合索引的\",{\"1\":{\"216\":3}}],[\"字段恢复到新值\",{\"1\":{\"344\":1}}],[\"字段进行排序\",{\"1\":{\"304\":1}}],[\"字段建立了索引后\",{\"1\":{\"304\":1}}],[\"字段建立了联合索引\",{\"1\":{\"149\":1}}],[\"字段建立索引后\",{\"1\":{\"304\":1}}],[\"字段建立索引\",{\"1\":{\"304\":1}}],[\"字段普通索引\",{\"1\":{\"274\":1}}],[\"字段是新值\",{\"1\":{\"344\":1}}],[\"字段是旧值\",{\"1\":{\"344\":1}}],[\"字段是非唯一索引\",{\"1\":{\"298\":1}}],[\"字段是索引\",{\"1\":{\"238\":1}}],[\"字段是允许为\",{\"1\":{\"166\":1}}],[\"字段前缀为\",{\"1\":{\"235\":1}}],[\"字段有序排列存储的\",{\"1\":{\"235\":1}}],[\"字段有唯一性限制的\",{\"1\":{\"221\":1}}],[\"字段为唯一二级索引\",{\"1\":{\"280\":1}}],[\"字段为字符串\",{\"1\":{\"238\":1}}],[\"字段为二级索引\",{\"1\":{\"234\":2,\"235\":2}}],[\"字段为主键索引\",{\"1\":{\"234\":2,\"274\":1,\"279\":1}}],[\"字段作为条件查询的时候\",{\"1\":{\"234\":3}}],[\"字段设置为唯一索引列\",{\"1\":{\"281\":1}}],[\"字段设置为索引即可\",{\"1\":{\"240\":1}}],[\"字段设置为普通索引\",{\"1\":{\"234\":1}}],[\"字段设置为二级索引\",{\"1\":{\"206\":1}}],[\"字段就是描述了找到所需数据时使用的扫描方式是什么\",{\"1\":{\"228\":1}}],[\"字段表示实际用的索引\",{\"1\":{\"228\":1}}],[\"字段表示可能用到的索引\",{\"1\":{\"228\":1}}],[\"字段中存在大量重复数据\",{\"1\":{\"222\":1}}],[\"字段能用到索引\",{\"1\":{\"217\":1}}],[\"字段能用到联合索引的\",{\"1\":{\"215\":1}}],[\"字段能用到联合索引\",{\"1\":{\"149\":1}}],[\"字段都用到了联合索引进行索引查询\",{\"1\":{\"216\":6}}],[\"字段都是变长字段\",{\"1\":{\"161\":1}}],[\"字段可以利用联合索引进行索引查询的意思\",{\"1\":{\"216\":2}}],[\"字段可以在联合索引的\",{\"1\":{\"216\":3}}],[\"字段使用了\",{\"1\":{\"216\":4,\"236\":1}}],[\"字段没用到联合索引\",{\"1\":{\"216\":1}}],[\"字段并没有使用到联合索引\",{\"1\":{\"216\":2}}],[\"字段用到了联合索引进行索引查询\",{\"1\":{\"216\":2}}],[\"字段无法利用联合索引进行索引查询的意思\",{\"1\":{\"216\":1}}],[\"字段值\",{\"1\":{\"217\":1}}],[\"字段值为\",{\"1\":{\"216\":9}}],[\"字段值就是\",{\"1\":{\"199\":1}}],[\"字段在\",{\"1\":{\"215\":1,\"239\":1}}],[\"字段排序\",{\"1\":{\"215\":1}}],[\"字段比较\",{\"1\":{\"215\":2}}],[\"字段组合成联合索引\",{\"1\":{\"215\":1}}],[\"字段上的索引\",{\"1\":{\"211\":1}}],[\"字段个数\",{\"1\":{\"203\":1}}],[\"字段特性\",{\"1\":{\"203\":1}}],[\"字段不为\",{\"1\":{\"191\":1}}],[\"字段的实际数据最多占用的存储空间长度是\",{\"1\":{\"216\":1}}],[\"字段的二级索引记录的范围里\",{\"1\":{\"216\":1}}],[\"字段的二级索引记录都是相邻的\",{\"1\":{\"216\":1}}],[\"字段的第一条记录\",{\"1\":{\"216\":1}}],[\"字段的查询条件\",{\"1\":{\"216\":1}}],[\"字段的范围查询\",{\"1\":{\"216\":4}}],[\"字段的值\",{\"1\":{\"239\":1}}],[\"字段的值在\",{\"1\":{\"216\":1}}],[\"字段的值进行排序\",{\"1\":{\"216\":2}}],[\"字段的值相同的情况下\",{\"1\":{\"216\":2}}],[\"字段的值排序\",{\"1\":{\"216\":2}}],[\"字段的值排序的\",{\"1\":{\"216\":3}}],[\"字段的值是在\",{\"1\":{\"239\":1}}],[\"字段的值是\",{\"1\":{\"216\":3}}],[\"字段的值是无序的\",{\"1\":{\"216\":2}}],[\"字段的值都符合\",{\"1\":{\"216\":1}}],[\"字段的值为\",{\"1\":{\"191\":1}}],[\"字段的数量\",{\"1\":{\"187\":1}}],[\"字段的类型是\",{\"1\":{\"216\":2}}],[\"字段的类型\",{\"1\":{\"187\":1}}],[\"字段和字符串\",{\"1\":{\"178\":1}}],[\"字段且字符集是\",{\"1\":{\"166\":1}}],[\"字段类型的\",{\"1\":{\"165\":1}}],[\"字段\",{\"0\":{\"195\":1},\"1\":{\"150\":1,\"169\":1,\"189\":1,\"195\":1,\"196\":1,\"232\":1,\"238\":2,\"243\":1,\"319\":1}}],[\"字段则无法利用到索引\",{\"1\":{\"149\":1}}],[\"字段名\",{\"1\":{\"142\":1}}],[\"语言的反射机制\",{\"1\":{\"481\":1}}],[\"语法\",{\"1\":{\"142\":1,\"333\":1}}],[\"语法解析器会根据语法规则\",{\"1\":{\"142\":1}}],[\"语法分析之后\",{\"1\":{\"144\":1}}],[\"语法分析\",{\"1\":{\"142\":1,\"150\":1}}],[\"语法树\",{\"1\":{\"142\":1}}],[\"语句去查询这条记录时就可以看到这条记录了\",{\"1\":{\"367\":1}}],[\"语句就不是快照读了\",{\"1\":{\"361\":1}}],[\"语句就是基于\",{\"1\":{\"361\":1}}],[\"语句就会释放的\",{\"1\":{\"329\":1}}],[\"语句将这条记录修改了\",{\"1\":{\"359\":1}}],[\"语句或者在自动提交的情况下\",{\"1\":{\"345\":1}}],[\"语句执行的时候\",{\"1\":{\"344\":1}}],[\"语句执行结束后才释放锁\",{\"1\":{\"312\":1}}],[\"语句混淆了\",{\"1\":{\"344\":1}}],[\"语句而已\",{\"1\":{\"341\":1}}],[\"语句重现\",{\"1\":{\"341\":1}}],[\"语句也是会使用事务的\",{\"1\":{\"334\":1}}],[\"语句必须满足以下条件能执行成功\",{\"1\":{\"330\":1}}],[\"语句必须满足如下条件之一才能执行成功\",{\"1\":{\"330\":1}}],[\"语句产生了\",{\"1\":{\"329\":1}}],[\"语句被阻塞了\",{\"1\":{\"329\":1}}],[\"语句中\",{\"1\":{\"329\":2}}],[\"语句修改数据库数据的时候\",{\"1\":{\"328\":1}}],[\"语句分析具体加了什么锁\",{\"1\":{\"321\":1}}],[\"语句时生成了一个\",{\"1\":{\"367\":1}}],[\"语句时\",{\"1\":{\"304\":1,\"329\":2}}],[\"语句如果查询条件不加索引\",{\"1\":{\"299\":1}}],[\"语句会加行级锁\",{\"0\":{\"283\":1}}],[\"语句会发生阻塞\",{\"1\":{\"280\":1}}],[\"语句会被阻塞\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"语句在正常执行时是不会生成锁结构的\",{\"1\":{\"276\":1}}],[\"语句并不会相互影响\",{\"1\":{\"275\":1}}],[\"语句是利用\",{\"1\":{\"311\":1}}],[\"语句是怎么加行级锁的\",{\"0\":{\"276\":1}}],[\"语句是不会对记录加锁的\",{\"1\":{\"275\":1,\"283\":1,\"313\":1}}],[\"语句是否满足\",{\"1\":{\"142\":1}}],[\"语句查询订单是否存在\",{\"1\":{\"273\":1}}],[\"语句查询的结果\",{\"1\":{\"140\":1}}],[\"语句引发的思考\",{\"1\":{\"230\":1}}],[\"语句扫描了大量的数据时\",{\"1\":{\"178\":1}}],[\"语句类型\",{\"1\":{\"150\":1}}],[\"语句的执行过程\",{\"1\":{\"343\":1}}],[\"语句的执行计划\",{\"1\":{\"145\":1}}],[\"语句的过程中\",{\"1\":{\"318\":1}}],[\"语句的请求到来\",{\"1\":{\"310\":1}}],[\"语句的场景\",{\"1\":{\"280\":1}}],[\"语句的\",{\"1\":{\"275\":1,\"329\":3,\"334\":1}}],[\"语句的时候\",{\"1\":{\"217\":1,\"302\":1,\"331\":1,\"334\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"语句的第一个字段\",{\"1\":{\"140\":1}}],[\"语句语法不对\",{\"1\":{\"142\":1}}],[\"语句做解析\",{\"1\":{\"141\":1}}],[\"语句后都持有范围为\",{\"1\":{\"275\":1,\"325\":1}}],[\"语句后\",{\"1\":{\"140\":1,\"312\":1,\"320\":1,\"334\":1}}],[\"语句了\",{\"1\":{\"140\":1}}],[\"语句\",{\"0\":{\"137\":1},\"1\":{\"139\":1,\"140\":1,\"235\":1,\"239\":1,\"274\":3,\"275\":1,\"277\":2,\"279\":1,\"280\":4,\"302\":1,\"310\":5,\"312\":6,\"329\":1,\"331\":1,\"333\":3,\"334\":3,\"341\":1,\"357\":2,\"361\":1,\"362\":1,\"369\":1}}],[\"词法分析\",{\"1\":{\"142\":1}}],[\"校验码等等\",{\"1\":{\"188\":1}}],[\"校验用户身份\",{\"1\":{\"150\":1}}],[\"校验客户端的用户名和密码\",{\"1\":{\"139\":1}}],[\"校验方式\",{\"1\":{\"43\":1}}],[\"简述全量同步和增量同步区别\",{\"1\":{\"388\":1}}],[\"简单而言\",{\"1\":{\"494\":2}}],[\"简单\",{\"1\":{\"456\":1}}],[\"简单来说就是混合了原哈希值中的高位和低位\",{\"1\":{\"474\":1}}],[\"简单来说就是把内存中的所有数据都记录到磁盘中\",{\"1\":{\"372\":1}}],[\"简单来说\",{\"1\":{\"272\":1}}],[\"简单的\",{\"1\":{\"178\":2}}],[\"简单总结一下\",{\"1\":{\"139\":1}}],[\"简称replid\",{\"1\":{\"384\":1}}],[\"简称\",{\"1\":{\"108\":2}}],[\"函数返回数据到response中\",{\"1\":{\"436\":1}}],[\"函数体\",{\"1\":{\"428\":1}}],[\"函数名\",{\"1\":{\"428\":1}}],[\"函数实现的\",{\"1\":{\"241\":1}}],[\"函数是用在了输入参数\",{\"1\":{\"238\":1}}],[\"函数是作用在了\",{\"1\":{\"238\":1}}],[\"函数\",{\"0\":{\"427\":1,\"428\":1},\"1\":{\"228\":1,\"236\":1}}],[\"函数只需要\",{\"1\":{\"197\":1}}],[\"函数需要通过遍历的方式来统计记录个数\",{\"1\":{\"197\":1}}],[\"函数统计有多少个记录时\",{\"1\":{\"192\":1}}],[\"函数指定的参数不为\",{\"1\":{\"191\":1,\"192\":1}}],[\"函数指针指向的还是\",{\"1\":{\"148\":1}}],[\"函数指针指向的函数\",{\"1\":{\"147\":2,\"148\":2}}],[\"函数的执行结果\",{\"1\":{\"197\":1}}],[\"函数的方式是不一样的\",{\"1\":{\"197\":1}}],[\"函数的参数是\",{\"1\":{\"193\":1}}],[\"函数的参数是数字\",{\"1\":{\"191\":1}}],[\"函数的参数是字段名\",{\"1\":{\"191\":1}}],[\"函数的参数不仅可以是字段名\",{\"1\":{\"191\":1}}],[\"函数的原理后\",{\"1\":{\"189\":1}}],[\"函数的接口\",{\"1\":{\"139\":1}}],[\"函数传入的参数有很多种\",{\"1\":{\"189\":1}}],[\"函数来判断一个变量的数据类型\",{\"1\":{\"424\":1}}],[\"函数来统计\",{\"1\":{\"189\":1}}],[\"函数来重置连接\",{\"1\":{\"139\":1}}],[\"函数里报错的\",{\"1\":{\"144\":1}}],[\"定格某一时刻的风景\",{\"1\":{\"357\":1}}],[\"定位到第一条不符合查询条件的二级索引记录\",{\"1\":{\"296\":1}}],[\"定位到该页后\",{\"1\":{\"244\":1}}],[\"定位到主键为\",{\"1\":{\"243\":1}}],[\"定位到槽后\",{\"1\":{\"243\":1,\"244\":1}}],[\"定期断开长连接\",{\"1\":{\"139\":1}}],[\"定义一个接口抽取出抽象方法\",{\"1\":{\"508\":1}}],[\"定义一个函数\",{\"1\":{\"428\":1}}],[\"定义tomcat集群\",{\"1\":{\"447\":1}}],[\"定义函数的语法\",{\"1\":{\"428\":1}}],[\"定义方式可能会有不同\",{\"1\":{\"255\":1}}],[\"定义了空闲连接的最大空闲时长\",{\"1\":{\"139\":1}}],[\"定义\",{\"0\":{\"54\":1},\"1\":{\"527\":1}}],[\"定义的服务器列表\",{\"1\":{\"32\":1}}],[\"断开\",{\"1\":{\"139\":2}}],[\"短连接\",{\"1\":{\"139\":1}}],[\"超过这些要求的话\",{\"1\":{\"252\":1}}],[\"超过这个值\",{\"1\":{\"139\":1}}],[\"超过了这个值可能会导致\",{\"1\":{\"188\":1}}],[\"超市\",{\"1\":{\"89\":1}}],[\"个特性\",{\"1\":{\"352\":1}}],[\"个事务的\",{\"1\":{\"349\":1}}],[\"个事务一次性一起刷盘的时间成本则近似于\",{\"1\":{\"348\":1}}],[\"个事务依次排队刷盘的时间成本是\",{\"1\":{\"348\":1}}],[\"个事务后才\",{\"1\":{\"343\":1,\"349\":1}}],[\"个从库\",{\"1\":{\"342\":1}}],[\"个阶段\",{\"1\":{\"342\":1,\"344\":1}}],[\"个重做日志文件组\",{\"1\":{\"339\":1}}],[\"个间隙锁\",{\"1\":{\"329\":1}}],[\"个记录锁和\",{\"1\":{\"329\":1}}],[\"个子节点\",{\"1\":{\"251\":1,\"252\":4,\"258\":1}}],[\"个扇区\",{\"1\":{\"248\":1}}],[\"个槽的编号分别为\",{\"1\":{\"243\":1}}],[\"个叶子节点的\",{\"1\":{\"207\":1}}],[\"个节点\",{\"1\":{\"205\":1}}],[\"个组成部分中\",{\"1\":{\"185\":1}}],[\"个区域\",{\"1\":{\"178\":1}}],[\"个变长字段\",{\"1\":{\"166\":1}}],[\"个字段的查询条件来形成扫描区间的边界条件\",{\"1\":{\"216\":3}}],[\"个字段值都是\",{\"1\":{\"162\":2}}],[\"个字符占用\",{\"1\":{\"165\":1}}],[\"个字节的指针来指向溢出页\",{\"1\":{\"168\":1,\"169\":1}}],[\"个字节\",{\"1\":{\"164\":3,\"165\":1,\"216\":1}}],[\"个部分的作用如下图\",{\"1\":{\"243\":1}}],[\"个部分\",{\"1\":{\"160\":1,\"185\":1}}],[\"个页会被划为一个区\",{\"1\":{\"156\":1}}],[\"个\",{\"1\":{\"139\":1,\"166\":1,\"207\":2,\"252\":2,\"294\":1,\"304\":1,\"339\":1,\"348\":1}}],[\"8之后\",{\"1\":{\"472\":1}}],[\"8之前\",{\"1\":{\"472\":1}}],[\"84676\",{\"1\":{\"436\":1,\"439\":1}}],[\"820\",{\"1\":{\"436\":1,\"439\":1}}],[\"8byte\",{\"1\":{\"187\":1}}],[\"8cc\",{\"1\":{\"150\":1}}],[\"8\",{\"1\":{\"139\":1,\"140\":4,\"144\":2,\"150\":1,\"162\":1,\"166\":2,\"178\":3,\"182\":1,\"187\":1,\"215\":4,\"216\":6,\"234\":1,\"236\":1,\"243\":6,\"248\":1,\"252\":2,\"279\":1,\"280\":1,\"288\":1,\"294\":1,\"300\":1,\"303\":1,\"304\":3,\"320\":1,\"333\":1,\"473\":3}}],[\"8003\",{\"1\":{\"412\":1}}],[\"8002\",{\"1\":{\"412\":1}}],[\"8001\",{\"1\":{\"412\":1}}],[\"800\",{\"1\":{\"352\":2}}],[\"800w\",{\"1\":{\"182\":2}}],[\"80\",{\"1\":{\"41\":4}}],[\"8082\",{\"1\":{\"39\":1,\"446\":1,\"447\":1}}],[\"8081\",{\"1\":{\"38\":2,\"39\":1,\"441\":1,\"442\":1,\"446\":1,\"447\":1}}],[\"8080\",{\"1\":{\"35\":2}}],[\"参考链接\",{\"1\":{\"530\":1}}],[\"参考资料\",{\"1\":{\"150\":1,\"169\":1,\"281\":1,\"317\":1,\"350\":1}}],[\"参数2\",{\"1\":{\"502\":2}}],[\"参数1\",{\"1\":{\"502\":2}}],[\"参数二\",{\"1\":{\"416\":1}}],[\"参数一\",{\"1\":{\"416\":1}}],[\"参数设置的值\",{\"1\":{\"348\":1}}],[\"参数设置为\",{\"1\":{\"330\":1}}],[\"参数来控制数据库的\",{\"1\":{\"343\":1}}],[\"参数来设置\",{\"1\":{\"173\":1,\"178\":1}}],[\"参数需要设置为\",{\"1\":{\"338\":1}}],[\"参数动态的调整大小\",{\"1\":{\"337\":1}}],[\"参数决定的\",{\"1\":{\"334\":1}}],[\"参数的时候\",{\"1\":{\"307\":1}}],[\"参数有\",{\"1\":{\"228\":1}}],[\"参数转化为参数\",{\"1\":{\"194\":1}}],[\"参数\",{\"1\":{\"180\":1,\"193\":1,\"281\":1,\"331\":1,\"338\":6,\"343\":1,\"349\":1,\"503\":1}}],[\"参数调整缓冲池的大小\",{\"1\":{\"180\":1}}],[\"参数控制\",{\"1\":{\"139\":1,\"338\":2,\"348\":1}}],[\"参数控制的是什么\",{\"1\":{\"338\":1}}],[\"参数控制的\",{\"1\":{\"139\":1}}],[\"参与者与用例之间的关系主要包括关联\",{\"1\":{\"59\":1}}],[\"参与者与用例之间的关系\",{\"1\":{\"59\":2}}],[\"参与者\",{\"1\":{\"59\":2,\"344\":4}}],[\"空参的构造器的访问权限得够\",{\"1\":{\"498\":1}}],[\"空间开销\",{\"1\":{\"526\":1}}],[\"空间或\",{\"1\":{\"179\":1,\"180\":1}}],[\"空间不足时\",{\"1\":{\"179\":1}}],[\"空间比较有限的情况下\",{\"1\":{\"178\":1}}],[\"空闲页链表\",{\"1\":{\"180\":1}}],[\"空闲页\",{\"1\":{\"178\":1}}],[\"空闲链表\",{\"1\":{\"176\":1}}],[\"空闲连接会一直占用着吗\",{\"1\":{\"139\":1}}],[\"空置\",{\"1\":{\"89\":1}}],[\"列表是\",{\"1\":{\"359\":1}}],[\"列表就只有\",{\"1\":{\"359\":1}}],[\"列表中最小的事务\",{\"1\":{\"359\":1}}],[\"列表中\",{\"1\":{\"358\":3}}],[\"列表\",{\"1\":{\"358\":1}}],[\"列子查询\",{\"1\":{\"261\":1}}],[\"列建立联合索引\",{\"1\":{\"219\":1}}],[\"列建立一个联合索引\",{\"1\":{\"219\":1}}],[\"列会出现\",{\"1\":{\"219\":1}}],[\"列作为聚簇索引的索引键\",{\"1\":{\"204\":1,\"245\":1}}],[\"列是\",{\"1\":{\"162\":2}}],[\"列不是变长字段\",{\"1\":{\"161\":1}}],[\"列和\",{\"1\":{\"161\":1}}],[\"列的值是\",{\"1\":{\"161\":1}}],[\"列的值为\",{\"1\":{\"161\":2}}],[\"列的状态为\",{\"1\":{\"139\":1}}],[\"列无法使用到联合索引\",{\"1\":{\"149\":1}}],[\"列\",{\"1\":{\"139\":1,\"162\":1,\"298\":2}}],[\"秒\",{\"1\":{\"139\":1,\"178\":1,\"198\":1,\"281\":1,\"338\":2,\"416\":1}}],[\"共同完成\",{\"1\":{\"344\":1}}],[\"共加了两种不同粒度的锁\",{\"1\":{\"304\":1}}],[\"共加了两个锁\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"322\":1}}],[\"共享字典\",{\"1\":{\"453\":1}}],[\"共享内存空间\",{\"1\":{\"375\":1}}],[\"共享\",{\"1\":{\"323\":1}}],[\"共享表锁\",{\"1\":{\"309\":1}}],[\"共享锁\",{\"1\":{\"283\":1,\"311\":1,\"313\":1}}],[\"共享和排他的间隙锁是没有区别的\",{\"1\":{\"275\":1}}],[\"共享存储\",{\"0\":{\"122\":1}}],[\"共有\",{\"1\":{\"198\":1,\"304\":1,\"351\":1}}],[\"共有三个文件\",{\"1\":{\"152\":1}}],[\"共有三个阶段\",{\"1\":{\"150\":1}}],[\"共有两个用户名为\",{\"1\":{\"139\":1}}],[\"命令格式如下\",{\"1\":{\"408\":1}}],[\"命令后\",{\"1\":{\"357\":1}}],[\"命令对表\",{\"1\":{\"199\":1}}],[\"命令效率是很高的\",{\"1\":{\"199\":1}}],[\"命令来表进行估算\",{\"1\":{\"199\":1}}],[\"命令\",{\"1\":{\"145\":1,\"357\":4,\"393\":1}}],[\"命令进行查看\",{\"1\":{\"139\":1}}],[\"命名为release\",{\"1\":{\"10\":1}}],[\"命名规则为\",{\"1\":{\"12\":1}}],[\"命名规则\",{\"0\":{\"8\":1}}],[\"命名一般为hotfix\",{\"1\":{\"7\":1}}],[\"普通\",{\"1\":{\"302\":1,\"312\":1,\"334\":2,\"357\":1,\"361\":1,\"362\":1,\"369\":1}}],[\"普通的\",{\"1\":{\"275\":1,\"283\":1,\"311\":1,\"313\":1,\"361\":1}}],[\"普通的静态访问最大并发数是\",{\"1\":{\"49\":1}}],[\"普通索引就是建立在普通字段上的索引\",{\"1\":{\"212\":1}}],[\"普通索引\",{\"0\":{\"212\":1},\"1\":{\"203\":2,\"209\":1}}],[\"普通字段\",{\"1\":{\"195\":1}}],[\"普遍我们都是使用下面这条命令进行连接\",{\"1\":{\"139\":1}}],[\"操作共享字典\",{\"1\":{\"453\":1}}],[\"操作成功\",{\"1\":{\"342\":1}}],[\"操作时\",{\"1\":{\"310\":2,\"331\":1}}],[\"操作都会加行级锁\",{\"1\":{\"283\":1}}],[\"操作会更多\",{\"1\":{\"252\":1}}],[\"操作会直接读写\",{\"1\":{\"248\":1}}],[\"操作的次数就越多\",{\"1\":{\"250\":1}}],[\"操作的次数\",{\"1\":{\"250\":1,\"258\":2}}],[\"操作的最小单位是页\",{\"1\":{\"243\":1}}],[\"操作越少\",{\"1\":{\"248\":1}}],[\"操作中完成查询工作\",{\"1\":{\"248\":2}}],[\"操作次数来读到\",{\"1\":{\"252\":1}}],[\"操作次数多\",{\"1\":{\"251\":1}}],[\"操作次数\",{\"1\":{\"247\":1,\"252\":1}}],[\"操作次数对索引的使用效率至关重要\",{\"1\":{\"244\":1}}],[\"操作就能查询到目标数据\",{\"1\":{\"207\":1}}],[\"操作系统的最小读写单位块的大小\",{\"1\":{\"250\":1}}],[\"操作系统一次会读写多个扇区\",{\"1\":{\"248\":1}}],[\"操作系统才会触发缺页中断\",{\"1\":{\"174\":1,\"336\":1}}],[\"操作系统里要使用\",{\"1\":{\"139\":1}}],[\"操作\",{\"1\":{\"155\":1,\"194\":1,\"205\":2,\"225\":1,\"228\":1,\"243\":1,\"246\":1,\"250\":1,\"251\":1,\"252\":1,\"256\":1,\"258\":2,\"310\":2,\"334\":1,\"337\":1,\"338\":1,\"340\":1,\"347\":1,\"348\":2}}],[\"操作平台\",{\"1\":{\"25\":1}}],[\"版本中\",{\"1\":{\"347\":1,\"348\":1}}],[\"版本链找到事务开始时的数据\",{\"1\":{\"364\":1}}],[\"版本链里找到满足其可见性的记录\",{\"1\":{\"334\":1}}],[\"版本链\",{\"1\":{\"334\":1,\"358\":1}}],[\"版本链如下图\",{\"1\":{\"334\":1}}],[\"版本是\",{\"1\":{\"288\":1}}],[\"版本\",{\"1\":{\"279\":1,\"280\":1,\"300\":1,\"303\":1,\"320\":1,\"348\":1}}],[\"版本为\",{\"1\":{\"234\":1}}],[\"版本之后增加的一种复制方式\",{\"1\":{\"342\":1}}],[\"版本之后\",{\"1\":{\"158\":2}}],[\"版本之前用的行格式\",{\"1\":{\"158\":1}}],[\"版本移除的是\",{\"1\":{\"140\":1}}],[\"版本直接将查询缓存删掉了\",{\"1\":{\"140\":1}}],[\"版本实现了\",{\"1\":{\"139\":1}}],[\"版本开始\",{\"1\":{\"138\":1,\"152\":1,\"312\":1}}],[\"版本的功能全部开发完成\",{\"1\":{\"7\":1}}],[\"存入redis\",{\"1\":{\"448\":2,\"463\":2}}],[\"存数据\",{\"1\":{\"416\":1}}],[\"存在下面的问题\",{\"1\":{\"414\":1}}],[\"存在这两种情况会将索引的\",{\"1\":{\"294\":1}}],[\"存在于表中\",{\"1\":{\"294\":2}}],[\"存在\",{\"1\":{\"289\":1,\"290\":1,\"294\":2,\"295\":1,\"300\":2}}],[\"存在大量范围检索的场景\",{\"1\":{\"256\":1}}],[\"存在最左匹配原则\",{\"1\":{\"215\":1}}],[\"存到\",{\"1\":{\"161\":1}}],[\"存储事项类型\",{\"1\":{\"508\":1}}],[\"存储\",{\"1\":{\"453\":1}}],[\"存储容量有限\",{\"1\":{\"416\":1}}],[\"存储容量更大\",{\"1\":{\"416\":1}}],[\"存储过程\",{\"1\":{\"272\":1}}],[\"存储层\",{\"1\":{\"272\":2}}],[\"存储到页目录\",{\"1\":{\"244\":1}}],[\"存储数据的方式也是不同的\",{\"1\":{\"243\":1}}],[\"存储千万级的数据只需要\",{\"1\":{\"205\":1}}],[\"存储在文件系统之上\",{\"1\":{\"272\":1}}],[\"存储在\",{\"1\":{\"204\":1}}],[\"存储变长字段实际占用的数据大小\",{\"1\":{\"169\":1}}],[\"存储的行为是由存储引擎实现的\",{\"1\":{\"152\":1}}],[\"存储引擎生成的\",{\"1\":{\"340\":1}}],[\"存储引擎层生成的日志\",{\"1\":{\"333\":2}}],[\"存储引擎层负责数据的存储和提取\",{\"1\":{\"138\":1}}],[\"存储引擎自己实现了行锁\",{\"1\":{\"329\":1}}],[\"存储引擎提供了个\",{\"1\":{\"312\":1}}],[\"存储引擎提供了一种轻量级的锁来实现自增\",{\"1\":{\"312\":1}}],[\"存储引擎默认的事务隔离级别正是可重复读\",{\"1\":{\"307\":1}}],[\"存储引擎默认会创建一个主键索引\",{\"1\":{\"234\":1}}],[\"存储引擎中\",{\"1\":{\"293\":1,\"298\":1,\"345\":1}}],[\"存储引擎中的\",{\"1\":{\"140\":1}}],[\"存储引擎实现的日志\",{\"1\":{\"341\":1}}],[\"存储引擎实现的\",{\"1\":{\"258\":1}}],[\"存储引擎一定会为表创建一个聚簇索引\",{\"1\":{\"245\":1,\"257\":1}}],[\"存储引擎的数据库表\",{\"1\":{\"358\":1}}],[\"存储引擎的日志\",{\"1\":{\"337\":1}}],[\"存储引擎的默认事务隔离级别是\",{\"1\":{\"329\":1}}],[\"存储引擎的聚簇索引和二级索引的存储结构后\",{\"1\":{\"234\":1}}],[\"存储引擎的行格式\",{\"1\":{\"154\":1}}],[\"存储引擎根据索引类型不同\",{\"1\":{\"234\":1}}],[\"存储引擎根据二级索引的\",{\"1\":{\"149\":1}}],[\"存储引擎在创建表时\",{\"1\":{\"234\":1}}],[\"存储引擎在二级索引定位到记录后\",{\"1\":{\"149\":1}}],[\"存储引擎支持多种索引数据结构\",{\"1\":{\"234\":1}}],[\"存储引擎会先写\",{\"1\":{\"339\":1}}],[\"存储引擎会根据不同的场景选择不同的列作为索引\",{\"1\":{\"204\":1}}],[\"存储引擎会自动将溢出的数据存放到\",{\"1\":{\"168\":1,\"169\":1}}],[\"存储引擎采用最多的索引类型\",{\"1\":{\"204\":1}}],[\"存储引擎\",{\"1\":{\"204\":1,\"234\":4,\"243\":1,\"257\":1,\"328\":1}}],[\"存储引擎有\",{\"1\":{\"202\":1,\"339\":1}}],[\"存储引擎时\",{\"1\":{\"197\":1,\"226\":1}}],[\"存储引擎是参与者\",{\"1\":{\"345\":1}}],[\"存储引擎是采用\",{\"1\":{\"242\":1}}],[\"存储引擎是支持事务的\",{\"1\":{\"197\":1}}],[\"存储引擎是用\",{\"1\":{\"156\":1}}],[\"存储引擎里\",{\"1\":{\"197\":1}}],[\"存储引擎来说明的\",{\"1\":{\"197\":1}}],[\"存储引擎来说明\",{\"1\":{\"190\":1}}],[\"存储引擎设计了一个缓冲池\",{\"1\":{\"172\":1,\"180\":1,\"335\":1}}],[\"存储引擎磁盘管理的最小单元\",{\"1\":{\"155\":1}}],[\"存储引擎展开讨论\",{\"1\":{\"152\":1}}],[\"存储引擎定位到二级索引后\",{\"1\":{\"149\":1}}],[\"存储引擎把下一条记录取出后就将其返回给执行器\",{\"1\":{\"148\":1}}],[\"存储引擎通过主键索引的\",{\"1\":{\"147\":1}}],[\"存放的是回滚数据的区的集合\",{\"1\":{\"157\":1}}],[\"存放应用程序运行时动态生成的\",{\"1\":{\"34\":1}}],[\"存放运行在\",{\"1\":{\"34\":1}}],[\"存放\",{\"1\":{\"34\":3,\"157\":2}}],[\"视图等等\",{\"1\":{\"272\":1}}],[\"视图等\",{\"1\":{\"138\":1}}],[\"另一次是\",{\"1\":{\"347\":1}}],[\"另一个就是在tomcat中实现jvm进程缓存\",{\"1\":{\"414\":1}}],[\"另一个事务已经\",{\"1\":{\"365\":1}}],[\"另一个事务就可以继续执行了\",{\"1\":{\"281\":1}}],[\"另一个拥有该间隙区间内的插入意向锁\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"另一个团队\",{\"1\":{\"12\":1}}],[\"另外一个事务要插入订单\",{\"1\":{\"274\":1}}],[\"另外一个是二级索引\",{\"1\":{\"232\":1}}],[\"另外\",{\"1\":{\"138\":1,\"162\":1,\"178\":1,\"207\":1,\"218\":1,\"226\":1,\"245\":1,\"248\":1,\"250\":1,\"252\":1,\"275\":1,\"309\":1,\"324\":1,\"329\":1,\"334\":1,\"365\":1,\"414\":1,\"424\":1}}],[\"先将被gc\",{\"1\":{\"529\":1}}],[\"先采用标记算法确定可回收对象\",{\"1\":{\"527\":1}}],[\"先定义一个接口抽取出抽象方法\",{\"1\":{\"508\":1}}],[\"先打给前台\",{\"1\":{\"507\":1}}],[\"先初始化main方法所在的类\",{\"1\":{\"492\":1}}],[\"先尝试扩容来减少链表长度\",{\"1\":{\"473\":1}}],[\"先查询redis\",{\"1\":{\"414\":1}}],[\"先执行\",{\"1\":{\"368\":1}}],[\"先开始从数据库查询账户余额大于\",{\"1\":{\"356\":1}}],[\"先开始从数据库中读取小林的余额数据\",{\"1\":{\"354\":1,\"355\":1}}],[\"先把日志写到\",{\"1\":{\"343\":1}}],[\"先写入到\",{\"1\":{\"338\":1}}],[\"先说明下实验环境\",{\"1\":{\"320\":1}}],[\"先创建一张\",{\"1\":{\"319\":1}}],[\"先创建一张商品表\",{\"1\":{\"204\":1}}],[\"先会加上表级别的意向独占锁\",{\"1\":{\"311\":1}}],[\"先要看看数据库中的长事务\",{\"1\":{\"310\":1}}],[\"先启用了事务\",{\"1\":{\"310\":1}}],[\"先备份了用户表的数据\",{\"1\":{\"307\":1}}],[\"先看事务\",{\"1\":{\"280\":1}}],[\"先插入了两个记录\",{\"1\":{\"312\":1}}],[\"先插入\",{\"1\":{\"280\":1}}],[\"先\",{\"1\":{\"274\":1}}],[\"先通过\",{\"1\":{\"273\":1}}],[\"先从根节点查找\",{\"1\":{\"256\":1}}],[\"先二分得出槽中间位是\",{\"1\":{\"243\":1}}],[\"先在表上加上意向独占锁\",{\"1\":{\"311\":1}}],[\"先在表上加上意向共享锁\",{\"1\":{\"311\":1}}],[\"先在\",{\"1\":{\"234\":1}}],[\"先按\",{\"1\":{\"215\":1}}],[\"先跟\",{\"1\":{\"159\":1}}],[\"先来说说表锁\",{\"1\":{\"309\":1}}],[\"先来说说非唯一索引等值查询时\",{\"1\":{\"296\":1}}],[\"先来说说\",{\"1\":{\"178\":1}}],[\"先来看一组测试数据\",{\"1\":{\"182\":1}}],[\"先来看第一条记录\",{\"1\":{\"161\":1,\"162\":1}}],[\"先来看看\",{\"1\":{\"152\":1}}],[\"先来一个上帝视角图\",{\"1\":{\"138\":1}}],[\"先不执行回表操作\",{\"1\":{\"149\":1}}],[\"先判断后执行的循环结构\",{\"1\":{\"56\":1}}],[\"零件\",{\"1\":{\"137\":1}}],[\"剥夺调度方式\",{\"1\":{\"135\":1}}],[\"非唯一索引加锁的流程图\",{\"1\":{\"300\":1}}],[\"非唯一索引和主键索引的范围查询的加锁规则不同之处在于\",{\"1\":{\"300\":1}}],[\"非唯一索引和主键索引的范围查询的加锁也有所不同\",{\"1\":{\"298\":1}}],[\"非唯一索引范围查询\",{\"0\":{\"298\":1},\"1\":{\"298\":1,\"300\":1}}],[\"非唯一索引等值查询时\",{\"1\":{\"296\":1}}],[\"非唯一索引等值查询的过程是一个扫描的过程\",{\"1\":{\"295\":1}}],[\"非唯一索引等值查询\",{\"0\":{\"295\":1},\"1\":{\"300\":1}}],[\"非唯一索引\",{\"1\":{\"288\":1,\"297\":2}}],[\"非唯一索引扫描\",{\"1\":{\"228\":1}}],[\"非\",{\"1\":{\"252\":2}}],[\"非聚簇索引\",{\"1\":{\"245\":1}}],[\"非索引\",{\"1\":{\"232\":1}}],[\"非叶子节点中有多少个子节点\",{\"1\":{\"253\":1,\"255\":1}}],[\"非叶子节点的索引也会同时存在在子节点中\",{\"1\":{\"253\":1}}],[\"非叶子节点只会存放索引\",{\"1\":{\"253\":1}}],[\"非叶子节点只存放索引\",{\"1\":{\"204\":1}}],[\"非叶子节点分为不同层次\",{\"1\":{\"244\":1}}],[\"非叶子节点内指向其他页的数量为\",{\"1\":{\"187\":1}}],[\"非叶子节点里的每条数据都指向新的页\",{\"1\":{\"187\":1}}],[\"非叶子节点\",{\"1\":{\"187\":1,\"244\":1}}],[\"非常重要\",{\"1\":{\"387\":1}}],[\"非常类似\",{\"1\":{\"168\":1}}],[\"非常像\",{\"1\":{\"158\":1}}],[\"非剥夺调度方式\",{\"1\":{\"135\":1}}],[\"非对称加密即加解密双方使用不同的密钥\",{\"1\":{\"107\":1}}],[\"非对称加密\",{\"0\":{\"107\":1},\"1\":{\"102\":1,\"107\":1}}],[\"75\",{\"1\":{\"473\":1}}],[\"7是\",{\"1\":{\"215\":1}}],[\"7号\",{\"1\":{\"178\":1}}],[\"7003\",{\"1\":{\"412\":1}}],[\"7003都是master\",{\"1\":{\"409\":1}}],[\"7001\",{\"1\":{\"407\":2,\"412\":1}}],[\"7004加入了集群\",{\"1\":{\"407\":1}}],[\"7004\",{\"1\":{\"406\":5,\"407\":1}}],[\"7002\",{\"1\":{\"393\":1,\"409\":1,\"410\":1,\"412\":1}}],[\"70\",{\"1\":{\"178\":1,\"436\":1,\"439\":1}}],[\"7和8\",{\"1\":{\"142\":1}}],[\"736\",{\"1\":{\"139\":1}}],[\"7\",{\"0\":{\"132\":1,\"452\":1,\"453\":1,\"454\":1},\"1\":{\"139\":1,\"144\":2,\"158\":1,\"164\":1,\"178\":1,\"185\":2,\"194\":1,\"205\":3,\"215\":3,\"216\":1,\"243\":1,\"244\":1,\"275\":1,\"294\":1,\"304\":3,\"324\":1,\"342\":1,\"348\":2}}],[\"7878\",{\"1\":{\"32\":1}}],[\"优势\",{\"1\":{\"456\":3}}],[\"优先查询redis缓存\",{\"1\":{\"449\":1}}],[\"优先查询jvm进程缓存\",{\"1\":{\"414\":1}}],[\"优先根据key查询jvm缓存\",{\"1\":{\"416\":1}}],[\"优先读取nginx本地缓存\",{\"1\":{\"414\":1}}],[\"优先读取浏览器本地缓存\",{\"1\":{\"414\":1}}],[\"优先从slave\",{\"1\":{\"398\":1}}],[\"优先从master节点读取\",{\"1\":{\"398\":1}}],[\"优先级越高\",{\"1\":{\"393\":1}}],[\"优先选择的是二级索引\",{\"1\":{\"192\":1}}],[\"优先插入\",{\"1\":{\"180\":1}}],[\"优化\",{\"1\":{\"272\":1}}],[\"优化阶段\",{\"1\":{\"150\":1}}],[\"优化器确定执行计划\",{\"1\":{\"333\":1}}],[\"优化器走的还是全表扫描\",{\"1\":{\"331\":1}}],[\"优化器最终选择的是索引扫描\",{\"1\":{\"329\":1}}],[\"优化器认为上面这样的查询过程的成本实在太高了\",{\"1\":{\"232\":1}}],[\"优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多\",{\"1\":{\"232\":1}}],[\"优化器就会选择二级索引进行扫描\",{\"1\":{\"196\":1}}],[\"优化器会使用key\",{\"1\":{\"194\":1}}],[\"优化器会基于查询成本的考虑\",{\"1\":{\"145\":1}}],[\"优化器基于查询成本的考虑\",{\"1\":{\"145\":1}}],[\"优化器主要负责将\",{\"1\":{\"145\":1}}],[\"优化器\",{\"0\":{\"145\":1},\"1\":{\"138\":1,\"145\":1,\"192\":1}}],[\"优点\",{\"1\":{\"130\":2,\"416\":2,\"516\":1,\"529\":1}}],[\"优雅强大\",{\"1\":{\"91\":1}}],[\"线程私有\",{\"1\":{\"539\":1}}],[\"线程来处理复制的请求\",{\"1\":{\"342\":1}}],[\"线程也比较多\",{\"1\":{\"342\":1}}],[\"线程\",{\"1\":{\"310\":3,\"342\":2}}],[\"线程的状态与转换\",{\"0\":{\"132\":1}}],[\"线程的实现方式\",{\"0\":{\"130\":1}}],[\"线程的实现方式和多线程模型\",{\"0\":{\"129\":1}}],[\"线程的属性\",{\"0\":{\"128\":1}}],[\"线程概念\",{\"0\":{\"125\":1}}],[\"线上版本\",{\"1\":{\"6\":1}}],[\"管理的策略\",{\"1\":{\"538\":1}}],[\"管理脏页+干净页\",{\"1\":{\"180\":1}}],[\"管理脏页\",{\"1\":{\"180\":1}}],[\"管理空闲页\",{\"1\":{\"180\":1}}],[\"管理连接\",{\"1\":{\"150\":1}}],[\"管理员角色名为\",{\"1\":{\"139\":1}}],[\"管理员收到请求后会将请求通知给\",{\"1\":{\"45\":1}}],[\"管道只能采用半双工通信\",{\"1\":{\"124\":1}}],[\"管道变空时\",{\"1\":{\"124\":1}}],[\"管道\",{\"1\":{\"124\":1,\"458\":1}}],[\"管道通信\",{\"0\":{\"124\":1}}],[\"信息写入\",{\"1\":{\"342\":1}}],[\"信息\",{\"1\":{\"280\":1,\"304\":1}}],[\"信息有存储了row\",{\"1\":{\"197\":1}}],[\"信息的不同\",{\"1\":{\"54\":1}}],[\"信箱\",{\"1\":{\"123\":1}}],[\"速度\",{\"1\":{\"526\":1}}],[\"速度更快\",{\"1\":{\"416\":1}}],[\"速度快\",{\"1\":{\"122\":1}}],[\"速度慢\",{\"1\":{\"122\":1}}],[\"灵活性高\",{\"1\":{\"122\":1}}],[\"极客时间\",{\"1\":{\"110\":1}}],[\"巨人的肩膀\",{\"1\":{\"110\":1}}],[\"搞懂了这些也就明白了为啥\",{\"1\":{\"110\":1}}],[\"拿去\",{\"1\":{\"312\":1}}],[\"拿一级证书的公钥解密一级证书\",{\"1\":{\"109\":1}}],[\"拿到商品id后\",{\"1\":{\"440\":1}}],[\"拿到二级证书的公钥和摘要验签\",{\"1\":{\"109\":1}}],[\"拿到后就可以用你安装的\",{\"1\":{\"108\":1}}],[\"拿到的才是未经篡改合法的摘要\",{\"1\":{\"108\":1}}],[\"拿到证书后计算摘要发现一样\",{\"1\":{\"108\":1}}],[\"拿到证书后\",{\"1\":{\"108\":1}}],[\"收到之后会如何验证这个证书呢\",{\"1\":{\"109\":1}}],[\"收费\",{\"1\":{\"91\":1}}],[\"现象\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"现象就是\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"现在准备插入一个数据7\",{\"1\":{\"226\":1}}],[\"现在就来回答一下\",{\"1\":{\"207\":1}}],[\"现在有一个\",{\"1\":{\"303\":1}}],[\"现在有一张用户表\",{\"1\":{\"303\":1}}],[\"现在有两个会话并行以下语句\",{\"1\":{\"197\":1}}],[\"现在有个编号为\",{\"1\":{\"178\":1}}],[\"现在有下面这条查询语句\",{\"1\":{\"149\":1}}],[\"现在不足\",{\"1\":{\"162\":1}}],[\"现在\",{\"1\":{\"161\":1,\"277\":2,\"280\":1,\"434\":1,\"449\":1,\"452\":1}}],[\"现在基本没人用了\",{\"1\":{\"158\":1}}],[\"现在再看这张图\",{\"1\":{\"150\":1}}],[\"现在我在表中将\",{\"1\":{\"145\":1}}],[\"现在我们知道事务在提交的时候\",{\"1\":{\"349\":1}}],[\"现在我们知道\",{\"1\":{\"217\":1}}],[\"现在我们知道了一张数据库表的数据是保存在\",{\"1\":{\"152\":1}}],[\"现在我们对\",{\"1\":{\"138\":1}}],[\"现在我们看看如果站点申请的是\",{\"1\":{\"109\":1}}],[\"现在最常用的存储引擎是\",{\"1\":{\"138\":1}}],[\"现有的javaocr工具包识别效果差强人意\",{\"1\":{\"99\":1}}],[\"小林coding\",{\"1\":{\"367\":2}}],[\"小林的账户余额为\",{\"1\":{\"360\":3}}],[\"小美\",{\"1\":{\"367\":1}}],[\"小于等于\",{\"1\":{\"292\":2,\"294\":4}}],[\"小于或者小于等于\",{\"0\":{\"294\":1},\"1\":{\"292\":1,\"294\":2}}],[\"小于\",{\"1\":{\"250\":1,\"252\":1,\"292\":2,\"294\":9,\"359\":1,\"360\":1}}],[\"小于根节点\",{\"1\":{\"250\":1}}],[\"小结\",{\"0\":{\"196\":1,\"375\":1,\"388\":1,\"394\":1,\"403\":1}}],[\"小时\",{\"1\":{\"139\":1}}],[\"小一点的\",{\"1\":{\"109\":1}}],[\"小小的真可爱🥰\",{\"1\":{\"95\":1}}],[\"三种回收算法的对比\",{\"0\":{\"526\":1}}],[\"三种策略对比\",{\"1\":{\"378\":1}}],[\"三\",{\"0\":{\"389\":1,\"420\":1,\"491\":1}}],[\"三个日志讲完了\",{\"1\":{\"343\":1}}],[\"三个格子从上至下分别表示\",{\"1\":{\"65\":1}}],[\"三叉树比二叉树的树高要矮\",{\"1\":{\"251\":1}}],[\"三次握手建立连接\",{\"1\":{\"139\":1}}],[\"三次握手\",{\"1\":{\"139\":3}}],[\"三级\",{\"1\":{\"109\":1}}],[\"二\",{\"0\":{\"381\":1,\"415\":1,\"482\":1}}],[\"二是可用性也很差\",{\"1\":{\"342\":1}}],[\"二进制日志\",{\"1\":{\"272\":1}}],[\"二进制位的值为0时\",{\"1\":{\"162\":1}}],[\"二进制位的值为1时\",{\"1\":{\"162\":1}}],[\"二进制位按照列的顺序逆序排列\",{\"1\":{\"162\":1}}],[\"二分查找树虽然是一个天然的二分结构\",{\"1\":{\"258\":1}}],[\"二分查找法每次都把查询的范围减半\",{\"1\":{\"249\":1}}],[\"二分查找法\",{\"1\":{\"249\":1}}],[\"二叉查找树由于存在退化成链表的可能性\",{\"1\":{\"250\":1}}],[\"二叉查找树就会退化成了一条链表\",{\"1\":{\"250\":1}}],[\"二叉查找树存在一个极端情况\",{\"1\":{\"250\":1}}],[\"二叉查找树解决了连续结构插入新元素开销很大的问题\",{\"1\":{\"250\":1}}],[\"二叉查找树解决了插入新节点的问题\",{\"1\":{\"250\":1}}],[\"二叉查找树查找某个节点的动图演示如下\",{\"1\":{\"250\":1}}],[\"二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点\",{\"1\":{\"250\":1}}],[\"二叉树\",{\"1\":{\"207\":1}}],[\"二叉树或\",{\"1\":{\"207\":1}}],[\"二级索引值\",{\"1\":{\"296\":1}}],[\"二级索引树是按照二级索引值\",{\"1\":{\"296\":1}}],[\"二级索引加了\",{\"1\":{\"280\":1}}],[\"二级索引查询商品\",{\"1\":{\"206\":1}}],[\"二级索引的叶子节点存放的是主键值\",{\"1\":{\"245\":1}}],[\"二级索引的叶子节点存放的数据是主键值\",{\"1\":{\"226\":1}}],[\"二级索引的\",{\"1\":{\"206\":1,\"208\":1,\"245\":1}}],[\"二级索引\",{\"1\":{\"145\":1,\"203\":2,\"206\":1,\"208\":1,\"216\":3,\"234\":5,\"245\":1,\"295\":1,\"297\":1,\"298\":1}}],[\"二级\",{\"1\":{\"109\":3}}],[\"二个出口\",{\"1\":{\"58\":1}}],[\"忙不过来\",{\"1\":{\"109\":1}}],[\"忙于当前的发布的同时\",{\"1\":{\"12\":1}}],[\"继续执行新的更新操作\",{\"1\":{\"339\":1}}],[\"继续执行\",{\"1\":{\"312\":1}}],[\"继续通过\",{\"1\":{\"304\":1}}],[\"继续通过二分法快速定位到符合页内范围包含查询值的页\",{\"1\":{\"244\":1}}],[\"继续向存储引擎索要下一条记录\",{\"1\":{\"149\":1}}],[\"继续往下授权啊\",{\"1\":{\"109\":1}}],[\"继承\",{\"1\":{\"66\":2}}],[\"继承是从上到下\",{\"1\":{\"61\":1}}],[\"授权认证\",{\"1\":{\"272\":1}}],[\"授权过了呢\",{\"1\":{\"109\":1}}],[\"授权即可\",{\"1\":{\"109\":1}}],[\"授权\",{\"1\":{\"109\":1}}],[\"他们相互不冲突\",{\"1\":{\"275\":1,\"323\":1}}],[\"他们区别在于\",{\"1\":{\"257\":1}}],[\"他们看起来是一条连着一条\",{\"1\":{\"184\":1}}],[\"他会把权力交给\",{\"1\":{\"109\":1}}],[\"他是不是要疯了\",{\"1\":{\"109\":1}}],[\"他也拿不到明文\",{\"1\":{\"104\":1}}],[\"办事\",{\"1\":{\"109\":1}}],[\"办公室\",{\"1\":{\"89\":1}}],[\"盾中执行\",{\"1\":{\"109\":1}}],[\"盾功能的一种\",{\"1\":{\"109\":1}}],[\"盾内置了证书\",{\"1\":{\"109\":1}}],[\"盾插到电脑上\",{\"1\":{\"109\":1}}],[\"端再根据\",{\"1\":{\"341\":1}}],[\"端验证了\",{\"1\":{\"109\":1}}],[\"端口是80\",{\"1\":{\"434\":1}}],[\"端口为7004\",{\"1\":{\"405\":1}}],[\"端口\",{\"1\":{\"35\":1}}],[\"避免内存碎片的问题\",{\"1\":{\"529\":1}}],[\"避免全量同步时的磁盘io\",{\"1\":{\"387\":1}}],[\"避免其他事务插入\",{\"1\":{\"291\":1}}],[\"避免了回表操作\",{\"1\":{\"228\":1}}],[\"避免在文件排序\",{\"1\":{\"219\":1}}],[\"避免安全风险\",{\"1\":{\"108\":1}}],[\"避免模棱两可和含混不清之处\",{\"1\":{\"58\":1}}],[\"整理\",{\"0\":{\"528\":1}}],[\"整个多级缓存中只差最后一环\",{\"1\":{\"452\":1}}],[\"整个key都是有效部分\",{\"1\":{\"402\":1}}],[\"整个发生幻读的时序图如下\",{\"1\":{\"367\":1}}],[\"整个数据库就处于只读状态了\",{\"1\":{\"307\":1}}],[\"整个进程都被阻塞\",{\"1\":{\"130\":1}}],[\"整个流程如下\",{\"1\":{\"108\":1}}],[\"整幅流程图的专业性就会大打折扣\",{\"1\":{\"55\":1}}],[\"验证\",{\"1\":{\"492\":1}}],[\"验证过程就结束了\",{\"1\":{\"109\":1}}],[\"验证通过之后即可开始通信\",{\"1\":{\"109\":1}}],[\"验证通过之后就会用\",{\"1\":{\"108\":1}}],[\"验签即可\",{\"1\":{\"108\":1}}],[\"抓\",{\"1\":{\"108\":1}}],[\"想必你也已经理解了这个思想\",{\"1\":{\"507\":1}}],[\"想对\",{\"1\":{\"280\":2}}],[\"想获取一个\",{\"1\":{\"280\":1}}],[\"想看某个章节的时候\",{\"1\":{\"243\":1}}],[\"想要更详细了解\",{\"1\":{\"235\":1}}],[\"想详细了解的可以去看这篇文章\",{\"1\":{\"228\":1}}],[\"想详细了解的可以看这篇\",{\"1\":{\"207\":1}}],[\"想想看在一个公司里如果大家都找\",{\"1\":{\"109\":1}}],[\"想想看是不是要先将银行发给我们的\",{\"1\":{\"109\":1}}],[\"想想看\",{\"1\":{\"108\":1}}],[\"想象一下上文中我们提到的学历\",{\"1\":{\"108\":1}}],[\"什么情况下插入语句会发生阻塞\",{\"1\":{\"296\":1}}],[\"什么情况下\",{\"1\":{\"296\":1}}],[\"什么情况下索引会失效\",{\"1\":{\"201\":1}}],[\"什么\",{\"0\":{\"283\":1}}],[\"什么时候会发生类初始化\",{\"1\":{\"478\":1,\"492\":1}}],[\"什么时候执行增量同步\",{\"1\":{\"388\":1}}],[\"什么时候执行全量同步\",{\"1\":{\"388\":1}}],[\"什么时候\",{\"1\":{\"343\":1}}],[\"什么时候才将\",{\"1\":{\"338\":1}}],[\"什么时候刷盘\",{\"0\":{\"338\":1,\"343\":1}}],[\"什么时候需要\",{\"0\":{\"220\":1}}],[\"什么时候不需要创建索引\",{\"0\":{\"222\":1},\"1\":{\"201\":1}}],[\"什么时候适用索引\",{\"0\":{\"221\":1},\"1\":{\"201\":1}}],[\"什么思路\",{\"1\":{\"108\":1}}],[\"什么是多级缓存\",{\"0\":{\"414\":1}}],[\"什么是增量同步\",{\"1\":{\"385\":1}}],[\"什么是幻读\",{\"0\":{\"302\":1,\"363\":1}}],[\"什么是隐式锁\",{\"1\":{\"276\":1}}],[\"什么是自平衡二叉树\",{\"0\":{\"251\":1}}],[\"什么是二分查找树\",{\"0\":{\"250\":1}}],[\"什么是二分查找\",{\"0\":{\"249\":1}}],[\"什么是索引\",{\"0\":{\"202\":1}}],[\"什么是\",{\"0\":{\"252\":1,\"253\":1},\"1\":{\"178\":1,\"337\":1}}],[\"什么是预读失效\",{\"1\":{\"178\":1}}],[\"什么是线程\",{\"0\":{\"126\":1}}],[\"什么是证书信任链\",{\"1\":{\"109\":1}}],[\"什么是双向认证\",{\"1\":{\"109\":1}}],[\"什么是e\",{\"0\":{\"89\":1}}],[\"什么是时序图\",{\"0\":{\"80\":1}}],[\"什么是nginx高可用\",{\"1\":{\"43\":1}}],[\"什么是nginx\",{\"0\":{\"20\":1}}],[\"答案是可以的\",{\"1\":{\"301\":1}}],[\"答案是不行\",{\"1\":{\"108\":1}}],[\"答案是用学历编号\",{\"1\":{\"108\":1}}],[\"颁发的\",{\"1\":{\"108\":1}}],[\"颁发的证书\",{\"1\":{\"108\":1,\"109\":1}}],[\"无需等到内存不够的时候才开始回收\",{\"1\":{\"516\":1}}],[\"无需从最小记录开始遍历整个页中的记录链表\",{\"1\":{\"243\":1}}],[\"无需再回表读取数据来进行判断\",{\"1\":{\"239\":1}}],[\"无需传输\",{\"1\":{\"108\":1}}],[\"无法共享\",{\"1\":{\"416\":1}}],[\"无法完成增量同步了\",{\"1\":{\"386\":1}}],[\"无法成功插入\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"无法插入\",{\"1\":{\"297\":1}}],[\"无法插入成功\",{\"1\":{\"296\":2,\"297\":1}}],[\"无法利用索引树的有序性来快速定位数据\",{\"1\":{\"232\":1}}],[\"无法把前缀索引用作覆盖索引\",{\"1\":{\"224\":1}}],[\"无序\",{\"1\":{\"216\":2}}],[\"无关\",{\"1\":{\"216\":1}}],[\"无非就是\",{\"1\":{\"110\":1}}],[\"无论输入的消息有多长\",{\"1\":{\"108\":1}}],[\"无论你是偶然路过的访客\",{\"1\":{\"1\":1}}],[\"内容如下\",{\"1\":{\"442\":1,\"463\":1}}],[\"内容刷新到磁盘中\",{\"1\":{\"155\":1,\"243\":1}}],[\"内置函数\",{\"1\":{\"272\":1}}],[\"内置在操作系统上的\",{\"1\":{\"108\":1}}],[\"内连接查询的是两张表交集部分的数\",{\"1\":{\"263\":1}}],[\"内连接\",{\"0\":{\"263\":1},\"1\":{\"261\":1}}],[\"内存结构规定了\",{\"1\":{\"538\":1}}],[\"内存结构是\",{\"1\":{\"538\":1}}],[\"内存结构相关知识\",{\"0\":{\"537\":1}}],[\"内存概述\",{\"0\":{\"538\":1}}],[\"内存敏感的高速缓存\",{\"1\":{\"520\":1}}],[\"内存不足\",{\"1\":{\"516\":1}}],[\"内存空间的一半时\",{\"1\":{\"338\":1}}],[\"内存也可以撑\",{\"1\":{\"185\":1}}],[\"内存数据和磁盘数据一致\",{\"1\":{\"178\":1}}],[\"内存篇\",{\"1\":{\"96\":1}}],[\"内部调用了运行时类的空参的构造器\",{\"1\":{\"498\":1}}],[\"内部开启一个\",{\"1\":{\"345\":1}}],[\"内部\",{\"1\":{\"345\":2}}],[\"内部架构里的各个功能模块\",{\"1\":{\"138\":1}}],[\"内部的结构\",{\"1\":{\"137\":1}}],[\"内部的架构\",{\"1\":{\"137\":1}}],[\"内核级线程\",{\"1\":{\"130\":1}}],[\"被弱引用关联的对象一定会被回收\",{\"1\":{\"521\":1}}],[\"被软引用关联的对象只有在内存不够的情况下才会被回收\",{\"1\":{\"520\":1}}],[\"被强引用关联的对象不会被回收\",{\"1\":{\"519\":1}}],[\"被代理类的对象\",{\"1\":{\"507\":2}}],[\"被代理类的调用要通过代理类\",{\"1\":{\"506\":1}}],[\"被代理类\",{\"1\":{\"506\":1}}],[\"被修改\",{\"1\":{\"337\":1}}],[\"被老板教训了一波\",{\"1\":{\"328\":1}}],[\"被\",{\"1\":{\"312\":1}}],[\"被问到一个关于\",{\"1\":{\"318\":1}}],[\"被问到关于幻读的问题\",{\"1\":{\"301\":1}}],[\"被问到这么个问题\",{\"1\":{\"151\":1}}],[\"被删除\",{\"1\":{\"291\":1}}],[\"被啪啪啪的打脸了\",{\"1\":{\"189\":1}}],[\"被访问不会移动到链表头部\",{\"1\":{\"178\":1}}],[\"被访问\",{\"1\":{\"178\":1}}],[\"被操作系统信任\",{\"1\":{\"108\":1}}],[\"被继承\",{\"1\":{\"61\":1}}],[\"细心的你一定发现了问题\",{\"1\":{\"108\":1}}],[\"摘要比对不成功的话\",{\"1\":{\"108\":1}}],[\"后访问的事务必须等前一个事务执行完成\",{\"1\":{\"357\":1}}],[\"后续命令则记录在repl\",{\"1\":{\"388\":1}}],[\"后续的查询语句利用这个\",{\"1\":{\"364\":1}}],[\"后续交由操作系统决定何时将数据持久化到磁盘\",{\"1\":{\"343\":1}}],[\"后续在持久化到磁盘如下图\",{\"1\":{\"337\":1}}],[\"后续\",{\"1\":{\"337\":1}}],[\"后续由后台线程选择一个合适的时机将脏页写入到磁盘\",{\"1\":{\"335\":1,\"343\":1,\"350\":1}}],[\"后续有对该表的\",{\"1\":{\"310\":1}}],[\"后续该用户在此连接里的任何操作\",{\"1\":{\"139\":1}}],[\"后来发现当时的文章写的不够详细\",{\"1\":{\"282\":1}}],[\"后来判断表或字段是否存在的工作就被放入到\",{\"1\":{\"144\":1}}],[\"后一个事务在执行这条语句的时候\",{\"1\":{\"275\":1}}],[\"后者在磁盘中\",{\"1\":{\"272\":1}}],[\"后面就出来了\",{\"1\":{\"252\":1}}],[\"后面就有人提出平衡二叉查找树\",{\"1\":{\"251\":1}}],[\"后面我们详细介绍\",{\"1\":{\"154\":1}}],[\"后缀为\",{\"1\":{\"235\":1}}],[\"后的条件列不是索引列\",{\"1\":{\"228\":1,\"240\":1,\"241\":1}}],[\"后就停止匹配了\",{\"1\":{\"216\":4}}],[\"后台线程\",{\"1\":{\"346\":1}}],[\"后台线程回定期将适量的脏页刷入到磁盘\",{\"1\":{\"179\":1}}],[\"后台线程就可以遍历\",{\"1\":{\"177\":1}}],[\"后\",{\"1\":{\"108\":1,\"174\":1,\"179\":1,\"217\":1,\"275\":1,\"285\":1,\"314\":1,\"335\":1,\"336\":1,\"358\":2}}],[\"得先要从磁盘读取该记录\",{\"1\":{\"335\":1}}],[\"得自己画出二级索引的\",{\"1\":{\"296\":1}}],[\"得需要回表操作才能完成查询的工作\",{\"1\":{\"232\":1}}],[\"得出结论是解析器只负责构建语法树和检查语法\",{\"1\":{\"142\":1}}],[\"得到对应的策略类\",{\"1\":{\"508\":1}}],[\"得到索引\",{\"1\":{\"474\":1}}],[\"得到的数据为空处理\",{\"1\":{\"450\":2}}],[\"得到的结果是2765\",{\"1\":{\"402\":1}}],[\"得到的结果是15495\",{\"1\":{\"402\":1}}],[\"得到的结果就是slot值\",{\"1\":{\"402\":1}}],[\"得到下面的反馈\",{\"1\":{\"408\":1}}],[\"得到了\",{\"1\":{\"368\":1}}],[\"得到\",{\"1\":{\"312\":1}}],[\"得到服务器的公钥和摘要验签\",{\"1\":{\"109\":1}}],[\"得到任务的\",{\"1\":{\"45\":1}}],[\"得用\",{\"1\":{\"108\":1,\"341\":1}}],[\"误以为此证书是合法就中招了\",{\"1\":{\"108\":1}}],[\"私钥签名\",{\"1\":{\"108\":1}}],[\"私钥对摘要加密呢\",{\"1\":{\"108\":1}}],[\"私钥加密其实这个说法其实并不严谨\",{\"1\":{\"107\":1}}],[\"私钥加密的内容\",{\"1\":{\"107\":1}}],[\"签名\",{\"1\":{\"108\":1}}],[\"生成一个\",{\"1\":{\"357\":1}}],[\"生成的范围为\",{\"1\":{\"325\":1}}],[\"生成的间隙锁\",{\"1\":{\"324\":1}}],[\"生成的结果里面\",{\"1\":{\"312\":1}}],[\"生成的\",{\"1\":{\"277\":1,\"312\":1,\"338\":1}}],[\"生成摘要\",{\"1\":{\"108\":1}}],[\"生命线代表时序图中的对象在一段时期内的存在\",{\"1\":{\"81\":1}}],[\"生命线详见下方\",{\"1\":{\"81\":1}}],[\"生命线\",{\"1\":{\"79\":1,\"81\":1}}],[\"步骤如下\",{\"1\":{\"108\":1,\"411\":1}}],[\"证书中的公钥来加密对称密钥了\",{\"1\":{\"108\":1}}],[\"证书中的公钥来解密签名\",{\"1\":{\"108\":1}}],[\"证书来验签等\",{\"1\":{\"108\":1}}],[\"证书\",{\"1\":{\"108\":2}}],[\"证书上\",{\"1\":{\"108\":1}}],[\"证书明文较长\",{\"1\":{\"108\":1}}],[\"证书的数字签名该如何产生的呢\",{\"1\":{\"108\":1}}],[\"证书由站点管理者向\",{\"1\":{\"108\":1}}],[\"问题\",{\"1\":{\"252\":1,\"492\":1}}],[\"问题来了\",{\"1\":{\"166\":1,\"304\":1}}],[\"问题二\",{\"1\":{\"108\":1,\"507\":1}}],[\"问题一\",{\"1\":{\"108\":1,\"507\":1}}],[\"问题修复后\",{\"1\":{\"7\":1}}],[\"看完这个例子\",{\"1\":{\"506\":1}}],[\"看完之后你会有一种突然被顿悟的感觉\",{\"1\":{\"282\":1}}],[\"看不到\",{\"1\":{\"367\":1}}],[\"看见\",{\"1\":{\"357\":1}}],[\"看见了\",{\"1\":{\"357\":1}}],[\"看下该位置的下一条记录是否存在间隙锁\",{\"1\":{\"296\":1}}],[\"看\",{\"1\":{\"217\":1}}],[\"看到有位读者说了这么一件事\",{\"1\":{\"328\":1}}],[\"看到第三步的时候\",{\"1\":{\"243\":1}}],[\"看到一个简单的测试方式\",{\"1\":{\"238\":1}}],[\"看到实际走了\",{\"1\":{\"235\":1}}],[\"看到\",{\"1\":{\"194\":1,\"359\":1}}],[\"看到这个图之后\",{\"1\":{\"186\":1}}],[\"看到这组数据似乎好像真的和标题对应\",{\"1\":{\"182\":1}}],[\"看上图中\",{\"1\":{\"186\":1}}],[\"看起来会比较轻松\",{\"1\":{\"306\":1}}],[\"看起来就像下面这样\",{\"1\":{\"168\":1}}],[\"看起来确实很完美\",{\"1\":{\"108\":1}}],[\"看能不能成功创建一张表\",{\"1\":{\"166\":1}}],[\"看看这三种日志是怎么工作的\",{\"1\":{\"333\":1}}],[\"看看会出现什么意外的情况\",{\"1\":{\"307\":1}}],[\"看看每个节点长啥样\",{\"1\":{\"242\":1}}],[\"看看上面的建表\",{\"1\":{\"183\":1}}],[\"看看里面有什么文件\",{\"1\":{\"152\":1}}],[\"看看执行器是怎么工作的\",{\"1\":{\"147\":1}}],[\"看看之前有没有执行过这一条命令\",{\"1\":{\"140\":1}}],[\"看看是什么类型的语句\",{\"1\":{\"140\":1}}],[\"看看内部里的每一个\",{\"1\":{\"137\":1}}],[\"看了上一节\",{\"1\":{\"104\":1}}],[\"申请物理内存\",{\"1\":{\"336\":1}}],[\"申请自增主键后就释放锁\",{\"1\":{\"312\":2}}],[\"申请一片连续的内存空间\",{\"1\":{\"174\":1,\"336\":1}}],[\"申请的合法证书\",{\"1\":{\"108\":1}}],[\"申请的时候会提交\",{\"1\":{\"108\":1}}],[\"申请\",{\"1\":{\"108\":1,\"310\":2}}],[\"申请证书即可\",{\"1\":{\"109\":1}}],[\"申请证书\",{\"1\":{\"108\":2,\"109\":1}}],[\"企业拿到证书后用学历编号在学信网上一查就知道证书真伪了\",{\"1\":{\"108\":1}}],[\"企业如何认定你提供的学历证书是真是假呢\",{\"1\":{\"108\":1}}],[\"企业一般会要求提供学历证明\",{\"1\":{\"108\":1}}],[\"企鹅\",{\"1\":{\"66\":1}}],[\"员工入职时\",{\"1\":{\"108\":1}}],[\"呢\",{\"1\":{\"107\":1,\"251\":1}}],[\"传统的缓存策略一般是请求到达tomcat后\",{\"1\":{\"414\":1}}],[\"传统流程图\",{\"1\":{\"58\":1}}],[\"传过来的二级证书\",{\"1\":{\"109\":1}}],[\"传了传给二级\",{\"1\":{\"109\":1}}],[\"传给\",{\"1\":{\"108\":1}}],[\"传输证书的合法性\",{\"1\":{\"109\":1}}],[\"传输\",{\"1\":{\"108\":1}}],[\"传输到\",{\"1\":{\"108\":1}}],[\"传输是安全的\",{\"1\":{\"107\":1}}],[\"向上一级询问是否加载过了\",{\"1\":{\"494\":1}}],[\"向集群中添加一个新的master节点\",{\"1\":{\"405\":1}}],[\"向表中新插入了一条\",{\"1\":{\"367\":1}}],[\"向事务\",{\"1\":{\"325\":1}}],[\"向该表插入一条\",{\"1\":{\"317\":1}}],[\"向获取\",{\"1\":{\"280\":1}}],[\"向操作系统申请的一片连续的内存空间\",{\"1\":{\"173\":1}}],[\"向右读就是真实数据\",{\"1\":{\"161\":1,\"163\":1}}],[\"向\",{\"1\":{\"107\":1}}],[\"准动态语言\",{\"1\":{\"480\":1}}],[\"准备阶段\",{\"1\":{\"344\":1}}],[\"准备\",{\"1\":{\"344\":1,\"492\":1}}],[\"准备工作\",{\"0\":{\"319\":1},\"1\":{\"42\":1}}],[\"准确的说私钥加密应该叫私钥签名\",{\"1\":{\"107\":1}}],[\"公钥如何安全地传输到\",{\"1\":{\"108\":1}}],[\"公钥才能解密\",{\"1\":{\"108\":1}}],[\"公钥加密的密文只有私钥可以解密\",{\"1\":{\"107\":1}}],[\"公交卡系统数据库等等\",{\"1\":{\"89\":1}}],[\"甚至代码可以被引进\",{\"1\":{\"480\":1}}],[\"甚至崩溃\",{\"1\":{\"331\":1}}],[\"甚至\",{\"1\":{\"255\":1}}],[\"甚至可以不动非叶子节点\",{\"1\":{\"255\":1}}],[\"甚至可能会通过文件排序\",{\"1\":{\"228\":1}}],[\"甚至几十万倍\",{\"1\":{\"248\":1}}],[\"甚至需要从一个页面复制数据到另外一个页面\",{\"1\":{\"226\":1}}],[\"甚至替换掉密钥以达到篡改报文的目的\",{\"1\":{\"106\":1}}],[\"甚至一个方法里面有很多分支语句的\",{\"1\":{\"84\":1}}],[\"元和对\",{\"1\":{\"352\":1}}],[\"元和\",{\"1\":{\"352\":1}}],[\"元数据锁\",{\"0\":{\"310\":1},\"1\":{\"308\":1}}],[\"元\",{\"1\":{\"104\":1,\"351\":1,\"352\":10}}],[\"你看\",{\"1\":{\"445\":1}}],[\"你的插槽是从哪里移动过来的\",{\"1\":{\"408\":1}}],[\"你的余额多了\",{\"1\":{\"351\":1}}],[\"你就可以在写数据时只写主库\",{\"1\":{\"342\":1}}],[\"你在主库上执行的结果并不是你在从库执行的结果\",{\"1\":{\"341\":1}}],[\"你怎么通过索引来提高查询效率呢\",{\"1\":{\"219\":1}}],[\"你能将这些索引分一下类吗\",{\"1\":{\"203\":1}}],[\"你知道索引有哪些吗\",{\"1\":{\"203\":1}}],[\"你会在执行计划的结果发现这条语句会走全表扫描\",{\"1\":{\"238\":1}}],[\"你会选择一页一页的找呢\",{\"1\":{\"202\":1}}],[\"你会观察到使用的虚拟内存空间很大\",{\"1\":{\"174\":1,\"336\":1}}],[\"你可能会好奇\",{\"1\":{\"197\":1}}],[\"你可以在上图的\",{\"1\":{\"359\":1}}],[\"你可以看查\",{\"1\":{\"280\":1}}],[\"你可以执行\",{\"1\":{\"139\":1}}],[\"你可以把用于维护的分支看成是依附于master的一种特别的发布分支\",{\"1\":{\"13\":1}}],[\"你试想一下\",{\"1\":{\"187\":1}}],[\"你这个表数据都马上要到\",{\"1\":{\"181\":1}}],[\"你想想啊\",{\"1\":{\"174\":1}}],[\"你应该就清楚\",{\"1\":{\"164\":1}}],[\"你还会解锁这些面试题\",{\"1\":{\"151\":1}}],[\"你妈是你妈\",{\"1\":{\"104\":1}}],[\"身份认证只是\",{\"1\":{\"109\":1}}],[\"身份认证\",{\"1\":{\"104\":1}}],[\"身份认证和不可否认\",{\"1\":{\"104\":1}}],[\"保持与master之间的同步\",{\"1\":{\"384\":1}}],[\"保持原样\",{\"1\":{\"104\":1}}],[\"保存未被刷入磁盘的脏页日志\",{\"1\":{\"341\":1}}],[\"保存的是全量的日志\",{\"1\":{\"341\":1}}],[\"保障事务的原子性\",{\"1\":{\"334\":1}}],[\"保护\",{\"1\":{\"280\":1}}],[\"保护访问和私有访问\",{\"1\":{\"73\":1}}],[\"保证此构造器是可访问的\",{\"1\":{\"503\":1}}],[\"保证当前方法是可访问的\",{\"1\":{\"502\":1}}],[\"保证当前属性是可访问的\",{\"1\":{\"501\":1}}],[\"保证父类有此构造器\",{\"1\":{\"498\":1}}],[\"保证核心\",{\"1\":{\"494\":1}}],[\"保证数据安全\",{\"1\":{\"494\":1}}],[\"保证了\",{\"1\":{\"538\":1}}],[\"保证了事务四大特性中的持久性\",{\"1\":{\"337\":1}}],[\"保证了查询操作的时间复杂度就会一直维持在\",{\"1\":{\"258\":1}}],[\"保证了密钥不会出现在内存中\",{\"1\":{\"109\":1}}],[\"保证缓存和磁盘数据一致\",{\"1\":{\"179\":1}}],[\"保管好私钥\",{\"1\":{\"107\":1}}],[\"冒充风险\",{\"1\":{\"103\":1}}],[\"冒号前面可以有示例名称也可以没有示例名称\",{\"1\":{\"75\":1}}],[\"风险极大\",{\"1\":{\"103\":1}}],[\"中非常重要的一部分\",{\"1\":{\"538\":1}}],[\"中等\",{\"1\":{\"526\":1}}],[\"中引用的对象\",{\"1\":{\"517\":1}}],[\"中只会有一个class实例\",{\"1\":{\"483\":1}}],[\"中事件\",{\"1\":{\"458\":1}}],[\"中事务\",{\"1\":{\"358\":1}}],[\"中至少包含1个字符\",{\"1\":{\"402\":1}}],[\"中途插入了一条记录\",{\"1\":{\"364\":1}}],[\"中途如果哪怕改了一个标点符号\",{\"1\":{\"104\":1}}],[\"中最小的事务\",{\"1\":{\"359\":1}}],[\"中四个字段作用\",{\"1\":{\"358\":1}}],[\"中余额\",{\"1\":{\"357\":2}}],[\"中已经有了事务记录\",{\"1\":{\"348\":1}}],[\"中没有该组事务的记录\",{\"1\":{\"348\":1}}],[\"中没有当前内部\",{\"1\":{\"346\":1}}],[\"中查找到与\",{\"1\":{\"346\":2}}],[\"中查找更详细的目录项\",{\"1\":{\"244\":1}}],[\"中有当前内部\",{\"1\":{\"346\":1}}],[\"中有两个指针\",{\"1\":{\"243\":1}}],[\"中间再穿插写入binlog\",{\"1\":{\"345\":1}}],[\"中间人\",{\"1\":{\"108\":1}}],[\"中间人中途虽然可以替换自己向\",{\"1\":{\"108\":1}}],[\"中间人也不例外\",{\"1\":{\"108\":1}}],[\"中间人可以替换掉证书明文\",{\"1\":{\"108\":1}}],[\"中间人可以篡改报文内容后再发送给对方\",{\"1\":{\"103\":1}}],[\"中间人可以获取到通信内容\",{\"1\":{\"103\":1}}],[\"中继日志\",{\"1\":{\"342\":1}}],[\"中记录的写入量大于\",{\"1\":{\"338\":1}}],[\"中会把记录中的内容都记下来\",{\"1\":{\"334\":1}}],[\"中会发生数据不一致的问题\",{\"1\":{\"312\":1}}],[\"中插入数据的场景\",{\"1\":{\"312\":1}}],[\"中插入数据\",{\"1\":{\"312\":1}}],[\"中插入了\",{\"1\":{\"312\":1}}],[\"中插入了一条记录\",{\"1\":{\"277\":1,\"324\":1}}],[\"中索引的数据结构就是采用了\",{\"1\":{\"253\":1}}],[\"中索引的数据结构和刚刚描述的页几乎是一模一样的\",{\"1\":{\"186\":1}}],[\"中留言区一位读者朋友出的问题\",{\"1\":{\"230\":1}}],[\"中进行索引查询\",{\"1\":{\"216\":3}}],[\"中进行查找\",{\"1\":{\"205\":2}}],[\"中常见的基于范围的顺序查找\",{\"1\":{\"207\":1}}],[\"中并不是这个意思\",{\"1\":{\"194\":1}}],[\"中就有了索引的概念\",{\"1\":{\"185\":1}}],[\"中时\",{\"1\":{\"176\":1}}],[\"中数据所在的页\",{\"1\":{\"172\":1,\"179\":1,\"335\":1}}],[\"中磁盘和内存交互的基本单位是页\",{\"1\":{\"168\":1}}],[\"中指向下一个记录的指针\",{\"1\":{\"161\":1}}],[\"中每一张表的数据都存放在一个独立的\",{\"1\":{\"152\":1}}],[\"中建立一张表都会生成一个\",{\"1\":{\"152\":1}}],[\"中\",{\"0\":{\"165\":1},\"1\":{\"151\":1,\"161\":1,\"165\":1,\"166\":5,\"168\":5,\"169\":5,\"172\":1,\"174\":2,\"178\":2,\"216\":1,\"225\":1,\"238\":1,\"244\":2,\"281\":1,\"333\":1,\"335\":2,\"336\":2,\"338\":2,\"341\":1,\"343\":1,\"344\":1,\"350\":1,\"359\":2,\"507\":1}}],[\"中的反射机制是指在运行状态中\",{\"1\":{\"481\":1}}],[\"中的部分是有效部分\",{\"1\":{\"402\":1}}],[\"中的某个数值\",{\"1\":{\"343\":1}}],[\"中的脏页刷新到磁盘中\",{\"1\":{\"339\":1}}],[\"中的脏页丢失而设计的\",{\"1\":{\"339\":1}}],[\"中的历史数据将数据恢复到事务开始之前的状态\",{\"1\":{\"334\":1}}],[\"中的原子性\",{\"1\":{\"334\":1}}],[\"中的块大小为\",{\"1\":{\"248\":1}}],[\"中的记录都是排序好的\",{\"1\":{\"221\":1}}],[\"中的目录\",{\"1\":{\"187\":1}}],[\"中的缓存页\",{\"1\":{\"174\":1}}],[\"中的页就叫做缓存页\",{\"1\":{\"174\":1,\"336\":1}}],[\"中的数据从主库传输到从库上\",{\"1\":{\"342\":1}}],[\"中的数据\",{\"1\":{\"172\":1,\"335\":1}}],[\"中的信息之所以要逆序存放\",{\"1\":{\"161\":1}}],[\"中的\",{\"0\":{\"257\":1},\"1\":{\"144\":1,\"150\":1,\"234\":2,\"275\":1,\"279\":1,\"280\":1,\"290\":1,\"304\":1,\"322\":1,\"336\":1,\"337\":1,\"338\":2,\"343\":1,\"346\":2,\"348\":2,\"350\":1,\"358\":2,\"359\":2,\"360\":2,\"367\":1}}],[\"中期间发生了什么\",{\"1\":{\"137\":1}}],[\"中级调度\",{\"1\":{\"134\":1}}],[\"中云监测平台长期存在两个分支master跟develop分支\",{\"1\":{\"7\":1}}],[\"窃听风险\",{\"1\":{\"103\":1}}],[\"安排负责事情\",{\"1\":{\"507\":1}}],[\"安全性和性能折中的方案就是参数\",{\"1\":{\"338\":1}}],[\"安全等等\",{\"1\":{\"272\":1}}],[\"安全通信的四大原则\",{\"0\":{\"104\":1},\"1\":{\"102\":1}}],[\"安装canal\",{\"0\":{\"457\":1}}],[\"安装openresty\",{\"0\":{\"432\":1}}],[\"安装包大\",{\"1\":{\"91\":1}}],[\"安装包小\",{\"1\":{\"91\":1}}],[\"安装之后\",{\"1\":{\"43\":1}}],[\"安装tomcat\",{\"0\":{\"33\":1}}],[\"安装nginx\",{\"0\":{\"27\":1}}],[\"安装\",{\"1\":{\"26\":2,\"28\":1,\"91\":1}}],[\"安装相关依赖\",{\"0\":{\"26\":1}}],[\"今天我心情好\",{\"1\":{\"351\":1}}],[\"今天给大家介绍了\",{\"1\":{\"241\":1}}],[\"今天就来图解\",{\"1\":{\"351\":1}}],[\"今天就来跟大家盘一盘\",{\"1\":{\"233\":1}}],[\"今天就带大家\",{\"1\":{\"201\":1}}],[\"今天就聊\",{\"1\":{\"171\":1}}],[\"今天试图由浅入深地把\",{\"1\":{\"102\":1}}],[\"今天翻了一下以前的旧相片\",{\"1\":{\"95\":1}}],[\"没加锁索引会加表锁\",{\"1\":{\"329\":1}}],[\"没加索引会锁全表\",{\"0\":{\"328\":1},\"1\":{\"96\":1,\"275\":1}}],[\"没执行事务\",{\"1\":{\"280\":1}}],[\"没错\",{\"1\":{\"186\":1,\"278\":1,\"351\":1}}],[\"没啥问题\",{\"1\":{\"185\":1}}],[\"没试过\",{\"1\":{\"181\":1}}],[\"没有安全方面的问题\",{\"1\":{\"492\":1}}],[\"没有任何代码侵入\",{\"1\":{\"456\":1}}],[\"没有网络开销\",{\"1\":{\"416\":1}}],[\"没有了\",{\"1\":{\"408\":1}}],[\"没有\",{\"1\":{\"340\":1,\"348\":1}}],[\"没有参数\",{\"1\":{\"338\":1}}],[\"没有使用索引列作为查询条件\",{\"1\":{\"299\":1}}],[\"没有加索引的查询\",{\"0\":{\"299\":1}}],[\"没有考虑\",{\"1\":{\"296\":1}}],[\"没有对应的数据行\",{\"1\":{\"270\":1}}],[\"没有实现\",{\"1\":{\"237\":1}}],[\"没有遵循最左匹配原则\",{\"1\":{\"232\":1}}],[\"没有性能差异\",{\"1\":{\"194\":1}}],[\"没有二级索引时\",{\"1\":{\"192\":1,\"193\":1}}],[\"没有索引下推的时候\",{\"1\":{\"149\":1}}],[\"没有人给他签名认证\",{\"1\":{\"109\":1}}],[\"没有讲全\",{\"1\":{\"102\":1}}],[\"网上很多资料说\",{\"1\":{\"329\":1}}],[\"网上挺多介绍\",{\"1\":{\"102\":1}}],[\"网卡名称\",{\"1\":{\"43\":1}}],[\"那~下篇文章见o\",{\"1\":{\"508\":1}}],[\"那不就变成了aop吗\",{\"1\":{\"507\":1}}],[\"那赵老板是不是告诉每个人自己新加了一个秘书叫李秘书\",{\"1\":{\"506\":1}}],[\"那个node来接收这些插槽\",{\"1\":{\"408\":1}}],[\"那读提交隔离级别是怎么工作呢\",{\"1\":{\"360\":1}}],[\"那这两个事务创建的\",{\"1\":{\"359\":1}}],[\"那这样在槽内查找某个记录的时间复杂度不就是\",{\"1\":{\"243\":1}}],[\"那有\",{\"1\":{\"348\":1}}],[\"那有什么其他方式可以避免\",{\"1\":{\"307\":1}}],[\"那直接修改\",{\"1\":{\"335\":1}}],[\"那修改完这条记录是选择直接写回到磁盘\",{\"1\":{\"335\":1}}],[\"那如果数据库有一个长事务\",{\"1\":{\"310\":1}}],[\"那如何找到最小记录\",{\"1\":{\"243\":1}}],[\"那它是在什么时候释放的\",{\"1\":{\"310\":1}}],[\"那它就向下一级\",{\"1\":{\"109\":1}}],[\"那是不是二叉查找树就可以作为索引的数据结构了呢\",{\"1\":{\"250\":1}}],[\"那是在联合索引里判断\",{\"1\":{\"217\":1}}],[\"那我们可以直接将\",{\"1\":{\"281\":1}}],[\"那我们能不能设计一个非线形且天然适合二分查找的数据结构呢\",{\"1\":{\"250\":1}}],[\"那我们为什么需要使用前缀来建立索引呢\",{\"1\":{\"224\":1}}],[\"那我们给报文加密不就行了\",{\"1\":{\"106\":1}}],[\"那在对表结构做变更操作的时候\",{\"1\":{\"310\":1}}],[\"那在联合索引的\",{\"1\":{\"217\":1}}],[\"那在分配足够多的控制块和缓存页后\",{\"1\":{\"174\":1}}],[\"那换到数据库中\",{\"1\":{\"202\":1}}],[\"那\",{\"1\":{\"187\":1,\"243\":1,\"296\":1,\"329\":1,\"358\":1}}],[\"那比如我实际当行的数据占用空间不是\",{\"1\":{\"187\":1}}],[\"那一页就能存下\",{\"1\":{\"187\":1}}],[\"那整个页的大小是\",{\"1\":{\"187\":1}}],[\"那按照二分法查找的规则\",{\"1\":{\"187\":1}}],[\"那下面就来说说\",{\"1\":{\"185\":1}}],[\"那下面我们就来看看这个建议值\",{\"1\":{\"182\":1}}],[\"那就会导致jvm启动gc\",{\"1\":{\"527\":1}}],[\"那就会全表扫描\",{\"1\":{\"145\":1}}],[\"那就可以保证同一个商品\",{\"1\":{\"446\":1}}],[\"那就发生了幻读的问题\",{\"1\":{\"302\":2,\"363\":2}}],[\"那就没必须加\",{\"1\":{\"291\":1}}],[\"那就继续比对\",{\"1\":{\"187\":1}}],[\"那就是\",{\"1\":{\"178\":1,\"183\":1,\"187\":2}}],[\"那到底是什么场景呢\",{\"1\":{\"288\":1}}],[\"那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢\",{\"1\":{\"216\":1}}],[\"那到底是怎么个回事呢\",{\"1\":{\"185\":1}}],[\"那到底怎么才能避免呢\",{\"1\":{\"178\":1}}],[\"那到底谁来做检测表和字段是否存在的工作呢\",{\"1\":{\"142\":1}}],[\"那为了避免这些问题\",{\"1\":{\"361\":1}}],[\"那为了实现非主键字段的快速搜索\",{\"1\":{\"245\":1}}],[\"那为了能快速知道哪些缓存页是脏的\",{\"1\":{\"177\":1}}],[\"那为啥要用第三方权威机构\",{\"1\":{\"108\":1}}],[\"那当我们从磁盘读取数据的时候\",{\"1\":{\"176\":1}}],[\"那假设数据库表只有一个\",{\"1\":{\"166\":1}}],[\"那具体怎么做到的呢\",{\"1\":{\"360\":1}}],[\"那具体怎么解决呢\",{\"1\":{\"156\":1}}],[\"那具体是保存在哪个文件呢\",{\"1\":{\"152\":1}}],[\"那你第一步肯定是要先连接\",{\"1\":{\"139\":1}}],[\"那他能怎么办\",{\"1\":{\"109\":1}}],[\"那么它就和没有任何引用一样\",{\"1\":{\"522\":1}}],[\"那么jvm缓存就一定能生效了\",{\"1\":{\"445\":1}}],[\"那么如何获取前端传递的商品参数呢\",{\"1\":{\"437\":1}}],[\"那么如果出现\",{\"1\":{\"349\":1}}],[\"那么如果随着系统运行\",{\"1\":{\"339\":1}}],[\"那么如果数据库里有很多数据\",{\"1\":{\"307\":1}}],[\"那么如果事务\",{\"1\":{\"297\":1}}],[\"那么如果等值查询的记录是存在于表中\",{\"1\":{\"292\":1}}],[\"那么7004节点的id是多少呢\",{\"1\":{\"408\":1}}],[\"那么master怎么知道slave与自己的数据差异在哪里呢\",{\"1\":{\"385\":1}}],[\"那么说明\",{\"1\":{\"360\":1}}],[\"那么说明这条记录是被还未提交的事务修改的\",{\"1\":{\"359\":1}}],[\"那么说明使用了索引下推的优化\",{\"1\":{\"217\":1}}],[\"那么事务后续使用当前读进行查询的时候\",{\"1\":{\"369\":1}}],[\"那么事务\",{\"1\":{\"354\":2,\"369\":1}}],[\"那么将这\",{\"1\":{\"348\":1}}],[\"那么将会被阻塞\",{\"1\":{\"310\":1}}],[\"那么总共就可以记录\",{\"1\":{\"339\":1}}],[\"那么我们要更新一条记录的时候\",{\"1\":{\"335\":1}}],[\"那么我们可以定期断开长连接\",{\"1\":{\"139\":1}}],[\"那么锁就会持续很长一段时间\",{\"1\":{\"329\":1}}],[\"那么有了\",{\"1\":{\"311\":1}}],[\"那么加\",{\"1\":{\"311\":1}}],[\"那么本线程接下来如果要对学生表执行写操作的语句\",{\"1\":{\"309\":1}}],[\"那么由于扫描的方式是全表扫描\",{\"1\":{\"299\":1}}],[\"那么由于查询该条件值的记录是包含一个等值查询的操作\",{\"1\":{\"293\":1}}],[\"那么插入语句会被阻塞\",{\"1\":{\"297\":1}}],[\"那么插入语句会发生阻塞\",{\"1\":{\"297\":3}}],[\"那么不管是\",{\"1\":{\"292\":1,\"294\":2}}],[\"那么其他事务即不能插入\",{\"1\":{\"287\":1,\"316\":1}}],[\"那么其他事务就无法插入\",{\"1\":{\"286\":1,\"315\":1,\"365\":1}}],[\"那么两个事务\",{\"1\":{\"280\":1}}],[\"那么此时有个问题\",{\"1\":{\"498\":1}}],[\"那么此时该事务\",{\"1\":{\"277\":1}}],[\"那么此时中间人是否可以在传输过程中将正常站点发给\",{\"1\":{\"108\":1}}],[\"那么另外一个事务在获取相同范围的\",{\"1\":{\"275\":2,\"287\":2,\"316\":2}}],[\"那么等值查询\",{\"1\":{\"275\":2}}],[\"那么往右边的子节点走\",{\"1\":{\"252\":1}}],[\"那么当事务\",{\"1\":{\"355\":1}}],[\"那么当在\",{\"1\":{\"297\":1}}],[\"那么当节点个数越多的时候\",{\"1\":{\"252\":1}}],[\"那么当客户端执行了一个很大的操作后\",{\"1\":{\"139\":1}}],[\"那么在事务期间的多次读取同一条数据\",{\"1\":{\"360\":1}}],[\"那么在事务执行中途发生了\",{\"1\":{\"334\":1}}],[\"那么在同时处理多个事务的时候\",{\"1\":{\"353\":1}}],[\"那么在每个事务提交过程中\",{\"1\":{\"347\":1}}],[\"那么在加\",{\"1\":{\"311\":1}}],[\"那么在线程\",{\"1\":{\"310\":1}}],[\"那么在备份数据库之前先开启事务\",{\"1\":{\"307\":1}}],[\"那么在访问最底部的节点时\",{\"1\":{\"251\":1}}],[\"那么在范围查询\",{\"1\":{\"156\":1}}],[\"那么多个普通字段组合在一起创建的索引就叫做联合索引\",{\"1\":{\"239\":1}}],[\"那么只需要在\",{\"1\":{\"234\":1}}],[\"那么需要检索两颗b+树\",{\"1\":{\"234\":1}}],[\"那么即使使用了左模糊匹配\",{\"1\":{\"232\":1}}],[\"那么使用\",{\"1\":{\"228\":1}}],[\"那么索引列会发生隐式类型转换\",{\"1\":{\"241\":1}}],[\"那么索引会失效\",{\"1\":{\"228\":1,\"240\":1,\"241\":1}}],[\"那么索引页中的一条数据也就是\",{\"1\":{\"187\":1}}],[\"那么每次插入的新数据就会按顺序添加到当前索引节点的位置\",{\"1\":{\"226\":1}}],[\"那么无论搜索哪个值都可能得到一半的数据\",{\"1\":{\"218\":1,\"222\":1}}],[\"那么二级索引的\",{\"1\":{\"206\":1}}],[\"那么上面的整个查询过程一共经历了\",{\"1\":{\"205\":1}}],[\"那么单个数据页最多只能放下\",{\"1\":{\"187\":1}}],[\"那么里面就是一行行的数据\",{\"1\":{\"187\":1}}],[\"那么最多需要经历三次的磁盘\",{\"1\":{\"187\":1}}],[\"那么自增长最大值是\",{\"1\":{\"183\":1}}],[\"那么支持\",{\"1\":{\"183\":1}}],[\"那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态\",{\"1\":{\"351\":1}}],[\"那么该记录的索引中的\",{\"1\":{\"292\":1}}],[\"那么该缓存页移动到\",{\"1\":{\"178\":1}}],[\"那么该缓存页就不会被从\",{\"1\":{\"178\":1}}],[\"那么该页就变成了干净页\",{\"1\":{\"178\":1}}],[\"那么磁盘查询时就会有大量的随机i\",{\"1\":{\"156\":1}}],[\"那么链表中相邻的两个页之间的物理位置并不是连续的\",{\"1\":{\"156\":1}}],[\"那么\",{\"1\":{\"149\":1,\"164\":1,\"165\":1,\"178\":1,\"192\":1,\"193\":1,\"216\":1,\"238\":1,\"275\":2,\"290\":1,\"291\":1,\"299\":1,\"304\":1,\"307\":1,\"312\":1,\"317\":1,\"322\":1,\"324\":1,\"329\":1,\"333\":1,\"334\":1,\"339\":1}}],[\"那么这一行\",{\"1\":{\"344\":1}}],[\"那么这些插入语句都会发生阻塞\",{\"1\":{\"296\":1}}],[\"那么这些操作都会被阻塞\",{\"1\":{\"285\":1}}],[\"那么这个插入语句就会被阻塞\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"那么这个二级索引长下图这样\",{\"1\":{\"234\":1}}],[\"那么这个问题对你没什么难度\",{\"1\":{\"151\":1}}],[\"那么这个表的查询缓存就会被清空\",{\"1\":{\"140\":1}}],[\"那么这时执行器与存储引擎的执行流程是这样的\",{\"1\":{\"148\":1}}],[\"那么执行器与存储引擎的执行流程是这样的\",{\"1\":{\"147\":1}}],[\"那么就根据num计算\",{\"1\":{\"402\":1}}],[\"那么就有两种情况\",{\"1\":{\"344\":1}}],[\"那么就可能出现这样的情况\",{\"1\":{\"312\":1}}],[\"那么就可以插入成功\",{\"1\":{\"297\":1}}],[\"那么就无法插入成功\",{\"1\":{\"297\":1}}],[\"那么就是一棵\",{\"1\":{\"252\":1}}],[\"那么就是\",{\"1\":{\"246\":1}}],[\"那么就需要频繁的重建索引\",{\"1\":{\"222\":1}}],[\"那么就不需要回表\",{\"1\":{\"208\":1}}],[\"那么就没有\",{\"1\":{\"164\":1}}],[\"那么就会被阻塞\",{\"1\":{\"310\":1}}],[\"那么就会有幻读的问题\",{\"1\":{\"297\":1}}],[\"那么就会全表扫描\",{\"1\":{\"275\":1}}],[\"那么就会走索引扫描\",{\"1\":{\"235\":1}}],[\"那么就会在\",{\"1\":{\"234\":1}}],[\"那么就会将变量\",{\"1\":{\"192\":1}}],[\"那么就会将它插入到\",{\"1\":{\"178\":1}}],[\"那么就会继续指向新的页\",{\"1\":{\"187\":1}}],[\"那么就会创建\",{\"1\":{\"162\":1}}],[\"那么就会直接返回\",{\"1\":{\"140\":1}}],[\"那么就要往下继续执行\",{\"1\":{\"140\":1}}],[\"那么大家知道\",{\"1\":{\"102\":1}}],[\"那用顺序图肯定是很不好画了\",{\"1\":{\"84\":1}}],[\"前台询问你想找a方面的业务还是b方面的业务\",{\"1\":{\"507\":1}}],[\"前提交过了\",{\"1\":{\"360\":1}}],[\"前提没有打开死锁检测\",{\"1\":{\"274\":1,\"320\":1}}],[\"前两次\",{\"1\":{\"360\":1}}],[\"前\",{\"1\":{\"358\":1}}],[\"前后读取的记录数量不一致\",{\"1\":{\"357\":1}}],[\"前后读取的数据不一致\",{\"1\":{\"357\":1}}],[\"前后两次读的数据可能会出现不一致\",{\"1\":{\"334\":1,\"360\":2,\"361\":1}}],[\"前后两次查询的记录条目就不一样了\",{\"1\":{\"369\":1}}],[\"前后两次查询的结果集都是一样的\",{\"1\":{\"364\":1}}],[\"前后两次查询\",{\"1\":{\"297\":1}}],[\"前后执行相同的\",{\"1\":{\"280\":2}}],[\"前者是在内存中\",{\"1\":{\"272\":1}}],[\"前的条件列是索引列\",{\"1\":{\"228\":1,\"240\":1,\"241\":1}}],[\"前缀为林的用户\",{\"1\":{\"235\":1}}],[\"前缀匹配的范围查询\",{\"1\":{\"216\":1}}],[\"前缀匹配进行范围查询\",{\"1\":{\"216\":1}}],[\"前缀不为\",{\"1\":{\"216\":1}}],[\"前缀索引有一定的局限性\",{\"1\":{\"224\":1}}],[\"前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引\",{\"1\":{\"224\":1}}],[\"前缀索引优化\",{\"0\":{\"224\":1},\"1\":{\"223\":1}}],[\"前缀索引可以建立在字段类型为\",{\"1\":{\"213\":1}}],[\"前缀索引是指对字符类型字段的前几个字符建立的索引\",{\"1\":{\"213\":1}}],[\"前缀索引\",{\"0\":{\"213\":1},\"1\":{\"203\":1,\"209\":1}}],[\"前面介绍的\",{\"1\":{\"340\":1}}],[\"前面也提到\",{\"1\":{\"313\":1}}],[\"前面的案例\",{\"1\":{\"299\":1}}],[\"前面的例子一中的查询语句\",{\"1\":{\"238\":1}}],[\"前面\",{\"1\":{\"239\":1}}],[\"前面已经讲了\",{\"1\":{\"207\":1}}],[\"前面我们提到\",{\"1\":{\"357\":1}}],[\"前面我们知道了\",{\"1\":{\"166\":1}}],[\"前面我也说过\",{\"1\":{\"297\":1}}],[\"前面我也用了四个例子说明了\",{\"1\":{\"216\":1}}],[\"前面我创建表的时候\",{\"1\":{\"166\":1}}],[\"前面了解完e\",{\"1\":{\"91\":1}}],[\"前文说了\",{\"1\":{\"109\":1}}],[\"前言\",{\"0\":{\"102\":1}}],[\"⚠️注意事项\",{\"1\":{\"264\":1,\"265\":1}}],[\"⚠️\",{\"1\":{\"100\":1}}],[\"纯java代码调用rapidocr\",{\"1\":{\"100\":1}}],[\"项目特点\",{\"0\":{\"100\":1}}],[\"项目中并不想再引入kotlin\",{\"1\":{\"99\":1}}],[\"项目起源\",{\"0\":{\"99\":1}}],[\"考虑一个问题\",{\"1\":{\"334\":1}}],[\"考虑下面场景\",{\"1\":{\"312\":1}}],[\"考虑\",{\"1\":{\"310\":1}}],[\"考虑精度与速度的平衡\",{\"1\":{\"99\":1}}],[\"考虑消息的嵌套\",{\"1\":{\"82\":1}}],[\"揭开\",{\"0\":{\"171\":1},\"1\":{\"96\":1}}],[\"完全不会对其生存时间构成影响\",{\"1\":{\"522\":1}}],[\"完全解决幻读了吗\",{\"0\":{\"362\":1},\"1\":{\"96\":1}}],[\"完整的item\",{\"1\":{\"451\":1,\"454\":1}}],[\"完整的common\",{\"1\":{\"450\":1}}],[\"完整流程描述\",{\"1\":{\"384\":1}}],[\"完整性\",{\"1\":{\"104\":2}}],[\"完\",{\"1\":{\"150\":1,\"229\":1,\"258\":1,\"305\":1}}],[\"完成对缓存的更新\",{\"1\":{\"459\":1}}],[\"完成数据整合后\",{\"1\":{\"442\":1}}],[\"完成fork后读取内存数据并写入\",{\"1\":{\"374\":1}}],[\"完成最后的引擎提交\",{\"1\":{\"348\":1}}],[\"完成了\",{\"1\":{\"348\":1}}],[\"完成刷盘\",{\"1\":{\"346\":1}}],[\"完成后通知队内其他事务操作结束\",{\"1\":{\"348\":1}}],[\"完成后\",{\"1\":{\"337\":1}}],[\"完成的\",{\"1\":{\"146\":1}}],[\"完成\",{\"1\":{\"139\":1}}],[\"完成高可用配置\",{\"1\":{\"43\":1}}],[\"行了\",{\"1\":{\"334\":1}}],[\"行数据\",{\"1\":{\"312\":1}}],[\"行信息\",{\"1\":{\"304\":1}}],[\"行级锁\",{\"0\":{\"313\":1}}],[\"行级锁的类型主要有三类\",{\"1\":{\"313\":1}}],[\"行级锁的加锁规则\",{\"1\":{\"300\":1}}],[\"行级锁的种类除了有记录锁\",{\"1\":{\"284\":1}}],[\"行级锁的种类只有记录锁\",{\"1\":{\"284\":1}}],[\"行级锁的种类是不同的\",{\"1\":{\"284\":1}}],[\"行级锁加锁规则比较复杂\",{\"1\":{\"288\":1}}],[\"行级锁有哪些种类\",{\"0\":{\"284\":1}}],[\"行锁是\",{\"1\":{\"323\":1}}],[\"行锁\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":2,\"322\":1}}],[\"行锁的释放时机是在事务提交\",{\"1\":{\"275\":1}}],[\"行子查询\",{\"1\":{\"261\":1}}],[\"行记录存储方式\",{\"1\":{\"158\":1}}],[\"行格式针对行溢出的处理是这样的\",{\"1\":{\"169\":1}}],[\"行格式中就不会有\",{\"1\":{\"169\":1}}],[\"行格式中会用\",{\"1\":{\"169\":2}}],[\"行格式在发生行溢出后的处理\",{\"1\":{\"168\":1}}],[\"行格式把这些值为\",{\"1\":{\"162\":1}}],[\"行格式是\",{\"1\":{\"161\":1}}],[\"行格式混个脸熟\",{\"1\":{\"159\":1}}],[\"行格式长什么样\",{\"0\":{\"159\":1}}],[\"行格式我这里就不讲了\",{\"1\":{\"158\":1}}],[\"行格式默认设置成\",{\"1\":{\"158\":1}}],[\"行格式\",{\"1\":{\"158\":5}}],[\"行格式有哪些\",{\"0\":{\"158\":1}}],[\"行溢出后\",{\"0\":{\"168\":1},\"1\":{\"151\":1,\"169\":1}}],[\"行\",{\"0\":{\"154\":1,\"181\":1},\"1\":{\"96\":1,\"153\":1,\"155\":1,\"187\":1,\"243\":1,\"272\":2,\"302\":1,\"363\":1}}],[\"行为和关系的一组对象的描述符\",{\"1\":{\"65\":1}}],[\"采用这个策略\",{\"1\":{\"346\":1}}],[\"采用的是\",{\"1\":{\"258\":1}}],[\"采用了\",{\"1\":{\"244\":1}}],[\"采用链表的结构是让数据页之间不需要是物理上的连续的\",{\"1\":{\"243\":1}}],[\"采用\",{\"0\":{\"247\":1},\"1\":{\"96\":1,\"246\":1,\"247\":1}}],[\"采用独立的进程\",{\"1\":{\"46\":1}}],[\"树化阈值选择\",{\"1\":{\"473\":1}}],[\"树化应是偶然情况\",{\"1\":{\"473\":1}}],[\"树化应当是偶然情况\",{\"1\":{\"473\":1}}],[\"树化的意义是什么\",{\"1\":{\"473\":1}}],[\"树化规则\",{\"1\":{\"473\":1}}],[\"树化与退化\",{\"0\":{\"473\":1}}],[\"树要实现范围查询\",{\"1\":{\"258\":1}}],[\"树叶子节点之间用链表连接了起来\",{\"1\":{\"258\":1}}],[\"树那样会发生复杂的树的变化\",{\"1\":{\"258\":1}}],[\"树点节点内容是数据页\",{\"1\":{\"257\":1}}],[\"树有一些特别的点\",{\"1\":{\"257\":1}}],[\"树有大量的冗余节点\",{\"1\":{\"255\":1,\"258\":1}}],[\"树作为了索引的数据结构\",{\"1\":{\"257\":1}}],[\"树作为索引的数据结构\",{\"1\":{\"234\":1,\"258\":1}}],[\"树作为索引\",{\"0\":{\"247\":1},\"1\":{\"96\":1,\"244\":1,\"246\":1,\"247\":1}}],[\"树没有将所有叶子节点用链表串联起来的结构\",{\"1\":{\"256\":1}}],[\"树没有冗余节点\",{\"1\":{\"255\":1}}],[\"树所有叶子节点间还有一个链表进行连接\",{\"1\":{\"256\":1}}],[\"树等值查询原理基本一致\",{\"1\":{\"256\":1}}],[\"树和\",{\"1\":{\"256\":1,\"258\":1}}],[\"树和二叉树来说\",{\"1\":{\"205\":1}}],[\"树会自动平衡\",{\"1\":{\"255\":1}}],[\"树则不同\",{\"1\":{\"255\":1}}],[\"树根节点的过程\",{\"1\":{\"255\":2}}],[\"树对于非叶子节点的子节点和索引的个数\",{\"1\":{\"255\":1}}],[\"树形结构变化很小\",{\"1\":{\"255\":1}}],[\"树更\",{\"1\":{\"254\":1,\"258\":1}}],[\"树可以比\",{\"1\":{\"254\":1,\"258\":1}}],[\"树稍快一些\",{\"1\":{\"254\":1}}],[\"树进行单个索引查询时\",{\"1\":{\"254\":1}}],[\"树差异的点\",{\"1\":{\"253\":1}}],[\"树与\",{\"1\":{\"253\":1,\"255\":1}}],[\"树结构如下图\",{\"1\":{\"253\":1}}],[\"树结构定位到\",{\"1\":{\"147\":1}}],[\"树做了一个升级\",{\"1\":{\"253\":1}}],[\"树在插入\",{\"1\":{\"258\":1}}],[\"树在删除根节点的时候\",{\"1\":{\"255\":1}}],[\"树在数据查询中比平衡二叉树效率要高\",{\"1\":{\"252\":1}}],[\"树在查询叶子节点中的数据时\",{\"1\":{\"252\":1}}],[\"树就是这个特性\",{\"1\":{\"255\":1}}],[\"树就是对\",{\"1\":{\"253\":1}}],[\"树就是一个多叉树\",{\"1\":{\"252\":1}}],[\"树就能找到数据\",{\"1\":{\"245\":1}}],[\"树就能查到全部结果了\",{\"1\":{\"232\":1}}],[\"树才能查到数据\",{\"1\":{\"245\":1}}],[\"树如下图\",{\"1\":{\"245\":1}}],[\"树如何实现快速查找主键为\",{\"1\":{\"244\":1}}],[\"树数据结构\",{\"1\":{\"244\":1}}],[\"树里的节点里存放的是什么呢\",{\"1\":{\"235\":1,\"242\":1}}],[\"树查询过程\",{\"1\":{\"235\":1}}],[\"树找到对应的叶子节点\",{\"1\":{\"234\":2}}],[\"树检索到对应的叶子节点\",{\"1\":{\"234\":2}}],[\"树为了维护索引有序性\",{\"1\":{\"220\":1}}],[\"树无法做到这一点\",{\"1\":{\"207\":1}}],[\"树来做范围查询的话\",{\"1\":{\"252\":1}}],[\"树来保存记录的\",{\"1\":{\"192\":1}}],[\"树来组织数据的\",{\"1\":{\"156\":1,\"242\":1}}],[\"树层级更高\",{\"1\":{\"188\":1}}],[\"树中要查找的索引值是\",{\"1\":{\"252\":1}}],[\"树中的每个节点都是一个数据页\",{\"1\":{\"244\":1}}],[\"树中\",{\"1\":{\"188\":1}}],[\"树中每一层都是通过双向链表连接起来的\",{\"1\":{\"156\":1}}],[\"树是聚簇索引树\",{\"1\":{\"290\":1}}],[\"树是如何进行查询的\",{\"0\":{\"244\":1}}],[\"树是按照\",{\"1\":{\"235\":1}}],[\"树是三层\",{\"1\":{\"187\":1}}],[\"树是两层\",{\"1\":{\"187\":1}}],[\"树快速定位到这条记录后\",{\"1\":{\"149\":1}}],[\"树的结构\",{\"1\":{\"296\":1}}],[\"树的插入和删除效率更高\",{\"1\":{\"255\":1}}],[\"树的插入也是一样\",{\"1\":{\"255\":1}}],[\"树的差异时\",{\"1\":{\"255\":1}}],[\"树的动图都是基于这个\",{\"1\":{\"255\":1}}],[\"树的非叶子节点不存放实际的记录数据\",{\"1\":{\"254\":1,\"258\":1}}],[\"树的非叶子节点的区的集合\",{\"1\":{\"157\":1}}],[\"树的查询波动会比较大\",{\"1\":{\"254\":1}}],[\"树的查询过程是怎样的\",{\"1\":{\"252\":1}}],[\"树的性能区别\",{\"1\":{\"253\":1}}],[\"树的每个节点都包含数据\",{\"1\":{\"252\":1}}],[\"树的每一个节点最多可以包括\",{\"1\":{\"252\":1}}],[\"树的高度会越来越高\",{\"1\":{\"258\":1}}],[\"树的高度就会很高\",{\"1\":{\"252\":1}}],[\"树的高度也会相应变高\",{\"1\":{\"252\":1}}],[\"树的高度也变高\",{\"1\":{\"250\":1}}],[\"树的阶\",{\"1\":{\"252\":1}}],[\"树的数据结构\",{\"1\":{\"245\":1}}],[\"树的特点\",{\"1\":{\"244\":1}}],[\"树的方式查询到数据的\",{\"1\":{\"232\":1}}],[\"树的叶子节点之间是用\",{\"1\":{\"257\":1}}],[\"树的叶子节点包含\",{\"1\":{\"232\":1}}],[\"树的叶子节点的区的集合\",{\"1\":{\"157\":1}}],[\"树的叶子节点的数据存储的是主键值\",{\"1\":{\"145\":1}}],[\"树的成本会比查询二级索引的\",{\"1\":{\"145\":1}}],[\"树索引的叶子节点保存数据的物理地址\",{\"1\":{\"234\":2}}],[\"树索引的叶子节点保存数据本身\",{\"1\":{\"234\":2}}],[\"树索引\",{\"1\":{\"138\":1,\"234\":4}}],[\"树\",{\"0\":{\"242\":1,\"252\":1,\"253\":1,\"257\":1},\"1\":{\"96\":1,\"155\":1,\"174\":1,\"184\":1,\"186\":1,\"207\":3,\"232\":1,\"234\":1,\"242\":1,\"244\":1,\"251\":1,\"252\":2,\"253\":1,\"254\":1,\"255\":2,\"256\":2,\"257\":3,\"258\":2,\"336\":1}}],[\"期间发生了什么\",{\"0\":{\"137\":1},\"1\":{\"96\":1,\"150\":1,\"333\":2}}],[\"期待与你共同成长\",{\"1\":{\"1\":1}}],[\"查找数据的时间复杂度变成了\",{\"1\":{\"250\":1}}],[\"查找记录\",{\"1\":{\"244\":1}}],[\"查询成功\",{\"1\":{\"454\":2}}],[\"查询库存信息\",{\"1\":{\"451\":1,\"454\":1}}],[\"查询本地缓存\",{\"1\":{\"451\":2,\"454\":2}}],[\"查询逻辑是\",{\"1\":{\"451\":1}}],[\"查询失败处理\",{\"1\":{\"450\":2}}],[\"查询redis数据为空\",{\"1\":{\"450\":2}}],[\"查询redis失败\",{\"1\":{\"450\":2}}],[\"查询redis\",{\"1\":{\"450\":2,\"454\":2}}],[\"查询redis的方法\",{\"1\":{\"450\":2}}],[\"查询redis缓存\",{\"0\":{\"449\":1}}],[\"查询tomcat\",{\"0\":{\"440\":1}}],[\"查询商品库存信息\",{\"1\":{\"448\":1,\"463\":1}}],[\"查询商品信息\",{\"1\":{\"448\":1,\"451\":1,\"454\":1,\"463\":1}}],[\"查询商品信息才可以\",{\"1\":{\"437\":1}}],[\"查询商品数据并返回到浏览器\",{\"1\":{\"434\":1}}],[\"查询到年龄大于\",{\"1\":{\"303\":1}}],[\"查询到对应的叶子节点\",{\"1\":{\"206\":1}}],[\"查询的值是\",{\"1\":{\"357\":1}}],[\"查询的值存在的情况\",{\"1\":{\"297\":1}}],[\"查询的值不存在的情况\",{\"1\":{\"296\":1}}],[\"查询的记录不存在时\",{\"1\":{\"296\":1}}],[\"查询的记录不存在的情况\",{\"1\":{\"296\":1}}],[\"查询的记录是\",{\"1\":{\"290\":1,\"291\":1}}],[\"查询的记录存不存在\",{\"1\":{\"289\":1,\"295\":1}}],[\"查询的结果就会被存入查询缓存中\",{\"1\":{\"140\":1}}],[\"查询订单等操作\",{\"1\":{\"273\":1}}],[\"查询出来的结果\",{\"1\":{\"261\":1}}],[\"查询底层节点的磁盘\",{\"1\":{\"254\":1,\"258\":1}}],[\"查询效率并不高\",{\"1\":{\"249\":1}}],[\"查询效率会更快\",{\"1\":{\"228\":1}}],[\"查询数据的过程又是怎样的\",{\"1\":{\"235\":1,\"242\":1}}],[\"查询数据等技术的实现方法\",{\"1\":{\"202\":1}}],[\"查询比较\",{\"1\":{\"235\":2}}],[\"查询可以使用到\",{\"1\":{\"228\":1}}],[\"查询将不会再次检索主键索引\",{\"1\":{\"225\":1}}],[\"查询优化器发现某个值出现在表的数据行中的百分比很高的时候\",{\"1\":{\"222\":1}}],[\"查询优化器发现某个值出现在表的数据行中的百分比\",{\"1\":{\"218\":1}}],[\"查询条件值的记录\",{\"1\":{\"294\":3}}],[\"查询条件用上了索引列\",{\"1\":{\"234\":1}}],[\"查询条件的字段\",{\"1\":{\"221\":1}}],[\"查询条件中的各个列必须是联合索引中从最左边开始连续的列\",{\"1\":{\"239\":1}}],[\"查询条件中的输入参数即使字符串\",{\"1\":{\"238\":1}}],[\"查询条件中\",{\"1\":{\"216\":1}}],[\"查询条件\",{\"1\":{\"216\":1}}],[\"查询一个数据的磁盘\",{\"1\":{\"205\":1}}],[\"查询一条记录\",{\"1\":{\"174\":1,\"336\":1}}],[\"查询过程是这样的\",{\"1\":{\"205\":1}}],[\"查询会产生磁盘\",{\"1\":{\"187\":1}}],[\"查询不会有问题\",{\"1\":{\"187\":1}}],[\"查询时长急剧上升\",{\"1\":{\"182\":1}}],[\"查询缓冲就被清空了\",{\"1\":{\"140\":1}}],[\"查询缓存的命中率很低的\",{\"1\":{\"140\":1}}],[\"查询缓存还挺有用\",{\"1\":{\"140\":1}}],[\"查询缓存\",{\"0\":{\"140\":1},\"1\":{\"138\":1,\"150\":1}}],[\"查询\",{\"1\":{\"137\":1,\"235\":1,\"272\":1}}],[\"查询语句是索引查询\",{\"1\":{\"304\":1}}],[\"查询语句会锁住\",{\"1\":{\"275\":1}}],[\"查询语句我们可以知道\",{\"1\":{\"216\":4}}],[\"查询语句使用了\",{\"1\":{\"216\":1}}],[\"查询语句进行词法分析\",{\"1\":{\"150\":1}}],[\"查询语句如果命中查询缓存则直接返回\",{\"1\":{\"150\":1}}],[\"查询语句先制定一个执行计划\",{\"1\":{\"145\":1}}],[\"查询语句中的表或者字段是否存在\",{\"1\":{\"144\":1}}],[\"查询语句流程主要可以分为下面这三个阶段\",{\"1\":{\"143\":1}}],[\"查询语句之前\",{\"1\":{\"141\":1}}],[\"查询语句的那一套流程\",{\"1\":{\"333\":1}}],[\"查询语句的执行计划如下\",{\"1\":{\"216\":1}}],[\"查询语句的执行方案确定下来\",{\"1\":{\"145\":1}}],[\"查询语句的执行流程\",{\"1\":{\"138\":1}}],[\"查询语句的\",{\"1\":{\"144\":1}}],[\"查询语句的流程了\",{\"1\":{\"143\":1}}],[\"查询语句的流程\",{\"1\":{\"138\":1}}],[\"查询语句执行流程\",{\"1\":{\"138\":1,\"150\":1,\"333\":1}}],[\"查询语句了\",{\"1\":{\"137\":1}}],[\"查询语句\",{\"1\":{\"96\":1,\"137\":1,\"140\":2,\"150\":2,\"216\":1,\"333\":1}}],[\"查看集群信息时就能看到\",{\"1\":{\"402\":1}}],[\"查看事务\",{\"1\":{\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"查看事务执行\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":2,\"321\":1}}],[\"查看一下\",{\"1\":{\"108\":1}}],[\"查看keepalived是否启动\",{\"1\":{\"43\":1}}],[\"查看是否存在此\",{\"1\":{\"346\":1}}],[\"查看是否有记录存在独占锁\",{\"1\":{\"311\":1}}],[\"查看是否已经安装上\",{\"1\":{\"43\":1}}],[\"查看是否开启\",{\"1\":{\"31\":1}}],[\"查看端口状态\",{\"1\":{\"35\":1}}],[\"查看版本\",{\"1\":{\"31\":1}}],[\"转移插槽\",{\"0\":{\"408\":1}}],[\"转账\",{\"1\":{\"352\":1}}],[\"转账这一动作在程序里会涉及到一系列的操作\",{\"1\":{\"351\":1}}],[\"转自小林coding\",{\"1\":{\"96\":1}}],[\"转换成\",{\"1\":{\"238\":2}}],[\"转换\",{\"1\":{\"87\":1}}],[\"感觉代理也不错如此嘛\",{\"1\":{\"506\":1}}],[\"感谢\",{\"1\":{\"167\":1}}],[\"感谢你的访问\",{\"1\":{\"1\":1}}],[\"感兴趣的可以自己去查查\",{\"1\":{\"334\":1}}],[\"感兴趣的可以去看这篇文章\",{\"1\":{\"155\":1}}],[\"感兴趣的朋友\",{\"1\":{\"144\":1}}],[\"感慨万千\",{\"1\":{\"95\":1}}],[\"毕竟那个时候的我\",{\"1\":{\"95\":1}}],[\"毕竟图标的目的是方便沟通\",{\"1\":{\"52\":1}}],[\"挺让人怀念的\",{\"1\":{\"95\":1}}],[\"时效性一般\",{\"1\":{\"456\":1}}],[\"时效性要求一般\",{\"1\":{\"456\":1}}],[\"时效性要求较高的缓存数据\",{\"1\":{\"456\":1}}],[\"时效性要求低的业务\",{\"1\":{\"456\":1}}],[\"时效性强\",{\"1\":{\"456\":1}}],[\"时效性差\",{\"1\":{\"456\":1}}],[\"时执行该语句块\",{\"1\":{\"429\":2}}],[\"时当前数据库中应该给下一个事务的\",{\"1\":{\"358\":1}}],[\"时加上\",{\"1\":{\"307\":1}}],[\"时刻\",{\"1\":{\"346\":1,\"368\":3}}],[\"时刻执行产生的结果集是不相同的\",{\"1\":{\"302\":1,\"363\":1}}],[\"时刻分别执行了下面查询语句\",{\"1\":{\"302\":1,\"363\":1}}],[\"时刻和\",{\"1\":{\"302\":1,\"363\":1}}],[\"时\",{\"1\":{\"149\":1,\"180\":1,\"194\":1,\"196\":1,\"216\":2,\"251\":1,\"275\":2,\"287\":2,\"295\":2,\"296\":2,\"300\":2,\"311\":2,\"312\":1,\"316\":2,\"330\":1,\"334\":1,\"337\":1,\"338\":3,\"347\":1,\"358\":2,\"414\":1,\"473\":1,\"498\":1}}],[\"时间执行的结果是有\",{\"1\":{\"302\":4,\"363\":4}}],[\"时间\",{\"1\":{\"138\":1}}],[\"时间过的真快啊\",{\"1\":{\"95\":1}}],[\"时序图绘制具体分为以下5步\",{\"1\":{\"82\":1}}],[\"时序图中每个对象底部中心都有一条垂直的虚线\",{\"1\":{\"81\":1}}],[\"时序图的组成元素\",{\"0\":{\"81\":1}}],[\"时序图是uml交互图中的一类\",{\"1\":{\"80\":1}}],[\"时序图\",{\"1\":{\"79\":1}}],[\"明天出差等等\",{\"1\":{\"506\":1}}],[\"明明查询\",{\"1\":{\"298\":1}}],[\"明明在我印象中小七没有太依赖人的时候\",{\"1\":{\"95\":1}}],[\"明确每个部门\",{\"1\":{\"58\":1}}],[\"永久免费\",{\"1\":{\"91\":1}}],[\"年\",{\"1\":{\"91\":1}}],[\"人家内存的访问速度是纳秒级别的\",{\"1\":{\"248\":1}}],[\"人员信息表\",{\"1\":{\"182\":1,\"183\":1}}],[\"人\",{\"1\":{\"91\":1}}],[\"人负责完成的任务环节\",{\"1\":{\"58\":1}}],[\"否则新位置\",{\"1\":{\"473\":1}}],[\"否则就会导致索引失效\",{\"1\":{\"228\":1,\"241\":1}}],[\"否则这样的查询效率是很低的\",{\"1\":{\"228\":1}}],[\"否则自动踢群\",{\"1\":{\"181\":1}}],[\"否则还是插入到\",{\"1\":{\"180\":1}}],[\"否则再去磁盘中读取\",{\"1\":{\"172\":1,\"335\":1}}],[\"否则一次读取\",{\"1\":{\"155\":1,\"243\":1}}],[\"否则继续往下执行\",{\"1\":{\"150\":1}}],[\"否则跳过该记录\",{\"1\":{\"149\":2}}],[\"否则发送到客户端\",{\"1\":{\"148\":1}}],[\"否则可以标在包内\",{\"1\":{\"73\":1}}],[\"否\",{\"1\":{\"91\":1,\"526\":1}}],[\"免费账号只能9个文件\",{\"1\":{\"91\":1}}],[\"模式和\",{\"1\":{\"341\":1}}],[\"模式\",{\"1\":{\"341\":2}}],[\"模板丰富\",{\"1\":{\"91\":1}}],[\"模块\",{\"1\":{\"435\":1}}],[\"模块使用\",{\"1\":{\"26\":1}}],[\"模块完成之后\",{\"1\":{\"7\":1}}],[\"方法只是起通知作用\",{\"1\":{\"520\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"517\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"517\":1}}],[\"方法的调用者\",{\"1\":{\"502\":1}}],[\"方法的过程\",{\"1\":{\"492\":1}}],[\"方法\",{\"1\":{\"499\":1}}],[\"方法在多线程环境中被正确加锁和同步\",{\"1\":{\"492\":1}}],[\"方法原理是什么\",{\"1\":{\"474\":1}}],[\"方法体是查询数据库的逻辑\",{\"1\":{\"416\":1}}],[\"方法有优劣之分\",{\"1\":{\"58\":1}}],[\"方式解决了幻读\",{\"1\":{\"302\":2,\"357\":2,\"361\":2,\"362\":2,\"369\":2}}],[\"方式来查询\",{\"1\":{\"235\":1}}],[\"方便\",{\"1\":{\"456\":1}}],[\"方便我们快速查找书中的内容\",{\"1\":{\"202\":1}}],[\"方便后续模块读取表名\",{\"1\":{\"150\":1}}],[\"方便大家理解\",{\"1\":{\"149\":1,\"338\":1}}],[\"方便快捷\",{\"1\":{\"91\":1}}],[\"名称叫做\",{\"1\":{\"453\":1}}],[\"名称\",{\"1\":{\"91\":1,\"225\":1}}],[\"名称和状态区别于其他对象而存在\",{\"1\":{\"70\":1}}],[\"连续执行两次同样的查询语句\",{\"1\":{\"329\":1}}],[\"连续执行\",{\"1\":{\"182\":1}}],[\"连续的\",{\"1\":{\"156\":1}}],[\"连线\",{\"1\":{\"90\":1}}],[\"连接redis失败\",{\"1\":{\"450\":2}}],[\"连接池大小\",{\"1\":{\"450\":2}}],[\"连接主库的\",{\"1\":{\"342\":1}}],[\"连接层\",{\"1\":{\"272\":1}}],[\"连接两张表\",{\"1\":{\"263\":1}}],[\"连接查询\",{\"1\":{\"261\":1}}],[\"连接起来的页相当于一个双向的链表\",{\"1\":{\"243\":1}}],[\"连接起来非常方便\",{\"1\":{\"72\":1}}],[\"连接的空闲时间\",{\"1\":{\"450\":2}}],[\"连接的建立后\",{\"1\":{\"139\":1}}],[\"连接的过程需要先经过\",{\"1\":{\"139\":1}}],[\"连接器自会判断用户身份\",{\"1\":{\"333\":1}}],[\"连接器的工作完成后\",{\"1\":{\"140\":1}}],[\"连接器的工作做完了\",{\"1\":{\"139\":1}}],[\"连接器就会自动将它断开\",{\"1\":{\"139\":1}}],[\"连接器就会获取该用户的权限\",{\"1\":{\"139\":1}}],[\"连接器就要开始验证你的用户名和密码\",{\"1\":{\"139\":1}}],[\"连接器\",{\"0\":{\"139\":1},\"1\":{\"150\":1}}],[\"连接中可以标注上网络协议\",{\"1\":{\"77\":1}}],[\"连接\",{\"0\":{\"77\":1},\"1\":{\"78\":1,\"139\":2}}],[\"连接点\",{\"1\":{\"58\":1}}],[\"连接线不能无故弯曲\",{\"1\":{\"57\":1}}],[\"连接数\",{\"0\":{\"48\":1}}],[\"连接超时时间\",{\"1\":{\"32\":1}}],[\"椭圆形框\",{\"1\":{\"90\":1}}],[\"世界上任何事物都不是孤立存在的\",{\"1\":{\"89\":1}}],[\"⑥\",{\"1\":{\"89\":1}}],[\"⑤\",{\"1\":{\"89\":1}}],[\"键也是属于实体的属性\",{\"1\":{\"89\":1}}],[\"键\",{\"1\":{\"89\":2}}],[\"④使用类的加载器\",{\"0\":{\"488\":1}}],[\"④\",{\"1\":{\"89\":1,\"90\":1}}],[\"男女的记录分布均匀\",{\"1\":{\"222\":1}}],[\"男\",{\"1\":{\"89\":1}}],[\"900\",{\"1\":{\"373\":1}}],[\"900秒内\",{\"1\":{\"373\":1}}],[\"9001\",{\"1\":{\"38\":1,\"39\":2}}],[\"90\",{\"1\":{\"324\":1,\"325\":1}}],[\"9\",{\"1\":{\"162\":2,\"226\":1,\"238\":5,\"243\":2,\"252\":4,\"294\":1,\"304\":2}}],[\"983573\",{\"1\":{\"89\":1}}],[\"全量同步需要先做rdb\",{\"1\":{\"385\":1}}],[\"全量同步\",{\"0\":{\"384\":1},\"1\":{\"388\":1}}],[\"全权负责整队的操作\",{\"1\":{\"348\":1}}],[\"全部写满就从头开始\",{\"1\":{\"341\":1}}],[\"全局锁主要应用于做全库逻辑备份\",{\"1\":{\"307\":1}}],[\"全局锁应用场景是什么\",{\"1\":{\"307\":1}}],[\"全局锁会被自动释放\",{\"1\":{\"307\":1}}],[\"全局锁是怎么用的\",{\"1\":{\"307\":1}}],[\"全局锁\",{\"0\":{\"307\":1}}],[\"全局块和\",{\"1\":{\"32\":1}}],[\"全局块\",{\"1\":{\"32\":2}}],[\"全外连接\",{\"1\":{\"261\":1,\"264\":1}}],[\"全扫描二级索引树\",{\"1\":{\"232\":1}}],[\"全索引扫描\",{\"1\":{\"228\":1}}],[\"全表扫描\",{\"0\":{\"148\":1},\"1\":{\"146\":1,\"228\":1}}],[\"全体学生就是一个实体集\",{\"1\":{\"89\":1}}],[\"具备nginx的完整功能\",{\"1\":{\"432\":1}}],[\"具备下列特点\",{\"1\":{\"432\":1}}],[\"具有相同的特征和性质的实体一定有相同的属性\",{\"1\":{\"89\":1}}],[\"具有相同属性的实体的集合称为实体集\",{\"1\":{\"89\":1}}],[\"具体业务\",{\"1\":{\"508\":1}}],[\"具体命令如下\",{\"1\":{\"408\":1}}],[\"具体内容如下\",{\"1\":{\"359\":1}}],[\"具体如下\",{\"1\":{\"345\":1}}],[\"具体更新一条记录\",{\"1\":{\"343\":1,\"350\":1}}],[\"具体详细过程如下\",{\"1\":{\"342\":1}}],[\"具体方式如下\",{\"1\":{\"311\":1}}],[\"具体怎么用的\",{\"1\":{\"308\":1}}],[\"具体怎么确定呢\",{\"1\":{\"304\":1}}],[\"具体的id\",{\"1\":{\"408\":1}}],[\"具体的实现可以看我这篇文章\",{\"1\":{\"334\":1}}],[\"具体的每一个操作的\",{\"1\":{\"334\":1}}],[\"具体的信息\",{\"1\":{\"304\":1}}],[\"具体的类目\",{\"1\":{\"70\":1}}],[\"具体加了什么锁呢\",{\"1\":{\"304\":1}}],[\"具体哪些情况\",{\"1\":{\"296\":2,\"297\":2,\"298\":2}}],[\"具体为什么要这样做呢\",{\"1\":{\"226\":1}}],[\"具体情况分为\",{\"1\":{\"166\":1}}],[\"具体是这样做的\",{\"1\":{\"178\":1}}],[\"具体是怎么保存\",{\"1\":{\"161\":1}}],[\"具体是负责做什么的\",{\"1\":{\"137\":1}}],[\"具体原因这里可以看这篇\",{\"1\":{\"149\":1}}],[\"具体可分为6种\",{\"1\":{\"66\":1}}],[\"具体配置\",{\"1\":{\"42\":1}}],[\"具体expires定义\",{\"1\":{\"42\":1}}],[\"具体场景会使用此分支\",{\"1\":{\"7\":1}}],[\"③调用class的静态方法\",{\"0\":{\"487\":1}}],[\"③\",{\"0\":{\"503\":1,\"507\":1},\"1\":{\"89\":1,\"90\":1}}],[\"③测试\",{\"0\":{\"39\":1}}],[\"班级\",{\"1\":{\"89\":1}}],[\"院系\",{\"1\":{\"89\":1}}],[\"姓名\",{\"1\":{\"89\":1}}],[\"食堂\",{\"1\":{\"89\":1}}],[\"学历编号其实就是我们常说的数字签名\",{\"1\":{\"108\":1}}],[\"学习任何语言必然离不开变量\",{\"1\":{\"423\":1}}],[\"学习\",{\"1\":{\"137\":1}}],[\"学习指路\",{\"1\":{\"97\":1}}],[\"学习和成长\",{\"1\":{\"1\":1}}],[\"学生\",{\"1\":{\"89\":1}}],[\"物理上不连续\",{\"1\":{\"246\":1}}],[\"物理存储\",{\"1\":{\"203\":1}}],[\"物\",{\"1\":{\"89\":1}}],[\"终结器引用\",{\"0\":{\"523\":1}}],[\"终于说完表空间的结构了\",{\"1\":{\"157\":1}}],[\"终点\",{\"1\":{\"88\":1}}],[\"终止点处放置\",{\"1\":{\"81\":1}}],[\"起到记录的索引作用\",{\"1\":{\"243\":1}}],[\"起点\",{\"1\":{\"88\":1}}],[\"起止框\",{\"1\":{\"58\":1}}],[\"展现从一个活动到另一个活动的控制流\",{\"1\":{\"88\":1}}],[\"展示出一个商业过程之间的关系\",{\"1\":{\"58\":1}}],[\"描述单个对象的状态及引起状态变化的原因\",{\"1\":{\"87\":1}}],[\"描述多个对象间的交互\",{\"1\":{\"87\":1}}],[\"描述一个特定对象的所有可能状态\",{\"1\":{\"83\":1}}],[\"但会堆积碎片\",{\"1\":{\"526\":1}}],[\"但一旦某个类被加载到类加载器中\",{\"1\":{\"493\":1}}],[\"但java可以称之为\",{\"1\":{\"480\":1}}],[\"但只有最后一次写操作才有意义\",{\"1\":{\"379\":1}}],[\"但用户\",{\"1\":{\"352\":1}}],[\"但即使\",{\"1\":{\"349\":1}}],[\"但在并发量较大的时候\",{\"1\":{\"347\":1}}],[\"但在\",{\"1\":{\"347\":1}}],[\"但累积\",{\"1\":{\"343\":1,\"349\":1}}],[\"但第二次返回了第一次没有返回的行\",{\"1\":{\"302\":1,\"363\":1}}],[\"但两个事务却不能在同一时间内\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"但两次读取的结果不一致\",{\"1\":{\"270\":1}}],[\"但不论是哪一种\",{\"1\":{\"312\":1}}],[\"但不同于间隙锁的是\",{\"1\":{\"275\":1,\"324\":1}}],[\"但不包括标记为\",{\"1\":{\"243\":1}}],[\"但对于记录锁\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"但对方如果要解密这个密钥还是要传加密密钥给对方\",{\"1\":{\"106\":1}}],[\"但它的好处是它并不需要扫全表\",{\"1\":{\"228\":1}}],[\"但该索引列的值并不唯一\",{\"1\":{\"228\":1}}],[\"但全世界的顶级\",{\"1\":{\"109\":1}}],[\"但\",{\"1\":{\"109\":1,\"341\":2}}],[\"但此证书中的域名与\",{\"1\":{\"108\":1}}],[\"但证书上的内容被篡改了\",{\"1\":{\"108\":1}}],[\"但是直接内存中的内存还未被回收\",{\"1\":{\"522\":1}}],[\"但是仔细想一想\",{\"1\":{\"506\":1}}],[\"但是为了方便\",{\"1\":{\"450\":1}}],[\"但是返回的是假数据\",{\"1\":{\"437\":1}}],[\"但是依然有两个问题没有解决\",{\"1\":{\"400\":1}}],[\"但是却已经被覆盖的数据\",{\"1\":{\"386\":1}}],[\"但是set\",{\"1\":{\"379\":1}}],[\"但是他去更新了这条记录\",{\"1\":{\"367\":1}}],[\"但是此时的余额已经可以被事务\",{\"1\":{\"357\":1}}],[\"但是与sql\",{\"1\":{\"357\":1}}],[\"但是要实现事务必须要遵守\",{\"1\":{\"352\":1}}],[\"但是钱并没有到你的账户上\",{\"1\":{\"351\":1}}],[\"但是性能很差\",{\"1\":{\"347\":1}}],[\"但是风险也是最大的\",{\"1\":{\"343\":1}}],[\"但是最终都写到同一个\",{\"1\":{\"343\":1}}],[\"但是最多只涉及树的一条路径\",{\"1\":{\"255\":1}}],[\"但是数据安全性方面比参数\",{\"1\":{\"338\":1}}],[\"但是数据库的读取并不以\",{\"1\":{\"155\":1,\"243\":1}}],[\"但是问题来了\",{\"1\":{\"337\":1}}],[\"但是问题又来了\",{\"1\":{\"107\":1}}],[\"但是表上有更新语句\",{\"1\":{\"333\":1}}],[\"但是优化器最终扫描选择的是全表\",{\"1\":{\"330\":1}}],[\"但是会因为一些条件会退化成间隙锁\",{\"1\":{\"329\":1}}],[\"但是会将连接恢复到刚刚创建完时的状态\",{\"1\":{\"139\":1}}],[\"但是具体加了什么锁而导致死锁\",{\"1\":{\"318\":1}}],[\"但是现在处于等待状态\",{\"1\":{\"317\":1}}],[\"但是现实就是这么残酷\",{\"1\":{\"185\":1}}],[\"但是一直不提交\",{\"1\":{\"310\":1}}],[\"但是一直还没提交\",{\"1\":{\"310\":1}}],[\"但是对主键索引加锁的时候\",{\"1\":{\"295\":1}}],[\"但是对于符合\",{\"1\":{\"216\":2}}],[\"但是查询条件值的记录不存在于表中\",{\"1\":{\"294\":1}}],[\"但是查询的数据不是主键值\",{\"1\":{\"245\":1}}],[\"但是查询的性能大大降低\",{\"1\":{\"233\":1}}],[\"但是实际在\",{\"1\":{\"293\":1,\"298\":1}}],[\"但是实际上在文件中它被分成很多小份的数据页\",{\"1\":{\"184\":1}}],[\"但是大体上是相同的\",{\"1\":{\"288\":1}}],[\"但是大家知道\",{\"1\":{\"242\":1}}],[\"但是并没有把数据持久化到磁盘\",{\"1\":{\"343\":1}}],[\"但是并没有什么区别\",{\"1\":{\"286\":1,\"315\":1}}],[\"但是并不意味着\",{\"1\":{\"234\":1}}],[\"但是不在\",{\"1\":{\"359\":1,\"360\":1}}],[\"但是不可能发生脏读和不可重复读现象\",{\"1\":{\"357\":1}}],[\"但是不可能发生脏读现象\",{\"1\":{\"357\":1}}],[\"但是不可以对该记录加\",{\"1\":{\"285\":1,\"314\":1}}],[\"但是不包含记录本身\",{\"1\":{\"284\":1,\"313\":1}}],[\"但是不会读取记录中的任何字段的值\",{\"1\":{\"193\":1}}],[\"但是不会去查表或者字段存不存在\",{\"1\":{\"142\":1}}],[\"但是好在我找点了点规律\",{\"1\":{\"282\":1}}],[\"但是只要破坏任意一个条件就死锁就不会成立\",{\"1\":{\"281\":1}}],[\"但是当搭配\",{\"1\":{\"312\":1}}],[\"但是当第一个事务还未提交的时候\",{\"1\":{\"280\":1}}],[\"但是当发生行溢出时\",{\"1\":{\"168\":1}}],[\"但是由于事务\",{\"1\":{\"280\":1}}],[\"但是由于这条语句会发生索引失效\",{\"1\":{\"178\":1}}],[\"但是事务\",{\"1\":{\"280\":1}}],[\"但是除了报错之外\",{\"1\":{\"279\":1,\"280\":1}}],[\"但是还是没有能完全解决幻读\",{\"1\":{\"366\":1}}],[\"但是还是有个别的情况造成的幻读现象是无法解决的\",{\"1\":{\"362\":1}}],[\"但是还要注意\",{\"1\":{\"275\":1}}],[\"但是还有个问题无法解决\",{\"1\":{\"178\":1}}],[\"但是有一点要注意\",{\"1\":{\"275\":1}}],[\"但是有没有想过\",{\"1\":{\"137\":1}}],[\"但是我们希望这个请求发送到tomcat服务器\",{\"1\":{\"441\":1}}],[\"但是我们无法从select\",{\"1\":{\"296\":1}}],[\"但是我们需要跳出来看\",{\"1\":{\"184\":1}}],[\"但是我在前面介绍\",{\"1\":{\"255\":1}}],[\"但是因为它本质上是一个二叉树\",{\"1\":{\"252\":1}}],[\"但是因为它包含在联合索引\",{\"1\":{\"149\":1}}],[\"但是插入新元素的时候性能太低\",{\"1\":{\"250\":1}}],[\"但是每次查找都需要不断计算中间位置\",{\"1\":{\"249\":1}}],[\"但是逻辑上连续\",{\"1\":{\"246\":1}}],[\"但是二级索引的叶子节点存放的是主键值\",{\"1\":{\"245\":1}}],[\"但是检索效率不高\",{\"1\":{\"243\":1}}],[\"但是下面这条语句还是走了索引扫描的\",{\"1\":{\"238\":1}}],[\"但是如果索引字段是整型类型\",{\"1\":{\"238\":1}}],[\"但是如果数据库表中的字段都是索引的话\",{\"1\":{\"232\":1}}],[\"但是比首节点的第二个索引值中的周字小\",{\"1\":{\"235\":1}}],[\"但是索引并不是万能的\",{\"1\":{\"233\":1}}],[\"但是索引也是有缺点的\",{\"1\":{\"220\":1}}],[\"但是开销依然很大\",{\"1\":{\"228\":1}}],[\"但是它会对读到的记录加上\",{\"1\":{\"361\":1}}],[\"但是它会占用物理空间\",{\"1\":{\"227\":1}}],[\"但是它很大程度上避免幻读现象\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"但是它并不是意向锁\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"但是它本质上还是一个二叉树\",{\"1\":{\"258\":1}}],[\"但是它存在一种极端的情况\",{\"1\":{\"258\":1}}],[\"但是它们数据的存储结构实现方式不同\",{\"1\":{\"234\":1}}],[\"但是它却只因为被访问了一次而进入到\",{\"1\":{\"178\":1}}],[\"但是更好的方式给\",{\"1\":{\"219\":1}}],[\"但是联合索引的最左匹配原则并没有在遇到\",{\"1\":{\"216\":3}}],[\"但是允许有空值\",{\"1\":{\"211\":1}}],[\"但是执行计划里的\",{\"1\":{\"232\":1}}],[\"但是执行一次\",{\"1\":{\"198\":1}}],[\"但是执行的效率会不同\",{\"1\":{\"145\":1}}],[\"但是叶子节点中存放的是真正的行数据\",{\"1\":{\"187\":1}}],[\"但是在这个隔离级别下\",{\"1\":{\"329\":1}}],[\"但是在插入数据时\",{\"1\":{\"270\":1}}],[\"但是在条件查询中\",{\"1\":{\"238\":1}}],[\"但是在符合\",{\"1\":{\"216\":1}}],[\"但是在范围查询字段的后面的字段无法用到联合索引\",{\"1\":{\"216\":2}}],[\"但是在\",{\"1\":{\"194\":1,\"197\":1}}],[\"但是在索引页中记录的是页\",{\"1\":{\"186\":1}}],[\"但是在一开始生成页的时候\",{\"1\":{\"185\":1}}],[\"但是若每次修改数据都刷入磁盘\",{\"1\":{\"179\":1}}],[\"但是磁盘中还是原数据\",{\"1\":{\"179\":1}}],[\"但是可能这些被提前加载进来的数据页\",{\"1\":{\"178\":1}}],[\"但是页面未发生修改\",{\"1\":{\"178\":1}}],[\"但是也不能每次都从磁盘里面读取数据\",{\"1\":{\"172\":1}}],[\"但是这样做的风险是\",{\"1\":{\"349\":2}}],[\"但是这两个是独立的逻辑\",{\"1\":{\"344\":1}}],[\"但是这里不是唯一索引范围查询\",{\"1\":{\"298\":1}}],[\"但是这里有一个关键问题\",{\"1\":{\"106\":1}}],[\"但是这次\",{\"1\":{\"434\":1}}],[\"但是这次的案例是查询\",{\"1\":{\"291\":1}}],[\"但是这次因为不是第一次查询了\",{\"1\":{\"147\":1}}],[\"但是这些记录数据是没用的\",{\"1\":{\"252\":1}}],[\"但是这条语句还要对\",{\"1\":{\"219\":1}}],[\"但是这个是包含\",{\"1\":{\"169\":1}}],[\"但是经过我和朋友看\",{\"1\":{\"142\":1}}],[\"但是注意\",{\"1\":{\"142\":1}}],[\"但是其实查询缓存挺鸡肋的\",{\"1\":{\"140\":1}}],[\"但是\",{\"1\":{\"139\":1,\"149\":1,\"162\":1,\"187\":1,\"189\":2,\"192\":1,\"193\":1,\"207\":1,\"215\":1,\"237\":2,\"239\":1,\"244\":1,\"252\":1,\"254\":1,\"257\":1,\"258\":1,\"288\":1,\"307\":1,\"312\":1,\"329\":1,\"334\":1,\"337\":1,\"340\":1,\"344\":1,\"346\":2,\"386\":1,\"407\":1}}],[\"但是上面的证书调包给了我们一种思路\",{\"1\":{\"108\":1}}],[\"但没打借条\",{\"1\":{\"104\":1}}],[\"但实际上是在和一个钓鱼网站通信\",{\"1\":{\"103\":1}}],[\"但我发现总是或多或少有些点有些遗漏\",{\"1\":{\"102\":1}}],[\"但时序图着重于时间顺序\",{\"1\":{\"86\":1}}],[\"但如果在流程图上\",{\"1\":{\"85\":1}}],[\"通俗易懂的双亲委派机制\",{\"1\":{\"508\":1}}],[\"通俗点说就是\",{\"1\":{\"480\":1}}],[\"通俗点讲就是\",{\"1\":{\"89\":1}}],[\"通知垃圾回收器进行回收\",{\"1\":{\"520\":1}}],[\"通知\",{\"1\":{\"391\":1,\"394\":1}}],[\"通常需要活对象的\",{\"1\":{\"526\":1}}],[\"通常\",{\"1\":{\"498\":1}}],[\"通常都会想对字段建立索引\",{\"1\":{\"233\":1}}],[\"通常都是建议将字段设置为\",{\"1\":{\"162\":1}}],[\"通常用于多表联查中\",{\"1\":{\"228\":1}}],[\"通常使用在多表联查中\",{\"1\":{\"228\":1}}],[\"通常在创建表的时候一起创建\",{\"1\":{\"210\":1}}],[\"通常在没有任何查询条件下的\",{\"1\":{\"197\":1}}],[\"通信方式\",{\"0\":{\"121\":1}}],[\"通信时将证书发给\",{\"1\":{\"109\":1}}],[\"通信原理简述\",{\"0\":{\"105\":1},\"1\":{\"102\":1}}],[\"通信图中的时间顺序可以从消息序号中获得\",{\"1\":{\"86\":1}}],[\"通信图和时序图有点类似\",{\"1\":{\"86\":1}}],[\"通信图组成元素\",{\"1\":{\"86\":1}}],[\"通信图描述的是对象和对象之间的调用关系\",{\"1\":{\"86\":1}}],[\"通信图\",{\"0\":{\"86\":1},\"1\":{\"87\":1}}],[\"通过程序计数器可以知道应该执行哪一句指令\",{\"1\":{\"539\":1}}],[\"通过任务id去获取额外信息\",{\"1\":{\"508\":1}}],[\"通过任务阶段来区分\",{\"1\":{\"58\":1}}],[\"通过id去查询信息\",{\"1\":{\"508\":1}}],[\"通过赵老板的信息拿到公司前台的电话\",{\"1\":{\"507\":1}}],[\"通过数组定义类引用\",{\"1\":{\"492\":1}}],[\"通过反射动态获取额外数据\",{\"1\":{\"508\":1}}],[\"通过反射\",{\"1\":{\"489\":1}}],[\"通过实现entryhandler<t>接口编写监听器\",{\"1\":{\"463\":1}}],[\"通过命令查看结果\",{\"1\":{\"408\":1}}],[\"通过命令查看集群状态\",{\"1\":{\"407\":1}}],[\"通过执行bgrewriteaof命令\",{\"1\":{\"379\":1}}],[\"通过执行计划显示的数据判断查询语句是否使用了索引\",{\"1\":{\"228\":1}}],[\"通过这个\",{\"1\":{\"364\":1}}],[\"通过加读写锁的方式来避免并行访问\",{\"1\":{\"357\":1}}],[\"通过加锁虽然完美地解决了顺序一致性的问题\",{\"1\":{\"347\":1}}],[\"通过举例子给大家说明\",{\"1\":{\"353\":1}}],[\"通过延迟写\",{\"1\":{\"348\":1}}],[\"通过使用\",{\"1\":{\"347\":1}}],[\"通过主键索引树搜索获取\",{\"1\":{\"343\":1,\"350\":1}}],[\"通过主键查询商品数据的过程\",{\"0\":{\"205\":1}}],[\"通过调用\",{\"1\":{\"338\":1}}],[\"通过几个小实验来证明这个结论吧\",{\"1\":{\"301\":1}}],[\"通过几个实验\",{\"1\":{\"292\":1}}],[\"通过前面这三个实验\",{\"1\":{\"294\":1}}],[\"通过前面这个实验\",{\"1\":{\"293\":1}}],[\"通过分层来降低每一层的搜索量\",{\"1\":{\"244\":1}}],[\"通过上图\",{\"1\":{\"244\":1}}],[\"通过二分法快速定位到符合页内范围包含查询值的页\",{\"1\":{\"244\":1}}],[\"通过二分查找的方法快速检索到记录在哪个分组\",{\"1\":{\"244\":1}}],[\"通过二级索引查询商品数据的过程\",{\"0\":{\"206\":1}}],[\"通过槽查找记录时\",{\"1\":{\"244\":1}}],[\"通过槽\",{\"1\":{\"243\":1}}],[\"通过查询比较的方式\",{\"1\":{\"232\":1}}],[\"通过将多个字段组合成一个索引\",{\"1\":{\"215\":1}}],[\"通过三种链表来管理缓页\",{\"1\":{\"180\":1}}],[\"通过索引只能定位到磁盘中的页\",{\"1\":{\"174\":1}}],[\"通过解析器对\",{\"1\":{\"150\":1}}],[\"通过\",{\"1\":{\"123\":1,\"179\":1,\"216\":5,\"275\":1,\"290\":1,\"291\":1,\"322\":1,\"329\":1,\"334\":3,\"344\":1,\"359\":1,\"462\":1,\"517\":1}}],[\"通过部门或者责任来区分\",{\"1\":{\"58\":1}}],[\"通过异步非阻塞的方式来处理请求\",{\"1\":{\"47\":1}}],[\"通过它访问到主机\",{\"1\":{\"43\":1}}],[\"通过expires参数设置\",{\"1\":{\"42\":1}}],[\"通过location指定不同的后缀名实现不同的请求转发\",{\"1\":{\"42\":1}}],[\"通过代理服务器进行互联网访问\",{\"1\":{\"21\":1}}],[\"单位s\",{\"1\":{\"453\":1}}],[\"单位是毫秒\",{\"1\":{\"450\":2}}],[\"单节点redis的并发能力是有上限的\",{\"1\":{\"382\":1}}],[\"单机redis存在的问题\",{\"1\":{\"370\":1}}],[\"单事务\",{\"1\":{\"347\":1}}],[\"单独执行一个更新语句的时候\",{\"1\":{\"338\":1}}],[\"单独给\",{\"1\":{\"219\":1}}],[\"单点查询\",{\"0\":{\"254\":1}}],[\"单向链表的特点就是插入\",{\"1\":{\"243\":1}}],[\"单列索引\",{\"1\":{\"203\":1}}],[\"单表建议值\",{\"0\":{\"187\":1}}],[\"单表数量限制\",{\"0\":{\"183\":1}}],[\"单表超过\",{\"1\":{\"181\":1}}],[\"单表最好不要超过\",{\"1\":{\"181\":1}}],[\"单表不要超过\",{\"0\":{\"181\":1},\"1\":{\"96\":1}}],[\"单字段的情况\",{\"0\":{\"166\":1}}],[\"单元\",{\"1\":{\"83\":1}}],[\"单连接请求上限次数\",{\"1\":{\"32\":1}}],[\"识别参与过程的交互对象\",{\"1\":{\"82\":1}}],[\"自己才会去加载这个类\",{\"1\":{\"494\":1}}],[\"自己也被自己顿悟了\",{\"1\":{\"282\":1}}],[\"自定义的http工具也需要放到这个目录下\",{\"1\":{\"442\":1}}],[\"自定义库\",{\"1\":{\"432\":1}}],[\"自定义一个函数\",{\"1\":{\"430\":1}}],[\"自定义格式\",{\"1\":{\"32\":1}}],[\"自动装配\",{\"1\":{\"459\":1}}],[\"自动提升一个slave为新的master\",{\"1\":{\"410\":1}}],[\"自动故障转移\",{\"0\":{\"410\":1}}],[\"自动故障恢复\",{\"1\":{\"391\":1}}],[\"自然也是\",{\"1\":{\"357\":1}}],[\"自然就没办法锁住这条不存在的记录\",{\"1\":{\"291\":1}}],[\"自然就没办法走索引了\",{\"1\":{\"236\":1}}],[\"自然就不需要考虑\",{\"1\":{\"275\":1}}],[\"自然就用不到喽\",{\"1\":{\"174\":1}}],[\"自带的引擎是\",{\"1\":{\"340\":1}}],[\"自带的函数来得到我们想要的结果\",{\"1\":{\"236\":1}}],[\"自增锁还是要等语句结束后才被释放\",{\"1\":{\"312\":1}}],[\"自增锁在申请之后就马上释放\",{\"1\":{\"312\":1}}],[\"自增字段选择无符号的\",{\"1\":{\"183\":1}}],[\"自连接\",{\"0\":{\"265\":1},\"1\":{\"261\":1}}],[\"自平衡二叉树虽然能保持查询操作的时间复杂度在o\",{\"1\":{\"252\":1}}],[\"自适应哈希索引\",{\"1\":{\"174\":1,\"336\":1}}],[\"自签名证书\",{\"1\":{\"109\":1}}],[\"自身调用自身的方法\",{\"1\":{\"81\":1}}],[\"自关联消息\",{\"1\":{\"79\":1,\"81\":1}}],[\"异步通知\",{\"1\":{\"456\":1}}],[\"异步复制\",{\"1\":{\"342\":1}}],[\"异步消息\",{\"1\":{\"79\":1,\"81\":1}}],[\"异常\",{\"1\":{\"519\":1}}],[\"异常等\",{\"1\":{\"499\":1}}],[\"异常重启会出现什么现象\",{\"0\":{\"346\":1},\"1\":{\"346\":1}}],[\"异常重启之后数据不会丢失\",{\"1\":{\"338\":1}}],[\"异常退出\",{\"1\":{\"46\":1}}],[\"返回一个代理类的对象\",{\"1\":{\"507\":1}}],[\"返回null\",{\"1\":{\"502\":1}}],[\"返回数据\",{\"1\":{\"451\":2,\"454\":2}}],[\"返回数据返回可能是多条\",{\"1\":{\"228\":1}}],[\"返回结果\",{\"1\":{\"444\":1,\"451\":1,\"454\":1}}],[\"返回404\",{\"1\":{\"442\":1,\"450\":1}}],[\"返回的响应内容包括\",{\"1\":{\"441\":1}}],[\"返回的字段\",{\"1\":{\"265\":1}}],[\"返回假数据\",{\"1\":{\"436\":1}}],[\"返回假的商品数据\",{\"1\":{\"434\":1}}],[\"返回值是common中返回的\",{\"1\":{\"442\":1}}],[\"返回值\",{\"1\":{\"428\":1}}],[\"返回记录给执行器\",{\"1\":{\"343\":1,\"350\":1}}],[\"返回左右表中所有的记录和左右表中连接字段相等的记录\",{\"1\":{\"264\":1}}],[\"返回包括右表中的所有记录和左表中连接字段相等的记录\",{\"1\":{\"264\":1}}],[\"返回包括左表中的所有记录和右表中连接字段相等的记录\",{\"1\":{\"264\":1}}],[\"返回根节点即可\",{\"1\":{\"250\":1}}],[\"返回给客户端\",{\"1\":{\"150\":1,\"342\":1}}],[\"返回了读取完毕的信息\",{\"1\":{\"148\":1}}],[\"返回消息表示从过程调用返回\",{\"1\":{\"81\":1}}],[\"返回消息\",{\"1\":{\"79\":1,\"81\":1}}],[\"返回消息等\",{\"1\":{\"79\":1,\"80\":1}}],[\"返回状态码200\",{\"1\":{\"42\":1}}],[\"返回状态码304\",{\"1\":{\"42\":1}}],[\"又返回来执行当前线程的代码时\",{\"1\":{\"539\":1}}],[\"又叫运行时数据区\",{\"1\":{\"538\":1}}],[\"又可以作为java中的map来使用\",{\"1\":{\"425\":1}}],[\"又可以细分为产品流程图\",{\"1\":{\"54\":1}}],[\"又该如何避免这种事故的发生\",{\"1\":{\"328\":1}}],[\"又能阻止其他事务将新纪录插入到被保护记录前面的间隙中\",{\"1\":{\"316\":1}}],[\"又能阻止其他事务将新记录插入到被保护记录前面的间隙中\",{\"1\":{\"287\":1}}],[\"又不会出现数据一致性问题\",{\"1\":{\"312\":1}}],[\"又是什么情况下\",{\"1\":{\"296\":1}}],[\"又发现这行数据\",{\"1\":{\"270\":1}}],[\"又称子查询\",{\"1\":{\"266\":1}}],[\"又称作业调度\",{\"1\":{\"134\":1}}],[\"又会在该页内进行二分法快速定位记录所在的分组\",{\"1\":{\"244\":1}}],[\"又什么好处\",{\"1\":{\"226\":1}}],[\"又没有唯一约束\",{\"1\":{\"164\":1}}],[\"又名pipe文件\",{\"1\":{\"124\":1}}],[\"又名序列图\",{\"1\":{\"79\":1,\"80\":1}}],[\"又成信箱通信方式\",{\"1\":{\"123\":1}}],[\"又看到了一些大学时候的照片\",{\"1\":{\"95\":1}}],[\"构造器\",{\"1\":{\"489\":1,\"499\":1}}],[\"构成一个双向链表\",{\"1\":{\"244\":1}}],[\"构建cache对象\",{\"1\":{\"416\":1}}],[\"构建出语法树\",{\"1\":{\"333\":1}}],[\"构建出\",{\"1\":{\"142\":1}}],[\"构建和编写一个正在开发的\",{\"1\":{\"58\":1}}],[\"构件表示如下\",{\"1\":{\"76\":1}}],[\"构件是软件开发过程中的产物\",{\"1\":{\"76\":1}}],[\"构件\",{\"0\":{\"76\":1},\"1\":{\"78\":1}}],[\"防止重复加载同一个\",{\"1\":{\"494\":1}}],[\"防止链表超长时性能下降\",{\"1\":{\"473\":1}}],[\"防止因为扫描全表\",{\"1\":{\"331\":1}}],[\"防止其他事务在这个记录之间插入新的记录\",{\"1\":{\"329\":1}}],[\"防止其他线程对这个表结构做了变更\",{\"1\":{\"310\":1}}],[\"防止索引失效\",{\"0\":{\"228\":1},\"1\":{\"223\":1}}],[\"防止惊群现象发生\",{\"1\":{\"32\":1}}],[\"防火墙等\",{\"1\":{\"75\":1}}],[\"协调者\",{\"1\":{\"344\":4}}],[\"协作图\",{\"0\":{\"86\":1}}],[\"协作\",{\"1\":{\"73\":1}}],[\"协议进行传输的\",{\"1\":{\"139\":1}}],[\"协议\",{\"1\":{\"26\":2,\"110\":1}}],[\"层开始更新记录\",{\"1\":{\"343\":1,\"350\":1}}],[\"层还会生成一条\",{\"1\":{\"340\":1}}],[\"层更新记录前\",{\"1\":{\"336\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"层生成的日志\",{\"1\":{\"333\":1}}],[\"层左右\",{\"1\":{\"207\":1}}],[\"层高度就可以满足\",{\"1\":{\"205\":1}}],[\"层每从\",{\"1\":{\"193\":1}}],[\"层每从存储引擎读到一条记录就会发送给客户端\",{\"1\":{\"148\":1}}],[\"层会循环向\",{\"1\":{\"192\":1}}],[\"层会维护一个名叫\",{\"1\":{\"192\":1}}],[\"层应该是比较合理的一个值\",{\"1\":{\"187\":1}}],[\"层结构的而已\",{\"1\":{\"186\":1}}],[\"层在判断其他的查询条件\",{\"1\":{\"149\":1}}],[\"层在判断该记录的\",{\"1\":{\"149\":1}}],[\"层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录\",{\"1\":{\"149\":2}}],[\"层部分负责的事情\",{\"1\":{\"149\":1}}],[\"层的树\",{\"1\":{\"186\":1}}],[\"层的查询缓存\",{\"1\":{\"140\":1}}],[\"层的\",{\"1\":{\"140\":1,\"343\":1}}],[\"层实现的日志\",{\"1\":{\"341\":1}}],[\"层实现\",{\"1\":{\"138\":1}}],[\"层负责建立连接\",{\"1\":{\"138\":1}}],[\"层和存储引擎层有了一个简单认识\",{\"1\":{\"138\":1}}],[\"层和存储引擎层\",{\"1\":{\"138\":1}}],[\"层次\",{\"0\":{\"134\":1}}],[\"层可以建模为uml包\",{\"1\":{\"73\":1}}],[\"层\",{\"1\":{\"73\":1,\"138\":1,\"149\":3,\"187\":3,\"192\":1,\"193\":1,\"239\":1,\"343\":1,\"350\":1}}],[\"绘制对象的关键状态和关键对象之间的连接关系\",{\"1\":{\"72\":1}}],[\"绘制流程图时\",{\"1\":{\"57\":1}}],[\"绘制流程图过程中还要注意一些约定俗成的路径规划\",{\"1\":{\"57\":1}}],[\"选中其中一个对象图形\",{\"1\":{\"72\":1}}],[\"选择依据是这样的\",{\"1\":{\"393\":1}}],[\"选择了\",{\"1\":{\"232\":1}}],[\"选择\",{\"0\":{\"207\":1},\"1\":{\"201\":1}}],[\"选择查询成本最小的执行计划\",{\"1\":{\"150\":1}}],[\"选择实体集应包含的属性\",{\"1\":{\"91\":1}}],[\"选择合适的对象符号\",{\"1\":{\"72\":1}}],[\"选择合适的算法\",{\"1\":{\"58\":1}}],[\"选择计算方法\",{\"1\":{\"58\":1}}],[\"选择结构又称分支结构\",{\"1\":{\"56\":1}}],[\"选择结构\",{\"1\":{\"56\":2}}],[\"选择结构和循环结构\",{\"1\":{\"56\":1}}],[\"建表后\",{\"1\":{\"211\":1,\"212\":1,\"213\":1}}],[\"建一张表\",{\"1\":{\"182\":1}}],[\"建立索引\",{\"1\":{\"304\":1}}],[\"建立了索引\",{\"1\":{\"233\":1}}],[\"建立一个索引就可以了\",{\"1\":{\"219\":1}}],[\"建立联合索引时\",{\"1\":{\"218\":1}}],[\"建立联合索引时的字段顺序\",{\"1\":{\"218\":1}}],[\"建立在多列上的索引称为联合索引\",{\"1\":{\"214\":1}}],[\"建立在单列上的索引称为单列索引\",{\"1\":{\"214\":1}}],[\"建立连接\",{\"1\":{\"150\":1,\"408\":1}}],[\"建立链\",{\"1\":{\"72\":1}}],[\"建议不开启\",{\"1\":{\"373\":1}}],[\"建议不要在命令行写密码\",{\"1\":{\"139\":1}}],[\"建议使用自增字段作为主键\",{\"1\":{\"226\":1}}],[\"建议给这个字段建立一个二级索引\",{\"1\":{\"196\":1}}],[\"建议命名为feature\",{\"1\":{\"7\":1}}],[\"建议命名为\",{\"1\":{\"7\":1}}],[\"建模时\",{\"1\":{\"72\":1}}],[\"画外音\",{\"1\":{\"109\":1}}],[\"画布左侧会自动出现绘制uml所需的符号\",{\"1\":{\"72\":1}}],[\"画流程图的时候如果弄错了\",{\"1\":{\"55\":1}}],[\"画流程图常用的工具\",{\"1\":{\"52\":1}}],[\"打印错误信息\",{\"1\":{\"430\":1}}],[\"打破循环等待条件\",{\"1\":{\"281\":1}}],[\"打开亿图图示\",{\"1\":{\"72\":1}}],[\"打标签\",{\"1\":{\"15\":1}}],[\"之间\",{\"1\":{\"205\":2,\"358\":1,\"359\":2,\"360\":2}}],[\"之间的部分\",{\"1\":{\"339\":2}}],[\"之间的记录\",{\"1\":{\"216\":1}}],[\"之间的位置\",{\"1\":{\"161\":1,\"163\":1}}],[\"之间的关系\",{\"1\":{\"58\":1}}],[\"之后插入一些通用处理\",{\"1\":{\"507\":1}}],[\"之后事务\",{\"1\":{\"367\":2}}],[\"之后就会被从库\",{\"1\":{\"346\":1}}],[\"之后可以在插入数据时\",{\"1\":{\"312\":1}}],[\"之后才产生的锁\",{\"1\":{\"280\":1}}],[\"之后成为默认的\",{\"1\":{\"204\":1}}],[\"之后成为默认的存储引擎\",{\"1\":{\"202\":1}}],[\"之后\",{\"1\":{\"187\":1,\"239\":1,\"312\":1}}],[\"之后随着程序的运行\",{\"1\":{\"174\":1,\"336\":1}}],[\"之后你们在去了解其他行格式\",{\"1\":{\"158\":1}}],[\"之后引入了\",{\"1\":{\"158\":1}}],[\"之后的通信其实还是在裸奔\",{\"1\":{\"106\":1}}],[\"之所以\",{\"1\":{\"296\":1}}],[\"之所以要绕一大圈才讲行记录的格式\",{\"1\":{\"157\":1}}],[\"之所以客户端显示的时候是直接显示所有记录的\",{\"1\":{\"148\":1}}],[\"之前已提交的记录都不会丢失\",{\"1\":{\"337\":1}}],[\"之前收到读者面试字节时\",{\"1\":{\"318\":1}}],[\"之前我们说过\",{\"1\":{\"442\":1}}],[\"之前我写过一篇关于\",{\"1\":{\"282\":1}}],[\"之前我也专门写过一篇文章\",{\"1\":{\"207\":1}}],[\"之前\",{\"1\":{\"217\":1,\"280\":1,\"311\":2}}],[\"之前讲事务隔离的时候就介绍到了\",{\"1\":{\"157\":1}}],[\"之前文章有说过\",{\"1\":{\"155\":1}}],[\"之前有位读者在面字节的时候\",{\"1\":{\"151\":1}}],[\"之前的版本\",{\"1\":{\"140\":1,\"149\":1}}],[\"之前专栏对uml类图的4种关联关系进行过详细拆解\",{\"1\":{\"70\":1}}],[\"之类的就行了\",{\"1\":{\"109\":1}}],[\"链条往下找旧版本的记录\",{\"1\":{\"359\":1,\"360\":1}}],[\"链表中\",{\"1\":{\"178\":2}}],[\"链表中移除\",{\"1\":{\"176\":1}}],[\"链表长度的比例可以通过\",{\"1\":{\"178\":1}}],[\"链表长度为\",{\"1\":{\"178\":1}}],[\"链表前排的位置\",{\"1\":{\"178\":1}}],[\"链表头部\",{\"1\":{\"178\":1}}],[\"链表头部的节点是最近使用的\",{\"1\":{\"178\":1}}],[\"链表和\",{\"1\":{\"178\":1}}],[\"链表从左到右有\",{\"1\":{\"178\":1}}],[\"链表末尾的节点\",{\"1\":{\"178\":1}}],[\"链表的\",{\"1\":{\"178\":1}}],[\"链表的前半部分\",{\"1\":{\"178\":1}}],[\"链表的头部\",{\"1\":{\"178\":2,\"180\":1}}],[\"链表的元素都是脏页\",{\"1\":{\"177\":1}}],[\"链表的节点也是控制块\",{\"1\":{\"177\":1}}],[\"链表类似的\",{\"1\":{\"177\":1}}],[\"链表后\",{\"1\":{\"176\":1,\"177\":1}}],[\"链表上除了有控制块\",{\"1\":{\"176\":1}}],[\"链表\",{\"1\":{\"176\":1,\"177\":2,\"178\":4,\"180\":1,\"472\":2}}],[\"链表节点移动到链表的头部\",{\"1\":{\"178\":1}}],[\"链表节点都对应一个空闲的缓存页\",{\"1\":{\"176\":1}}],[\"链表节点是一个一个的控制块\",{\"1\":{\"176\":1}}],[\"链表节点\",{\"1\":{\"174\":1}}],[\"链接\",{\"1\":{\"86\":1,\"492\":1}}],[\"链一端的一个对象可以得到另一位置上的一个或一组对象\",{\"1\":{\"70\":1}}],[\"链主要用来导航\",{\"1\":{\"70\":1}}],[\"链同样使用一根实线段来表示\",{\"1\":{\"70\":1}}],[\"链在对象图中的作用类似于关联关系在类图中的作用\",{\"1\":{\"70\":1}}],[\"链是类之间的关联关系的实例\",{\"1\":{\"70\":1}}],[\"链\",{\"1\":{\"70\":1}}],[\"状态的\",{\"1\":{\"346\":1}}],[\"状态也是会刷盘的\",{\"1\":{\"345\":1}}],[\"状态后\",{\"1\":{\"345\":1,\"350\":1}}],[\"状态设置为\",{\"1\":{\"345\":1,\"348\":1,\"350\":1}}],[\"状态机主要由状态\",{\"1\":{\"87\":1}}],[\"状态机图描述一个对象在其生命周期中的各种状态以及状态的转换\",{\"1\":{\"87\":1}}],[\"状态机图\",{\"0\":{\"87\":1},\"1\":{\"87\":1}}],[\"状态图比较适合对象导向的程序\",{\"1\":{\"85\":1}}],[\"状态图更重视动作的完成\",{\"1\":{\"85\":1}}],[\"状态图\",{\"0\":{\"85\":1},\"1\":{\"83\":1,\"85\":1}}],[\"状态图他们三者分别解决什么样的问题\",{\"0\":{\"83\":1}}],[\"状态\",{\"1\":{\"70\":1,\"346\":1}}],[\"两次rdb之间写入数据有丢失的风险\",{\"1\":{\"375\":1}}],[\"两位拳击手就可以直接开打\",{\"1\":{\"344\":1}}],[\"两位拳击手\",{\"1\":{\"344\":1}}],[\"两阶段提交虽然能够保证\",{\"1\":{\"347\":1}}],[\"两阶段提交虽然保证了两个日志文件的数据一致性\",{\"1\":{\"347\":1}}],[\"两阶段提交有什么问题\",{\"0\":{\"347\":1}}],[\"两阶段提交是以\",{\"1\":{\"346\":1}}],[\"两阶段提交的过程是怎样的\",{\"0\":{\"345\":1}}],[\"两阶段提交把单个事务的提交拆分成了\",{\"1\":{\"344\":1}}],[\"两阶段提交其实是分布式事务一致性协议\",{\"1\":{\"344\":1}}],[\"两阶段提交\",{\"1\":{\"343\":1,\"344\":1,\"345\":1}}],[\"两大作用\",{\"1\":{\"334\":1}}],[\"两个对象的计数都为1\",{\"1\":{\"516\":1}}],[\"两个对象之间的单路通信\",{\"1\":{\"81\":1}}],[\"两个日志的提交顺序一致\",{\"1\":{\"347\":1}}],[\"两个日志的内容一致\",{\"1\":{\"347\":1}}],[\"两个日志的过程中\",{\"1\":{\"344\":1}}],[\"两个事务即使生成的间隙锁的范围是一样的\",{\"1\":{\"326\":1}}],[\"两个事务的间隙锁之间是相互兼容的\",{\"1\":{\"323\":1}}],[\"两个事务的加锁过程\",{\"1\":{\"280\":1}}],[\"两个事务是可以同时持有的\",{\"1\":{\"275\":1}}],[\"两个事务都陷入了等待状态\",{\"1\":{\"274\":1}}],[\"两个区域\",{\"1\":{\"180\":1}}],[\"两个条件\",{\"1\":{\"178\":1}}],[\"两个部分\",{\"1\":{\"159\":1}}],[\"两个都是紧凑的行格式\",{\"1\":{\"158\":1}}],[\"两个问题\",{\"0\":{\"49\":1}}],[\"两者ip一定不要搞错了\",{\"1\":{\"440\":1}}],[\"两者一笔对就可以发现报文是否被篡改了\",{\"1\":{\"108\":1}}],[\"两者的异同\",{\"1\":{\"69\":1}}],[\"两者的关系\",{\"1\":{\"69\":1}}],[\"两者几乎使用一套完全相同的标识\",{\"1\":{\"68\":1}}],[\"鸟与翅膀的关系\",{\"1\":{\"66\":1}}],[\"鸟是动物的一种\",{\"1\":{\"66\":1}}],[\"组装类型\",{\"1\":{\"508\":1}}],[\"组合数据\",{\"1\":{\"444\":1,\"451\":1,\"454\":1}}],[\"组合关系同样是关联关系的一种\",{\"1\":{\"66\":1}}],[\"组合关系\",{\"1\":{\"66\":1}}],[\"组提交的效果\",{\"1\":{\"348\":1}}],[\"组提交吗\",{\"1\":{\"348\":1}}],[\"组提交\",{\"0\":{\"348\":1},\"1\":{\"348\":4}}],[\"组等很多概念\",{\"1\":{\"184\":1}}],[\"组成的\",{\"1\":{\"157\":2,\"272\":1}}],[\"组成\",{\"0\":{\"114\":1},\"1\":{\"153\":1}}],[\"组成元素\",{\"1\":{\"88\":1}}],[\"组成元素以及绘制规范\",{\"1\":{\"52\":1,\"91\":1}}],[\"组件\",{\"1\":{\"73\":1}}],[\"依然有少量的代码侵入\",{\"1\":{\"456\":1}}],[\"依然维持在\",{\"1\":{\"205\":1}}],[\"依然无法解决公钥被调包的风险\",{\"1\":{\"108\":1}}],[\"依然还是会被中间人截获的\",{\"1\":{\"106\":1}}],[\"依然是可以继续存活的\",{\"1\":{\"66\":1}}],[\"依次看看每一个功能模块的作用\",{\"1\":{\"138\":1}}],[\"依次画出随后消息\",{\"1\":{\"82\":1}}],[\"依次选择\",{\"1\":{\"72\":1}}],[\"依赖\",{\"1\":{\"73\":1}}],[\"依赖关系\",{\"1\":{\"66\":1}}],[\"部署图的组成元素\",{\"1\":{\"78\":1}}],[\"部署图实例\",{\"0\":{\"78\":1}}],[\"部署图是用来显示系统中软件和硬件的物理架构\",{\"1\":{\"74\":1}}],[\"部署图\",{\"0\":{\"74\":1}}],[\"部分解释\",{\"0\":{\"262\":1}}],[\"部分字段没有用到联合索引的\",{\"1\":{\"216\":1}}],[\"部分替代掉之后\",{\"1\":{\"185\":1}}],[\"部分的空间全部被\",{\"1\":{\"185\":1}}],[\"部分的对象还是可能继续存在的\",{\"1\":{\"66\":1}}],[\"部分\",{\"1\":{\"185\":3}}],[\"部分显示了\",{\"1\":{\"149\":1}}],[\"部分地方结合自己的理解与网上的资料可能有所更改\",{\"1\":{\"96\":1}}],[\"部分与组合同时创建并同时消亡\",{\"1\":{\"66\":1}}],[\"部分与整体生命期一致\",{\"1\":{\"66\":1}}],[\"部分对象的生命周期并不由整体对象来管理\",{\"1\":{\"66\":1}}],[\"部门维度\",{\"1\":{\"58\":1}}],[\"部门\",{\"1\":{\"58\":1}}],[\"棒棒糖表示法\",{\"1\":{\"66\":1}}],[\"接下里用两个实验来说明\",{\"1\":{\"295\":1}}],[\"接下里用两个案例来说明\",{\"1\":{\"289\":1}}],[\"接下里\",{\"1\":{\"159\":1}}],[\"接下来需要判断\",{\"1\":{\"360\":1}}],[\"接下来详细说下\",{\"1\":{\"357\":1}}],[\"接下来介绍每个阶段的过程\",{\"1\":{\"348\":1}}],[\"接下来就讲这个\",{\"1\":{\"343\":1}}],[\"接下来就是了\",{\"1\":{\"142\":1}}],[\"接下来等着你的\",{\"1\":{\"329\":1}}],[\"接下来说的案例都是基于\",{\"1\":{\"328\":1}}],[\"接下来跟大家聊下为什么会发生死锁\",{\"1\":{\"273\":1}}],[\"接下来举几个查询语句\",{\"1\":{\"234\":1}}],[\"接下来我通过一个简单例子\",{\"1\":{\"204\":1}}],[\"接下来我们就说\",{\"1\":{\"296\":1}}],[\"接下来我们再一起看看哪些情况会导致索引失效\",{\"1\":{\"234\":1}}],[\"接下来我们一步步来看看\",{\"1\":{\"104\":1}}],[\"接下来我们看看\",{\"1\":{\"103\":1}}],[\"接下来拿行记录的\",{\"1\":{\"178\":1}}],[\"接下来看看\",{\"1\":{\"166\":1}}],[\"接下来看第二条记录\",{\"1\":{\"162\":1}}],[\"接下来\",{\"1\":{\"138\":1,\"146\":2,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"203\":1,\"216\":1,\"234\":1,\"274\":1,\"280\":1,\"284\":1,\"290\":1,\"291\":2,\"292\":1,\"301\":1,\"303\":1,\"304\":2,\"318\":1,\"321\":1,\"353\":1,\"356\":1,\"357\":1,\"359\":1,\"365\":1,\"451\":1}}],[\"接下来将重点讲第三部分\",{\"1\":{\"59\":1}}],[\"接着将各实现类放入到枚举类中\",{\"1\":{\"508\":1}}],[\"接着将虚拟地址和物理地址建立映射关系\",{\"1\":{\"174\":1,\"336\":1}}],[\"接着按顺序执行了以下操作\",{\"1\":{\"360\":1}}],[\"接着调用引擎的提交事务接口\",{\"1\":{\"345\":1,\"350\":1}}],[\"接着对旧的\",{\"1\":{\"339\":1}}],[\"接着还会做语法分析\",{\"1\":{\"333\":1}}],[\"接着再备份商品表的数据\",{\"1\":{\"307\":1}}],[\"接着继续扫描已经存在的二级索引记录\",{\"1\":{\"298\":1}}],[\"接着继续扫描\",{\"1\":{\"297\":1}}],[\"接着继续往右匹配\",{\"1\":{\"235\":1}}],[\"接着会继续扫描\",{\"1\":{\"294\":1}}],[\"接着会发生如下的过程\",{\"1\":{\"178\":1}}],[\"接着扫描到第三行的时候\",{\"1\":{\"293\":1}}],[\"接着才是缓存页\",{\"1\":{\"174\":1}}],[\"接着\",{\"1\":{\"149\":2,\"244\":1,\"277\":2,\"280\":1,\"310\":1,\"311\":1,\"337\":1,\"348\":1,\"359\":2,\"367\":1}}],[\"接着判断记录是否符合查询条件\",{\"1\":{\"147\":1}}],[\"接着就要进入执行\",{\"1\":{\"143\":1}}],[\"接收方也能识别出来\",{\"1\":{\"104\":1}}],[\"接收信号\",{\"1\":{\"88\":1}}],[\"接收消息\",{\"1\":{\"79\":1,\"80\":1}}],[\"接口\",{\"1\":{\"73\":1,\"78\":1,\"490\":1,\"499\":1}}],[\"接口方法在实现类中出现\",{\"1\":{\"66\":1}}],[\"接口方法\",{\"1\":{\"66\":1}}],[\"接口名称\",{\"1\":{\"66\":1}}],[\"顶端有interface\",{\"1\":{\"66\":1}}],[\"矩形表示法\",{\"1\":{\"66\":1}}],[\"矩形框\",{\"1\":{\"58\":1,\"90\":1}}],[\"鸭\",{\"1\":{\"66\":1}}],[\"动态的创建一个代理类及其对象\",{\"1\":{\"507\":1}}],[\"动态性\",{\"0\":{\"481\":1}}],[\"动态语言\",{\"1\":{\"480\":1}}],[\"动态代理相关api\",{\"1\":{\"507\":1}}],[\"动态代理是指客户通过代理类来调用其它对象的方法\",{\"1\":{\"507\":1}}],[\"动态代理\",{\"0\":{\"504\":1,\"507\":1},\"1\":{\"478\":1}}],[\"动作\",{\"1\":{\"87\":1}}],[\"动物依赖水和氧气\",{\"1\":{\"66\":1}}],[\"动静分离\",{\"0\":{\"24\":1}}],[\"才启动的事务生成的\",{\"1\":{\"358\":1}}],[\"才提交事务\",{\"1\":{\"351\":1}}],[\"才可以继续执行\",{\"1\":{\"357\":1}}],[\"才可以持久化到磁盘\",{\"1\":{\"346\":1}}],[\"才可以确定插入的位置\",{\"1\":{\"296\":1}}],[\"才是事务真正启动的时机\",{\"1\":{\"357\":1}}],[\"才是将数据持久化到磁盘的操作\",{\"1\":{\"343\":1}}],[\"才是有序的\",{\"1\":{\"215\":1}}],[\"才返回客户端结果\",{\"1\":{\"342\":1}}],[\"才验证我上面说的结论\",{\"1\":{\"292\":1}}],[\"才代表事务成功获取到了锁\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"才存放了数据\",{\"1\":{\"244\":1}}],[\"才能被垃圾回收\",{\"1\":{\"519\":1}}],[\"才能继续执行\",{\"1\":{\"357\":1}}],[\"才能获取到插入意向锁\",{\"1\":{\"275\":1}}],[\"才能方便定位记录所在的页\",{\"1\":{\"244\":1}}],[\"才能更好的理解索引失效的问题\",{\"1\":{\"234\":1}}],[\"才能查到数据\",{\"1\":{\"206\":1}}],[\"才进入\",{\"1\":{\"180\":1}}],[\"才将页插入\",{\"1\":{\"178\":1}}],[\"才去执行回表操作获取整个记录\",{\"1\":{\"149\":1}}],[\"才会出现01111这样的值\",{\"1\":{\"475\":1}}],[\"才会进行树化\",{\"1\":{\"473\":1}}],[\"才会执行下一条\",{\"1\":{\"312\":1}}],[\"才会把\",{\"1\":{\"312\":1}}],[\"才会发生阻塞\",{\"1\":{\"296\":1}}],[\"才会将隐式锁转换为显式锁\",{\"1\":{\"276\":1}}],[\"才会将页插入到\",{\"1\":{\"180\":1}}],[\"才会存放实际数据\",{\"1\":{\"253\":1}}],[\"才会采用主键索引来进行统计\",{\"1\":{\"194\":1}}],[\"才会被插入到\",{\"1\":{\"178\":1}}],[\"才会被执行的用例\",{\"1\":{\"63\":1}}],[\"才会有磁盘上的页被缓存到\",{\"1\":{\"174\":1,\"336\":1}}],[\"才会显示出所有的记录\",{\"1\":{\"148\":1}}],[\"才会收到这样的报错\",{\"1\":{\"139\":1}}],[\"才得到正确的可供正式运行的程序\",{\"1\":{\"58\":1}}],[\"拓展用例是在特定条件出现时\",{\"1\":{\"63\":1}}],[\"拓展关系\",{\"0\":{\"63\":1}}],[\"拓展和依赖\",{\"1\":{\"59\":2}}],[\"账号登录与微信登录\",{\"1\":{\"61\":1}}],[\"箭头指向被扩展的用例\",{\"1\":{\"63\":1}}],[\"箭头指向被包含的用例\",{\"1\":{\"62\":1}}],[\"箭头指向被泛化\",{\"1\":{\"61\":1}}],[\"箭头指向用例\",{\"1\":{\"60\":1}}],[\"带上索引就能避免全表记录加锁了吗\",{\"1\":{\"329\":1}}],[\"带着这个问题\",{\"1\":{\"137\":1}}],[\"带着这个疑问相信你不难理解数字证书和数字签名这两个让人费解的含义\",{\"1\":{\"110\":1}}],[\"带线型箭头的虚线表示\",{\"1\":{\"81\":1}}],[\"带线型箭头的实线表示\",{\"1\":{\"81\":1}}],[\"带实心箭头的实线表示\",{\"1\":{\"81\":1}}],[\"带有关键字\",{\"1\":{\"76\":1}}],[\"带空心箭头的实线\",{\"1\":{\"61\":1}}],[\"带箭头的实线\",{\"1\":{\"60\":1}}],[\"举例个例子\",{\"1\":{\"216\":1}}],[\"举例几个范围查例子\",{\"1\":{\"216\":1}}],[\"举例说明\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":1}}],[\"举个具体例子\",{\"1\":{\"365\":1}}],[\"举个具体的例子来说明这四种隔离级别\",{\"1\":{\"357\":1}}],[\"举个栗子\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"举个拳击比赛的例子\",{\"1\":{\"344\":1}}],[\"举个例子大家就知道了\",{\"1\":{\"307\":1}}],[\"举个例子\",{\"1\":{\"178\":1,\"197\":1,\"226\":1,\"235\":1,\"236\":1,\"240\":1,\"277\":1,\"285\":1,\"302\":1,\"312\":1,\"314\":1,\"317\":1,\"344\":1,\"363\":1}}],[\"举个全表扫描的例子\",{\"1\":{\"148\":1}}],[\"举一个具体的例子\",{\"1\":{\"149\":1}}],[\"举一个例子\",{\"1\":{\"10\":1}}],[\"泛化关系\",{\"1\":{\"66\":1}}],[\"泛化关系的箭头不是指向被泛化\",{\"1\":{\"61\":1}}],[\"泛化是从下到上的抽象过程\",{\"1\":{\"61\":1}}],[\"泛化和继承是不同的方向\",{\"1\":{\"61\":1}}],[\"泛化\",{\"0\":{\"61\":1},\"1\":{\"59\":2,\"66\":1,\"72\":1,\"73\":1}}],[\"关闭redis连接的工具方法\",{\"1\":{\"450\":2}}],[\"关键因素之一\",{\"1\":{\"334\":1}}],[\"关键是备份期间\",{\"1\":{\"307\":1}}],[\"关键还得看这条语句在执行过程种\",{\"1\":{\"329\":1}}],[\"关键还要考虑插入记录的主键值\",{\"1\":{\"296\":1}}],[\"关键还是看数据表中的字段\",{\"1\":{\"232\":1}}],[\"关键字左或者左右模糊匹配无法走索引呢\",{\"1\":{\"235\":1}}],[\"关于反射的理解\",{\"0\":{\"480\":1}}],[\"关于索引的内容还有很多\",{\"1\":{\"246\":1}}],[\"关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案\",{\"1\":{\"174\":1,\"336\":1}}],[\"关于redis的学习\",{\"1\":{\"97\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"关联条件是两张表的\",{\"1\":{\"228\":1}}],[\"关联和实现\",{\"1\":{\"72\":1}}],[\"关联关系\",{\"0\":{\"60\":1},\"1\":{\"66\":1}}],[\"关联\",{\"1\":{\"59\":1}}],[\"关系说明\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":1}}],[\"关系\",{\"0\":{\"61\":1},\"1\":{\"59\":1,\"66\":1}}],[\"系统就会拒绝接下来的连接请求\",{\"1\":{\"139\":1}}],[\"系统分析师要根据建模的目标\",{\"1\":{\"72\":1}}],[\"系统执行这些动作\",{\"1\":{\"59\":1}}],[\"系统中有两个进程\",{\"1\":{\"44\":1}}],[\"特性\",{\"1\":{\"334\":1}}],[\"特地去看\",{\"1\":{\"146\":1}}],[\"特征\",{\"0\":{\"114\":1}}],[\"特点就是每个节点最多有\",{\"1\":{\"252\":1}}],[\"特点\",{\"1\":{\"66\":2,\"91\":1,\"539\":1}}],[\"特点是占有内存少\",{\"1\":{\"20\":1}}],[\"特别是在软件架构层次已经被验证有效\",{\"1\":{\"58\":1}}],[\"面向对象\",{\"2\":{\"510\":1}}],[\"面向对象的\",{\"1\":{\"58\":1}}],[\"面对\",{\"1\":{\"312\":1}}],[\"面对大表的记录统计\",{\"1\":{\"198\":1}}],[\"面试官反问的大概意思是\",{\"1\":{\"301\":1}}],[\"面试中\",{\"1\":{\"201\":1}}],[\"面试也很经常问\",{\"1\":{\"164\":1}}],[\"面试汇总篇👇\",{\"1\":{\"96\":1}}],[\"面是几个重要且最常用的符号\",{\"1\":{\"55\":1}}],[\"代理类的对象\",{\"1\":{\"507\":1}}],[\"代理类和目标对象的类都是在编译期间确定下来\",{\"1\":{\"506\":1}}],[\"代理类可以决定什么时候将方法转到原始对象上\",{\"1\":{\"506\":1}}],[\"代理类\",{\"1\":{\"506\":1}}],[\"代理对象决定是否以及何时将方法调用转到原始对象上\",{\"1\":{\"505\":1}}],[\"代理模式的原理\",{\"0\":{\"505\":1}}],[\"代理到windows上的tomcat服务\",{\"1\":{\"442\":1}}],[\"代表全部\",{\"1\":{\"408\":1}}],[\"代表60秒内至少执行1000次修改则触发rdb\",{\"1\":{\"375\":1}}],[\"代表了全表扫描\",{\"1\":{\"231\":1,\"236\":1}}],[\"代表整个\",{\"1\":{\"178\":1}}],[\"代表的是最多存储的字符数量\",{\"1\":{\"165\":1}}],[\"代表该列的值不为null\",{\"1\":{\"162\":1}}],[\"代表该列的值为null\",{\"1\":{\"162\":1}}],[\"代表流程中步骤的形状放在负责这些步骤的职能单位相应的一栏中\",{\"1\":{\"58\":1}}],[\"代码实现动态代理\",{\"1\":{\"507\":1}}],[\"代码举例说明\",{\"1\":{\"506\":1}}],[\"代码零侵入\",{\"1\":{\"456\":1}}],[\"代码可能会很臃肿\",{\"1\":{\"237\":1}}],[\"代码结构变化很大\",{\"1\":{\"144\":1}}],[\"代码结构不好\",{\"1\":{\"144\":1}}],[\"代码我就不放了\",{\"1\":{\"144\":1}}],[\"代码和动态编译的\",{\"1\":{\"34\":1}}],[\"代码会合并到\",{\"1\":{\"7\":1}}],[\"泳道\",{\"1\":{\"88\":1}}],[\"泳道图绘制的场景非常清晰\",{\"1\":{\"58\":1}}],[\"泳道图也叫跨职能流程图\",{\"1\":{\"58\":1}}],[\"泳道流程图专注于价值活动之间的逻辑关系\",{\"1\":{\"58\":1}}],[\"泳道流程图是一种特殊的图表\",{\"1\":{\"58\":1}}],[\"旨在展示工作流中每个步骤涉及的流程和职能部门\",{\"1\":{\"58\":1}}],[\"相信看完你就拿捏这道题目了\",{\"1\":{\"247\":1}}],[\"相信大家都能分析出答案\",{\"1\":{\"231\":1}}],[\"相信大家都非常清楚\",{\"1\":{\"161\":1}}],[\"相信大家看完本文应该对\",{\"1\":{\"110\":1}}],[\"相信大家看完一定能掌握\",{\"1\":{\"102\":1}}],[\"相等\",{\"1\":{\"228\":1}}],[\"相比存储即存索引又存记录的\",{\"1\":{\"254\":1,\"258\":1}}],[\"相比于\",{\"1\":{\"205\":1,\"207\":1}}],[\"相比于扫描主键索引效率会高一些\",{\"1\":{\"196\":1}}],[\"相比于没有使用索引下推\",{\"1\":{\"149\":1}}],[\"相比\",{\"1\":{\"193\":1}}],[\"相似查询性能\",{\"1\":{\"187\":1}}],[\"相同的\",{\"1\":{\"346\":2}}],[\"相同的情况才\",{\"1\":{\"215\":1}}],[\"相同的情况再按\",{\"1\":{\"215\":3}}],[\"相同的情况下再按\",{\"1\":{\"215\":1}}],[\"相同的记录\",{\"1\":{\"147\":1}}],[\"相同的概率可以认为接近于\",{\"1\":{\"108\":1}}],[\"相当于代理类\",{\"1\":{\"506\":1}}],[\"相当于被代理类\",{\"1\":{\"506\":1}}],[\"相当于java中调用service\",{\"1\":{\"435\":1}}],[\"相当于延迟了\",{\"1\":{\"349\":1}}],[\"相当于记录了逻辑操作\",{\"1\":{\"341\":1}}],[\"相当于一个环形\",{\"1\":{\"339\":2}}],[\"相当于一个点一样\",{\"1\":{\"58\":1}}],[\"相当于锁了整张表\",{\"1\":{\"329\":1}}],[\"相当于锁住了全表\",{\"1\":{\"329\":1}}],[\"相当于锁住整个表\",{\"1\":{\"275\":1}}],[\"相当于把整个表锁住了\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1,\"329\":1}}],[\"相当于\",{\"1\":{\"232\":1}}],[\"相当于这个预读是白做了\",{\"1\":{\"178\":1}}],[\"相当于缓存了个寂寞\",{\"1\":{\"140\":1}}],[\"相关服务监听到通知后修改缓存数据\",{\"1\":{\"456\":1}}],[\"相关的书籍来了解红黑树的约束条件\",{\"1\":{\"251\":1}}],[\"相关原语\",{\"0\":{\"118\":1}}],[\"相关问题\",{\"0\":{\"109\":1},\"1\":{\"102\":1}}],[\"相关信息\",{\"1\":{\"4\":1,\"52\":1}}],[\"相应的面试题整理会放在redis面试题\",{\"1\":{\"97\":1}}],[\"相较不在意是哪一个程序完成的\",{\"1\":{\"85\":1}}],[\"圆圈旁为接口名称\",{\"1\":{\"66\":1}}],[\"圆圈\",{\"1\":{\"58\":1}}],[\"圆弧形框\",{\"1\":{\"58\":1}}],[\"平台\",{\"1\":{\"432\":1}}],[\"平行四边形框\",{\"1\":{\"58\":1}}],[\"平均到8080\",{\"1\":{\"40\":1}}],[\"输出的内容很多\",{\"1\":{\"304\":1}}],[\"输出的结果分析出\",{\"1\":{\"296\":1}}],[\"输出的结果\",{\"1\":{\"296\":1}}],[\"输出结果如下\",{\"1\":{\"293\":2,\"294\":3,\"296\":1,\"297\":1}}],[\"输出结果\",{\"1\":{\"54\":1,\"507\":2}}],[\"输入yes\",{\"1\":{\"408\":1}}],[\"输入的参数是整型的话\",{\"1\":{\"238\":1}}],[\"输入密码\",{\"1\":{\"62\":1}}],[\"输入输出框\",{\"1\":{\"58\":1}}],[\"菱形框\",{\"1\":{\"58\":1,\"90\":1}}],[\"判断效率高\",{\"1\":{\"516\":1}}],[\"判断查询结果\",{\"1\":{\"451\":2,\"454\":2}}],[\"判断到插入的位置被事务\",{\"1\":{\"365\":1}}],[\"判断的结果是在的\",{\"1\":{\"359\":1,\"360\":1}}],[\"判断输入的语句是否符合\",{\"1\":{\"333\":1}}],[\"判断记录的\",{\"1\":{\"149\":1}}],[\"判断表或字段是否存在的工作\",{\"1\":{\"144\":1}}],[\"判断你输入的这个\",{\"1\":{\"142\":1}}],[\"判断条件\",{\"1\":{\"88\":1}}],[\"判断框\",{\"1\":{\"58\":1}}],[\"判断继续执行某个功能还是退出循环\",{\"1\":{\"56\":1}}],[\"美国国家标准化协会ansi曾规定了一些常用的流程图符号\",{\"1\":{\"58\":1}}],[\"易于理解\",{\"1\":{\"58\":1}}],[\"编写监听器\",{\"0\":{\"463\":1}}],[\"编写配置\",{\"0\":{\"461\":1}}],[\"编写初始化类\",{\"1\":{\"448\":1}}],[\"编写item\",{\"0\":{\"436\":1},\"1\":{\"436\":1}}],[\"编写程序\",{\"1\":{\"58\":1}}],[\"编译依赖\",{\"1\":{\"26\":1}}],[\"就算扫描到软引用对象也不一定会回收它\",{\"1\":{\"520\":1}}],[\"就访问第几个服务\",{\"1\":{\"446\":1}}],[\"就一定能发送请求到windows的tomcat服务\",{\"1\":{\"442\":1}}],[\"就类似于springmvc中的\",{\"1\":{\"435\":1}}],[\"就被windows上安装的nginx服务给接收到了\",{\"1\":{\"434\":1}}],[\"就被移除这个功能了\",{\"1\":{\"333\":1}}],[\"就知道要做全量同步了\",{\"1\":{\"384\":1}}],[\"就感觉发生了幻觉一样\",{\"1\":{\"356\":1}}],[\"就好比买一件商品\",{\"1\":{\"352\":1}}],[\"就像相机拍照那样\",{\"1\":{\"357\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"352\":1}}],[\"就像我们书那样\",{\"1\":{\"243\":1}}],[\"就忽视binlog\",{\"1\":{\"348\":1}}],[\"就马上将\",{\"1\":{\"348\":1}}],[\"就拿着\",{\"1\":{\"346\":1}}],[\"就直接返回给执行器更新\",{\"1\":{\"343\":1,\"350\":1}}],[\"就直接把该页对应的\",{\"1\":{\"178\":1}}],[\"就返回客户端结果\",{\"1\":{\"342\":1}}],[\"就创建一个新的文件继续写\",{\"1\":{\"341\":1}}],[\"就意味着该对象己经死亡\",{\"1\":{\"517\":1}}],[\"就意味着发生了\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"就意味着能在\",{\"1\":{\"346\":1}}],[\"就意味着\",{\"1\":{\"339\":1}}],[\"就意味着其他事务无法删除\",{\"1\":{\"291\":1}}],[\"就意味着其他事务无法对该记录进行更新和删除操作了\",{\"1\":{\"290\":1}}],[\"就读取\",{\"1\":{\"334\":2}}],[\"就陷入了等待状态\",{\"1\":{\"324\":1,\"325\":1}}],[\"就跟大家好好聊这个问题\",{\"1\":{\"362\":1}}],[\"就跟大家一层一层的分析这个问题\",{\"1\":{\"247\":1}}],[\"就跟聊聊上面两个事务执行\",{\"1\":{\"318\":1}}],[\"就采用轻量级锁\",{\"1\":{\"312\":1}}],[\"就采用\",{\"1\":{\"312\":1}}],[\"就把这个轻量级锁释放了\",{\"1\":{\"312\":1}}],[\"就都会被阻塞\",{\"1\":{\"310\":1}}],[\"就不用继续等待了\",{\"1\":{\"348\":1}}],[\"就不用担心无法回滚到事务之前的数据\",{\"1\":{\"334\":1}}],[\"就不能称为逻辑日志了\",{\"1\":{\"341\":1}}],[\"就不需要从磁盘获取数据了\",{\"1\":{\"335\":1}}],[\"就不会出现上面这种情况了\",{\"1\":{\"307\":1}}],[\"就不得不提到uml的另一种图形\",{\"1\":{\"68\":1}}],[\"就说到这啦\",{\"1\":{\"300\":1}}],[\"就说到这了\",{\"1\":{\"232\":1}}],[\"就带大家简单分析一下\",{\"1\":{\"298\":1}}],[\"就认为发生幻读\",{\"1\":{\"290\":1}}],[\"就多增加了\",{\"1\":{\"282\":1}}],[\"就出现下面这个提示\",{\"1\":{\"281\":1}}],[\"就出现了报错\",{\"1\":{\"280\":1}}],[\"就出现了自平衡二叉树\",{\"1\":{\"258\":1}}],[\"就对这个事务进行回滚\",{\"1\":{\"281\":1}}],[\"就如前面的这个例子\",{\"1\":{\"280\":1}}],[\"就引出了间隙锁\",{\"1\":{\"365\":1}}],[\"就引出了\",{\"1\":{\"275\":1}}],[\"就引出了二级索引\",{\"1\":{\"245\":1}}],[\"就有多少个索引\",{\"1\":{\"253\":1,\"255\":1}}],[\"就相当于\",{\"1\":{\"238\":2}}],[\"就无法申请到\",{\"1\":{\"310\":1}}],[\"就无法走索引了呢\",{\"1\":{\"236\":1,\"237\":1}}],[\"就无法使用前缀索引\",{\"1\":{\"224\":1}}],[\"就代表了全表扫描\",{\"1\":{\"235\":1}}],[\"就代表联合索引中的所有字段都用到了联合索引进行索引查询\",{\"1\":{\"216\":1}}],[\"就查询过程就一定都用上索引\",{\"1\":{\"234\":1}}],[\"就只有\",{\"1\":{\"232\":1}}],[\"就只需要缓冲一条记录吗\",{\"1\":{\"174\":1,\"336\":1}}],[\"就可能出现脏读\",{\"1\":{\"353\":1}}],[\"就可能会出现死锁\",{\"1\":{\"273\":1}}],[\"就可能会插入到现有数据页中间的某个位置\",{\"1\":{\"226\":1}}],[\"就可以在\",{\"1\":{\"364\":1}}],[\"就可以读到事务\",{\"1\":{\"360\":1}}],[\"就可以保证即使数据库发生异常重启\",{\"1\":{\"337\":1}}],[\"就可以匹配上联合索引\",{\"1\":{\"215\":1,\"239\":1}}],[\"就可以将\",{\"1\":{\"108\":1}}],[\"就可以获得证书上的公钥\",{\"1\":{\"108\":1}}],[\"就可以作为学生的\",{\"1\":{\"89\":1}}],[\"就在对表中的记录加上\",{\"1\":{\"365\":1}}],[\"就在字段类型占用的字节数上加\",{\"1\":{\"216\":1}}],[\"就在它对应的控制块中记录下来这个访问时间\",{\"1\":{\"178\":1}}],[\"就选择第一个不包含\",{\"1\":{\"204\":1,\"245\":1}}],[\"就没有区别了\",{\"1\":{\"197\":1}}],[\"就没必要在主键索引查找了\",{\"1\":{\"145\":1}}],[\"就将\",{\"1\":{\"192\":1,\"193\":1}}],[\"就退出循环\",{\"1\":{\"192\":1}}],[\"就要将隔离级别升级到可重复读以上的隔离级别\",{\"1\":{\"361\":1}}],[\"就要将隔离级别升级到读已提交以上的隔离级别\",{\"1\":{\"361\":1}}],[\"就要将该页放到\",{\"1\":{\"178\":1}}],[\"就要升级到\",{\"1\":{\"357\":2}}],[\"就要保证转账业务里的所有数据库的操作是不可分割的\",{\"1\":{\"351\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"343\":1}}],[\"就要看插入的位置的下一条记录是否有间隙锁\",{\"1\":{\"296\":1}}],[\"就要考虑数据迁移了\",{\"1\":{\"181\":1}}],[\"就能看到事务\",{\"1\":{\"367\":1}}],[\"就能看见最新的余额数据了\",{\"1\":{\"357\":1}}],[\"就能达到这样的效果\",{\"1\":{\"351\":1}}],[\"就能避免幻读的问题了\",{\"1\":{\"291\":1}}],[\"就能查询到数据了\",{\"1\":{\"208\":1}}],[\"就能查询到结果的过程就叫作\",{\"1\":{\"206\":1}}],[\"就能查询更多的节点\",{\"1\":{\"207\":1}}],[\"就能找到数据\",{\"1\":{\"206\":1}}],[\"就能有效地保证\",{\"1\":{\"178\":1}}],[\"就能使用顺序\",{\"1\":{\"156\":1}}],[\"就加入到结果集里\",{\"1\":{\"178\":1}}],[\"就淘汰最久没被使用的节点\",{\"1\":{\"178\":1}}],[\"就从\",{\"1\":{\"176\":1}}],[\"就具体讲一下\",{\"1\":{\"157\":1}}],[\"就真正开始执行语句了\",{\"1\":{\"146\":1}}],[\"就确定了执行方案\",{\"1\":{\"146\":1}}],[\"就表示锁的范围\",{\"1\":{\"291\":1}}],[\"就表示锁的范围最右值\",{\"1\":{\"275\":1,\"304\":1,\"322\":1}}],[\"就表示执行过程中使用了哪个索引\",{\"1\":{\"145\":1}}],[\"就表示一个类\",{\"1\":{\"65\":1}}],[\"就会自动的调用如下的方法\",{\"1\":{\"507\":1}}],[\"就会自动开辟一个新页面\",{\"1\":{\"226\":1}}],[\"就会变为一个slave节点了\",{\"1\":{\"410\":1}}],[\"就会覆盖数组中的旧数据\",{\"1\":{\"386\":1}}],[\"就会得到\",{\"1\":{\"368\":1}}],[\"就会把该事务的事务\",{\"1\":{\"358\":1}}],[\"就会把预读页放到\",{\"1\":{\"178\":1}}],[\"就会马上启动事务\",{\"1\":{\"357\":1}}],[\"就会发现两次查询的记录条目就不一样了\",{\"1\":{\"369\":1}}],[\"就会发现前后两次读到的数据是不一致的\",{\"1\":{\"355\":1}}],[\"就会发生一个蛋疼的事情\",{\"1\":{\"351\":1}}],[\"就会发生阻塞\",{\"1\":{\"296\":1,\"317\":1}}],[\"就会被事务\",{\"1\":{\"365\":1}}],[\"就会被持久化到磁盘\",{\"1\":{\"349\":1}}],[\"就会被阻塞的\",{\"1\":{\"275\":1}}],[\"就会被阻塞\",{\"1\":{\"275\":1,\"277\":1,\"287\":1,\"310\":1,\"316\":1}}],[\"就会跟裁判说还没准备好\",{\"1\":{\"344\":1}}],[\"就会跟裁判说准备好了\",{\"1\":{\"344\":1}}],[\"就会造成主从环境的数据不一致性\",{\"1\":{\"344\":1}}],[\"就会造成小红的资金损失\",{\"1\":{\"104\":1}}],[\"就会往后移动\",{\"1\":{\"339\":1}}],[\"就会顺着\",{\"1\":{\"334\":1}}],[\"就会对全表的记录加锁了\",{\"1\":{\"329\":1}}],[\"就会给全表的加上\",{\"1\":{\"329\":1}}],[\"就会全表扫描\",{\"1\":{\"329\":1}}],[\"就会有大量的线程被阻塞住\",{\"1\":{\"310\":1}}],[\"就会继续往后找存在的记录\",{\"1\":{\"293\":2,\"294\":3}}],[\"就会退化成退化成记录锁或间隙锁\",{\"1\":{\"288\":1}}],[\"就会阻塞\",{\"1\":{\"280\":1}}],[\"就会报主键索引冲突的错误\",{\"1\":{\"279\":1}}],[\"就会出现下面这个提示\",{\"1\":{\"281\":1}}],[\"就会出现两个重复的订单\",{\"1\":{\"274\":1}}],[\"就会出现一个很奇怪的问题\",{\"1\":{\"178\":1}}],[\"就会分裂节点\",{\"1\":{\"252\":1}}],[\"就会影响查询性能\",{\"1\":{\"250\":1,\"258\":1}}],[\"就会进行全表扫描\",{\"1\":{\"240\":1}}],[\"就会导致对锁的争用\",{\"1\":{\"347\":1}}],[\"就会导致其他事务插入一条\",{\"1\":{\"298\":1}}],[\"就会导致二分查找树退化成一个链表\",{\"1\":{\"258\":1}}],[\"就会导致索引失效\",{\"1\":{\"236\":1,\"241\":1}}],[\"就会导致优化器在做索引选择的时候更加复杂\",{\"1\":{\"227\":1}}],[\"就会显示\",{\"1\":{\"228\":1}}],[\"就会先检索二级索引\",{\"1\":{\"208\":1}}],[\"就会先去查询缓存\",{\"1\":{\"140\":1}}],[\"就会\",{\"1\":{\"192\":1}}],[\"就会产生大量的磁盘\",{\"1\":{\"178\":1}}],[\"就会从\",{\"1\":{\"178\":1}}],[\"就会用\",{\"1\":{\"166\":2}}],[\"就会为记录添加\",{\"1\":{\"164\":1}}],[\"就会停止匹配\",{\"1\":{\"149\":1,\"216\":2}}],[\"就会将记录返回给执行器\",{\"1\":{\"147\":1}}],[\"就会向执行器上报记录找不到的错误\",{\"1\":{\"147\":1}}],[\"就会在备份数据库之前先开启事务\",{\"1\":{\"307\":1}}],[\"就会在执行\",{\"1\":{\"144\":1}}],[\"就会在解析器这个阶段报错\",{\"1\":{\"142\":1}}],[\"就会解析出\",{\"1\":{\"140\":1}}],[\"就收到一个\",{\"1\":{\"139\":1}}],[\"就需要搭建主从集群\",{\"1\":{\"382\":1}}],[\"就需要遍历表里所有记录\",{\"1\":{\"311\":1}}],[\"就需要在二级索引索引上加范围\",{\"1\":{\"297\":1}}],[\"就需要在交互对话里面输入密码\",{\"1\":{\"139\":1}}],[\"就需要磁盘\",{\"1\":{\"251\":1}}],[\"就需要先从磁盘读取索引到内存\",{\"1\":{\"248\":1}}],[\"就需要先在二级索引找到主键值\",{\"1\":{\"246\":1}}],[\"就需要多个数据页\",{\"1\":{\"244\":1}}],[\"就需要扫描表来统计具体的记录\",{\"1\":{\"197\":1}}],[\"就需要去申请新的页了\",{\"1\":{\"185\":1}}],[\"就需要调大\",{\"1\":{\"179\":1,\"180\":1}}],[\"就需要优化器来决定使用哪个索引了\",{\"1\":{\"145\":1}}],[\"就需要做的处理单元比较多\",{\"1\":{\"85\":1}}],[\"就详细说一条\",{\"1\":{\"138\":1}}],[\"就那么几个\",{\"1\":{\"109\":1}}],[\"就是形同虚设\",{\"1\":{\"522\":1}}],[\"就是加载类到内存中\",{\"1\":{\"493\":1}}],[\"就是响应数据\",{\"1\":{\"441\":1}}],[\"就是尚未同步\",{\"1\":{\"386\":1}}],[\"就是salve需要增量拷贝的数据了\",{\"1\":{\"386\":1}}],[\"就是只更新slave与master存在差异的部分数据\",{\"1\":{\"385\":1}}],[\"就是尽量在开启事务之后\",{\"1\":{\"368\":1,\"369\":1}}],[\"就是将\",{\"1\":{\"345\":1}}],[\"就是老板的挨骂\",{\"1\":{\"329\":1}}],[\"就是开启了事务\",{\"1\":{\"310\":1}}],[\"就是说明在插入\",{\"1\":{\"296\":1}}],[\"就是我们前面分析出那三个锁\",{\"1\":{\"294\":1}}],[\"就是对\",{\"1\":{\"279\":1,\"280\":1,\"314\":1}}],[\"就是间隙锁\",{\"1\":{\"275\":1}}],[\"就是自己连接自己\",{\"1\":{\"265\":1}}],[\"就是为了让树化几率足够小提高了计算效率\",{\"1\":{\"473\":1}}],[\"就是为了自平衡\",{\"1\":{\"251\":1}}],[\"就是为了解决上述三个风险而生的\",{\"1\":{\"104\":1}}],[\"就是通过这样的方式实现了\",{\"1\":{\"359\":1}}],[\"就是通过\",{\"1\":{\"238\":1}}],[\"就是看replid是否一致\",{\"1\":{\"384\":1}}],[\"就是看\",{\"1\":{\"238\":1}}],[\"就是一个没有使用索引\",{\"1\":{\"228\":1}}],[\"就是一条记录的存储结构\",{\"1\":{\"158\":1}}],[\"就是充当索引\",{\"1\":{\"202\":1}}],[\"就是不要使用\",{\"1\":{\"196\":1}}],[\"就是不需要读取记录中的字段值\",{\"1\":{\"193\":1}}],[\"就是在\",{\"1\":{\"182\":1}}],[\"就是\",{\"1\":{\"182\":1,\"275\":1}}],[\"就是让链表中相邻的页的物理位置也相邻\",{\"1\":{\"156\":1}}],[\"就是使用了主键索引\",{\"1\":{\"145\":1}}],[\"就是选择使用主键索引\",{\"1\":{\"145\":1}}],[\"就是由存储引擎层实现的\",{\"1\":{\"138\":1}}],[\"就是这个类有一个属性是其他类\",{\"1\":{\"66\":1}}],[\"就是构造这个类的时候\",{\"1\":{\"66\":1}}],[\"就是研究用什么方法最有效\",{\"1\":{\"58\":1}}],[\"就使用斜体表示\",{\"1\":{\"65\":1}}],[\"就停止继续向下搜索并立即处理该请求\",{\"1\":{\"39\":1}}],[\"计算对象的\",{\"1\":{\"474\":1}}],[\"计算方式是利用crc16算法得到一个hash值\",{\"1\":{\"402\":1}}],[\"计算方法是研究数值计算的近似方法的\",{\"1\":{\"58\":1}}],[\"计算方法\",{\"1\":{\"58\":1}}],[\"计算公式如下\",{\"1\":{\"218\":1}}],[\"计算公式\",{\"1\":{\"169\":1}}],[\"计算出来的消息摘要的长度总是固定的\",{\"1\":{\"108\":1}}],[\"计算机语言只是一种工具\",{\"1\":{\"58\":1}}],[\"梯形法或辛普生法等不同的方法\",{\"1\":{\"58\":1}}],[\"用标准c语言编写并以源代码形式开放\",{\"1\":{\"421\":1}}],[\"用最少的命令达到相同效果\",{\"1\":{\"379\":1}}],[\"用新rdb文件替换旧的rdb文件\",{\"1\":{\"375\":1}}],[\"用途不同\",{\"1\":{\"341\":1}}],[\"用\",{\"1\":{\"272\":1,\"339\":2}}],[\"用到的\",{\"1\":{\"255\":1}}],[\"用数组来实现线性排序的数据虽然简单好用\",{\"1\":{\"250\":1}}],[\"用数学语言描述它\",{\"1\":{\"58\":1}}],[\"用整型作为输入参数\",{\"1\":{\"238\":1}}],[\"用上了索引并不意味着查询的时候会使用到索引\",{\"1\":{\"228\":1}}],[\"用下面这条语句作为例子\",{\"1\":{\"192\":1,\"193\":1,\"195\":1}}],[\"用下划线在属性上表明关键字的属性组合\",{\"1\":{\"91\":1}}],[\"用三种方式执行过程\",{\"1\":{\"146\":1}}],[\"用公钥解密叫做验签\",{\"1\":{\"107\":1}}],[\"用实体名及其属性名集合来抽象和刻画同类实体称为实体型\",{\"1\":{\"89\":1}}],[\"用实箭线表示\",{\"1\":{\"66\":1}}],[\"用来释放redis连接\",{\"1\":{\"450\":1}}],[\"用来打印数组\",{\"1\":{\"428\":1}}],[\"用来记录新的更新操作\",{\"1\":{\"339\":1}}],[\"用来实现事务的持久性\",{\"1\":{\"272\":1}}],[\"用来存储当前数据库的默认字符集和字符校验规则\",{\"1\":{\"152\":1}}],[\"用来描述现实世界的概念模型\",{\"1\":{\"89\":1}}],[\"用来表达各个对象在某一时刻的状态\",{\"1\":{\"69\":1}}],[\"用一个简化的图来表示三者的差别就是\",{\"1\":{\"87\":1}}],[\"用一个框表示要完成的一个或几个步骤\",{\"1\":{\"58\":1}}],[\"用带实心菱形的实线表示\",{\"1\":{\"66\":1}}],[\"用带空心菱形的实线表示\",{\"1\":{\"66\":1}}],[\"用带空心三角形的虚线表示\",{\"1\":{\"66\":1}}],[\"用带空心三角形的实线表示\",{\"1\":{\"66\":1}}],[\"用虚箭线表示\",{\"1\":{\"66\":1}}],[\"用户\",{\"1\":{\"352\":4}}],[\"用户钱没少\",{\"1\":{\"307\":1}}],[\"用户名称\",{\"1\":{\"182\":1,\"183\":1}}],[\"用户id\",{\"1\":{\"182\":1,\"183\":1}}],[\"用户级线程\",{\"1\":{\"130\":1}}],[\"用户不用担心访问的是某宝结果却在和钓鱼网站通信的问题\",{\"1\":{\"104\":1}}],[\"用户手册等等\",{\"1\":{\"76\":1}}],[\"用户在登录过程中忘记了密码\",{\"1\":{\"63\":1}}],[\"用户在账号登录过程中\",{\"1\":{\"62\":1}}],[\"用户登录系统\",{\"1\":{\"60\":1}}],[\"用例与用例之间的关系\",{\"1\":{\"61\":1}}],[\"用例\",{\"1\":{\"59\":2,\"73\":1}}],[\"用例图的三大组成元素\",{\"1\":{\"59\":1}}],[\"用例图是编写需求说明时经常用到的需求表达方式\",{\"1\":{\"59\":1}}],[\"用例图\",{\"0\":{\"59\":1}}],[\"用连接点\",{\"1\":{\"58\":1}}],[\"用图形表示算法\",{\"1\":{\"58\":1}}],[\"用图表示的算法就是流程图\",{\"1\":{\"58\":1}}],[\"用于保存jvm中下一条所要执行的指令的地址\",{\"1\":{\"539\":1}}],[\"用于方便地搭建能够处理超高并发\",{\"1\":{\"432\":1}}],[\"用于控制单个线程内\",{\"1\":{\"343\":1}}],[\"用于掉电等故障恢复\",{\"1\":{\"341\":1}}],[\"用于备份恢复\",{\"1\":{\"341\":1}}],[\"用于事务和\",{\"1\":{\"232\":1}}],[\"用于存数据\",{\"1\":{\"187\":1}}],[\"用于描述对象之间的传递消息的时间顺序\",{\"1\":{\"79\":1,\"80\":1}}],[\"用于描述某一时刻的一组对象及它们之间的关系\",{\"1\":{\"69\":1}}],[\"用于描述系统中所包含的类以及它们之间的相互关系\",{\"1\":{\"69\":1}}],[\"用于拓展用例对基础用例的增强\",{\"1\":{\"63\":1}}],[\"用于向开发\",{\"1\":{\"59\":1}}],[\"用于说明\",{\"1\":{\"58\":1}}],[\"用于将画在不同地方的流程线连接起来\",{\"1\":{\"58\":1}}],[\"用于判断给定的条件\",{\"1\":{\"56\":1}}],[\"用于表示程序执行时各个对象的交互过程\",{\"1\":{\"83\":1}}],[\"用于表示完成某件事情中的各个活动过程\",{\"1\":{\"83\":1}}],[\"用于表示uri包含正则表达式\",{\"1\":{\"39\":2}}],[\"用于表达数据的流转\",{\"1\":{\"54\":1}}],[\"用于进行访问\",{\"1\":{\"42\":1}}],[\"用于后端服务器性能不均的情况\",{\"1\":{\"41\":1}}],[\"用于不含正则表达式的uri前\",{\"1\":{\"39\":2}}],[\"用于功能开发的分支\",{\"1\":{\"6\":1}}],[\"用于集成的分支\",{\"1\":{\"6\":1}}],[\"用于\",{\"1\":{\"6\":1}}],[\"用于维护的分支\",{\"1\":{\"6\":1}}],[\"运算步骤少的方法\",{\"1\":{\"58\":1}}],[\"运行的执行的流程\",{\"0\":{\"495\":1}}],[\"运行命令以重新加载openresty配置\",{\"1\":{\"439\":1}}],[\"运行\",{\"1\":{\"422\":1}}],[\"运行下面的\",{\"1\":{\"182\":1}}],[\"运行一段时间后\",{\"1\":{\"176\":1}}],[\"运行时根据对象计数器是否为\",{\"1\":{\"516\":1}}],[\"运行时类必须提供空参的构造器\",{\"1\":{\"498\":1}}],[\"运行时类\",{\"1\":{\"483\":1}}],[\"运行时结构不可变的语言就是静态语言\",{\"1\":{\"480\":1}}],[\"运行时产生的临时文件\",{\"1\":{\"34\":1}}],[\"运行时所需要的\",{\"1\":{\"34\":1}}],[\"运行日志目录webapps\",{\"1\":{\"34\":1}}],[\"希望采用方法简单\",{\"1\":{\"58\":1}}],[\"+主键值\",{\"1\":{\"296\":1}}],[\"+∞\",{\"1\":{\"275\":9,\"277\":2,\"293\":5,\"298\":2,\"304\":3,\"365\":1}}],[\"+6\",{\"1\":{\"139\":1}}],[\"+50＝100+50+49×100＝5050\",{\"1\":{\"58\":1}}],[\"+\",{\"1\":{\"58\":3,\"65\":1,\"110\":1,\"139\":19,\"152\":9,\"157\":2,\"167\":2,\"169\":2,\"182\":3,\"187\":1,\"188\":1,\"200\":1,\"216\":1,\"237\":3,\"272\":2,\"282\":1,\"284\":1,\"287\":1,\"290\":12,\"293\":24,\"294\":24,\"296\":1,\"297\":12,\"298\":12,\"313\":1,\"316\":1,\"329\":1,\"334\":3,\"348\":1,\"358\":1,\"367\":12,\"416\":2,\"448\":2,\"463\":4,\"472\":2,\"473\":1,\"480\":2,\"489\":1,\"496\":3,\"507\":1,\"508\":2}}],[\"+100\",{\"1\":{\"58\":1}}],[\"+$\",{\"1\":{\"32\":1}}],[\"拟定出有效的解决方法和步骤即算法\",{\"1\":{\"58\":1}}],[\"光学习语言的规则还不够\",{\"1\":{\"58\":1}}],[\"案例需求\",{\"1\":{\"411\":1}}],[\"案例中的事务\",{\"1\":{\"275\":1}}],[\"案例\",{\"0\":{\"58\":1,\"430\":1}}],[\"结构示意图如下\",{\"1\":{\"244\":1}}],[\"结构如下图\",{\"1\":{\"243\":1}}],[\"结构规划\",{\"1\":{\"57\":1}}],[\"结构规范\",{\"0\":{\"56\":1}}],[\"结果只有一条的主键或唯一索引扫描\",{\"1\":{\"228\":1}}],[\"结果找到了\",{\"1\":{\"187\":1}}],[\"结论都一样\",{\"1\":{\"144\":1}}],[\"结点\",{\"1\":{\"78\":1}}],[\"结束符号\",{\"1\":{\"57\":1}}],[\"可达性分析算法\",{\"0\":{\"517\":1}}],[\"可参考jdk\",{\"1\":{\"474\":1}}],[\"可靠性较低\",{\"1\":{\"416\":1}}],[\"可靠性要求较高\",{\"1\":{\"416\":1}}],[\"可靠性更好\",{\"1\":{\"416\":1}}],[\"可见的第一条记录\",{\"1\":{\"359\":1,\"360\":1}}],[\"可见的\",{\"1\":{\"359\":1}}],[\"可见\",{\"1\":{\"358\":1,\"414\":1}}],[\"可取的值有\",{\"1\":{\"338\":1}}],[\"可重复读是如何工作的\",{\"0\":{\"359\":1}}],[\"可重复读隔离级是由\",{\"1\":{\"364\":1}}],[\"可重复读隔离级\",{\"1\":{\"303\":1}}],[\"可重复读隔离级别并没有彻底解决幻读\",{\"1\":{\"369\":1}}],[\"可重复读隔离级别是启动事务时生成一个\",{\"1\":{\"359\":1}}],[\"可重复读隔离级别的事务\",{\"1\":{\"307\":1}}],[\"可重复读隔离级别下虽然很大程度上避免了幻读\",{\"1\":{\"366\":1}}],[\"可重复读隔离级别下\",{\"1\":{\"275\":1}}],[\"可重复读隔离级别\",{\"0\":{\"362\":1},\"1\":{\"96\":1}}],[\"可重复读\",{\"1\":{\"275\":1,\"279\":1,\"288\":1,\"302\":1,\"320\":1,\"329\":1,\"334\":2,\"357\":8,\"359\":2,\"361\":4,\"362\":1,\"365\":1}}],[\"可能无法满足大对象的内存分配\",{\"1\":{\"527\":1}}],[\"可能存在中间不一致状态\",{\"1\":{\"456\":1}}],[\"可能存储更多的数据\",{\"1\":{\"168\":1}}],[\"可能与数据库差异较大\",{\"1\":{\"454\":1}}],[\"可能发生幻读现象\",{\"1\":{\"357\":1}}],[\"可能发生不可重复读和幻读现象\",{\"1\":{\"357\":1}}],[\"可能发生脏读\",{\"1\":{\"357\":1}}],[\"可能出现半成功的状态\",{\"1\":{\"344\":1}}],[\"可能涉及复杂的树的变形\",{\"1\":{\"255\":1}}],[\"可能有的同学会疑问\",{\"1\":{\"243\":1}}],[\"可能也是因为\",{\"1\":{\"237\":1}}],[\"可能你写的查询语句是会导致索引失效\",{\"1\":{\"233\":1}}],[\"可能大家就有点模糊了\",{\"1\":{\"203\":1}}],[\"可能大家担心\",{\"1\":{\"179\":1}}],[\"可能会产生比较严重的后果\",{\"1\":{\"455\":1}}],[\"可能会给数据库带来较大压力\",{\"1\":{\"448\":1}}],[\"可能会发生意想不到的事情\",{\"1\":{\"310\":1}}],[\"可能会导致树的复杂变化\",{\"1\":{\"255\":1}}],[\"可能会出现其他的索引失效场景\",{\"1\":{\"228\":1}}],[\"可能会带来立竿见影的性能提升哈\",{\"1\":{\"187\":1}}],[\"可能会将\",{\"1\":{\"178\":1}}],[\"可能就会扩展到\",{\"1\":{\"186\":1}}],[\"可能数据库已经爆满了\",{\"1\":{\"183\":1}}],[\"可能这个查询出来的结果就几条记录\",{\"1\":{\"178\":1}}],[\"可能是频繁访问的页\",{\"1\":{\"178\":1}}],[\"可能剩余的那点儿空间不够一对控制块和缓存页的大小\",{\"1\":{\"174\":1}}],[\"可能离得非常远\",{\"1\":{\"156\":1}}],[\"可执行程序\",{\"1\":{\"76\":1}}],[\"可视化\",{\"1\":{\"58\":1}}],[\"可省略开始\",{\"1\":{\"57\":1}}],[\"可以作为gc\",{\"1\":{\"517\":1}}],[\"可以作为判断依据\",{\"1\":{\"384\":1}}],[\"可以标记为垃圾对象\",{\"1\":{\"517\":1}}],[\"可以直接回收\",{\"1\":{\"516\":1}}],[\"可以直接从叶子节点中删除\",{\"1\":{\"255\":1}}],[\"可以调用其静态方法\",{\"1\":{\"489\":1}}],[\"可以同时通知多个缓存服务\",{\"1\":{\"456\":1}}],[\"可以打印table\",{\"1\":{\"430\":1}}],[\"可以打开\",{\"1\":{\"108\":1}}],[\"可以从以下几个方面来优化redis主从就集群\",{\"1\":{\"387\":1}}],[\"可以立即执行一次rdb\",{\"1\":{\"373\":1}}],[\"可以获取到这条记录\",{\"1\":{\"359\":1}}],[\"可以很大程度上避免幻读现象的发生\",{\"1\":{\"357\":1}}],[\"可以尽早的处理下一组事务\",{\"1\":{\"348\":1}}],[\"可以知道\",{\"1\":{\"348\":2}}],[\"可以知道该记录是被哪个事务修改的\",{\"1\":{\"334\":1}}],[\"可以称为逻辑日志\",{\"1\":{\"341\":1}}],[\"可以说这是\",{\"1\":{\"337\":1}}],[\"可以比喻为你有一个本子\",{\"1\":{\"337\":1}}],[\"可以根据\",{\"1\":{\"337\":1}}],[\"可以利用require\",{\"1\":{\"442\":1}}],[\"可以利用\",{\"1\":{\"334\":2}}],[\"可以利用任何一种计算机高级语言编写程序\",{\"1\":{\"58\":1}}],[\"可以告诉优化器使用哪个索引\",{\"1\":{\"330\":1,\"331\":1}}],[\"可以不需要等到将缓存在\",{\"1\":{\"337\":1}}],[\"可以不指定主键的值\",{\"1\":{\"312\":1}}],[\"可以不用这个参数\",{\"1\":{\"139\":1}}],[\"可以分为全局锁\",{\"1\":{\"306\":1}}],[\"可以确认\",{\"1\":{\"304\":1}}],[\"可以确认是\",{\"1\":{\"275\":1,\"290\":1,\"322\":1}}],[\"可以得到事务\",{\"1\":{\"294\":3}}],[\"可以得知事务\",{\"1\":{\"294\":1}}],[\"可以得知\",{\"1\":{\"293\":2,\"294\":2,\"297\":3}}],[\"可以插入成功\",{\"1\":{\"280\":1}}],[\"可以执行\",{\"1\":{\"279\":1}}],[\"可以考虑\",{\"1\":{\"256\":1,\"489\":1}}],[\"可以查看目录\",{\"1\":{\"243\":1}}],[\"可以避免回表的操作\",{\"1\":{\"225\":1}}],[\"可以避免流程线的交叉或过长\",{\"1\":{\"58\":1}}],[\"可以增加一个索引页中存储的索引值\",{\"1\":{\"224\":1}}],[\"可以建立联合索引\",{\"1\":{\"221\":1}}],[\"可以在nginx的多个worker之间共享数据\",{\"1\":{\"453\":1}}],[\"可以在集群间共享\",{\"1\":{\"416\":1}}],[\"可以在redis\",{\"1\":{\"373\":1}}],[\"可以在事务没提交之前持久化到磁盘\",{\"1\":{\"346\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"239\":1}}],[\"可以在联合索引遍历过程中\",{\"1\":{\"217\":1}}],[\"可以在http\",{\"1\":{\"32\":1}}],[\"可以在http块\",{\"1\":{\"32\":1}}],[\"可以定位到符合前缀为\",{\"1\":{\"216\":1}}],[\"可以定位到符合\",{\"1\":{\"216\":2}}],[\"可以发现\",{\"1\":{\"197\":1}}],[\"可以使用下面这条命令\",{\"1\":{\"309\":1}}],[\"可以使用下面这两个方式\",{\"1\":{\"275\":1,\"283\":1,\"313\":1}}],[\"可以使用下面的命令\",{\"1\":{\"309\":1}}],[\"可以使用二分法快速定位要查询的记录在哪个槽\",{\"1\":{\"243\":1}}],[\"可以使用这面这条命令\",{\"1\":{\"211\":1,\"212\":1,\"213\":1}}],[\"可以使用链表结构\",{\"1\":{\"176\":1}}],[\"可以使浏览器缓存过期时间\",{\"1\":{\"42\":1}}],[\"可以通过下面方式查看\",{\"1\":{\"404\":1}}],[\"可以通过设置下面这两个参数来实现\",{\"1\":{\"348\":1}}],[\"可以通过\",{\"1\":{\"180\":1,\"216\":2,\"337\":1}}],[\"可以通过调整\",{\"1\":{\"173\":1,\"180\":1}}],[\"可以通过3个维度来确定泳道图类型\",{\"1\":{\"58\":1}}],[\"可以看做是命令日志文件\",{\"1\":{\"377\":1}}],[\"可以看的出来\",{\"1\":{\"348\":1}}],[\"可以看这篇\",{\"1\":{\"338\":1}}],[\"可以看这篇文章\",{\"1\":{\"161\":1}}],[\"可以看出来\",{\"1\":{\"337\":1}}],[\"可以看我之前写的这篇\",{\"1\":{\"257\":1}}],[\"可以看我写的这篇\",{\"1\":{\"235\":1}}],[\"可以看完这篇文章\",{\"1\":{\"164\":1}}],[\"可以看到商品id是以路径占位符方式传递的\",{\"1\":{\"439\":1}}],[\"可以看到页面有发起ajax请求查询真实商品数据\",{\"1\":{\"434\":1}}],[\"可以看到caffeine的性能遥遥领先\",{\"1\":{\"416\":1}}],[\"可以看到7004节点的插槽数量为0\",{\"1\":{\"407\":1}}],[\"可以看到这个转账的过程涉及到了两次修改数据库的操作\",{\"1\":{\"351\":1}}],[\"可以看到这条记录是没有加任何锁的\",{\"1\":{\"280\":1}}],[\"可以看到表不存在的错误是在get\",{\"1\":{\"144\":1}}],[\"可以看到\",{\"1\":{\"138\":1,\"139\":1,\"149\":2,\"152\":1,\"159\":1,\"166\":3,\"178\":1,\"193\":1,\"215\":2,\"216\":4,\"232\":1,\"238\":2,\"240\":1,\"244\":1,\"249\":1,\"251\":1,\"252\":1,\"274\":1,\"277\":1,\"279\":1,\"280\":1,\"296\":1,\"297\":2,\"298\":1,\"304\":1,\"312\":1,\"320\":1,\"324\":1,\"325\":1,\"329\":2,\"344\":1,\"346\":1,\"347\":1,\"408\":1}}],[\"可以看到很多内置的被信任的证书\",{\"1\":{\"108\":1}}],[\"可以微信搜索关注\",{\"1\":{\"144\":1}}],[\"可以让aof文件执行重写功能\",{\"1\":{\"379\":1}}],[\"可以让其他事务的插入\",{\"1\":{\"296\":1}}],[\"可以让大一点的\",{\"1\":{\"109\":1}}],[\"可以让互相之间不会影响\",{\"1\":{\"46\":1}}],[\"可以防止证书造假\",{\"1\":{\"108\":1}}],[\"可以公开的\",{\"1\":{\"107\":1}}],[\"可以和word办公软件结合起来使用\",{\"1\":{\"91\":1}}],[\"可以唯一标识每个实体的属性称为键\",{\"1\":{\"89\":1}}],[\"可以用单引号或双引号\",{\"1\":{\"425\":1}}],[\"可以用\",{\"1\":{\"89\":1}}],[\"可以用矩形法\",{\"1\":{\"58\":1}}],[\"可以具体到人\",{\"1\":{\"89\":1}}],[\"可以是内连接查询\",{\"1\":{\"265\":1}}],[\"可以是硬件也可以是运行其上的软件系统\",{\"1\":{\"75\":1}}],[\"可以是事物\",{\"1\":{\"59\":1}}],[\"可以参照相应的类图\",{\"1\":{\"72\":1}}],[\"可以没有\",{\"1\":{\"65\":1}}],[\"可以先进行1+2\",{\"1\":{\"58\":1}}],[\"可以有不同的解题方法和步骤\",{\"1\":{\"58\":1}}],[\"可以解诀session的问题\",{\"1\":{\"41\":1}}],[\"可以支持的并发处理量就越多\",{\"1\":{\"32\":1}}],[\"可以把动态页面和静态页面由不同的服务器来解析\",{\"1\":{\"24\":1}}],[\"可以继续为接下来的一次发布开发新功能\",{\"1\":{\"12\":1}}],[\"当另一个线程的时间片用完\",{\"1\":{\"539\":1}}],[\"当当前线程的时间片使用完以后\",{\"1\":{\"539\":1}}],[\"当jvm内存不足时\",{\"1\":{\"520\":1}}],[\"当jvm内存不够时\",{\"1\":{\"520\":1}}],[\"当通过代理类对象调用方法时\",{\"1\":{\"507\":1}}],[\"当通过代理类的对象调用方法a时\",{\"1\":{\"507\":1}}],[\"当通过子类引用父类的静态变量\",{\"1\":{\"492\":1}}],[\"当访问一个静态域时\",{\"1\":{\"492\":1}}],[\"当访问的页不在\",{\"1\":{\"178\":1}}],[\"当访问的页在\",{\"1\":{\"178\":1}}],[\"当初始化一个类\",{\"1\":{\"492\":1}}],[\"当初始化一个类的时候\",{\"1\":{\"492\":1}}],[\"当虚拟机启动\",{\"1\":{\"492\":1}}],[\"当链表长度超过树化阈值\",{\"1\":{\"473\":1}}],[\"当收到变化的消息时\",{\"1\":{\"459\":1}}],[\"当canal监听到binlog变化时\",{\"1\":{\"459\":1}}],[\"当发现变化后\",{\"1\":{\"456\":1}}],[\"当发生超时后\",{\"1\":{\"281\":1}}],[\"当发生行溢出时\",{\"1\":{\"168\":1,\"169\":1}}],[\"当请求进入openresty之后\",{\"1\":{\"449\":1}}],[\"当参数为nil时\",{\"1\":{\"430\":1}}],[\"当7002再次启动\",{\"1\":{\"410\":1}}],[\"当集群中有一个master宕机会发生什么呢\",{\"1\":{\"410\":1}}],[\"当集群发生故障转移时\",{\"1\":{\"391\":1}}],[\"当故障节点恢复后会自动成为新的master的slave节点\",{\"1\":{\"393\":1}}],[\"当故障实例恢复后也以新的master为主\",{\"1\":{\"391\":1}}],[\"当选出一个新的master后\",{\"1\":{\"393\":1}}],[\"当第一次变成slave\",{\"1\":{\"384\":1}}],[\"当主进程执行写操作时\",{\"1\":{\"374\":1}}],[\"当主进程执行读操作时\",{\"1\":{\"374\":1}}],[\"当redis实例故障重启后\",{\"1\":{\"372\":1}}],[\"当多个事务并发执行的时候\",{\"1\":{\"361\":1}}],[\"当多个事务并发执行时可能会遇到\",{\"1\":{\"357\":1}}],[\"当事物\",{\"1\":{\"359\":1}}],[\"当事务回滚时\",{\"1\":{\"334\":1}}],[\"当事务执行\",{\"1\":{\"285\":1,\"314\":1}}],[\"当事务需要加锁的时\",{\"1\":{\"276\":1}}],[\"当事务\",{\"1\":{\"275\":1,\"317\":1,\"357\":1}}],[\"当事务提交之后会把所有修改信息都存到该日志文件中\",{\"1\":{\"272\":1}}],[\"当客户端执行\",{\"1\":{\"345\":1}}],[\"当优化器分析出成本最小的执行计划后\",{\"1\":{\"343\":1}}],[\"当前module的src下\",{\"1\":{\"496\":1}}],[\"当前读语句\",{\"1\":{\"368\":1}}],[\"当前读\",{\"1\":{\"365\":1}}],[\"当前读是如何避免幻读的\",{\"0\":{\"365\":1}}],[\"当前数据库中\",{\"1\":{\"358\":2}}],[\"当前记录写到的位置\",{\"1\":{\"339\":1}}],[\"当前jvm启动时只能同时启动一种推理引擎\",{\"1\":{\"100\":1}}],[\"当设置该参数为\",{\"1\":{\"338\":3}}],[\"当系统崩溃时\",{\"1\":{\"337\":1}}],[\"当在数据量非常大的数据库表执行\",{\"1\":{\"329\":1}}],[\"当在联合索引查询数据时\",{\"1\":{\"215\":1}}],[\"当执行插入\",{\"1\":{\"311\":1}}],[\"当会话退出后\",{\"1\":{\"309\":1}}],[\"当会话断开了\",{\"1\":{\"307\":1}}],[\"当同一个查询在不同的时间产生不同的结果集时\",{\"1\":{\"302\":1,\"363\":1}}],[\"当某个对象不再被其他的对象所引用时\",{\"1\":{\"523\":1}}],[\"当某个类加载器需要加载某个\",{\"1\":{\"494\":1}}],[\"当某个事务持有非唯一索引的\",{\"1\":{\"296\":1}}],[\"当某一个\",{\"1\":{\"178\":1}}],[\"当其他事务插入一条\",{\"1\":{\"296\":4}}],[\"当有多个事务提交的时候\",{\"1\":{\"348\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"337\":1}}],[\"当有一个事务持有二级索引的间隙锁\",{\"1\":{\"296\":2}}],[\"当有线程对表结构进行变更\",{\"1\":{\"310\":1}}],[\"当有线程在执行\",{\"1\":{\"310\":1}}],[\"当有死锁发生时\",{\"1\":{\"281\":1}}],[\"当条件值的记录\",{\"1\":{\"294\":2}}],[\"当条件值的记录在表中\",{\"1\":{\"292\":1}}],[\"当条件值的记录不在表中\",{\"1\":{\"292\":1}}],[\"当唯一索引进行范围查询时\",{\"1\":{\"292\":1}}],[\"当检测到死锁后\",{\"1\":{\"281\":1}}],[\"当隔离级别是可重复读\",{\"1\":{\"278\":1}}],[\"当隔离级别为读已提交时\",{\"1\":{\"278\":1}}],[\"当业务量很大的时候\",{\"1\":{\"273\":1}}],[\"当树的节点越多的时候\",{\"1\":{\"251\":1}}],[\"当每次插入的元素都是二叉查找树中最大的元素\",{\"1\":{\"250\":1}}],[\"当中主键最小的\",{\"1\":{\"243\":1}}],[\"当查询的记录\",{\"1\":{\"295\":2,\"300\":2}}],[\"当查询的记录是\",{\"1\":{\"289\":2,\"300\":2}}],[\"当查询的记录不存在时\",{\"1\":{\"275\":1}}],[\"当查询的数据是主键值时\",{\"1\":{\"245\":1}}],[\"当查询的数据是能在二级索引的\",{\"1\":{\"206\":1}}],[\"当查询语句中包含\",{\"1\":{\"228\":1}}],[\"当页面写满\",{\"1\":{\"226\":1}}],[\"当页被真正访问的时候\",{\"1\":{\"178\":1}}],[\"当二级索引记录的\",{\"1\":{\"216\":2}}],[\"当你的查询语句的执行计划里\",{\"1\":{\"217\":1}}],[\"当你想查阅书中某个知识的内容\",{\"1\":{\"202\":1}}],[\"当你使用\",{\"1\":{\"194\":1}}],[\"当你发现执行计划里的\",{\"1\":{\"149\":1}}],[\"当我深入\",{\"1\":{\"189\":1}}],[\"当我们通过代理类的对象\",{\"1\":{\"507\":1}}],[\"当我们查询\",{\"1\":{\"445\":1}}],[\"当我们查询一条记录时\",{\"1\":{\"174\":1,\"336\":1}}],[\"当我们要执行\",{\"1\":{\"331\":1}}],[\"当我们执行\",{\"1\":{\"329\":1}}],[\"当我们用非唯一索引进行等值查询的时候\",{\"1\":{\"295\":1}}],[\"当我们用唯一索引进行等值查询的时候\",{\"1\":{\"289\":1}}],[\"当我们需要存储大量的记录时\",{\"1\":{\"244\":1}}],[\"当我们在查询条件中对索引列进行表达式计算\",{\"1\":{\"241\":1}}],[\"当我们在查询条件中对索引列使用函数\",{\"1\":{\"241\":1}}],[\"当我们在查询条件中对索引列做了计算\",{\"1\":{\"228\":1}}],[\"当我们在数据表插入一条记录的同时\",{\"1\":{\"200\":1}}],[\"当我们使用左或者左右模糊匹配的时候\",{\"1\":{\"228\":1,\"235\":1,\"241\":1}}],[\"当我们对一张数据表中的记录进行统计的时候\",{\"1\":{\"189\":1}}],[\"当我们理解了实际问题的需求之后\",{\"1\":{\"89\":1}}],[\"当时网上有很多博客也这么说\",{\"1\":{\"189\":1}}],[\"当单表数据库到达某个量级的上限时\",{\"1\":{\"187\":1}}],[\"当从页里读取行记录时\",{\"1\":{\"178\":1}}],[\"当脏页上的数据写入磁盘后\",{\"1\":{\"178\":1}}],[\"当空间不够了\",{\"1\":{\"178\":1}}],[\"当\",{\"1\":{\"176\":1,\"179\":1,\"180\":1,\"185\":1,\"251\":1,\"312\":6,\"330\":1,\"338\":1,\"339\":2,\"347\":3}}],[\"当修改数据时\",{\"1\":{\"172\":1,\"179\":1,\"335\":1}}],[\"当读取数据时\",{\"1\":{\"172\":1,\"335\":1}}],[\"当数据达到\",{\"1\":{\"182\":1}}],[\"当数据从磁盘中取出后\",{\"1\":{\"172\":1}}],[\"当数据表的字段都定义成\",{\"1\":{\"162\":1}}],[\"当数据表没有变长字段的时候\",{\"1\":{\"161\":1}}],[\"当表中所有字段都定义成\",{\"1\":{\"169\":1}}],[\"当一个类需要加载的时候\",{\"1\":{\"494\":1}}],[\"当一个缓存元素过期的时候\",{\"1\":{\"416\":1}}],[\"当一个事务对某条聚簇索引记录进行改动时\",{\"1\":{\"358\":1}}],[\"当一个事务对一条记录加了\",{\"1\":{\"285\":2,\"314\":2}}],[\"当一个事务前后两次查询的结果集\",{\"1\":{\"290\":1}}],[\"当一个事务执行了下面这条语句\",{\"1\":{\"285\":1,\"314\":1}}],[\"当一个事务的等待时间超过该值后\",{\"1\":{\"281\":1}}],[\"当一个对象被删除或自我删除时\",{\"1\":{\"81\":1}}],[\"当一条记录有\",{\"1\":{\"162\":1}}],[\"当需要读一条记录的时候\",{\"1\":{\"155\":1,\"243\":1}}],[\"当管道写满时\",{\"1\":{\"124\":1}}],[\"当状态图中某一个状态下少考虑了哪一个输入事件\",{\"1\":{\"85\":1}}],[\"当整体对象已经不存在的时候\",{\"1\":{\"66\":1}}],[\"当这个过程涉及许多不同人\",{\"1\":{\"58\":1}}],[\"当型结构\",{\"1\":{\"56\":1}}],[\"当然其他线程对学生表进行写操作时也会被阻塞\",{\"1\":{\"309\":1}}],[\"当然是缓存起来好\",{\"1\":{\"335\":1}}],[\"当然是选择在书的目录去找\",{\"1\":{\"202\":1}}],[\"当然是安装\",{\"1\":{\"108\":1}}],[\"当然这只是我们抽象出来的\",{\"1\":{\"184\":1}}],[\"当然不是了\",{\"1\":{\"139\":1}}],[\"当然\",{\"1\":{\"46\":1,\"48\":1,\"58\":1,\"139\":1,\"145\":1,\"166\":1,\"174\":1,\"275\":1,\"307\":1,\"317\":1,\"324\":1}}],[\"它对运行时类的构造函数进行了查找\",{\"1\":{\"498\":1}}],[\"它首先把这个任务委托给他的上级类加载器\",{\"1\":{\"494\":1}}],[\"它将维持加载一段时间\",{\"1\":{\"493\":1}}],[\"它的事务\",{\"1\":{\"359\":2}}],[\"它的聚簇索引记录中都包含下面两个隐藏列\",{\"1\":{\"358\":1}}],[\"它的默认值就是\",{\"1\":{\"152\":1}}],[\"它做的变更才能被其他事务看到\",{\"1\":{\"357\":1}}],[\"它做的变更就能被其他事务看到\",{\"1\":{\"357\":1}}],[\"它可以保证多个逻辑操作要不全部成功\",{\"1\":{\"344\":1}}],[\"它可以很好的反应各种复杂的逻辑\",{\"1\":{\"84\":1}}],[\"它会先看这条记录的\",{\"1\":{\"359\":1}}],[\"它会根据不同的情况自动使用\",{\"1\":{\"341\":1}}],[\"它会维持自平衡\",{\"1\":{\"251\":1}}],[\"它什么时候刷新到磁盘\",{\"1\":{\"338\":1}}],[\"它保证了事务的\",{\"1\":{\"334\":1}}],[\"它属于行级锁\",{\"1\":{\"324\":1}}],[\"它代表的是\",{\"1\":{\"296\":2}}],[\"它不再限制一个节点就只能有\",{\"1\":{\"252\":1}}],[\"它不是流程图中必要的部分\",{\"1\":{\"58\":1}}],[\"它是由记录锁和间隙锁组合而成的\",{\"1\":{\"288\":1}}],[\"它是靠聚簇索引记录自带的\",{\"1\":{\"276\":1}}],[\"它是一种特殊的间隙锁\",{\"1\":{\"275\":1,\"317\":1}}],[\"它是一个不可分割的工作单位\",{\"1\":{\"268\":1}}],[\"它是一个二叉查找树\",{\"1\":{\"250\":1}}],[\"它是记录锁和间隙锁的组合\",{\"1\":{\"275\":1}}],[\"它是放在\",{\"1\":{\"174\":1}}],[\"它采用\",{\"1\":{\"234\":1}}],[\"它一般会忽略索引\",{\"1\":{\"218\":1,\"222\":1}}],[\"它更适合做等值的查询\",{\"1\":{\"207\":1}}],[\"它永远都不是\",{\"1\":{\"191\":1}}],[\"它就是采用了\",{\"1\":{\"257\":1,\"258\":1}}],[\"它就是一棵树\",{\"1\":{\"186\":1}}],[\"它就从管道中被抛弃\",{\"1\":{\"124\":1}}],[\"它实际是放在一个叫\",{\"1\":{\"184\":1}}],[\"它也是通过一些约束条件来达到自平衡\",{\"1\":{\"251\":1}}],[\"它也是利用了\",{\"1\":{\"245\":1}}],[\"它也是根据场景来使用的\",{\"1\":{\"220\":1}}],[\"它也没有占用到\",{\"1\":{\"178\":1}}],[\"它也忙不过来啊\",{\"1\":{\"109\":1}}],[\"它改进了\",{\"1\":{\"178\":1}}],[\"它跟\",{\"1\":{\"177\":1}}],[\"它长这样\",{\"1\":{\"159\":1}}],[\"它本质上是一种流程图\",{\"1\":{\"88\":1}}],[\"它直观地反应了push程序执行的过程\",{\"1\":{\"84\":1}}],[\"它通常用来帮助理解分布式系统\",{\"1\":{\"74\":1}}],[\"它有两种表示方法\",{\"1\":{\"66\":1}}],[\"它有一个入口\",{\"1\":{\"58\":1}}],[\"它指定了子类如何特化父类的所有特征和行为\",{\"1\":{\"66\":1}}],[\"它们是通过\",{\"1\":{\"357\":1,\"361\":1}}],[\"它们是按顺序执行的\",{\"1\":{\"56\":1}}],[\"它们持久化到磁盘的时机分别由下面这两个参数控制\",{\"1\":{\"347\":1}}],[\"它们区别就在于叶子节点存放的是什么数据\",{\"1\":{\"245\":1}}],[\"它们区别在于\",{\"1\":{\"192\":1,\"234\":1}}],[\"它们都需要扫描表来进行记录个数的统计\",{\"1\":{\"197\":1}}],[\"它们的区别在于\",{\"1\":{\"337\":1}}],[\"它们的区别在于创建\",{\"1\":{\"334\":1,\"357\":1,\"361\":1}}],[\"它们的区别如下\",{\"1\":{\"139\":1}}],[\"它们的快照读\",{\"1\":{\"334\":1}}],[\"它们的行格式是这样的\",{\"1\":{\"162\":1}}],[\"它们的行格式都和\",{\"1\":{\"158\":1}}],[\"它们前边的符号有以下几类\",{\"1\":{\"65\":1}}],[\"它由两部分组成\",{\"1\":{\"64\":1}}],[\"它由循环体中的条件\",{\"1\":{\"56\":1}}],[\"它能使人们思路清楚\",{\"1\":{\"58\":1}}],[\"它表示工作的流程\",{\"1\":{\"58\":1}}],[\"指明构造器的参数列表\",{\"1\":{\"503\":1}}],[\"指明获取的方法的形参列表\",{\"1\":{\"502\":1}}],[\"指明获取的方法的名称\",{\"1\":{\"502\":1}}],[\"指的是创建该\",{\"1\":{\"358\":1}}],[\"指的是在创建\",{\"1\":{\"358\":2}}],[\"指的就是\",{\"1\":{\"358\":1}}],[\"指的就是指把日志写入到\",{\"1\":{\"343\":1}}],[\"指一个事务执行过程中看到的数据\",{\"1\":{\"357\":1}}],[\"指一个事务提交之后\",{\"1\":{\"357\":1}}],[\"指一个事务还没提交时\",{\"1\":{\"357\":1}}],[\"指针可以将这些\",{\"1\":{\"334\":1}}],[\"指针和一个\",{\"1\":{\"334\":1}}],[\"指向每一个旧版本记录\",{\"1\":{\"358\":1}}],[\"指向的是下一条记录的\",{\"1\":{\"161\":1,\"163\":1}}],[\"指向线\",{\"1\":{\"58\":1}}],[\"指数据在传输过程中没有被篡改\",{\"1\":{\"104\":1}}],[\"指在程序中需要反复执行某个功能而设置的一种程序结构\",{\"1\":{\"56\":1}}],[\"指定监听的表信息\",{\"1\":{\"463\":1}}],[\"指定key\",{\"1\":{\"453\":1}}],[\"指定密码\",{\"1\":{\"139\":1}}],[\"指定用户名\",{\"1\":{\"139\":1}}],[\"指定\",{\"1\":{\"139\":1}}],[\"指定轮询几率\",{\"1\":{\"41\":1}}],[\"指定nginx进程运行文件存放地址\",{\"1\":{\"32\":1}}],[\"各进程要互斥访问管道\",{\"1\":{\"124\":1}}],[\"各进程拥有独立的内存地址空间\",{\"1\":{\"120\":1}}],[\"各个事务按顺序做\",{\"1\":{\"348\":1}}],[\"各个对象之间的调用顺序是怎样的一目了然\",{\"1\":{\"84\":1}}],[\"各个步骤是按先后顺序执行的\",{\"1\":{\"56\":1}}],[\"各分功能又可进一步分解为若干二级分功能\",{\"1\":{\"53\":1}}],[\"呈现的是页面跳转顺序\",{\"1\":{\"54\":1}}],[\"流动\",{\"1\":{\"54\":1}}],[\"流程如下\",{\"1\":{\"393\":1}}],[\"流程\",{\"1\":{\"384\":1,\"529\":1}}],[\"流程线\",{\"1\":{\"58\":1}}],[\"流程处理关系为并行关系的\",{\"1\":{\"57\":1}}],[\"流程图则比较适合描述程序导向或是数据处理的程序\",{\"1\":{\"85\":1}}],[\"流程图更在意动作是如何完成的\",{\"1\":{\"85\":1}}],[\"流程图和状态图的差别在于\",{\"1\":{\"85\":1}}],[\"流程图\",{\"0\":{\"83\":1,\"84\":1,\"85\":1},\"1\":{\"83\":1}}],[\"流程图是描述一个事件过程的步骤\",{\"1\":{\"58\":1}}],[\"流程图是用一些图框来表示各种类型的操作\",{\"1\":{\"58\":1}}],[\"流程图还能作为程序说明书的一部分提供给别人\",{\"1\":{\"58\":1}}],[\"流程图不仅可以指导编写程序\",{\"1\":{\"58\":1}}],[\"流程图有三大结构\",{\"1\":{\"56\":1}}],[\"流程图中的每个符号都有着特定含义\",{\"1\":{\"55\":1}}],[\"流程图=流程+图\",{\"1\":{\"54\":1}}],[\"流程中的若干活动\",{\"1\":{\"54\":1}}],[\"流程有六个要素构成\",{\"1\":{\"54\":1}}],[\"流程举例说明\",{\"0\":{\"10\":1}}],[\"根本原因是因为它们都是二叉树\",{\"1\":{\"251\":1}}],[\"根公钥\",{\"1\":{\"109\":1}}],[\"根证书\",{\"1\":{\"109\":1}}],[\"根据要求通过反射查找相应的策略执行相应的逻辑\",{\"1\":{\"508\":1}}],[\"根据id获取更多的信息\",{\"1\":{\"508\":1}}],[\"根据id查询redis\",{\"1\":{\"451\":1}}],[\"根据id查询商品库存\",{\"1\":{\"442\":1,\"444\":1}}],[\"根据id查询商品\",{\"1\":{\"442\":1,\"444\":1}}],[\"根据key查询redis数据\",{\"1\":{\"450\":1}}],[\"根据key去数据库查询数据\",{\"1\":{\"416\":1}}],[\"根据key的有效部分计算哈希值\",{\"1\":{\"403\":1}}],[\"根据不同的查询方式\",{\"1\":{\"369\":1}}],[\"根据加锁的范围\",{\"1\":{\"306\":1}}],[\"根据我的经验\",{\"1\":{\"275\":1,\"291\":1,\"304\":1,\"322\":1}}],[\"根据索引类型不同\",{\"1\":{\"257\":1}}],[\"根据索引的类型又分为聚簇索引和二级索引\",{\"1\":{\"192\":1}}],[\"根据上述的公式\",{\"1\":{\"187\":1}}],[\"根据执行计划执行\",{\"1\":{\"150\":1}}],[\"根据词法分析的结果\",{\"1\":{\"142\":1}}],[\"根据类的关系的不同\",{\"1\":{\"66\":1}}],[\"根据给定的条件是否成立决定如何执行其后的操作\",{\"1\":{\"58\":1}}],[\"根据判断条件\",{\"1\":{\"56\":1}}],[\"根据判断的结果来控制程序的流程\",{\"1\":{\"56\":1}}],[\"根据判断的结果判断某些条件\",{\"1\":{\"56\":1}}],[\"根据流程图\",{\"1\":{\"54\":1}}],[\"根目录\",{\"1\":{\"32\":1}}],[\"所占内存的大小\",{\"1\":{\"343\":1}}],[\"所占用的字节数\",{\"1\":{\"166\":1}}],[\"所占用的字节数是多少\",{\"1\":{\"166\":2}}],[\"所占用的字节数的\",{\"1\":{\"166\":3}}],[\"所消耗的时间也就越小\",{\"1\":{\"248\":1}}],[\"所消耗的时间也就越大\",{\"1\":{\"248\":1}}],[\"所需数据只需在索引即可全部获得\",{\"1\":{\"228\":1}}],[\"所有需要访问和使用类数据只能通过这个class对象\",{\"1\":{\"492\":1}}],[\"所有的类都继承自object类\",{\"1\":{\"523\":1}}],[\"所有的slave都不可用才读取master\",{\"1\":{\"398\":1}}],[\"所有的内置函数\",{\"1\":{\"138\":1}}],[\"所有存储引擎都可以使用\",{\"1\":{\"341\":1}}],[\"所有记录都会被加锁\",{\"1\":{\"329\":1}}],[\"所有非叶子节点都是冗余索引\",{\"1\":{\"258\":1}}],[\"所有索引都会在叶子节点出现\",{\"1\":{\"253\":1}}],[\"所有元素都需要向后排列\",{\"1\":{\"250\":1}}],[\"所有节点按照索引键大小排序\",{\"1\":{\"244\":1}}],[\"所有完整的用户记录都存放在聚簇索引的叶子节点\",{\"1\":{\"245\":1,\"257\":1}}],[\"所有完整的用户记录都存放在主键索引的\",{\"1\":{\"206\":1,\"208\":1}}],[\"所有完整的用户数据都存放在聚簇索引的叶子节点\",{\"1\":{\"234\":1}}],[\"所有\",{\"1\":{\"166\":1}}],[\"所谓的幻读是指在同一事务下\",{\"1\":{\"329\":1}}],[\"所谓的长事务\",{\"1\":{\"310\":1}}],[\"所谓的存储引擎\",{\"1\":{\"202\":1}}],[\"所谓关联关系\",{\"1\":{\"66\":1}}],[\"所谓依赖关系\",{\"1\":{\"66\":1}}],[\"所谓流程\",{\"1\":{\"54\":1}}],[\"所以其他类加载器并没有机会再去加载\",{\"1\":{\"494\":1}}],[\"所以其他事务插入\",{\"1\":{\"290\":1}}],[\"所以取3\",{\"1\":{\"473\":1}}],[\"所以还需要编写一个server来对这个路径做反向代理\",{\"1\":{\"441\":1}}],[\"所以还会再查一次\",{\"1\":{\"147\":1,\"148\":1}}],[\"所以可以直接运行lua代码\",{\"1\":{\"422\":1}}],[\"所以可以验证内容是否被篡改了\",{\"1\":{\"108\":1}}],[\"所以重写命令后\",{\"1\":{\"379\":1}}],[\"所以重点说一下数据页中的\",{\"1\":{\"243\":1}}],[\"所以查询不出来\",{\"1\":{\"367\":1}}],[\"所以查二级索引的\",{\"1\":{\"232\":1}}],[\"所以此时活跃事务的事务\",{\"1\":{\"359\":2}}],[\"所以从\",{\"1\":{\"357\":1}}],[\"所以余额\",{\"1\":{\"357\":2}}],[\"所以大多数\",{\"1\":{\"352\":1}}],[\"所以大家误以为加了表锁\",{\"1\":{\"329\":1}}],[\"所以说\",{\"1\":{\"346\":1}}],[\"所以说查询缓存很鸡肋\",{\"1\":{\"333\":1}}],[\"所以频繁的\",{\"1\":{\"343\":1}}],[\"所以针对这种格式\",{\"1\":{\"341\":1}}],[\"所以参数为\",{\"1\":{\"338\":2}}],[\"所以写入\",{\"1\":{\"338\":1,\"349\":1}}],[\"所以磁盘操作是\",{\"1\":{\"337\":1}}],[\"所以磁盘操作是顺序写\",{\"1\":{\"337\":1}}],[\"所以有了\",{\"1\":{\"337\":1}}],[\"所以有时候访问到了非叶子节点就可以找到索引\",{\"1\":{\"254\":1}}],[\"所以决定要使用\",{\"1\":{\"333\":1}}],[\"所以全表扫描的场景下\",{\"1\":{\"329\":1}}],[\"所以只会对\",{\"1\":{\"329\":1}}],[\"所以只要是你认为能更好的说明你的意图\",{\"1\":{\"52\":1}}],[\"所以为了能安全的对表结构进行变更\",{\"1\":{\"310\":1}}],[\"所以如果不小心整个数据库的数据被删除了\",{\"1\":{\"341\":1}}],[\"所以如果只加记录锁\",{\"1\":{\"298\":1}}],[\"所以如果事务\",{\"1\":{\"294\":1}}],[\"所以肯定存在值相同的记录\",{\"1\":{\"297\":1}}],[\"所以肯定存在索引值相同的记录\",{\"1\":{\"295\":1,\"300\":1}}],[\"所以该版本的记录对事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"所以该版本的记录对当前事务\",{\"1\":{\"358\":1}}],[\"所以该版本的记录对当前事务不可见\",{\"1\":{\"358\":2}}],[\"所以该版本的记录对当前事务可见\",{\"1\":{\"358\":1}}],[\"所以该二级索引的\",{\"1\":{\"297\":1}}],[\"所以该记录的索引中的\",{\"1\":{\"293\":1}}],[\"所以该主键索引的\",{\"1\":{\"293\":1}}],[\"所以扫描第二行的时候\",{\"1\":{\"293\":1,\"298\":1}}],[\"所以对该主键索引加的是范围为\",{\"1\":{\"293\":1,\"294\":1}}],[\"所以即使\",{\"1\":{\"291\":1}}],[\"所以是不会发生退化锁的现象\",{\"1\":{\"298\":1}}],[\"所以是对主键索引加锁\",{\"1\":{\"290\":1}}],[\"所以是通过全表扫描来查询数据的\",{\"1\":{\"238\":1}}],[\"所以行级锁的种类主要有三类\",{\"1\":{\"284\":1}}],[\"所以后面的内容都是基于\",{\"1\":{\"283\":1}}],[\"所以完全算是新的文章了\",{\"1\":{\"282\":1}}],[\"所以我重写了这篇文章\",{\"1\":{\"282\":1}}],[\"所以我们必须保证数据库数据\",{\"1\":{\"455\":1}}],[\"所以我们监听\",{\"1\":{\"442\":1}}],[\"所以我们认为\",{\"1\":{\"367\":1}}],[\"所以我们不能用一种线性结构将磁盘排序\",{\"1\":{\"250\":1}}],[\"所以我们可以采用二分查找法\",{\"1\":{\"249\":1}}],[\"所以我们心里要清楚有哪些情况会导致索引失效\",{\"1\":{\"228\":1}}],[\"所以我们从顶层开始对比\",{\"1\":{\"187\":1}}],[\"所以我们千万不要随便信任第三方的证书\",{\"1\":{\"108\":1}}],[\"所以我们增加服务器的数量\",{\"1\":{\"23\":1}}],[\"所以导致第二个事务会等待\",{\"1\":{\"280\":1}}],[\"所以导致事务\",{\"1\":{\"280\":1}}],[\"所以事务过程中每次查询的数据都是一样的\",{\"1\":{\"364\":1}}],[\"所以事务\",{\"1\":{\"277\":1,\"280\":2,\"290\":1,\"291\":1,\"324\":1,\"325\":1,\"357\":1,\"359\":2,\"360\":2}}],[\"所以所以两个事务中\",{\"1\":{\"275\":1}}],[\"所以两个事务先要查询该订单是否存在\",{\"1\":{\"274\":1}}],[\"所以当其它事务持有该间隙的间隙锁时\",{\"1\":{\"275\":1}}],[\"所以当时在新增订单的时候做了幂等性校验\",{\"1\":{\"273\":1}}],[\"所以当调用该函数的时候\",{\"1\":{\"147\":1}}],[\"所以讨论\",{\"1\":{\"258\":1}}],[\"所以树的高度越高\",{\"1\":{\"250\":1,\"258\":1}}],[\"所以索引的数据结构不仅要能高效地查询某一个记录\",{\"1\":{\"248\":1}}],[\"所以索引是以空间换时间的设计思想\",{\"1\":{\"202\":1}}],[\"所以操作系统的最小读写单位是块\",{\"1\":{\"248\":1}}],[\"所以聚簇索引只能有一个\",{\"1\":{\"245\":1,\"257\":1}}],[\"所以到页\",{\"1\":{\"244\":1}}],[\"所以通过对所有记录进行分组\",{\"1\":{\"244\":1}}],[\"所以通常会说\",{\"1\":{\"193\":1}}],[\"所以主键为\",{\"1\":{\"243\":1}}],[\"所以先是拿\",{\"1\":{\"238\":1}}],[\"所以结果应该是\",{\"1\":{\"238\":2}}],[\"所以干脆将这种索引失效的场景告诉程序员\",{\"1\":{\"237\":1}}],[\"所以无法走索引\",{\"1\":{\"237\":1}}],[\"所以无法像\",{\"1\":{\"197\":1}}],[\"所以就发生幻读\",{\"1\":{\"369\":2}}],[\"所以就很好了避免幻读问题\",{\"1\":{\"302\":2,\"357\":2,\"361\":2,\"362\":2,\"364\":1}}],[\"所以就会被阻塞\",{\"1\":{\"280\":1}}],[\"所以就会导致索引失效\",{\"1\":{\"241\":1}}],[\"所以就到叶子节点\",{\"1\":{\"244\":1}}],[\"所以就跟大家图解下innodb\",{\"1\":{\"243\":1}}],[\"所以就可以通过扫描索引来查询数据\",{\"1\":{\"236\":1}}],[\"所以就无法匹配上联合索引\",{\"1\":{\"215\":1,\"239\":1}}],[\"所以继续看下一个索引值\",{\"1\":{\"235\":1}}],[\"所以选择去节点2继续查询\",{\"1\":{\"235\":1}}],[\"所以得在二级索引树逐一遍历\",{\"1\":{\"232\":1}}],[\"所以要避免这种问题的出现\",{\"1\":{\"228\":1}}],[\"所以要在高位补\",{\"1\":{\"162\":1}}],[\"所以前缀为\",{\"1\":{\"216\":1}}],[\"所以类似于\",{\"1\":{\"216\":1}}],[\"所以在\",{\"1\":{\"348\":1}}],[\"所以在实际使用中\",{\"1\":{\"342\":1}}],[\"所以在加锁时\",{\"1\":{\"295\":1}}],[\"所以在使用这两条语句的时候\",{\"1\":{\"283\":1,\"313\":1}}],[\"所以在线上千万不要执行没有带索引条件的\",{\"1\":{\"275\":1}}],[\"所以在删除的时候\",{\"1\":{\"255\":1}}],[\"所以在查询过程中会发生\",{\"1\":{\"252\":1}}],[\"所以在查询过程都用上了索引\",{\"1\":{\"234\":1}}],[\"所以在执行\",{\"1\":{\"216\":1}}],[\"所以在设计数据库表的时候\",{\"1\":{\"162\":1}}],[\"所以符合\",{\"1\":{\"216\":2}}],[\"所以b+tree\",{\"1\":{\"205\":1}}],[\"所以找到第三层的索引数据\",{\"1\":{\"205\":1}}],[\"所以找到了页号\",{\"1\":{\"187\":1}}],[\"所以根据\",{\"1\":{\"205\":1}}],[\"所以直接选择全表扫描的方式来查询数据\",{\"1\":{\"232\":1}}],[\"所以直接读取最新的数据就好了\",{\"1\":{\"357\":1}}],[\"所以直接读取\",{\"1\":{\"197\":1}}],[\"所以直接在存储引擎过滤出满足\",{\"1\":{\"149\":1}}],[\"所以它的执行效率是比较差的\",{\"1\":{\"195\":1}}],[\"所以不同类型的操作\",{\"1\":{\"334\":1}}],[\"所以不需要经过查询缓存\",{\"1\":{\"333\":1}}],[\"所以不需要读取记录中的字段值\",{\"1\":{\"193\":1}}],[\"所以不会刷盘\",{\"1\":{\"348\":1}}],[\"所以不会对主键索引加锁\",{\"1\":{\"295\":1,\"300\":1}}],[\"所以不会再继续扫描\",{\"1\":{\"294\":1}}],[\"所以不会发生复杂的树的变形\",{\"1\":{\"255\":1}}],[\"所以不会产生额外的流量\",{\"1\":{\"42\":1}}],[\"所以不适合作为数据库的索引结构\",{\"1\":{\"250\":1}}],[\"所以不知道从哪个索引值开始比较\",{\"1\":{\"235\":1}}],[\"所以二级索引树比聚簇索引树小\",{\"1\":{\"192\":1}}],[\"所以上面这条语句\",{\"1\":{\"191\":1}}],[\"所以凡事带有\",{\"1\":{\"189\":1}}],[\"所以增加硬件配置\",{\"1\":{\"187\":1}}],[\"所以页与页之间就有了上下层级的概念\",{\"1\":{\"186\":1}}],[\"所以测试数据只限于参考\",{\"1\":{\"182\":1}}],[\"所以并不是机器配置就是用于数据库配置\",{\"1\":{\"182\":1}}],[\"所以需要从\",{\"1\":{\"243\":1}}],[\"所以需要先淘汰末尾的\",{\"1\":{\"178\":1}}],[\"所以需要在\",{\"1\":{\"26\":3}}],[\"所以把\",{\"1\":{\"178\":1}}],[\"所以相当于\",{\"1\":{\"176\":1}}],[\"所以代表着变长字段允许存储的最大字节数是\",{\"1\":{\"166\":1}}],[\"所以会分别对这两个索引加锁\",{\"1\":{\"304\":1}}],[\"所以会往该节点的左边子节点走\",{\"1\":{\"252\":1}}],[\"所以会带来的存储空间的问题\",{\"1\":{\"227\":1}}],[\"所以会用\",{\"1\":{\"166\":2}}],[\"所以会调用\",{\"1\":{\"147\":1}}],[\"所以用二进制来表示是酱紫的\",{\"1\":{\"162\":1}}],[\"所以这里还是能获取到abc\",{\"1\":{\"520\":1}}],[\"所以这里不用管\",{\"1\":{\"161\":1}}],[\"所以这会成为性能瓶颈\",{\"1\":{\"347\":1}}],[\"所以这次就带着这个问题\",{\"1\":{\"333\":1}}],[\"所以这次小林就带大家拆解一下\",{\"1\":{\"137\":1}}],[\"所以这条插入语句可以插入成功\",{\"1\":{\"296\":1}}],[\"所以这条插入语句可以执行成功\",{\"1\":{\"296\":1}}],[\"所以这条插入语句会被阻塞\",{\"1\":{\"296\":2,\"297\":1}}],[\"所以这条语句相当于\",{\"1\":{\"238\":2}}],[\"所以这两个数据结构非常适合检索存于磁盘中的数据\",{\"1\":{\"258\":1}}],[\"所以这个查询过程是全表扫描的\",{\"1\":{\"178\":1}}],[\"所以每一个字符占用的\",{\"1\":{\"161\":1}}],[\"所以攻破了这个知识点后\",{\"1\":{\"151\":1}}],[\"所以接着向存储引擎层要求继续读刚才那条记录的下一条记录\",{\"1\":{\"148\":1}}],[\"所以优化器决定选用访问类型为\",{\"1\":{\"147\":1,\"148\":1}}],[\"所以一般是推荐使用长连接\",{\"1\":{\"139\":1}}],[\"所以都是合法的\",{\"1\":{\"108\":1}}],[\"所以必须要用\",{\"1\":{\"108\":1}}],[\"所以能保证\",{\"1\":{\"107\":1}}],[\"所以获取明文后有安全风险\",{\"1\":{\"103\":1}}],[\"所以普通的静态访问最大并发数是\",{\"1\":{\"48\":1}}],[\"所以\",{\"1\":{\"48\":1,\"139\":1,\"140\":1,\"144\":1,\"152\":1,\"158\":2,\"161\":4,\"162\":4,\"166\":4,\"169\":1,\"172\":1,\"174\":1,\"176\":1,\"178\":1,\"187\":4,\"194\":1,\"196\":1,\"197\":1,\"207\":1,\"208\":1,\"215\":2,\"216\":5,\"219\":1,\"220\":1,\"225\":1,\"228\":1,\"230\":1,\"232\":4,\"238\":1,\"239\":1,\"243\":1,\"245\":1,\"248\":2,\"252\":2,\"257\":1,\"279\":1,\"283\":1,\"287\":1,\"290\":1,\"294\":1,\"296\":1,\"297\":1,\"307\":1,\"311\":1,\"312\":2,\"316\":1,\"324\":1,\"334\":1,\"336\":1,\"337\":1,\"338\":1,\"339\":2,\"340\":1,\"344\":2,\"345\":1,\"346\":2,\"348\":1,\"357\":2,\"359\":1,\"365\":2,\"369\":1,\"442\":1,\"480\":1}}],[\"所以降低了风险\",{\"1\":{\"46\":1}}],[\"所以省掉了锁带来的开销\",{\"1\":{\"46\":1}}],[\"要创建xxx类的对象\",{\"1\":{\"489\":1}}],[\"要与安装canal时设置的名称一致\",{\"1\":{\"461\":1}}],[\"要返回真实数据\",{\"1\":{\"437\":1}}],[\"要进一步提高redis的并发能力\",{\"1\":{\"382\":1}}],[\"要进行目标值附近的小范围扫描\",{\"1\":{\"228\":1}}],[\"要不全部失败\",{\"1\":{\"344\":1}}],[\"要不追求性能\",{\"1\":{\"338\":1}}],[\"要不追求数据安全性\",{\"1\":{\"338\":1}}],[\"要不然我们不清楚所指定的条件\",{\"1\":{\"265\":1}}],[\"要写到磁盘\",{\"1\":{\"337\":1}}],[\"要把被更新的列的旧值记下来\",{\"1\":{\"334\":1}}],[\"要把这条记录中的内容都记下来\",{\"1\":{\"334\":1}}],[\"要把这条记录的主键值记下来\",{\"1\":{\"334\":1}}],[\"要把回滚时需要的信息都记录到\",{\"1\":{\"334\":1}}],[\"要把区分度大的字段排在前面\",{\"1\":{\"218\":1}}],[\"要怎么回滚到事务之前的数据呢\",{\"1\":{\"334\":1}}],[\"要释放表锁\",{\"1\":{\"309\":1}}],[\"要使用全局锁\",{\"1\":{\"307\":1}}],[\"要先对\",{\"1\":{\"304\":1}}],[\"要找到这个问题的答案\",{\"1\":{\"297\":1}}],[\"要多显示一个数值\",{\"1\":{\"296\":1}}],[\"要看条件值的记录是否存在于表中\",{\"1\":{\"292\":1}}],[\"要将该记录的索引中的\",{\"1\":{\"291\":1}}],[\"要加上\",{\"1\":{\"283\":1,\"313\":1}}],[\"要这么加行级锁\",{\"1\":{\"282\":1}}],[\"要么先记\",{\"1\":{\"312\":1}}],[\"要么全部不完成\",{\"1\":{\"352\":1}}],[\"要么全部完成\",{\"1\":{\"352\":1}}],[\"要么全部执行成功\",{\"1\":{\"351\":1}}],[\"要么全部失败\",{\"1\":{\"269\":1,\"351\":1}}],[\"要么全部成功\",{\"1\":{\"269\":1}}],[\"要么同时失败\",{\"1\":{\"268\":1}}],[\"要设计一个\",{\"1\":{\"258\":1}}],[\"要设计一个适合\",{\"1\":{\"248\":1}}],[\"要能高效地查询某一个记录\",{\"1\":{\"248\":1}}],[\"要解决幻读现象不建议将隔离级别升级到\",{\"1\":{\"357\":1}}],[\"要解决不可重复读现象\",{\"1\":{\"357\":1,\"361\":1}}],[\"要解决脏读现象\",{\"1\":{\"357\":1,\"361\":1}}],[\"要解决这个问题\",{\"1\":{\"351\":1}}],[\"要解决这问题\",{\"1\":{\"312\":1}}],[\"要解决办法很简单\",{\"1\":{\"240\":1}}],[\"要解释这个问题\",{\"1\":{\"247\":1}}],[\"要会自动把字符串转为数字\",{\"1\":{\"238\":1}}],[\"要明白这个原因\",{\"1\":{\"238\":1}}],[\"要查询的数据就不能只在二级索引树里找了\",{\"1\":{\"232\":1}}],[\"要避免这类特殊场景下发生幻读的现象的话\",{\"1\":{\"368\":1,\"369\":1}}],[\"要避免这种问题的出现\",{\"1\":{\"228\":1}}],[\"要避免幻读就是避免结果集某一条记录被其他事务删除\",{\"1\":{\"290\":1}}],[\"要避免预读失效带来影响\",{\"1\":{\"178\":1}}],[\"要尽量避免全表扫描和全索引扫描\",{\"1\":{\"228\":1}}],[\"要利用索引的有序性\",{\"1\":{\"219\":1}}],[\"要清楚这些索引的使用和实现方式\",{\"1\":{\"203\":1}}],[\"要对这些索引进行分类\",{\"1\":{\"203\":1}}],[\"要花费差不多\",{\"1\":{\"198\":1}}],[\"要弄明白这个\",{\"1\":{\"190\":1}}],[\"要实现这个\",{\"1\":{\"178\":1}}],[\"要想回答这个问题\",{\"1\":{\"272\":1}}],[\"要想提升查询性能\",{\"1\":{\"172\":1}}],[\"要想知道优化器选择了哪个索引\",{\"1\":{\"145\":1}}],[\"要保证所有字段的长度\",{\"1\":{\"167\":1,\"169\":1}}],[\"要算\",{\"1\":{\"165\":1}}],[\"要在一的一方写1\",{\"1\":{\"90\":1}}],[\"要在两个实体连线方向各写1\",{\"1\":{\"90\":1}}],[\"要换成查看有哪些订单\",{\"1\":{\"53\":1}}],[\"要求必须与一个引用队列关联\",{\"1\":{\"522\":1}}],[\"要求\",{\"1\":{\"498\":1}}],[\"要求nginx服务器找到标识uri和请求字符串匹配度最高的location后\",{\"1\":{\"39\":1}}],[\"要求请求字符串与uri严格匹配\",{\"1\":{\"39\":1}}],[\"表明有事务想在某个区间插入新记录\",{\"1\":{\"317\":1}}],[\"表级别的独占锁\",{\"1\":{\"309\":1}}],[\"表级别的共享锁\",{\"1\":{\"309\":1}}],[\"表级锁有哪些\",{\"1\":{\"308\":1}}],[\"表级锁\",{\"0\":{\"308\":1}}],[\"表级锁和行锁三类\",{\"1\":{\"306\":1}}],[\"表锁和行锁是满足读读共享\",{\"1\":{\"311\":1}}],[\"表锁除了会限制别的线程的读写外\",{\"1\":{\"309\":1}}],[\"表锁\",{\"0\":{\"309\":1},\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":1,\"308\":1,\"322\":1}}],[\"表里的主键通常都会设置成自增的\",{\"1\":{\"312\":1}}],[\"表里有以下行数据\",{\"1\":{\"303\":1}}],[\"表里有这三条记录\",{\"1\":{\"161\":1}}],[\"表里只有一个主键索引\",{\"1\":{\"303\":1}}],[\"表里现在已经有了\",{\"1\":{\"274\":1}}],[\"表结构的先后顺序就可以了\",{\"1\":{\"264\":1}}],[\"表子查询\",{\"1\":{\"261\":1}}],[\"表增加了\",{\"1\":{\"238\":1}}],[\"表达式参数就是缓存的key\",{\"1\":{\"416\":1}}],[\"表达式计算的情况多种多样\",{\"1\":{\"237\":1}}],[\"表达式计算后的值\",{\"1\":{\"237\":1}}],[\"表达分功能或功能单元相互关系或从属关系的图称为功能结构图\",{\"1\":{\"53\":1}}],[\"表数据太少的时候\",{\"1\":{\"222\":1}}],[\"表数据既可以存在共享表空间文件\",{\"1\":{\"152\":1}}],[\"表的更新只会记录这两个\",{\"1\":{\"312\":1}}],[\"表的总行数\",{\"1\":{\"218\":1}}],[\"表的这三条记录作为例子\",{\"1\":{\"162\":1}}],[\"表索引有着更广泛的适用场景的原因\",{\"1\":{\"207\":1}}],[\"表不适合做范围查询\",{\"1\":{\"207\":1}}],[\"表不存在或者字段不存在\",{\"1\":{\"142\":1}}],[\"表\",{\"1\":{\"197\":1,\"198\":1,\"234\":1,\"272\":1,\"319\":1}}],[\"表空间中的\",{\"1\":{\"337\":1,\"341\":1}}],[\"表空间\",{\"0\":{\"184\":1}}],[\"表空间是由各个段\",{\"1\":{\"157\":1}}],[\"表空间由段\",{\"1\":{\"153\":1}}],[\"表空间文件的结构是怎么样的\",{\"0\":{\"153\":1}}],[\"表就有主键索引\",{\"1\":{\"145\":1}}],[\"表只有一个索引就是主键\",{\"1\":{\"145\":1}}],[\"表名等等\",{\"1\":{\"333\":1}}],[\"表名字\",{\"1\":{\"152\":2}}],[\"表名\",{\"1\":{\"142\":1}}],[\"表中主键\",{\"1\":{\"314\":1}}],[\"表中时\",{\"1\":{\"294\":2}}],[\"表中有一个范围\",{\"1\":{\"286\":1,\"287\":1,\"315\":1,\"316\":1,\"365\":1}}],[\"表中有多少个记录\",{\"1\":{\"191\":1}}],[\"表中的记录如下\",{\"1\":{\"319\":1}}],[\"表中的情况\",{\"1\":{\"294\":3}}],[\"表中的有这些行记录\",{\"1\":{\"288\":1}}],[\"表中的\",{\"1\":{\"279\":1,\"280\":1}}],[\"表中的某些列可能会存储\",{\"1\":{\"162\":1}}],[\"表中最后一个记录的\",{\"1\":{\"275\":1}}],[\"表中\",{\"1\":{\"137\":1,\"161\":1,\"191\":2,\"277\":1,\"280\":1,\"322\":1}}],[\"表示每执行一次写命令\",{\"1\":{\"378\":1}}],[\"表示每次提交事务都\",{\"1\":{\"343\":1,\"349\":1}}],[\"表示每次提交事务都会将\",{\"1\":{\"347\":1}}],[\"表示每次提交事务都会\",{\"1\":{\"343\":1}}],[\"表示每次提交事务都只\",{\"1\":{\"343\":1}}],[\"表示每次事务提交时\",{\"1\":{\"338\":3,\"347\":1,\"349\":1}}],[\"表示生成该版本记录的活跃事务已经被提交\",{\"1\":{\"358\":1}}],[\"表示生成该版本记录的活跃事务依然活跃着\",{\"1\":{\"358\":1}}],[\"表示这个版本的记录是在创建\",{\"1\":{\"358\":2}}],[\"表示这个数据是由哪个事务生成的\",{\"1\":{\"164\":1}}],[\"表示如果队列中的事务数达到\",{\"1\":{\"348\":1}}],[\"表示在等待\",{\"1\":{\"348\":1}}],[\"表示在这3天之内访问这个url\",{\"1\":{\"42\":1}}],[\"表示当前要擦除的位置\",{\"1\":{\"339\":1}}],[\"表示当前记录的类型\",{\"1\":{\"163\":1}}],[\"表示\",{\"1\":{\"339\":1}}],[\"表示开启这个逻辑\",{\"1\":{\"281\":1}}],[\"表示的是\",{\"1\":{\"275\":1}}],[\"表示行级锁\",{\"1\":{\"275\":1,\"279\":1,\"280\":1,\"290\":1,\"304\":1,\"322\":1}}],[\"表示走索引扫描\",{\"1\":{\"235\":1}}],[\"表示对索引列进行范围查询\",{\"1\":{\"232\":1}}],[\"表示对一个给定的条件进行判断\",{\"1\":{\"58\":1}}],[\"表示采用了索引范围扫描\",{\"1\":{\"228\":1}}],[\"表示数据扫描类型\",{\"1\":{\"228\":1}}],[\"表示扫描的数据行数\",{\"1\":{\"228\":1}}],[\"表示索引的长度\",{\"1\":{\"228\":1}}],[\"表示节点允许的最大子节点个数为\",{\"1\":{\"207\":1}}],[\"表示此页\",{\"1\":{\"178\":1}}],[\"表示此页已被使用\",{\"1\":{\"178\":1}}],[\"表示此页未被使用\",{\"1\":{\"178\":1}}],[\"表示联系\",{\"1\":{\"90\":1}}],[\"表示实体或联系的属性\",{\"1\":{\"90\":1}}],[\"表示实体\",{\"1\":{\"90\":1}}],[\"表示法\",{\"1\":{\"70\":1}}],[\"表示类是接口所有特征和行为的实现\",{\"1\":{\"66\":1}}],[\"表示protected\",{\"1\":{\"65\":1}}],[\"表示private\",{\"1\":{\"65\":1}}],[\"表示public\",{\"1\":{\"65\":1}}],[\"表示用例与用例之间的关系\",{\"1\":{\"62\":1,\"63\":1}}],[\"表示参与者与参与者之间\",{\"1\":{\"61\":1}}],[\"表示参与者与用例之间的关系\",{\"1\":{\"60\":1}}],[\"表示方法\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":1}}],[\"表示流程的路径和方向\",{\"1\":{\"58\":1}}],[\"表示流程开始或结束\",{\"1\":{\"58\":1}}],[\"表示一般的处理功能\",{\"1\":{\"58\":1}}],[\"直到下一次再次访问到8081时才可以生效\",{\"1\":{\"445\":1}}],[\"直到将slave现在的offset也覆盖\",{\"1\":{\"386\":1}}],[\"直到数组被填满\",{\"1\":{\"386\":1}}],[\"直到事务结束\",{\"1\":{\"329\":1}}],[\"直到事务\",{\"1\":{\"317\":1,\"357\":1,\"365\":1}}],[\"直到拥有间隙锁的那个事务提交为止\",{\"1\":{\"317\":1}}],[\"直到表结构变更完成\",{\"1\":{\"310\":1}}],[\"直到执行完\",{\"1\":{\"310\":1}}],[\"直到锁被释放\",{\"1\":{\"309\":1}}],[\"直到扫描到第一个不符合条件的二级索引记录就停止扫描\",{\"1\":{\"295\":1,\"300\":1}}],[\"直到扫描完表中的所有记录\",{\"1\":{\"178\":1}}],[\"直到第一个事务提交后\",{\"1\":{\"280\":1}}],[\"直到找到\",{\"1\":{\"256\":1,\"359\":1,\"360\":1}}],[\"直到匹配不到前缀为林的索引值\",{\"1\":{\"235\":1}}],[\"直到某条记录的\",{\"1\":{\"216\":1}}],[\"直到某条记录不符合\",{\"1\":{\"216\":2}}],[\"直到符合查询的全部记录被读完\",{\"1\":{\"192\":1}}],[\"直到存储引擎把表中的所有记录读完\",{\"1\":{\"148\":1,\"149\":2}}],[\"直到型结构\",{\"1\":{\"56\":1}}],[\"直观形象\",{\"1\":{\"58\":1}}],[\"直至各分功能被分解为功能单元为止\",{\"1\":{\"53\":1}}],[\"直接内存释放\",{\"1\":{\"522\":1}}],[\"直接修改缓存\",{\"1\":{\"456\":1}}],[\"直接执行第5歩\",{\"1\":{\"411\":1}}],[\"直接执行where\",{\"1\":{\"215\":1}}],[\"直接停止一个redis实例\",{\"1\":{\"410\":1}}],[\"直接调用\",{\"1\":{\"348\":2}}],[\"直接持久到磁盘\",{\"1\":{\"347\":1}}],[\"直接持久化到磁盘\",{\"1\":{\"338\":2,\"347\":1}}],[\"直接读取缓存中的记录\",{\"1\":{\"335\":1}}],[\"直接查该表是否有意向独占锁\",{\"1\":{\"311\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"217\":1,\"239\":1}}],[\"直接从内存中读取\",{\"1\":{\"172\":1}}],[\"直接在二级索引就能查找到结果\",{\"1\":{\"145\":1}}],[\"直接通信方式\",{\"1\":{\"123\":1}}],[\"直接通过浏览器自身确认是否过期即可\",{\"1\":{\"42\":1}}],[\"直接传输密钥无论从哪一端传从上节分析来看是不行了\",{\"1\":{\"107\":1}}],[\"直接跳转到127\",{\"1\":{\"39\":2}}],[\"直接下载\",{\"1\":{\"28\":1}}],[\"如3\",{\"1\":{\"508\":1}}],[\"如java\",{\"1\":{\"480\":1}}],[\"如非必要\",{\"1\":{\"473\":1}}],[\"如上图\",{\"1\":{\"522\":1}}],[\"如上图所示\",{\"1\":{\"408\":1}}],[\"如上面事务\",{\"1\":{\"275\":1}}],[\"如存储过程\",{\"1\":{\"138\":1}}],[\"如日期\",{\"1\":{\"138\":1}}],[\"如下过程\",{\"1\":{\"348\":1}}],[\"如下动图演示\",{\"1\":{\"250\":1}}],[\"如下面这条语句\",{\"1\":{\"234\":3}}],[\"如下查询语句\",{\"1\":{\"206\":1}}],[\"如下\",{\"1\":{\"191\":2,\"204\":1,\"215\":1,\"304\":1,\"359\":1,\"360\":1,\"364\":1,\"412\":1}}],[\"如下所示\",{\"1\":{\"108\":1}}],[\"如下图红框所示\",{\"1\":{\"449\":1}}],[\"如下图的黄色部分\",{\"1\":{\"227\":1}}],[\"如下图的右边\",{\"1\":{\"216\":1}}],[\"如下图中所示\",{\"1\":{\"187\":1}}],[\"如下图\",{\"1\":{\"75\":2,\"145\":1,\"161\":1,\"174\":1,\"178\":1,\"206\":2,\"216\":1,\"228\":1,\"234\":1,\"274\":1,\"333\":1,\"334\":1,\"337\":1,\"339\":1,\"343\":1,\"345\":1,\"348\":1,\"359\":1,\"360\":1}}],[\"如下图所以\",{\"1\":{\"66\":1}}],[\"如下图所示\",{\"1\":{\"64\":1,\"65\":1,\"77\":1,\"234\":1,\"243\":1,\"498\":1}}],[\"如证书序列号\",{\"1\":{\"108\":1}}],[\"如\",{\"1\":{\"108\":1,\"182\":1,\"188\":1,\"216\":1,\"272\":1}}],[\"如何判断对象可以回收\",{\"0\":{\"515\":1}}],[\"如何动态的去调用被代理类中的同名方法a\",{\"1\":{\"507\":1}}],[\"如何根据加载到内存中的被代理类\",{\"1\":{\"507\":1}}],[\"如何调用静态方法\",{\"1\":{\"502\":1}}],[\"如何在程序中通过代码获取tom这个变量值\",{\"1\":{\"478\":1}}],[\"如何将同一类数据固定的保存在同一个redis实例\",{\"1\":{\"403\":1}}],[\"如何避免这种事故的发生\",{\"0\":{\"330\":1}}],[\"如何避免死锁\",{\"0\":{\"281\":1}}],[\"如何找到组里最小的记录\",{\"1\":{\"243\":1}}],[\"如何为存储的数据建立索引和如何更新\",{\"1\":{\"202\":1}}],[\"如何优化\",{\"0\":{\"198\":1}}],[\"如何提高缓存命中率\",{\"0\":{\"178\":1}}],[\"如何管理脏页\",{\"0\":{\"177\":1}}],[\"如何管理空闲页\",{\"0\":{\"176\":1}}],[\"如何管理\",{\"0\":{\"175\":1}}],[\"如何查看\",{\"1\":{\"139\":1}}],[\"如何验证\",{\"1\":{\"109\":1}}],[\"如何验证证书的真实性\",{\"1\":{\"108\":1}}],[\"如何防止证书被调包\",{\"1\":{\"108\":1}}],[\"如何防止证书被篡改\",{\"1\":{\"108\":1}}],[\"如何解决公钥传输问题呢\",{\"1\":{\"108\":1}}],[\"如何绘制时序图\",{\"0\":{\"82\":1}}],[\"如此下去即可实现千万测试数据的插入\",{\"1\":{\"182\":1}}],[\"如此往复\",{\"1\":{\"149\":2,\"178\":1}}],[\"如此一来由于公钥加密只有私钥能解密\",{\"1\":{\"107\":1}}],[\"如此继续\",{\"1\":{\"53\":1}}],[\"如依赖\",{\"1\":{\"72\":1}}],[\"如定积分求值问题\",{\"1\":{\"58\":1}}],[\"如图1~6歩\",{\"1\":{\"411\":1}}],[\"如图所示\",{\"1\":{\"204\":1}}],[\"如图示\",{\"1\":{\"106\":1}}],[\"如图中有两个以1标志的连接点\",{\"1\":{\"58\":1}}],[\"如图\",{\"1\":{\"56\":1,\"379\":1,\"384\":1,\"385\":1,\"400\":1,\"402\":1,\"407\":1,\"411\":1,\"414\":2,\"452\":1}}],[\"如果b对象不再引用bytebuffer对象\",{\"1\":{\"522\":1}}],[\"如果软引用所引用对象被垃圾回收\",{\"1\":{\"520\":1}}],[\"如果目标对象没有任何引用链相连\",{\"1\":{\"517\":1}}],[\"如果申请内存时\",{\"1\":{\"516\":1}}],[\"如果调用的运行时类中的方法没返回值\",{\"1\":{\"502\":1}}],[\"如果加载过了就不用再加载一遍\",{\"1\":{\"494\":1}}],[\"如果上级的类加载器没有加载\",{\"1\":{\"494\":1}}],[\"如果其父类没有被初始化\",{\"1\":{\"492\":1}}],[\"如果其他事务对持有独占锁的记录进行修改时是会被阻塞的\",{\"1\":{\"329\":1}}],[\"如果其他事务插入的\",{\"1\":{\"291\":1}}],[\"如果您已掌握以下几个问题\",{\"1\":{\"478\":1}}],[\"如果追求hash分布性\",{\"1\":{\"475\":1}}],[\"如果追求效率\",{\"1\":{\"475\":1}}],[\"如果root\",{\"1\":{\"473\":1}}],[\"如果redis缓存未命中\",{\"1\":{\"449\":1}}],[\"如果redis查询未命中\",{\"1\":{\"414\":1}}],[\"如果重新计算后的树元素个数\",{\"1\":{\"473\":1}}],[\"如果数组容量已经\",{\"1\":{\"473\":1}}],[\"如果数据库的引擎支持的事务支持可重复读的隔离级别\",{\"1\":{\"307\":1}}],[\"如果数据库表中的字段只有主键+二级索引\",{\"1\":{\"232\":1}}],[\"如果数据库表中\",{\"1\":{\"222\":1}}],[\"如果数据多了\",{\"1\":{\"186\":1}}],[\"如果数据存在于\",{\"1\":{\"172\":1,\"335\":2}}],[\"如果缓存数据与数据库数据存在较大差异\",{\"1\":{\"455\":1}}],[\"如果缓存时间过长\",{\"1\":{\"454\":1}}],[\"如果所有商品数据都在第一次查询时添加缓存\",{\"1\":{\"448\":1}}],[\"如果能让同一个商品\",{\"1\":{\"445\":1}}],[\"如果能容少量事务的\",{\"1\":{\"343\":1}}],[\"如果未命中\",{\"1\":{\"416\":1}}],[\"如果未命中则查询数据库\",{\"1\":{\"414\":1}}],[\"如果jvm进程缓存未命中\",{\"1\":{\"414\":1}}],[\"如果nginx本地缓存未命中\",{\"1\":{\"414\":1}}],[\"如果大多数sentinel都认为实例主观下线\",{\"1\":{\"394\":1}}],[\"如果超过一定时间没有相向则认为是主观下线\",{\"1\":{\"394\":1}}],[\"如果超过指定值\",{\"1\":{\"393\":1}}],[\"如果超过了这个参数规定的大小\",{\"1\":{\"343\":1}}],[\"如果实在是太多slave\",{\"1\":{\"387\":1}}],[\"如果master故障\",{\"1\":{\"391\":1}}],[\"如果master继续写入新数据\",{\"1\":{\"386\":1}}],[\"如果mysql\",{\"1\":{\"334\":1}}],[\"如果slave\",{\"1\":{\"393\":1}}],[\"如果slave出现网络阻塞\",{\"1\":{\"386\":1}}],[\"如果slave的offset小于master的offset\",{\"1\":{\"384\":1}}],[\"如果至少有1个key被修改\",{\"1\":{\"373\":1}}],[\"如果发现其父类还没有进行初始化\",{\"1\":{\"492\":1}}],[\"如果发现即使在\",{\"1\":{\"331\":1}}],[\"如果发生了读写冲突的时候\",{\"1\":{\"357\":1}}],[\"如果此时事务\",{\"1\":{\"354\":1}}],[\"如果此时有大量该表的\",{\"1\":{\"310\":1}}],[\"如果中途发生发生中断或错误\",{\"1\":{\"351\":1}}],[\"如果想提升\",{\"1\":{\"348\":1}}],[\"如果想关闭查询缓存\",{\"1\":{\"140\":1}}],[\"如果说\",{\"1\":{\"348\":1}}],[\"如果说间隙锁锁住的是一个区间\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"如果任何一位拳击手\",{\"1\":{\"344\":1}}],[\"如果两位拳击手\",{\"1\":{\"344\":1}}],[\"如果两个事务分别向对方持有的间隙锁范围内插入一条记录\",{\"1\":{\"326\":1}}],[\"如果觉得自己准备好了\",{\"1\":{\"344\":1}}],[\"如果出现前后两次查询到的记录数量不一样的情况\",{\"1\":{\"356\":1}}],[\"如果出现前后两次读到的数据不一样的情况\",{\"1\":{\"355\":1}}],[\"如果出现半成功的状态\",{\"1\":{\"344\":1}}],[\"如果出现了错误或者用户执\",{\"1\":{\"334\":1}}],[\"如果走了全表扫描\",{\"1\":{\"329\":1}}],[\"如果可以\",{\"1\":{\"310\":1}}],[\"如果锁定读查询语句\",{\"1\":{\"299\":1}}],[\"如果锁状态是等待状态\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"如果插入\",{\"1\":{\"297\":4}}],[\"如果插入的记录在其他事务持有间隙锁范围内\",{\"1\":{\"326\":1}}],[\"如果插入的新记录的\",{\"1\":{\"296\":1,\"297\":6}}],[\"如果插入的位置的下一条记录的索引上有间隙锁\",{\"1\":{\"296\":1}}],[\"如果存在间隙锁\",{\"1\":{\"296\":1}}],[\"如果存在允许\",{\"1\":{\"162\":1}}],[\"如果事务开启后\",{\"1\":{\"369\":1}}],[\"如果事务的数量提前达到了\",{\"1\":{\"348\":1}}],[\"如果事务\",{\"1\":{\"294\":1,\"297\":1}}],[\"如果条件值的记录不在表中\",{\"1\":{\"294\":1}}],[\"如果条件值的记录存在于表中\",{\"1\":{\"293\":1}}],[\"如果条件不成立\",{\"1\":{\"149\":1}}],[\"如果唯一二级索引列重复\",{\"1\":{\"278\":1}}],[\"如果主键索引重复\",{\"1\":{\"278\":1}}],[\"如果主键声明\",{\"1\":{\"183\":2}}],[\"如果记录的\",{\"1\":{\"358\":5}}],[\"如果记录不在\",{\"1\":{\"343\":1,\"350\":1}}],[\"如果记录之间加有间隙锁\",{\"1\":{\"276\":1}}],[\"如果记录是存在的\",{\"1\":{\"147\":1}}],[\"如果记录是不存在的\",{\"1\":{\"147\":1}}],[\"如果已加间隙锁\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"如果表中最后一个记录的\",{\"1\":{\"275\":2}}],[\"如果表里存在二级索引\",{\"1\":{\"196\":1}}],[\"如果表里有二级索引时\",{\"1\":{\"192\":1,\"193\":1}}],[\"如果表里只有主键索引\",{\"1\":{\"192\":1,\"193\":1}}],[\"如果节点饱和\",{\"1\":{\"255\":1}}],[\"如果叶子节点存储的不是实际数据\",{\"1\":{\"246\":1}}],[\"如果叶子节点存储的是实际数据的就是聚簇索引\",{\"1\":{\"246\":1}}],[\"如果某天赵老板新招了个李秘书\",{\"1\":{\"506\":1}}],[\"如果某sentinel节点发现某实例未在规定时间响应\",{\"1\":{\"392\":1}}],[\"如果某个查询语句使用了二级索引\",{\"1\":{\"245\":1}}],[\"如果某个槽内的记录很多\",{\"1\":{\"243\":1}}],[\"如果某一条记录中的\",{\"1\":{\"191\":1}}],[\"如果字符串是索引列\",{\"1\":{\"241\":1}}],[\"如果字段允许为\",{\"1\":{\"216\":1}}],[\"如果规则是\",{\"1\":{\"238\":2}}],[\"如果索引字段是字符串类型\",{\"1\":{\"238\":1}}],[\"如果索引中存在这些数据\",{\"1\":{\"225\":1}}],[\"如果将\",{\"1\":{\"234\":1}}],[\"如果起不到定位的字段通常是不需要创建索引的\",{\"1\":{\"222\":1}}],[\"如果只用到\",{\"1\":{\"219\":1}}],[\"如果创建了一个\",{\"1\":{\"215\":1,\"239\":1}}],[\"如果要释放全局锁\",{\"1\":{\"307\":1}}],[\"如果要在查询时对记录加行级锁\",{\"1\":{\"283\":1}}],[\"如果要在查询时对记录加行锁\",{\"1\":{\"275\":1,\"313\":1}}],[\"如果要从中找出数字\",{\"1\":{\"249\":1}}],[\"如果要查询的数据在\",{\"1\":{\"234\":1}}],[\"如果要查询的数据都在\",{\"1\":{\"234\":2}}],[\"如果要创建前缀索引\",{\"1\":{\"213\":1}}],[\"如果要创建普通索引\",{\"1\":{\"212\":1}}],[\"如果要创建唯一索引\",{\"1\":{\"211\":1}}],[\"如果要执行\",{\"1\":{\"196\":1}}],[\"如果我用\",{\"1\":{\"206\":1}}],[\"如果我们每次在事务执行过程中\",{\"1\":{\"334\":1}}],[\"如果我们把二叉树改成\",{\"1\":{\"251\":1}}],[\"如果我们仅仅按照第二列搜索\",{\"1\":{\"239\":1}}],[\"如果我们想对学生表\",{\"1\":{\"309\":1}}],[\"如果我们想使用联合索引中尽可能多的列\",{\"1\":{\"239\":1}}],[\"如果我们想提高一条语句查询速度\",{\"1\":{\"233\":1}}],[\"如果我们使用非自增主键\",{\"1\":{\"226\":1}}],[\"如果我们使用自增主键\",{\"1\":{\"226\":1}}],[\"如果我们建表的时候指定了主键或者唯一约束列\",{\"1\":{\"164\":1}}],[\"如果我们输入的\",{\"1\":{\"142\":1}}],[\"如果对数据安全性要求较高\",{\"1\":{\"380\":1}}],[\"如果对\",{\"1\":{\"304\":1,\"318\":1}}],[\"如果对一张大表经常用\",{\"1\":{\"198\":1}}],[\"如果对象的位置在中间部分\",{\"1\":{\"81\":1}}],[\"如果对象位于时序图的顶部\",{\"1\":{\"81\":1}}],[\"如果三个页都在磁盘中\",{\"1\":{\"187\":1}}],[\"如果还有新的记录插入的话\",{\"1\":{\"185\":1}}],[\"如果还是从\",{\"1\":{\"108\":1}}],[\"如果建表的时候\",{\"1\":{\"183\":1}}],[\"如果在老年代这种每次回收都有大量对象存活的区域\",{\"1\":{\"528\":1}}],[\"如果在执行目标方法之前\",{\"1\":{\"507\":1}}],[\"如果在上面这种情况事务\",{\"1\":{\"354\":1}}],[\"如果在这一步完成后数据库崩溃\",{\"1\":{\"348\":2}}],[\"如果在将\",{\"1\":{\"344\":2}}],[\"如果在持久化\",{\"1\":{\"344\":1}}],[\"如果在全库逻辑备份期间\",{\"1\":{\"307\":1}}],[\"如果在插入数据的时候\",{\"1\":{\"279\":1}}],[\"如果在插入新记录时\",{\"1\":{\"278\":1}}],[\"如果在\",{\"1\":{\"228\":1,\"240\":1,\"241\":1}}],[\"如果在很短的时间出现这种现象\",{\"1\":{\"180\":1}}],[\"如果在脏页还没有来得及刷入到磁盘时\",{\"1\":{\"179\":1}}],[\"如果间断出现这种现象\",{\"1\":{\"179\":1}}],[\"如果淘汰的是脏页\",{\"1\":{\"179\":1}}],[\"如果后面用这个备份文件恢复数据库数据的话\",{\"1\":{\"307\":1}}],[\"如果后续的访问时间与第一次访问的时间不在某个时间间隔内\",{\"1\":{\"178\":1}}],[\"如果后续的访问时间与第一次访问的时间在某个时间间隔内\",{\"1\":{\"178\":1}}],[\"如果后端服务器down掉\",{\"1\":{\"41\":1}}],[\"如果符合条件\",{\"1\":{\"178\":1}}],[\"如果符合则发送给客户端\",{\"1\":{\"147\":1}}],[\"如果预读的页一直没有被访问\",{\"1\":{\"178\":1}}],[\"如果使用\",{\"1\":{\"235\":1,\"252\":1}}],[\"如果使用的是\",{\"1\":{\"234\":2}}],[\"如果使用的二进制位个数不足整数个字节\",{\"1\":{\"162\":1}}],[\"如果使用简单的\",{\"1\":{\"178\":1}}],[\"如果访问了\",{\"1\":{\"178\":1}}],[\"如果一样的话就不进行后续更新流程\",{\"1\":{\"343\":1,\"350\":1}}],[\"如果一张表只有一个\",{\"1\":{\"169\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"522\":1}}],[\"如果一个事务\",{\"1\":{\"354\":1}}],[\"如果一个事务获取了\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"如果一个数据页存不了一条记录\",{\"1\":{\"168\":1,\"169\":1}}],[\"如果一个用户已经建立了连接\",{\"1\":{\"139\":1}}],[\"如果有人想想替换系统级别的类\",{\"1\":{\"494\":1}}],[\"如果有新的数据写入\",{\"1\":{\"386\":1}}],[\"如果有就提交事务\",{\"1\":{\"346\":1}}],[\"如果有就意味着表里已经有记录被加了独占锁\",{\"1\":{\"311\":1}}],[\"如果有的话\",{\"1\":{\"317\":1}}],[\"如果有其他线程执行了\",{\"1\":{\"310\":1}}],[\"如果有其他线程要更改该表的结构\",{\"1\":{\"310\":1}}],[\"如果有其他事务在\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"如果有其他事务插入了\",{\"1\":{\"296\":1}}],[\"如果有其他事务插入\",{\"1\":{\"291\":1}}],[\"如果有其他事务\",{\"1\":{\"290\":1}}],[\"如果有间隙锁\",{\"1\":{\"296\":1,\"297\":1}}],[\"如果有主键\",{\"1\":{\"204\":1,\"245\":1}}],[\"如果有多个二级索引的时候\",{\"1\":{\"194\":1}}],[\"如果有多个字段的话\",{\"1\":{\"167\":1,\"169\":1}}],[\"如果有修改\",{\"1\":{\"42\":1}}],[\"如果采用的是\",{\"1\":{\"166\":1}}],[\"如果变长字段允许存储的最大字节数大于\",{\"1\":{\"166\":1}}],[\"如果变长字段允许存储的最大字节数小于等于\",{\"1\":{\"166\":1}}],[\"如果既没有指定主键\",{\"1\":{\"164\":1}}],[\"如果这时候其他事务对这条记录进行删除或者更新操作\",{\"1\":{\"285\":1}}],[\"如果这个实验案例中\",{\"1\":{\"297\":1}}],[\"如果这个锁不可能发生冲突\",{\"1\":{\"276\":1}}],[\"如果这个操作发生在磁盘中呢\",{\"1\":{\"250\":1}}],[\"如果这个脚本检测为真\",{\"1\":{\"43\":1}}],[\"如果这一项为\",{\"1\":{\"228\":1}}],[\"如果这些预读页如果一直不会被访问到\",{\"1\":{\"178\":1}}],[\"如果这样的话\",{\"1\":{\"162\":1}}],[\"如果把查询语句的条件改成\",{\"1\":{\"237\":1}}],[\"如果把这些\",{\"1\":{\"162\":1}}],[\"如果把整个证书内容都加密生成签名的话\",{\"1\":{\"108\":1}}],[\"如果成立\",{\"1\":{\"149\":1}}],[\"如果成立则将其发送给客户端\",{\"1\":{\"149\":2}}],[\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给\",{\"1\":{\"343\":1,\"350\":1}}],[\"如果不小心整个数据库的数据被删除了\",{\"1\":{\"341\":1}}],[\"如果不满足可见行\",{\"1\":{\"334\":1}}],[\"如果不存在间隙锁\",{\"1\":{\"296\":1}}],[\"如果不存在才插入订单记录\",{\"1\":{\"273\":1}}],[\"如果不遵循\",{\"1\":{\"215\":1}}],[\"如果不为\",{\"1\":{\"192\":1}}],[\"如果不想翻倍翻倍的增加数据\",{\"1\":{\"182\":1}}],[\"如果不允许为null\",{\"1\":{\"166\":1}}],[\"如果不是则跳过\",{\"1\":{\"148\":1}}],[\"如果不符合则跳过该记录\",{\"1\":{\"147\":1}}],[\"如果查询失败则继续查询tomcat\",{\"1\":{\"451\":1}}],[\"如果查询条件中对索引字段使用函数\",{\"1\":{\"236\":1}}],[\"如果查询条件不是一个字段\",{\"1\":{\"221\":1}}],[\"如果查询条件是以下这几种\",{\"1\":{\"215\":2,\"239\":2}}],[\"如果查询的数据能在二级索引找到\",{\"1\":{\"246\":1}}],[\"如果查询的数据能在二级索引里查询的到\",{\"1\":{\"208\":1}}],[\"如果查询的数据不在二级索引里\",{\"1\":{\"208\":1,\"246\":1}}],[\"如果查询的语句没有命中查询缓存中\",{\"1\":{\"140\":1}}],[\"如果查询的语句命中查询缓存\",{\"1\":{\"140\":1}}],[\"如果查询语句的执行计划里的\",{\"1\":{\"145\":1}}],[\"如果刚缓存了一个查询结果很大的数据\",{\"1\":{\"140\":1}}],[\"如果长连接累计很多\",{\"1\":{\"139\":1}}],[\"如果空闲连接超过了这个时间\",{\"1\":{\"139\":1}}],[\"如果你想了解\",{\"1\":{\"338\":1}}],[\"如果你想知道当前\",{\"1\":{\"139\":1}}],[\"如果你的业务对于统计个数不需要很精确\",{\"1\":{\"199\":1}}],[\"如果你非要统计表中该字段不为\",{\"1\":{\"196\":1}}],[\"如果你发现\",{\"1\":{\"179\":1,\"180\":1}}],[\"如果你把\",{\"1\":{\"174\":1}}],[\"如果你还不知道\",{\"1\":{\"164\":1}}],[\"如果你熟悉\",{\"1\":{\"164\":1}}],[\"如果你不知道什么是\",{\"1\":{\"161\":1}}],[\"如果你不知道也没关系\",{\"1\":{\"151\":1}}],[\"如果你知道\",{\"1\":{\"151\":1}}],[\"如果你在\",{\"1\":{\"139\":1}}],[\"如果\",{\"1\":{\"139\":2,\"140\":1,\"178\":2,\"192\":1,\"250\":3,\"275\":5,\"276\":1,\"280\":1,\"290\":3,\"291\":1,\"292\":1,\"302\":1,\"304\":4,\"312\":2,\"322\":4,\"330\":1,\"339\":1,\"343\":1,\"346\":3,\"347\":1,\"350\":1,\"363\":1}}],[\"如果命令行中不填写密码\",{\"1\":{\"139\":1}}],[\"如果也忙不过来呢\",{\"1\":{\"109\":1}}],[\"如果用户名和密码都对了\",{\"1\":{\"139\":1}}],[\"如果用户名或密码不对\",{\"1\":{\"139\":2}}],[\"如果用户密码都没有问题\",{\"1\":{\"139\":1}}],[\"如果用的是\",{\"1\":{\"108\":1}}],[\"如果用流程图来表示上述状态图\",{\"1\":{\"85\":1}}],[\"如果客户端收到了真的证书\",{\"1\":{\"108\":1}}],[\"如果客户端收到一个假的证书\",{\"1\":{\"108\":1}}],[\"如果直接传公钥\",{\"1\":{\"107\":1}}],[\"如果通过报文的方式直接传输密钥\",{\"1\":{\"106\":1}}],[\"如果强调上下级关系\",{\"1\":{\"86\":1}}],[\"如果强调时间和顺序\",{\"1\":{\"86\":1}}],[\"如果内部显示了其成员\",{\"1\":{\"73\":1}}],[\"如果是0则永不参与选举\",{\"1\":{\"393\":1}}],[\"如果是save\",{\"1\":{\"373\":1}}],[\"如果是更新操作\",{\"1\":{\"336\":1,\"337\":1}}],[\"如果是全表扫描的话\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1}}],[\"如果是记录锁的话\",{\"1\":{\"280\":1}}],[\"如果是两个订单号一样的请求同时进来\",{\"1\":{\"274\":1}}],[\"如果是查询\",{\"1\":{\"235\":1}}],[\"如果是想精确的获取表的记录总数\",{\"1\":{\"200\":1}}],[\"如果是\",{\"1\":{\"187\":1,\"279\":1,\"291\":1,\"292\":1,\"294\":2,\"402\":1}}],[\"如果是非叶子节点的话\",{\"1\":{\"187\":1}}],[\"如果是叶子节点\",{\"1\":{\"187\":1}}],[\"如果是以页为单位来分配存储空间\",{\"1\":{\"156\":1}}],[\"如果是则将记录发给客户端\",{\"1\":{\"148\":1}}],[\"如果是连接本地的\",{\"1\":{\"139\":1}}],[\"如果是下面这类复杂的\",{\"1\":{\"84\":1}}],[\"如果是接口\",{\"1\":{\"65\":1}}],[\"如果是支持\",{\"1\":{\"48\":1}}],[\"如果框图是正确的而结果不对\",{\"1\":{\"58\":1}}],[\"如果设置3d\",{\"1\":{\"42\":1}}],[\"如果经常更新的文件\",{\"1\":{\"42\":1}}],[\"如果uri包含正则表达式\",{\"1\":{\"39\":1}}],[\"如果匹配成功\",{\"1\":{\"39\":1}}],[\"如果没有就回滚事务\",{\"1\":{\"346\":1}}],[\"如果没有自己还没有准备好\",{\"1\":{\"344\":1}}],[\"如果没有间隙锁则可以插入成功\",{\"1\":{\"297\":1}}],[\"如果没有间隙锁\",{\"1\":{\"296\":1}}],[\"如果没有使用索引\",{\"1\":{\"329\":1}}],[\"如果没有使用\",{\"1\":{\"274\":1}}],[\"如果没有特别的业务需求\",{\"1\":{\"226\":1}}],[\"如果没有主键\",{\"1\":{\"204\":1,\"245\":1}}],[\"如果没有安装\",{\"1\":{\"28\":1}}],[\"如果没有\",{\"1\":{\"26\":1,\"311\":1}}],[\"功能图不要有专业术语\",{\"1\":{\"53\":1}}],[\"功能图\",{\"1\":{\"53\":1}}],[\"功能开发完成后合并入develop分支\",{\"1\":{\"15\":1}}],[\"确保加载的类信息符合jvm规范\",{\"1\":{\"492\":1}}],[\"确保jvm缓存生效\",{\"1\":{\"446\":1}}],[\"确保\",{\"1\":{\"331\":1}}],[\"确保系统已经安装了wget\",{\"1\":{\"28\":1}}],[\"确实还挺复杂的\",{\"1\":{\"282\":1}}],[\"确定了插入位置后\",{\"1\":{\"296\":1}}],[\"确定事务加了什么类型的锁\",{\"1\":{\"280\":2}}],[\"确定事务加了什么锁\",{\"1\":{\"279\":1}}],[\"确定事务\",{\"1\":{\"277\":2}}],[\"确定联系的类型\",{\"1\":{\"91\":1}}],[\"确定实体集的关键字\",{\"1\":{\"91\":1}}],[\"确定实体集之间的联系\",{\"1\":{\"91\":1}}],[\"确定所有的实体集合\",{\"1\":{\"91\":1}}],[\"确定交互过程的上下文\",{\"1\":{\"82\":1}}],[\"确定连接点后则会变成红色实心圆点\",{\"1\":{\"72\":1}}],[\"确定好对象及对象状态\",{\"1\":{\"72\":1}}],[\"确定算法和画流程图\",{\"1\":{\"58\":1}}],[\"确认要转移吗\",{\"1\":{\"408\":1}}],[\"确认对方的真实身份\",{\"1\":{\"104\":1}}],[\"确认登录等操作\",{\"1\":{\"62\":1}}],[\"确认各个环节怎样操作\",{\"1\":{\"53\":1}}],[\"确立所需解决的问题以及最后应达到的要求\",{\"1\":{\"58\":1}}],[\"找到这一行\",{\"1\":{\"333\":1}}],[\"找到所有二分查找中用到的所有中间节点\",{\"1\":{\"250\":1}}],[\"找到主键为\",{\"1\":{\"244\":1}}],[\"找到\",{\"1\":{\"243\":1}}],[\"找到对应的记录\",{\"1\":{\"243\":1}}],[\"找到对应的叶子节点\",{\"1\":{\"206\":1,\"208\":1}}],[\"找到第一个满足条件的主键值\",{\"1\":{\"217\":1}}],[\"找到第二层的索引数据\",{\"1\":{\"205\":1}}],[\"找到后再翻到对应的页\",{\"1\":{\"202\":1}}],[\"找到页号\",{\"1\":{\"187\":2}}],[\"找到nginx配置文件\",{\"1\":{\"38\":1}}],[\"找相关领域专家探讨\",{\"1\":{\"53\":1}}],[\"做路径映射\",{\"1\":{\"435\":1}}],[\"做个实验\",{\"1\":{\"364\":1}}],[\"做一次\",{\"1\":{\"348\":1}}],[\"做一些文档工作或者跟发布相关的任务\",{\"1\":{\"10\":1}}],[\"做了一次组写入\",{\"1\":{\"348\":1}}],[\"做了一些优化\",{\"1\":{\"180\":1}}],[\"做了个改进\",{\"1\":{\"348\":1}}],[\"做了几个实验\",{\"1\":{\"300\":1}}],[\"做法就是在新增订单记录之前\",{\"1\":{\"273\":1}}],[\"做\",{\"1\":{\"180\":1}}],[\"做项目之前要搞清楚业务是怎样流转的\",{\"1\":{\"53\":1}}],[\"任何对原始对象的调用都要通过代理\",{\"1\":{\"505\":1}}],[\"任何人都可以拿到\",{\"1\":{\"107\":1}}],[\"任何图都是可以的\",{\"1\":{\"52\":1}}],[\"任何还处于开发状态的功能只能等待下一个发布周期\",{\"1\":{\"12\":1}}],[\"图片\",{\"1\":{\"182\":2,\"183\":1,\"184\":2,\"185\":2,\"186\":2,\"187\":2,\"189\":1,\"190\":1,\"192\":2,\"193\":2,\"194\":1,\"195\":1,\"197\":1,\"198\":1,\"199\":2,\"230\":1,\"231\":3,\"232\":4,\"233\":1,\"234\":4,\"235\":3,\"236\":2,\"237\":2,\"238\":4,\"239\":1,\"240\":2,\"242\":1,\"243\":4,\"244\":1,\"245\":1,\"249\":1,\"250\":1,\"251\":4,\"252\":2,\"253\":1,\"281\":2,\"351\":2,\"354\":1,\"355\":1,\"356\":1,\"357\":4,\"358\":1}}],[\"图片文件夹\",{\"1\":{\"42\":1}}],[\"图中顺时针\",{\"1\":{\"339\":1}}],[\"图中蓝色部分\",{\"1\":{\"339\":1}}],[\"图中的红色部分\",{\"1\":{\"339\":1}}],[\"图中的\",{\"1\":{\"339\":1,\"343\":2}}],[\"图中的页号只是个示例\",{\"1\":{\"187\":1}}],[\"图中包含大量的动图来帮助大家理解\",{\"1\":{\"247\":1}}],[\"图中绿色部分\",{\"1\":{\"206\":1}}],[\"图中橙色部分\",{\"1\":{\"206\":1}}],[\"图中\",{\"1\":{\"178\":1,\"275\":1,\"290\":1,\"304\":1,\"322\":1}}],[\"图解mysql\",{\"1\":{\"96\":1}}],[\"图以及其他包\",{\"1\":{\"73\":1}}],[\"图是一种用来说明的工具\",{\"1\":{\"52\":1}}],[\"程序计数器是每个线程所私有的\",{\"1\":{\"539\":1}}],[\"程序计数器\",{\"0\":{\"539\":1}}],[\"程序经过javac命令以后\",{\"1\":{\"483\":1}}],[\"程序是有空间局部性的\",{\"1\":{\"178\":1}}],[\"程序调试\",{\"1\":{\"58\":1}}],[\"程序流程图等\",{\"1\":{\"54\":1}}],[\"程序员需要掌握的几种图\",{\"1\":{\"52\":1}}],[\"程序猿常用画图知识及工具\",{\"0\":{\"52\":1}}],[\"作用\",{\"1\":{\"539\":1}}],[\"作为起始点进行搜索\",{\"1\":{\"517\":1}}],[\"作为方法区中类数据的访问入口\",{\"1\":{\"492\":1,\"493\":1}}],[\"作为协调者\",{\"1\":{\"345\":1}}],[\"作为例子\",{\"1\":{\"290\":1}}],[\"作为一个联合索引\",{\"1\":{\"225\":1}}],[\"作为索引的数据结构\",{\"0\":{\"207\":1},\"1\":{\"201\":1,\"234\":1,\"258\":1}}],[\"作为在后端圈开车的多年老司机\",{\"1\":{\"181\":1}}],[\"作为\",{\"1\":{\"178\":1,\"243\":1}}],[\"作为链表的节点\",{\"1\":{\"176\":1}}],[\"作为键的属性取值必须唯一且不能\",{\"1\":{\"89\":1}}],[\"作为管理员不参与任何工作\",{\"1\":{\"44\":1}}],[\"作\",{\"1\":{\"48\":1}}],[\"量\",{\"1\":{\"48\":1}}],[\"大多数情况下\",{\"1\":{\"455\":1}}],[\"大多数的核心功能模块都在这实现\",{\"1\":{\"138\":1}}],[\"大事务\",{\"1\":{\"337\":1}}],[\"大于或者大于等于\",{\"0\":{\"293\":1}}],[\"大于\",{\"1\":{\"252\":1,\"293\":1,\"297\":2}}],[\"大于根节点\",{\"1\":{\"250\":1}}],[\"大于等于\",{\"1\":{\"216\":1,\"292\":1,\"293\":2}}],[\"大概就是\",{\"1\":{\"328\":1}}],[\"大概就像下面这样\",{\"1\":{\"184\":1}}],[\"大概原理是\",{\"1\":{\"239\":1}}],[\"大概应该是\",{\"1\":{\"187\":1}}],[\"大概\",{\"1\":{\"187\":1}}],[\"大约什么时候能用完\",{\"1\":{\"183\":1}}],[\"大量热数据淘汰的问题\",{\"1\":{\"180\":1}}],[\"大部分情况下\",{\"1\":{\"178\":1}}],[\"大致的思想为\",{\"1\":{\"508\":1}}],[\"大致的意思是\",{\"1\":{\"330\":1}}],[\"大致如下图所示\",{\"1\":{\"168\":1}}],[\"大致可以分为以下5步\",{\"1\":{\"91\":1}}],[\"大小150m\",{\"1\":{\"453\":1}}],[\"大小\",{\"1\":{\"161\":1,\"248\":1}}],[\"大家好\",{\"1\":{\"333\":1}}],[\"大家自己也验证下这个结论\",{\"1\":{\"294\":1}}],[\"大家可以把\",{\"1\":{\"357\":1}}],[\"大家可以耐心看下去\",{\"1\":{\"282\":1}}],[\"大家可以看\",{\"1\":{\"251\":1}}],[\"大家背八股文的时候\",{\"1\":{\"242\":1}}],[\"大家肯定都能霹雳啪啦地说出聚簇索引\",{\"1\":{\"203\":1}}],[\"大家肯定第一个先学到的就是\",{\"1\":{\"137\":1}}],[\"大家都知道索引能够加快数据的查询\",{\"1\":{\"185\":1}}],[\"大家都知道\",{\"1\":{\"152\":1,\"184\":1}}],[\"大家想想\",{\"1\":{\"108\":1}}],[\"大雁是鸟的一种\",{\"1\":{\"66\":1}}],[\"大\",{\"1\":{\"48\":1}}],[\"持有的对象\",{\"1\":{\"517\":1}}],[\"持久性是通过\",{\"1\":{\"352\":1}}],[\"持久性是通过redo\",{\"1\":{\"272\":1}}],[\"持久性\",{\"1\":{\"269\":1,\"352\":1,\"361\":1}}],[\"持久化到磁盘\",{\"1\":{\"338\":3,\"348\":1,\"349\":1}}],[\"持久化到磁盘即可\",{\"1\":{\"337\":1}}],[\"持久化\",{\"1\":{\"2\":1,\"97\":1}}],[\"持续更新\",{\"1\":{\"91\":1}}],[\"持\",{\"1\":{\"48\":1}}],[\"支持多种存储引擎\",{\"1\":{\"152\":1,\"243\":1}}],[\"支持索引类型是\",{\"1\":{\"138\":1}}],[\"支持\",{\"1\":{\"138\":1}}],[\"支持网页版\",{\"1\":{\"91\":1}}],[\"支持的最大并发数是多少\",{\"1\":{\"49\":1}}],[\"支持的最大连接数\",{\"1\":{\"32\":1}}],[\"支\",{\"1\":{\"48\":1}}],[\"够\",{\"1\":{\"48\":1}}],[\"说道这里\",{\"1\":{\"507\":1}}],[\"说个前提\",{\"1\":{\"328\":1}}],[\"说个很早之前自己遇到过数据库死锁问题\",{\"1\":{\"273\":1}}],[\"说说意向锁\",{\"1\":{\"311\":1}}],[\"说的是\",{\"1\":{\"255\":1}}],[\"说下查询过程是怎么选择用哪个索引类型的\",{\"1\":{\"234\":1}}],[\"说白了就是如何存储数据\",{\"1\":{\"202\":1}}],[\"说是在解析器做的\",{\"1\":{\"142\":1}}],[\"说明这是一个全新的slave\",{\"1\":{\"384\":1}}],[\"说明slave数据落后于master\",{\"1\":{\"384\":1}}],[\"说明是已经被同步到slave的数据\",{\"1\":{\"386\":1}}],[\"说明是无法进行删除的\",{\"1\":{\"303\":1}}],[\"说明是间隙锁\",{\"1\":{\"290\":1,\"304\":1,\"322\":1}}],[\"说明是记录锁\",{\"1\":{\"290\":1,\"304\":1,\"322\":1}}],[\"说明是\",{\"1\":{\"275\":3,\"290\":1,\"304\":1,\"322\":1}}],[\"说明是通过全表扫描的方式查询数据的\",{\"1\":{\"237\":1}}],[\"说明用上了覆盖索引\",{\"1\":{\"232\":2}}],[\"说明优化器使用了\",{\"1\":{\"216\":3}}],[\"说明\",{\"1\":{\"216\":1,\"238\":1,\"346\":2}}],[\"说明只有\",{\"1\":{\"216\":1}}],[\"说明一下\",{\"1\":{\"204\":1}}],[\"说明左侧节点最小\",{\"1\":{\"187\":1}}],[\"说明我们的推论是正确的\",{\"1\":{\"166\":1}}],[\"说明使用了索引下推\",{\"1\":{\"149\":1}}],[\"说明没有使用索引\",{\"1\":{\"145\":1,\"228\":1}}],[\"说明对象是在交互的过程中被创建的\",{\"1\":{\"81\":1}}],[\"说明在交互开始时对象就已经存在了\",{\"1\":{\"81\":1}}],[\"说到对象图\",{\"1\":{\"68\":1}}],[\"说\",{\"1\":{\"48\":1,\"275\":1}}],[\"来导入该函数库\",{\"1\":{\"442\":1}}],[\"来控制并发事务访问同一个记录时的行为\",{\"1\":{\"361\":1}}],[\"来控制并发事务访问同一个记录时的行为就叫\",{\"1\":{\"358\":1}}],[\"来判断当前版本的记录是否可见\",{\"1\":{\"359\":1}}],[\"来保证的\",{\"1\":{\"352\":2}}],[\"来接收主库的\",{\"1\":{\"342\":1}}],[\"来实现\",{\"1\":{\"340\":1}}],[\"来实现的\",{\"1\":{\"334\":1,\"349\":1,\"361\":1}}],[\"来进行回滚\",{\"1\":{\"334\":1}}],[\"来进一步减少需要扫描的记录数量\",{\"1\":{\"216\":1}}],[\"来执行\",{\"1\":{\"334\":1}}],[\"来锁住记录本身和记录之间的\",{\"1\":{\"329\":1}}],[\"来申请自增\",{\"1\":{\"312\":1}}],[\"来验证\",{\"1\":{\"303\":1}}],[\"来解决\",{\"1\":{\"344\":1}}],[\"来解除死锁状态\",{\"1\":{\"281\":1}}],[\"来解析正则表达式\",{\"1\":{\"26\":1}}],[\"来降低检索的时间复杂度\",{\"1\":{\"244\":1}}],[\"来做统计\",{\"1\":{\"198\":1}}],[\"来统计记录个数\",{\"1\":{\"196\":1}}],[\"来处理\",{\"1\":{\"194\":1}}],[\"来算\",{\"1\":{\"187\":1}}],[\"来划分\",{\"1\":{\"174\":1,\"336\":1}}],[\"来提高数据库的读写性能\",{\"1\":{\"172\":1,\"180\":1,\"335\":1}}],[\"来标记值为\",{\"1\":{\"169\":1}}],[\"来管理的\",{\"1\":{\"155\":1}}],[\"来决定选择使用哪个索引\",{\"1\":{\"145\":1}}],[\"来完成的\",{\"1\":{\"145\":1}}],[\"来完成\",{\"1\":{\"141\":1}}],[\"来签名认证\",{\"1\":{\"109\":3}}],[\"来说说\",{\"1\":{\"306\":1}}],[\"来说\",{\"1\":{\"107\":1}}],[\"来表示联系的类型\",{\"1\":{\"91\":1}}],[\"来\",{\"1\":{\"48\":1,\"349\":1}}],[\"源码中\",{\"1\":{\"474\":1}}],[\"源码里面在扫描记录的时候\",{\"1\":{\"329\":1}}],[\"源码文章\",{\"1\":{\"144\":1}}],[\"源码来证明表或字段是否存在的判断\",{\"1\":{\"144\":1}}],[\"源码\",{\"1\":{\"142\":1,\"146\":1}}],[\"源代码\",{\"1\":{\"76\":1}}],[\"源\",{\"1\":{\"48\":1}}],[\"资源\",{\"1\":{\"516\":1}}],[\"资\",{\"1\":{\"48\":1}}],[\"地\",{\"1\":{\"48\":1}}],[\"地址是指向对应页的指针\",{\"1\":{\"186\":1}}],[\"地址\",{\"1\":{\"28\":1,\"139\":1,\"459\":1,\"492\":1}}],[\"求1+2+3+\",{\"1\":{\"58\":1}}],[\"求\",{\"1\":{\"48\":1}}],[\"请使用代码实现\",{\"1\":{\"478\":1}}],[\"请查看更多感兴趣文章~\",{\"1\":{\"478\":1}}],[\"请添加图片描述\",{\"1\":{\"250\":3}}],[\"请看下图这个神奇的操作\",{\"1\":{\"250\":1}}],[\"请\",{\"1\":{\"48\":1}}],[\"请求方式\",{\"1\":{\"441\":1}}],[\"请求参数处理\",{\"0\":{\"437\":1}}],[\"请求地址是localhost\",{\"1\":{\"434\":1}}],[\"请求进入tomcat后\",{\"1\":{\"414\":1}}],[\"请求到达nginx后\",{\"1\":{\"414\":1}}],[\"请求要经过tomcat处理\",{\"1\":{\"414\":1}}],[\"请求的域名不一致\",{\"1\":{\"108\":1}}],[\"请求的url过滤\",{\"1\":{\"32\":1}}],[\"请求转向\",{\"1\":{\"38\":2}}],[\"请求转向mysvr\",{\"1\":{\"32\":1}}],[\"频繁切换上下文带来的损耗\",{\"1\":{\"47\":1}}],[\"设计模式\",{\"1\":{\"480\":1}}],[\"设计了一个页目录\",{\"1\":{\"246\":1}}],[\"设计\",{\"1\":{\"177\":1}}],[\"设计的初衷就是为了让一个数据页中可以存放更多的行记录\",{\"1\":{\"158\":1}}],[\"设计文档\",{\"1\":{\"76\":1}}],[\"设计图等等\",{\"1\":{\"76\":1}}],[\"设计算法是程序设计的核心\",{\"1\":{\"58\":1}}],[\"设备是不带阴影的立方体\",{\"1\":{\"75\":1}}],[\"设想好一步一步怎样运算或处理\",{\"1\":{\"58\":1}}],[\"设多了会造成\",{\"1\":{\"47\":1}}],[\"设少了会浪费\",{\"1\":{\"47\":1}}],[\"设置指定对象的此属性值\",{\"1\":{\"501\":1}}],[\"设置类变量默认初始值的阶段\",{\"1\":{\"492\":1}}],[\"设置有效期\",{\"1\":{\"456\":1}}],[\"设置缓存为软引用或弱引用\",{\"1\":{\"416\":1}}],[\"设置缓存有效期为\",{\"1\":{\"416\":1}}],[\"设置缓存的有效时间\",{\"1\":{\"416\":1}}],[\"设置缓存的数量上限\",{\"1\":{\"416\":1}}],[\"设置缓存大小上限为\",{\"1\":{\"416\":1}}],[\"设置组提交的两个参数\",{\"1\":{\"349\":1}}],[\"设置的上限是\",{\"1\":{\"339\":1}}],[\"设置为public\",{\"1\":{\"498\":1}}],[\"设置为大于\",{\"1\":{\"349\":1}}],[\"设置为\",{\"1\":{\"281\":1,\"330\":1,\"343\":2,\"349\":1}}],[\"设置为普通索引\",{\"1\":{\"145\":1}}],[\"设置事务等待锁的超时时间\",{\"1\":{\"281\":1}}],[\"设置伪列起始点为\",{\"1\":{\"182\":1}}],[\"设置\",{\"1\":{\"180\":1}}],[\"设置成\",{\"1\":{\"140\":1}}],[\"设置worker数量\",{\"1\":{\"47\":1}}],[\"设置多少个\",{\"0\":{\"47\":1}}],[\"设置默认页\",{\"1\":{\"32\":1,\"38\":2}}],[\"设置一个进程是否同时接受多个网络连接\",{\"1\":{\"32\":1}}],[\"设置网路连接序列化\",{\"1\":{\"32\":1}}],[\"数组容量不是2的n次幂可不可以\",{\"1\":{\"475\":1}}],[\"数组容量为什么必须是2的n次幂\",{\"1\":{\"475\":1}}],[\"数组扩容时\",{\"1\":{\"473\":1}}],[\"数组中每一格就是一个链表\",{\"1\":{\"472\":1}}],[\"数组\",{\"1\":{\"472\":2,\"490\":1}}],[\"数组不能为空\",{\"1\":{\"430\":1}}],[\"数组就是特殊的table\",{\"1\":{\"425\":1}}],[\"数量越大\",{\"1\":{\"220\":1}}],[\"数的层级最多也就是\",{\"1\":{\"187\":1}}],[\"数的层数为\",{\"1\":{\"187\":1}}],[\"数的叶子节点才是存在数据的\",{\"1\":{\"187\":1}}],[\"数学和加密函数等\",{\"1\":{\"138\":1}}],[\"数据同步策略\",{\"0\":{\"456\":1}}],[\"数据key不是与节点绑定\",{\"1\":{\"402\":1}}],[\"数据满足完整性约束\",{\"1\":{\"352\":1}}],[\"数据不就不一致了\",{\"1\":{\"346\":1}}],[\"数据就会发生丢失\",{\"1\":{\"342\":1}}],[\"数据安全性和写入性能是熊掌不可得兼的\",{\"1\":{\"338\":1}}],[\"数据安全性\",{\"1\":{\"338\":1}}],[\"数据也要写磁盘\",{\"1\":{\"337\":1}}],[\"数据也不会丢失\",{\"1\":{\"248\":1}}],[\"数据\",{\"1\":{\"272\":1}}],[\"数据将持久化到数据库\",{\"1\":{\"269\":1}}],[\"数据保持一致\",{\"1\":{\"269\":1}}],[\"数据和最多有\",{\"1\":{\"252\":1}}],[\"数据部分为主键值\",{\"1\":{\"245\":1}}],[\"数据是按照索引第一列排序\",{\"1\":{\"239\":1}}],[\"数据被存放在了\",{\"1\":{\"226\":1}}],[\"数据结构\",{\"1\":{\"203\":1,\"251\":1}}],[\"数据节点\",{\"1\":{\"187\":1}}],[\"数据的读取速度是非常快的\",{\"1\":{\"416\":1}}],[\"数据的场景中\",{\"1\":{\"338\":1}}],[\"数据的查找过程\",{\"1\":{\"185\":1}}],[\"数据的时候\",{\"1\":{\"182\":1}}],[\"数据段\",{\"1\":{\"157\":1}}],[\"数据页里存放了用户的记录以及各种信息\",{\"1\":{\"257\":1}}],[\"数据页内包含用户记录\",{\"1\":{\"246\":1}}],[\"数据页中有一个页目录\",{\"1\":{\"243\":1}}],[\"数据页中的记录按照\",{\"1\":{\"243\":1}}],[\"数据页包括七个部分\",{\"1\":{\"243\":1}}],[\"数据页的主要作用是存储记录\",{\"1\":{\"243\":1}}],[\"数据页的默认大小是\",{\"1\":{\"243\":1}}],[\"数据页的存储空间大致被划分成了\",{\"1\":{\"185\":1}}],[\"数据页的结构这里我就不讲细说了\",{\"1\":{\"155\":1}}],[\"数据页\",{\"1\":{\"155\":2,\"168\":1,\"174\":1,\"186\":1,\"243\":1,\"246\":1,\"336\":1,\"337\":1,\"341\":1}}],[\"数据表中的行记录是用\",{\"1\":{\"155\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"352\":1}}],[\"数据库保持一致性状态\",{\"1\":{\"352\":1}}],[\"数据库中的\",{\"1\":{\"351\":1}}],[\"数据库会自动给主键赋值递增的值\",{\"1\":{\"312\":1}}],[\"数据库会根据主键将其插入到对应的叶子节点中\",{\"1\":{\"226\":1}}],[\"数据库发生文件排序\",{\"1\":{\"219\":1}}],[\"数据库的\",{\"1\":{\"243\":1}}],[\"数据库的索引和数据都是存储在硬盘的\",{\"1\":{\"205\":1}}],[\"数据库的文件存放在哪个目录\",{\"1\":{\"152\":1}}],[\"数据库版本\",{\"1\":{\"187\":1}}],[\"数据库表使用了\",{\"1\":{\"216\":1}}],[\"数据库表中的记录都是按行\",{\"1\":{\"154\":1}}],[\"数据库表\",{\"1\":{\"152\":1,\"364\":1}}],[\"数据库\",{\"1\":{\"152\":1}}],[\"数据一旦被读取\",{\"1\":{\"124\":1}}],[\"数据流程图\",{\"1\":{\"54\":2}}],[\"数字\",{\"1\":{\"238\":2}}],[\"数字签名\",{\"1\":{\"102\":1}}],[\"数字证书\",{\"0\":{\"108\":1},\"1\":{\"102\":1}}],[\"数\",{\"1\":{\"48\":1}}],[\"数相等是最为适宜的\",{\"1\":{\"47\":1}}],[\"数和服务器的\",{\"1\":{\"47\":1}}],[\"都不通过强引用引用该对象\",{\"1\":{\"519\":1}}],[\"都能够调用它的任意一个方法\",{\"1\":{\"481\":1}}],[\"都有了\",{\"1\":{\"474\":1}}],[\"都有可能发生崩溃\",{\"1\":{\"346\":1}}],[\"都配置为\",{\"1\":{\"348\":1}}],[\"都进行了优化\",{\"1\":{\"348\":1}}],[\"都设置为\",{\"1\":{\"347\":1}}],[\"都已经完成了刷盘\",{\"1\":{\"346\":1}}],[\"都处于\",{\"1\":{\"346\":1}}],[\"都回答准备好了\",{\"1\":{\"344\":1}}],[\"都要持久化到磁盘\",{\"1\":{\"344\":1}}],[\"都要进行回表操作\",{\"1\":{\"149\":1}}],[\"都可以恢复\",{\"1\":{\"341\":1}}],[\"都只是缓存在\",{\"1\":{\"338\":1,\"349\":1}}],[\"都将缓存在\",{\"1\":{\"338\":1,\"347\":1}}],[\"都记录下回滚时需要的信息到一个日志里\",{\"1\":{\"334\":1}}],[\"都陷入了等待状态\",{\"1\":{\"320\":1}}],[\"都需要去更新计数器\",{\"1\":{\"516\":1}}],[\"都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"都需要进行动态维护\",{\"1\":{\"220\":1}}],[\"都对应一次磁盘\",{\"1\":{\"250\":1,\"258\":1}}],[\"都知道\",{\"1\":{\"242\":1}}],[\"都支持\",{\"1\":{\"234\":1}}],[\"都使用了主键或唯一索引\",{\"1\":{\"228\":1}}],[\"都是针对索引项这个单位去加锁的\",{\"1\":{\"329\":1}}],[\"都是连续的\",{\"1\":{\"312\":1}}],[\"都是在这些记录的主键索引上\",{\"1\":{\"294\":1}}],[\"都是在这些记录的主键索引上加\",{\"1\":{\"294\":2}}],[\"都是在这些记录的索引上加\",{\"1\":{\"292\":3}}],[\"都是通过多叉树的方式\",{\"1\":{\"258\":1}}],[\"都是追加操作\",{\"1\":{\"226\":1}}],[\"都是\",{\"1\":{\"216\":1,\"357\":1}}],[\"都是先从索引的基本原理\",{\"1\":{\"201\":1}}],[\"都是一个独立的进程\",{\"1\":{\"47\":1}}],[\"都会把旧版本的记录写入到\",{\"1\":{\"358\":1}}],[\"都会重新生成一个\",{\"1\":{\"357\":1}}],[\"都会至少调用\",{\"1\":{\"347\":1}}],[\"都会影响业务\",{\"1\":{\"342\":1}}],[\"都会被记录到\",{\"1\":{\"341\":1}}],[\"都会被阻塞\",{\"1\":{\"299\":1,\"307\":1}}],[\"都会生成一个新的\",{\"1\":{\"334\":1,\"360\":1,\"361\":1}}],[\"都会随着插入的元素增多\",{\"1\":{\"251\":1}}],[\"都会默认将主键索引设置为自增的\",{\"1\":{\"226\":1}}],[\"都会有\",{\"1\":{\"187\":1}}],[\"都会从\",{\"1\":{\"185\":1}}],[\"都会在\",{\"1\":{\"152\":1}}],[\"都会基于连接开始时读到的权限进行权限逻辑的判断\",{\"1\":{\"139\":1}}],[\"都在执行\",{\"1\":{\"320\":1}}],[\"都在等待对方事务的间隙锁释放\",{\"1\":{\"275\":1,\"325\":1,\"326\":1}}],[\"都在\",{\"1\":{\"138\":1}}],[\"都离不来实体关系图\",{\"1\":{\"89\":1}}],[\"都应该先弄清楚图形的概念\",{\"1\":{\"52\":1}}],[\"都采用了\",{\"1\":{\"47\":1}}],[\"类来实现弱引用\",{\"1\":{\"521\":1}}],[\"类来创建软引用\",{\"1\":{\"520\":1}}],[\"类缓存\",{\"1\":{\"493\":1}}],[\"类加载器\",{\"1\":{\"493\":1}}],[\"类加载的过程\",{\"1\":{\"483\":1}}],[\"类构造器是构造类信息的\",{\"1\":{\"492\":1}}],[\"类构造器<clinit>\",{\"1\":{\"492\":1}}],[\"类型和\",{\"1\":{\"228\":1}}],[\"类型表示使用了主键或者唯一索引与常量值进行比较\",{\"1\":{\"228\":1}}],[\"类型表示采用了非唯一索引\",{\"1\":{\"228\":1}}],[\"类型是使用主键或唯一索引时产生的访问方式\",{\"1\":{\"228\":1}}],[\"类型是密码\",{\"1\":{\"43\":1}}],[\"类型转换操作\",{\"1\":{\"228\":1}}],[\"类型且不为\",{\"1\":{\"216\":1}}],[\"类型的间隙锁\",{\"1\":{\"291\":1,\"322\":1,\"323\":1}}],[\"类型的记录锁\",{\"1\":{\"290\":1}}],[\"类型的\",{\"1\":{\"275\":1,\"304\":1}}],[\"类型的意向锁\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":1,\"322\":1}}],[\"类型的列最多可以存储\",{\"1\":{\"168\":1}}],[\"类型的列且字符集是\",{\"1\":{\"166\":1}}],[\"类型的列\",{\"1\":{\"165\":1}}],[\"类型的字段\",{\"1\":{\"161\":1,\"166\":1}}],[\"类型\",{\"1\":{\"70\":1,\"142\":1,\"183\":2}}],[\"类的加载器的分类\",{\"0\":{\"494\":1}}],[\"类的加载器的作用\",{\"0\":{\"493\":1}}],[\"类的加载过程\",{\"0\":{\"492\":1},\"1\":{\"481\":1,\"492\":2,\"494\":1,\"495\":1}}],[\"类的被动引用\",{\"1\":{\"492\":1}}],[\"类的主动引用\",{\"1\":{\"492\":1}}],[\"类的关系\",{\"0\":{\"66\":1}}],[\"类的操作\",{\"1\":{\"65\":1}}],[\"类的特性\",{\"1\":{\"65\":1}}],[\"类名称\",{\"1\":{\"65\":1}}],[\"类是具有相似结构\",{\"1\":{\"65\":1}}],[\"类之间的关系\",{\"1\":{\"64\":1}}],[\"类\",{\"0\":{\"65\":1},\"1\":{\"64\":1,\"73\":1}}],[\"类图和对象图的关系及异同\",{\"0\":{\"69\":1}}],[\"类图中还有一个重要元素\",{\"1\":{\"66\":1}}],[\"类图\",{\"0\":{\"64\":1},\"1\":{\"68\":1,\"69\":1}}],[\"类似java的条件控制\",{\"1\":{\"429\":1}}],[\"类似java的map\",{\"1\":{\"425\":1}}],[\"类似红黑树的旋转操作等\",{\"1\":{\"255\":1}}],[\"类似于问你准备好了吗\",{\"1\":{\"344\":1}}],[\"类似于\",{\"1\":{\"216\":2}}],[\"类似\",{\"1\":{\"47\":1,\"312\":1}}],[\"合适\",{\"0\":{\"47\":1}}],[\"合并一次刷盘\",{\"1\":{\"348\":1}}],[\"合并入master\",{\"1\":{\"15\":2}}],[\"合并入master和develop分支\",{\"1\":{\"10\":1}}],[\"合并入develop\",{\"1\":{\"15\":2}}],[\"合并后即可删除\",{\"1\":{\"15\":1}}],[\"合并后删除自己\",{\"1\":{\"7\":1}}],[\"合并release\",{\"1\":{\"10\":1}}],[\"合并回master和develop分支\",{\"1\":{\"7\":1}}],[\"上述方法的返回值就作为当前类中的invoke\",{\"1\":{\"507\":1}}],[\"上一节中\",{\"1\":{\"437\":1}}],[\"上一秒钟所有事务数据才可能丢失\",{\"1\":{\"338\":1}}],[\"上的所有变化并以二进制形式保存在磁盘上\",{\"1\":{\"342\":1}}],[\"上的所有请求失败\",{\"1\":{\"46\":1}}],[\"上的数据\",{\"1\":{\"341\":1}}],[\"上加了\",{\"1\":{\"304\":1}}],[\"上加范围为\",{\"1\":{\"297\":1}}],[\"上加的是间隙锁\",{\"1\":{\"322\":1}}],[\"上加的是\",{\"1\":{\"275\":1}}],[\"上图就是聚簇索引\",{\"1\":{\"234\":1}}],[\"上图中粉红色字段\",{\"1\":{\"243\":1}}],[\"上图中控制块和缓存页之间灰色部分称为碎片空间\",{\"1\":{\"174\":1}}],[\"上图中的饭卡\",{\"1\":{\"89\":1}}],[\"上找出数据行\",{\"1\":{\"217\":1}}],[\"上面我们都是在说一个数据页中的记录检索\",{\"1\":{\"244\":1}}],[\"上面的结果\",{\"1\":{\"474\":1}}],[\"上面的结果为\",{\"1\":{\"238\":1}}],[\"上面的每个阶段都有一个队列\",{\"1\":{\"348\":1}}],[\"上面的案例是针对唯一二级索引重复而插入失败的场景\",{\"1\":{\"280\":1}}],[\"上面的中间部分是\",{\"1\":{\"144\":1}}],[\"上面这种\",{\"1\":{\"338\":1}}],[\"上面这两条语句必须在一个事务中\",{\"1\":{\"283\":1,\"313\":1}}],[\"上面这些查询语句的条件都用到了索引列\",{\"1\":{\"234\":1}}],[\"上面这些查询条件之所以会失效\",{\"1\":{\"215\":1}}],[\"上面这个两种策略是\",{\"1\":{\"281\":1}}],[\"上面这个过程叫做回表\",{\"1\":{\"234\":1}}],[\"上面这个是\",{\"1\":{\"168\":1}}],[\"上面所说的只是针对于一个字段的计算方式\",{\"1\":{\"166\":1}}],[\"上\",{\"1\":{\"108\":1,\"402\":1}}],[\"上安装\",{\"1\":{\"26\":2}}],[\"了解classloader\",{\"0\":{\"491\":1}}],[\"了另一个\",{\"1\":{\"354\":1}}],[\"了吗\",{\"1\":{\"243\":1}}],[\"了\",{\"1\":{\"46\":1,\"102\":1,\"152\":1,\"156\":2,\"161\":1,\"181\":1,\"306\":1,\"349\":1}}],[\"服务刚刚启动时\",{\"1\":{\"448\":1}}],[\"服务和动态网关\",{\"1\":{\"432\":1}}],[\"服务端是允许多个客户端连接的\",{\"1\":{\"353\":1}}],[\"服务层\",{\"1\":{\"272\":2}}],[\"服务收到\",{\"1\":{\"140\":1}}],[\"服务发送\",{\"1\":{\"140\":1}}],[\"服务异常重启的现象\",{\"1\":{\"139\":1}}],[\"服务占用内存太大\",{\"1\":{\"139\":1}}],[\"服务默认是\",{\"1\":{\"139\":1}}],[\"服务支持的最大连接数由\",{\"1\":{\"139\":1}}],[\"服务就没有再执行过任何命令\",{\"1\":{\"139\":1}}],[\"服务被多少个客户端连接了\",{\"1\":{\"139\":2}}],[\"服务正常运行\",{\"1\":{\"139\":1}}],[\"服务并没有启动\",{\"1\":{\"139\":1}}],[\"服务的\",{\"1\":{\"139\":1}}],[\"服务\",{\"1\":{\"139\":6}}],[\"服务不会中断\",{\"1\":{\"46\":1}}],[\"服务器忽然掉电了\",{\"1\":{\"351\":1}}],[\"服务器通过api和存储引擎进行通信\",{\"1\":{\"272\":1}}],[\"服务器配置\",{\"1\":{\"187\":1}}],[\"服务器权重+2\",{\"1\":{\"43\":1}}],[\"服务器内的应用程序\",{\"1\":{\"34\":1}}],[\"服务器整体运行的配置指令\",{\"1\":{\"32\":1}}],[\"进而完成对其它数据库的同步\",{\"1\":{\"458\":1}}],[\"进而提升写\",{\"1\":{\"337\":1}}],[\"进入阻塞状态\",{\"1\":{\"280\":1}}],[\"进入到\",{\"1\":{\"178\":1}}],[\"进一步节省查询需要的时间\",{\"1\":{\"256\":1}}],[\"进行测试\",{\"1\":{\"507\":1}}],[\"进行组提交\",{\"1\":{\"348\":1}}],[\"进行了等值查询\",{\"1\":{\"296\":1,\"297\":1}}],[\"进行数据恢复使用\",{\"1\":{\"272\":1}}],[\"进行连接\",{\"1\":{\"257\":1}}],[\"进行比较\",{\"1\":{\"252\":1}}],[\"进行执行计划查看的时候\",{\"1\":{\"228\":1}}],[\"进行全表扫描\",{\"1\":{\"218\":1,\"222\":1}}],[\"进行范围查询\",{\"1\":{\"216\":3}}],[\"进行排序\",{\"1\":{\"215\":1}}],[\"进行模糊匹配\",{\"1\":{\"178\":1}}],[\"进行模型瘦身和深度优化\",{\"1\":{\"99\":1}}],[\"进行存放的\",{\"1\":{\"154\":1}}],[\"进行查询\",{\"1\":{\"147\":1,\"148\":1}}],[\"进行属性描述\",{\"1\":{\"89\":1}}],[\"进行反向代理配置\",{\"1\":{\"38\":1}}],[\"进程本地缓存\",{\"1\":{\"416\":1}}],[\"进程中途挂了\",{\"1\":{\"349\":1}}],[\"进程调度的方式\",{\"1\":{\"135\":1}}],[\"进程调度的时机\",{\"0\":{\"135\":1}}],[\"进程间的数据交换是以格式化的消息为单位的\",{\"1\":{\"123\":1}}],[\"进程是分配系统资源的单位\",{\"1\":{\"120\":1}}],[\"进程通信\",{\"0\":{\"119\":1}}],[\"进程控制用的程序段称为原语\",{\"1\":{\"117\":1}}],[\"进程控制用原语实现\",{\"1\":{\"117\":1}}],[\"进程控制就是要实现进程状态的转换\",{\"1\":{\"117\":1}}],[\"进程控制\",{\"0\":{\"116\":1}}],[\"进程的崩溃并不会丢失数据\",{\"1\":{\"338\":1}}],[\"进程的崩溃会导致上一秒钟所有事务数据的丢失\",{\"1\":{\"338\":1}}],[\"进程的切换\",{\"1\":{\"118\":1}}],[\"进程的唤醒\",{\"1\":{\"118\":1}}],[\"进程的阻塞\",{\"1\":{\"118\":1}}],[\"进程的终止\",{\"1\":{\"118\":1}}],[\"进程的创建\",{\"1\":{\"118\":1}}],[\"进程的组织\",{\"0\":{\"115\":1}}],[\"进程的状态与转换\",{\"0\":{\"115\":1}}],[\"进程的概念\",{\"0\":{\"114\":1}}],[\"进程的异常退出\",{\"1\":{\"46\":1}}],[\"进程与线程\",{\"0\":{\"113\":1}}],[\"进程所能建立连接的最大值\",{\"1\":{\"48\":1}}],[\"进程\",{\"1\":{\"46\":1}}],[\"进程则很快启动新的worker\",{\"1\":{\"46\":1}}],[\"进程来说\",{\"1\":{\"46\":1}}],[\"本地方法栈中jni\",{\"1\":{\"517\":1}}],[\"本地缓存查询失败\",{\"1\":{\"454\":2}}],[\"本地缓存\",{\"1\":{\"454\":2}}],[\"本地缓存api\",{\"0\":{\"453\":1}}],[\"本应去缓存中查询商品信息\",{\"1\":{\"440\":1}}],[\"本身\",{\"1\":{\"359\":1}}],[\"本身就是唯一的\",{\"1\":{\"183\":1}}],[\"本身是不直接支持\",{\"1\":{\"45\":1}}],[\"本次的例子加的是\",{\"1\":{\"277\":1}}],[\"本次案例使用存储引擎\",{\"1\":{\"274\":1}}],[\"本次案例中\",{\"1\":{\"166\":2,\"325\":1}}],[\"本次例子中\",{\"1\":{\"216\":1}}],[\"本次查询没有其他条件\",{\"1\":{\"149\":1}}],[\"本文参考文章或视频\",{\"1\":{\"508\":1}}],[\"本文参考和转载文章\",{\"1\":{\"4\":1,\"52\":1}}],[\"本文主要以\",{\"1\":{\"152\":1}}],[\"本文转自知乎\",{\"1\":{\"110\":1}}],[\"本文大纲如下\",{\"1\":{\"102\":1}}],[\"本文基于黑马的教程与其他文章进行整理\",{\"1\":{\"97\":1}}],[\"本\",{\"1\":{\"48\":1}}],[\"访问table\",{\"1\":{\"425\":1}}],[\"访问数组\",{\"1\":{\"425\":1}}],[\"访问数据库等\",{\"1\":{\"45\":1}}],[\"访问的时候与java中类似\",{\"1\":{\"425\":1}}],[\"访问缓存有网络开销\",{\"1\":{\"416\":1}}],[\"访问服务端\",{\"1\":{\"414\":1}}],[\"访问非静态资源\",{\"1\":{\"414\":1}}],[\"访问共享内存\",{\"1\":{\"374\":1}}],[\"访问每个节点\",{\"1\":{\"250\":1,\"258\":1}}],[\"访问方式\",{\"1\":{\"228\":1}}],[\"访问了\",{\"1\":{\"178\":1}}],[\"访问http\",{\"1\":{\"39\":2}}],[\"会直接覆盖这段内存\",{\"1\":{\"527\":1}}],[\"会引发内存泄漏\",{\"1\":{\"516\":1}}],[\"会引发脏读\",{\"1\":{\"361\":1}}],[\"会生成一个或者多个字节码文件\",{\"1\":{\"483\":1}}],[\"会生成一个插入意向锁\",{\"1\":{\"317\":1,\"326\":1,\"365\":1}}],[\"会重新计算索引位置\",{\"1\":{\"473\":1}}],[\"会重新创建\",{\"1\":{\"360\":1}}],[\"会通知canal的客户端\",{\"1\":{\"459\":1}}],[\"会查询数据库\",{\"1\":{\"445\":1}}],[\"会不断检查您的master和slave是否按预期工作\",{\"1\":{\"391\":1}}],[\"会再次从0开始读写\",{\"1\":{\"386\":1}}],[\"会执行全量同步\",{\"1\":{\"384\":1}}],[\"会创建一个\",{\"1\":{\"364\":1}}],[\"会发现这条记录的\",{\"1\":{\"360\":1}}],[\"会看这条记录的\",{\"1\":{\"360\":1}}],[\"会看一下更新前的记录和更新后的记录是否一样\",{\"1\":{\"343\":1,\"350\":1}}],[\"会记录相应的\",{\"1\":{\"359\":1}}],[\"会缓存在\",{\"1\":{\"347\":2}}],[\"会的\",{\"1\":{\"346\":1}}],[\"会同时维护\",{\"1\":{\"345\":1}}],[\"会宣布比赛暂停\",{\"1\":{\"344\":1}}],[\"会依次询问两位拳击手\",{\"1\":{\"344\":1}}],[\"会包含提交\",{\"1\":{\"344\":1}}],[\"会写到\",{\"1\":{\"343\":1}}],[\"会写入\",{\"1\":{\"336\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"会切换回\",{\"1\":{\"339\":1}}],[\"会切换至\",{\"1\":{\"339\":1}}],[\"会触发落盘\",{\"1\":{\"338\":1}}],[\"会隐式开启事务\",{\"1\":{\"334\":1}}],[\"会出现同时处理多个事务的情况\",{\"1\":{\"353\":1}}],[\"会出现幻读的问题\",{\"1\":{\"329\":1}}],[\"会出现一些用时稍长的\",{\"1\":{\"179\":1,\"180\":1}}],[\"会加一个表级别的\",{\"1\":{\"312\":1}}],[\"会加上\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"会阻塞后续该表的所有\",{\"1\":{\"310\":1}}],[\"会影响插入性能\",{\"1\":{\"312\":1}}],[\"会影响并发性能\",{\"1\":{\"309\":1}}],[\"会影响整体数据查询的效率\",{\"1\":{\"251\":1}}],[\"会释放当前会话的所有表锁\",{\"1\":{\"309\":1}}],[\"会在重启后回滚该组事务\",{\"1\":{\"348\":1}}],[\"会在中间确认两位拳击手的状态\",{\"1\":{\"344\":1}}],[\"会在后面说\",{\"1\":{\"296\":1,\"297\":2}}],[\"会在插入间隙上获取插入意向锁\",{\"1\":{\"275\":1}}],[\"会因为主键冲突\",{\"1\":{\"290\":1}}],[\"会\",{\"1\":{\"289\":1,\"300\":1}}],[\"会退化成记录锁或者间隙锁\",{\"1\":{\"292\":1}}],[\"会退化成记录锁\",{\"1\":{\"290\":1}}],[\"会退化成\",{\"1\":{\"289\":1,\"291\":1,\"300\":1}}],[\"会变\",{\"1\":{\"280\":1}}],[\"会显示\",{\"1\":{\"279\":1,\"280\":1}}],[\"会比\",{\"1\":{\"254\":1}}],[\"会使得查询操作的时间复杂度从\",{\"1\":{\"250\":1}}],[\"会走索引\",{\"1\":{\"239\":1}}],[\"会自动的调用被代理类中同名的方法\",{\"1\":{\"507\":1}}],[\"会自动给这个表加上\",{\"1\":{\"310\":1}}],[\"会自动把字符串转为数字\",{\"1\":{\"238\":1,\"241\":1}}],[\"会自顶向下逐层进行查找\",{\"1\":{\"205\":1}}],[\"会用一个特殊的记录来标识最后一条记录\",{\"1\":{\"293\":1,\"298\":1}}],[\"会用\",{\"1\":{\"227\":1}}],[\"会导致磁盘的\",{\"1\":{\"343\":1}}],[\"会导致它变成一个瘸子\",{\"1\":{\"250\":1}}],[\"会导致更多的存储空间占用\",{\"1\":{\"227\":1}}],[\"会导致当前\",{\"1\":{\"46\":1}}],[\"会省略值为null\",{\"1\":{\"227\":1}}],[\"会降低表的增删改的效率\",{\"1\":{\"220\":1}}],[\"会先将终结器引用对象放入引用队列中\",{\"1\":{\"523\":1}}],[\"会先更新内存\",{\"1\":{\"343\":1,\"350\":1}}],[\"会先写入\",{\"1\":{\"342\":1}}],[\"会先写入到\",{\"1\":{\"337\":1}}],[\"会先记录更新前的数据到\",{\"1\":{\"334\":1}}],[\"会先创建\",{\"1\":{\"307\":1}}],[\"会先检查二级索引中的\",{\"1\":{\"206\":1}}],[\"会先对\",{\"1\":{\"141\":1}}],[\"会采用全表扫描的方式来统计\",{\"1\":{\"196\":1}}],[\"会采用全表扫描的方式来计数\",{\"1\":{\"195\":1}}],[\"会对数据库产生冲击\",{\"1\":{\"414\":1}}],[\"会对记录加上读写锁\",{\"1\":{\"357\":1}}],[\"会对每一个索引加\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1}}],[\"会对每一个扫描到的索引加\",{\"1\":{\"292\":1}}],[\"会对该二级索引记录加的是范围为\",{\"1\":{\"298\":1}}],[\"会对该主键索引加的是范围为\",{\"1\":{\"293\":1}}],[\"会对查询出来的结果进行去重处理\",{\"1\":{\"261\":1}}],[\"会对\",{\"1\":{\"194\":1}}],[\"会读取所有表中的字段\",{\"1\":{\"189\":1}}],[\"会读取该用户的权限\",{\"1\":{\"139\":1}}],[\"会有一些固定的信息\",{\"1\":{\"188\":1}}],[\"会将最新信息推送给redis的客户端\",{\"1\":{\"391\":1}}],[\"会将多个\",{\"1\":{\"348\":1}}],[\"会将这两个参数设置为\",{\"1\":{\"347\":1}}],[\"会将该事物执行过程中产生的所有\",{\"1\":{\"340\":1}}],[\"会将树的高度变矮\",{\"1\":{\"258\":1}}],[\"会将自动\",{\"1\":{\"238\":2}}],[\"会将\",{\"1\":{\"194\":1}}],[\"会将表的索引装载到内存中\",{\"1\":{\"187\":1}}],[\"会将请求经由\",{\"1\":{\"45\":1}}],[\"会报错\",{\"1\":{\"182\":1}}],[\"会主动触发脏页刷新到磁盘\",{\"1\":{\"179\":1}}],[\"会被回滚到事务开始前的状态\",{\"1\":{\"352\":1}}],[\"会被持久化到磁盘吗\",{\"1\":{\"346\":1}}],[\"会被复制到从库\",{\"1\":{\"344\":2}}],[\"会被保存到\",{\"1\":{\"343\":1,\"350\":1}}],[\"会被阻塞\",{\"1\":{\"339\":1}}],[\"会被逐一插入到\",{\"1\":{\"178\":1}}],[\"会被挤到\",{\"1\":{\"178\":1}}],[\"会被淘汰掉\",{\"1\":{\"178\":1}}],[\"会提前把它相邻的数据页一并加载进来\",{\"1\":{\"178\":1}}],[\"会为被\",{\"1\":{\"312\":1}}],[\"会为\",{\"1\":{\"174\":1,\"290\":1,\"336\":1}}],[\"会把缓存在\",{\"1\":{\"338\":1}}],[\"会把所有的脏页刷入到磁盘\",{\"1\":{\"179\":1}}],[\"会把存储的数据划分为若干个\",{\"1\":{\"174\":1,\"336\":1}}],[\"会把内容很长的明文压缩成小得多的定长字符串\",{\"1\":{\"108\":1}}],[\"会调用存储引擎的接口\",{\"1\":{\"343\":1,\"350\":1}}],[\"会调用\",{\"1\":{\"147\":1,\"148\":2}}],[\"会选择查询代价小的普通索引\",{\"1\":{\"145\":1}}],[\"会根据事务的\",{\"1\":{\"334\":1}}],[\"会根据不同的场景选择不同的列作为索引\",{\"1\":{\"245\":1}}],[\"会根据你输入的字符串识别出关键字出来\",{\"1\":{\"142\":1}}],[\"会根据这些信息生成证书\",{\"1\":{\"108\":1}}],[\"会认定为不通过\",{\"1\":{\"108\":1}}],[\"会占用两个连接\",{\"1\":{\"48\":1}}],[\"会合并到\",{\"1\":{\"7\":1}}],[\"多事务\",{\"1\":{\"347\":1}}],[\"多版本并发控制\",{\"1\":{\"283\":1,\"334\":3,\"352\":1,\"358\":1,\"361\":1,\"364\":1}}],[\"多字\",{\"1\":{\"282\":1}}],[\"多字段的情况\",{\"0\":{\"167\":1}}],[\"多的数据就会存到另外的\",{\"1\":{\"168\":1}}],[\"多的一方写n\",{\"1\":{\"90\":1}}],[\"多对多模型\",{\"1\":{\"131\":1}}],[\"多对多联系\",{\"1\":{\"89\":1}}],[\"多对一模型\",{\"1\":{\"131\":1}}],[\"多线程模型\",{\"0\":{\"131\":1}}],[\"多设备\",{\"1\":{\"91\":1}}],[\"多平台支持\",{\"1\":{\"91\":2}}],[\"多\",{\"1\":{\"91\":1}}],[\"多路复用机制\",{\"1\":{\"47\":1}}],[\"多个事务的\",{\"1\":{\"348\":1}}],[\"多个事务按进入的顺序将\",{\"1\":{\"348\":1}}],[\"多个\",{\"1\":{\"45\":1}}],[\"多级缓存的实现离不开nginx编程\",{\"1\":{\"431\":1}}],[\"多级缓存的关键有两个\",{\"1\":{\"414\":1}}],[\"多级缓存就是充分利用请求处理的每个环节\",{\"1\":{\"414\":1}}],[\"多级缓存\",{\"0\":{\"413\":1},\"1\":{\"2\":1,\"97\":1}}],[\"只负责查询余额\",{\"1\":{\"357\":1}}],[\"只负责给多个\",{\"1\":{\"44\":1}}],[\"只说两阶段提交\",{\"1\":{\"350\":1}}],[\"只针对\",{\"1\":{\"348\":1}}],[\"只记录未被刷入磁盘的数据的物理日志\",{\"1\":{\"341\":1}}],[\"只会和共享表锁\",{\"1\":{\"311\":1}}],[\"只在二级索引索引\",{\"1\":{\"297\":1}}],[\"只在二级索引索引上加范围为\",{\"1\":{\"297\":1}}],[\"只在叶子节点存储数据\",{\"1\":{\"207\":1}}],[\"只存在于可重复读隔离级别\",{\"1\":{\"286\":1,\"315\":1}}],[\"只存储\",{\"1\":{\"168\":1,\"169\":1}}],[\"只返回两个表中连接字段相等的行\",{\"1\":{\"263\":1}}],[\"只需要发送一条消息到mq中\",{\"1\":{\"456\":1}}],[\"只需要调整在连接查询时sql中\",{\"1\":{\"264\":1}}],[\"只需要扩大一下设置参数即可\",{\"1\":{\"182\":1}}],[\"只需将查找的数据与节点的数据进行比较\",{\"1\":{\"250\":1}}],[\"只检索给定范围的行\",{\"1\":{\"228\":1}}],[\"只不过数组是环形\",{\"1\":{\"386\":1}}],[\"只不过\",{\"1\":{\"228\":1}}],[\"只不过我们在这里只是简单画了三个节点\",{\"1\":{\"186\":1}}],[\"只维护一个\",{\"1\":{\"197\":1}}],[\"只听过\",{\"1\":{\"181\":1}}],[\"只有内存不够的时候才会回收\",{\"1\":{\"520\":1}}],[\"只有所有\",{\"1\":{\"519\":1}}],[\"只有能够被根对象集合直接或者间接连接的对象才是存活对象\",{\"1\":{\"517\":1}}],[\"只有真正声明这个域的类才会被初始化\",{\"1\":{\"492\":1}}],[\"只有2的幂次方在减1的时候\",{\"1\":{\"475\":1}}],[\"只有满足查询条件的记录才会对它们的主键索引加锁\",{\"1\":{\"295\":1}}],[\"只有这些数据\",{\"1\":{\"277\":1,\"280\":1}}],[\"只有当执行完一条\",{\"1\":{\"312\":1}}],[\"只有当锁状态为正常状态时\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"只有当没有二级索引的时候\",{\"1\":{\"194\":1}}],[\"只有叶子节点\",{\"1\":{\"244\":1}}],[\"只有两个字段\",{\"1\":{\"232\":1}}],[\"只有男女\",{\"1\":{\"222\":1}}],[\"只有在数据迁移时可能用到\",{\"1\":{\"373\":1}}],[\"只有在执行这个命令后\",{\"1\":{\"357\":1}}],[\"只有在操作系统崩溃或者系统断电的情况下\",{\"1\":{\"338\":1}}],[\"只有在事务\",{\"1\":{\"304\":1}}],[\"只有在特殊情况下\",{\"1\":{\"276\":1}}],[\"只有在\",{\"1\":{\"215\":1}}],[\"只有后面的\",{\"1\":{\"178\":1}}],[\"只有同时满足\",{\"1\":{\"178\":1}}],[\"只有\",{\"1\":{\"173\":1,\"217\":1}}],[\"只有再新建的连接才会使用新的权限设置\",{\"1\":{\"139\":1}}],[\"只是影响到该对象\",{\"1\":{\"516\":1}}],[\"只是很大程度上避免了幻读现象的发生\",{\"1\":{\"369\":1}}],[\"只是将这个记录的\",{\"1\":{\"163\":1}}],[\"只是知识的搬运工\",{\"1\":{\"1\":1}}],[\"只出现在数据表有变长字段的时候\",{\"1\":{\"161\":1}}],[\"只能做全量同步\",{\"1\":{\"386\":1}}],[\"只能看见启动事务时的数据\",{\"1\":{\"357\":1}}],[\"只能使用\",{\"1\":{\"341\":1}}],[\"只能防止删除或者修改\",{\"1\":{\"298\":1}}],[\"只能通过把索引字段的取值都取出来\",{\"1\":{\"237\":1}}],[\"只能根据前缀进行比较\",{\"1\":{\"235\":1}}],[\"只能从\",{\"1\":{\"217\":1}}],[\"只能处理一行数据\",{\"1\":{\"155\":1,\"243\":1}}],[\"只能自己证明自己了\",{\"1\":{\"109\":1}}],[\"只要id不变\",{\"1\":{\"446\":1}}],[\"只要我们调用ngx\",{\"1\":{\"442\":1}}],[\"只要我们提高进入到\",{\"1\":{\"178\":1}}],[\"只要系统没有宕机\",{\"1\":{\"349\":1}}],[\"只要系统发生死锁\",{\"1\":{\"281\":1}}],[\"只要数据成功复制到任意一个从库上\",{\"1\":{\"342\":1}}],[\"只要一部分复制成功响应回来就行\",{\"1\":{\"342\":1}}],[\"只要操作系统不宕机\",{\"1\":{\"338\":1}}],[\"只要先将\",{\"1\":{\"337\":1}}],[\"只要\",{\"1\":{\"302\":1,\"363\":1}}],[\"只要保证前后两次查询\",{\"1\":{\"291\":1}}],[\"只要有条件列不是索引列\",{\"1\":{\"240\":1}}],[\"只要内容不同\",{\"1\":{\"108\":1}}],[\"只要把对称加密的密钥加密传给\",{\"1\":{\"107\":1}}],[\"只支持windows\",{\"1\":{\"91\":1}}],[\"一定会发生类的初始化\",{\"1\":{\"492\":1}}],[\"一定要检查语句是否走了索引\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1}}],[\"一定要掌握\",{\"1\":{\"164\":1}}],[\"一共分为3步\",{\"1\":{\"474\":1}}],[\"一\",{\"0\":{\"371\":1,\"414\":1,\"479\":1}}],[\"一是性能很差\",{\"1\":{\"342\":1}}],[\"一次是\",{\"1\":{\"347\":3}}],[\"一次\",{\"1\":{\"339\":1}}],[\"一次最少把内存中的\",{\"1\":{\"155\":1,\"243\":1}}],[\"一次最少从磁盘中读取\",{\"1\":{\"155\":1,\"243\":1}}],[\"一起使用的时候\",{\"1\":{\"312\":1}}],[\"一旦启动gc\",{\"1\":{\"527\":1}}],[\"一旦导致无法分配对象\",{\"1\":{\"527\":1}}],[\"一旦发现master故障\",{\"1\":{\"393\":1}}],[\"一旦出现\",{\"1\":{\"310\":1}}],[\"一旦创建了这个分支并把它推向中央仓库\",{\"1\":{\"12\":1}}],[\"一只小铭\",{\"1\":{\"300\":1}}],[\"一只大雁脱离了雁群\",{\"1\":{\"66\":1}}],[\"一会又是记录锁\",{\"1\":{\"282\":1}}],[\"一会加是间隙锁\",{\"1\":{\"282\":1}}],[\"一致性则是通过持久性+原子性+隔离性来保证\",{\"1\":{\"352\":1}}],[\"一致性就是要求上述步骤操作后\",{\"1\":{\"352\":1}}],[\"一致性\",{\"1\":{\"269\":1,\"272\":1,\"352\":1,\"361\":1}}],[\"一棵\",{\"1\":{\"252\":1}}],[\"一张表只能有一个聚簇索引\",{\"1\":{\"245\":1}}],[\"一张表可以有多个唯一索引\",{\"1\":{\"211\":1}}],[\"一张表最多只有一个主键索引\",{\"1\":{\"210\":1}}],[\"一些大对象如\",{\"1\":{\"168\":1}}],[\"一些精彩的流程图\",{\"1\":{\"91\":1}}],[\"一条更新语句执行完成\",{\"1\":{\"350\":1}}],[\"一条记录更新完了\",{\"1\":{\"343\":1,\"350\":1}}],[\"一条记录的每一次更新操作产生的\",{\"1\":{\"334\":1}}],[\"一条记录的过程\",{\"1\":{\"333\":1}}],[\"一条记录时\",{\"1\":{\"334\":1}}],[\"一条记录有\",{\"1\":{\"162\":1}}],[\"一条\",{\"1\":{\"230\":1}}],[\"一条完整的记录分为\",{\"1\":{\"159\":1}}],[\"一行记录最大能存储\",{\"1\":{\"169\":1}}],[\"一行记录最大只能存储\",{\"1\":{\"166\":1}}],[\"一行记录除了\",{\"1\":{\"165\":1}}],[\"一行记录的存储结构\",{\"1\":{\"151\":2}}],[\"一行记录是怎么存储的\",{\"0\":{\"151\":1},\"1\":{\"151\":1}}],[\"一直访问同一个tomcat服务\",{\"1\":{\"446\":1}}],[\"一直到\",{\"1\":{\"347\":1}}],[\"一直跟这个事务启动时看到的数据是一致的\",{\"1\":{\"302\":1,\"357\":2,\"361\":1,\"362\":1}}],[\"一直重复上述过程\",{\"1\":{\"148\":1}}],[\"一直加到100\",{\"1\":{\"58\":1}}],[\"一树一溪\",{\"1\":{\"144\":1}}],[\"一样也是在插入数据的时候\",{\"1\":{\"312\":1}}],[\"一样\",{\"1\":{\"139\":1}}],[\"一图胜千言\",{\"1\":{\"108\":1}}],[\"一把作为私钥\",{\"1\":{\"107\":1}}],[\"一把作为公钥\",{\"1\":{\"107\":1}}],[\"一种是通信双方使用同一把密钥\",{\"1\":{\"106\":1}}],[\"一种类与接口的关系\",{\"1\":{\"66\":1}}],[\"一对一模型\",{\"1\":{\"131\":1}}],[\"一对一联系\",{\"1\":{\"89\":1}}],[\"一对多联系\",{\"1\":{\"89\":1}}],[\"一栏代表一个职能单位\",{\"1\":{\"58\":1}}],[\"一般我们为了避免日志丢失的风险\",{\"1\":{\"347\":1}}],[\"一般我们认为安全的通信需要包括以下四个原则\",{\"1\":{\"104\":1}}],[\"一般会\",{\"1\":{\"343\":1}}],[\"一般购买商品的业务逻辑是会涉及到多张数据库表的更新\",{\"1\":{\"307\":1}}],[\"一般由==重做日志缓冲\",{\"1\":{\"272\":1}}],[\"一般在\",{\"1\":{\"228\":1}}],[\"一般\",{\"1\":{\"187\":1}}],[\"一般还没有到这个限制之前\",{\"1\":{\"183\":1}}],[\"一般建议设置成可用物理内存的\",{\"1\":{\"173\":1}}],[\"一般来说\",{\"1\":{\"108\":1}}],[\"一般使用矩形表示\",{\"1\":{\"81\":1}}],[\"一般用立方体表示\",{\"1\":{\"75\":1}}],[\"一般就会使用对象图\",{\"1\":{\"68\":1}}],[\"一般是类的方法或行为\",{\"1\":{\"65\":1}}],[\"一般是类的字段和属性\",{\"1\":{\"65\":1}}],[\"一般情况下分析程序中的方法用流程图更好\",{\"1\":{\"84\":1}}],[\"一般情况下\",{\"1\":{\"58\":1}}],[\"一般情况下产品或系统的总功能可分解为若干分功能\",{\"1\":{\"53\":1}}],[\"一般说\",{\"1\":{\"58\":1}}],[\"一般软件生命周期中需要画图的地方\",{\"0\":{\"53\":1}}],[\"一般有多个\",{\"1\":{\"44\":1}}],[\"一个对象是否有虚引用的存在\",{\"1\":{\"522\":1}}],[\"一个对象图是类图的一个实例\",{\"1\":{\"68\":1}}],[\"一个新对象的方式来创建强引用\",{\"1\":{\"519\":1}}],[\"一个公司前台就完美解决了这个问题\",{\"1\":{\"507\":1}}],[\"一个class对象对应的是一个加载到jvm中的一个\",{\"1\":{\"483\":1}}],[\"一个加载的类在\",{\"1\":{\"483\":1}}],[\"一个类只有一个class对象\",{\"1\":{\"480\":1}}],[\"一个记录\",{\"1\":{\"365\":1}}],[\"一个主库一般跟\",{\"1\":{\"342\":1}}],[\"一个是在nginx中编写业务\",{\"1\":{\"414\":1}}],[\"一个是非唯一索引\",{\"1\":{\"295\":1}}],[\"一个是主键索引\",{\"1\":{\"232\":1,\"295\":1}}],[\"一个拥有间隙锁\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"一个事务去访问记录的时候\",{\"1\":{\"358\":1}}],[\"一个事务中的所有操作\",{\"1\":{\"352\":1}}],[\"一个事务在执行过程中\",{\"1\":{\"334\":1}}],[\"一个事务在插入一条记录的时候\",{\"1\":{\"317\":1}}],[\"一个事务在持有\",{\"1\":{\"312\":1}}],[\"一个事务持有了范围为\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁\",{\"1\":{\"275\":1,\"323\":1}}],[\"一个事务要插入订单\",{\"1\":{\"274\":1}}],[\"一个事务按照条件查询数据时\",{\"1\":{\"270\":1}}],[\"一个事务先后读取同一条记录\",{\"1\":{\"270\":1}}],[\"一个事务读取到了另一个事务未提交的数据\",{\"1\":{\"270\":1}}],[\"一个表中可以有多个二级索引\",{\"1\":{\"246\":1}}],[\"一个表只能有一个聚簇索引\",{\"1\":{\"246\":1}}],[\"一个字符集为\",{\"1\":{\"216\":1}}],[\"一个字符串最多需要三个字节\",{\"1\":{\"166\":1}}],[\"一个页的默认大小为\",{\"1\":{\"174\":1,\"336\":1}}],[\"一个页的大小一般是\",{\"1\":{\"168\":1}}],[\"一个处于空闲状态的连接被服务端主动断开后\",{\"1\":{\"139\":1}}],[\"一个进程不能直接访问另一个进程的地址空间\",{\"1\":{\"120\":1}}],[\"一个进程退出后\",{\"1\":{\"46\":1}}],[\"一个系统模型只有一个部署图\",{\"1\":{\"74\":1}}],[\"一个用例可以被特别列举为一个或多个子用例\",{\"1\":{\"61\":1}}],[\"一个复杂的程序往往不是一次上机就能通过并得到正确的结果的\",{\"1\":{\"58\":1}}],[\"一个计算问题的解决过程通常包含下面几步\",{\"1\":{\"58\":1}}],[\"一个流程从开始符开始\",{\"1\":{\"57\":1}}],[\"一个流程会将这6个要素有序串联起来\",{\"1\":{\"54\":1}}],[\"一个\",{\"1\":{\"48\":1,\"185\":1}}],[\"一个为\",{\"1\":{\"44\":2}}],[\"再回收不被gc\",{\"1\":{\"529\":1}}],[\"再简单举一个例子\",{\"1\":{\"506\":1}}],[\"再查询tomcat\",{\"1\":{\"449\":1}}],[\"再转为json\",{\"1\":{\"442\":1}}],[\"再有专门的nginx服务来做反向代理\",{\"1\":{\"414\":1}}],[\"再执行\",{\"1\":{\"368\":1}}],[\"再使用普通\",{\"1\":{\"367\":1}}],[\"再使用二分搜索出\",{\"1\":{\"243\":1}}],[\"再次查询时更新\",{\"1\":{\"456\":1}}],[\"再次查询账户余额大于\",{\"1\":{\"356\":1}}],[\"再次读取记录时\",{\"1\":{\"359\":1}}],[\"再次读取该数据时\",{\"1\":{\"355\":1}}],[\"再返回给主库\",{\"1\":{\"342\":1}}],[\"再返回给客户端\",{\"1\":{\"22\":1}}],[\"再把得到的变化信息通知给canal的客户端\",{\"1\":{\"458\":1}}],[\"再把\",{\"1\":{\"342\":1,\"343\":1}}],[\"再提交事务\",{\"1\":{\"342\":1}}],[\"再将缓存在\",{\"1\":{\"338\":1}}],[\"再一次查询\",{\"1\":{\"297\":1}}],[\"再按主键\",{\"1\":{\"296\":1}}],[\"再按照\",{\"1\":{\"216\":2}}],[\"再通过\",{\"1\":{\"337\":1}}],[\"再通过页里的\",{\"1\":{\"336\":1}}],[\"再通过页里的页目录去定位到某条具体的记录\",{\"1\":{\"174\":1}}],[\"再通过索引从磁盘中找到某行数据\",{\"1\":{\"248\":1}}],[\"再遍历槽内的所有记录\",{\"1\":{\"243\":1,\"244\":1}}],[\"再说一个相似\",{\"1\":{\"232\":1}}],[\"再到聚簇索引树检索到对应的数据行\",{\"1\":{\"232\":1}}],[\"再到索引的使用场景\",{\"1\":{\"201\":1}}],[\"再对比\",{\"1\":{\"217\":1}}],[\"再来说说元数据锁\",{\"1\":{\"310\":1}}],[\"再来看针对\",{\"1\":{\"294\":1}}],[\"再来\",{\"1\":{\"196\":1}}],[\"再来假设\",{\"1\":{\"191\":1}}],[\"再写入磁盘\",{\"1\":{\"179\":1}}],[\"再判断该记录的\",{\"1\":{\"149\":1}}],[\"再然后拿二级证书的公钥解密\",{\"1\":{\"109\":1}}],[\"再根据证书上的摘要算法计算出摘要后把证书上的摘要也给替换掉\",{\"1\":{\"108\":1}}],[\"再用此公钥加密对称加密密钥传给\",{\"1\":{\"108\":1}}],[\"再加上为了解释清楚为什么\",{\"1\":{\"282\":1}}],[\"再加上不能范围查询\",{\"1\":{\"250\":1}}],[\"再加上是左模糊匹配\",{\"1\":{\"232\":1}}],[\"再加上\",{\"1\":{\"232\":1}}],[\"再加上页目录\",{\"1\":{\"187\":1}}],[\"再加4\",{\"1\":{\"58\":1}}],[\"再加3\",{\"1\":{\"58\":1}}],[\"再输入192\",{\"1\":{\"43\":1}}],[\"把每个if中的逻辑抽取出到各实现类中\",{\"1\":{\"508\":1}}],[\"把数据写入本地缓存\",{\"1\":{\"454\":2}}],[\"把得到的数值对tomcat服务的数量取余\",{\"1\":{\"446\":1}}],[\"把item序列化为json\",{\"1\":{\"444\":1,\"451\":1,\"454\":1}}],[\"把结果返回给用户\",{\"1\":{\"435\":1}}],[\"把他们用指针连起来\",{\"1\":{\"250\":1}}],[\"把条件\",{\"1\":{\"147\":1}}],[\"把\",{\"1\":{\"142\":1,\"342\":1,\"345\":1,\"443\":1}}],[\"把它用框图画出来\",{\"1\":{\"58\":1}}],[\"把主服务器\",{\"1\":{\"43\":1}}],[\"把两台服务器上nginx和keepalived启动\",{\"1\":{\"43\":1}}],[\"kə\",{\"1\":{\"458\":1}}],[\"kb\",{\"1\":{\"246\":1,\"257\":1}}],[\"k\",{\"1\":{\"216\":1}}],[\"kill\",{\"1\":{\"139\":2,\"310\":1}}],[\"killall\",{\"1\":{\"43\":1}}],[\"klt\",{\"1\":{\"130\":1}}],[\"key为索引的\",{\"1\":{\"426\":1}}],[\"key为角标的\",{\"1\":{\"425\":1}}],[\"key是查询的key\",{\"1\":{\"450\":2}}],[\"key是数组角标而已\",{\"1\":{\"425\":1}}],[\"key是num\",{\"1\":{\"402\":1}}],[\"key中不包含\",{\"1\":{\"402\":1}}],[\"key中包含\",{\"1\":{\"402\":1}}],[\"key=index\",{\"1\":{\"232\":1,\"235\":1}}],[\"keys\",{\"1\":{\"228\":1,\"330\":1}}],[\"key\",{\"0\":{\"287\":1,\"316\":1},\"1\":{\"140\":2,\"145\":3,\"161\":1,\"182\":1,\"183\":1,\"196\":1,\"204\":4,\"206\":1,\"210\":1,\"211\":1,\"215\":2,\"216\":14,\"228\":2,\"236\":1,\"250\":4,\"274\":2,\"275\":20,\"277\":2,\"278\":4,\"280\":6,\"282\":1,\"284\":1,\"287\":8,\"288\":6,\"289\":2,\"290\":3,\"291\":5,\"292\":8,\"293\":14,\"294\":23,\"295\":3,\"296\":2,\"297\":8,\"298\":9,\"299\":3,\"300\":8,\"302\":3,\"304\":24,\"305\":1,\"313\":1,\"316\":8,\"317\":1,\"319\":1,\"322\":3,\"329\":5,\"330\":2,\"357\":3,\"361\":4,\"362\":3,\"365\":3,\"368\":1,\"369\":2,\"416\":1,\"419\":4,\"426\":2,\"450\":12,\"451\":8,\"453\":2,\"454\":16,\"474\":1}}],[\"keychain\",{\"1\":{\"108\":1}}],[\"keepalived停止\",{\"1\":{\"43\":1}}],[\"keepalived启动\",{\"1\":{\"43\":1}}],[\"keepalived\",{\"1\":{\"43\":7}}],[\"keepalive\",{\"1\":{\"32\":2,\"450\":2}}],[\"下架\",{\"1\":{\"462\":1}}],[\"下一个事务\",{\"1\":{\"359\":2}}],[\"下一条记录的位置\",{\"1\":{\"163\":1}}],[\"下个事务才可以继续进行\",{\"1\":{\"347\":1}}],[\"下动态函数的问题\",{\"1\":{\"341\":1}}],[\"下图中有时刻\",{\"1\":{\"346\":1}}],[\"下图中的\",{\"1\":{\"199\":1}}],[\"下图就是\",{\"1\":{\"257\":1}}],[\"下图是官方给出的性能对比\",{\"1\":{\"416\":1}}],[\"下图是每次插入的元素都是平衡二叉查找树中最大的元素\",{\"1\":{\"251\":1}}],[\"下图是\",{\"1\":{\"202\":1}}],[\"下图是公众号\",{\"1\":{\"144\":1}}],[\"下次分配内存的时候\",{\"1\":{\"527\":1}}],[\"下次访问即可更新缓存\",{\"1\":{\"454\":1}}],[\"下次要小心点\",{\"1\":{\"331\":1}}],[\"下次见啦\",{\"1\":{\"232\":1}}],[\"下次查询同样的数据的时候\",{\"1\":{\"172\":1}}],[\"下次的读数据将会被阻塞\",{\"1\":{\"124\":1}}],[\"下推到了哪里\",{\"1\":{\"149\":1}}],[\"下推\",{\"1\":{\"149\":1}}],[\"下下级\",{\"1\":{\"109\":1}}],[\"下面\",{\"1\":{\"395\":1,\"442\":1,\"444\":1}}],[\"下面会说\",{\"1\":{\"338\":1}}],[\"下面举个\",{\"1\":{\"279\":1,\"280\":1}}],[\"下面事务\",{\"1\":{\"275\":1}}],[\"下面通过三个方面\",{\"1\":{\"253\":1}}],[\"下面是按照时间顺序执行两个事务的行为\",{\"1\":{\"357\":1}}],[\"下面是红黑树插入节点的过程\",{\"1\":{\"251\":1}}],[\"下面是二叉查找树插入某个节点的动图演示\",{\"1\":{\"250\":1}}],[\"下面这个例子\",{\"1\":{\"290\":1,\"291\":1}}],[\"下面这个动图是删除\",{\"1\":{\"255\":1}}],[\"下面这个平衡二叉查找树的高度为\",{\"1\":{\"251\":1}}],[\"下面这条查询语句\",{\"1\":{\"237\":1}}],[\"下面这张二级索引图\",{\"1\":{\"235\":1}}],[\"下面这三条记录的\",{\"1\":{\"216\":1}}],[\"下面的命令可以异步执行rdb\",{\"1\":{\"373\":1}}],[\"下面的实验案例\",{\"1\":{\"234\":1}}],[\"下面的内容本文非原创\",{\"1\":{\"96\":1}}],[\"下面几种情况会触发脏页的刷新\",{\"1\":{\"179\":1}}],[\"下面我就来看看\",{\"1\":{\"185\":1}}],[\"下面我们就以\",{\"1\":{\"187\":1}}],[\"下面我们就把车速踩到底\",{\"1\":{\"181\":1}}],[\"下面我们再来看看索引的结构\",{\"1\":{\"184\":1}}],[\"下面我们从下往上一个个看看\",{\"1\":{\"153\":1}}],[\"下面我将从流程图vs顺序图\",{\"1\":{\"83\":1}}],[\"下面就是\",{\"1\":{\"138\":1}}],[\"下新建检测脚本\",{\"1\":{\"43\":1}}],[\"下载\",{\"0\":{\"28\":1}}],[\"虛拟ip\",{\"1\":{\"43\":1}}],[\"密码1111\",{\"1\":{\"43\":1}}],[\"每隔1秒发送一次ping命令\",{\"1\":{\"394\":1}}],[\"每隔1秒向集群的每个实例发送ping命令\",{\"1\":{\"392\":1}}],[\"每隔1s发送一次心跳\",{\"1\":{\"43\":1}}],[\"每隔一秒一起持久化到磁盘\",{\"1\":{\"346\":1}}],[\"每次对象被引用时\",{\"1\":{\"516\":1}}],[\"每次对某条聚簇索引记录进行改动时\",{\"1\":{\"358\":1}}],[\"每次hash运算结果也不会变\",{\"1\":{\"446\":1}}],[\"每次查询时都访问同一个tomcat服务\",{\"1\":{\"445\":1}}],[\"每次查找都要不断计算中间的位置\",{\"1\":{\"250\":1}}],[\"每次执行的时候都是读取最新的数据\",{\"1\":{\"365\":1}}],[\"每次读取数据时创建的\",{\"1\":{\"360\":1}}],[\"每次事务提交时都将缓存在\",{\"1\":{\"338\":1}}],[\"每插入一条新记录\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"每组的地址偏移量也被称之为槽\",{\"1\":{\"243\":1}}],[\"每种都要考虑的话\",{\"1\":{\"237\":1}}],[\"每一条修改数据的\",{\"1\":{\"341\":1}}],[\"每一条记录的索引上都会加\",{\"1\":{\"299\":1}}],[\"每一层父节点的索引值都会出现在下层子节点的索引值中\",{\"1\":{\"204\":1}}],[\"每一种存储引擎支持的索引类型不一定相同\",{\"1\":{\"204\":1}}],[\"每一个代理类只能为一个接口服务\",{\"1\":{\"506\":1}}],[\"每一个master都有唯一的replid\",{\"1\":{\"384\":1}}],[\"每一个控制块都对应一个缓存页\",{\"1\":{\"174\":1}}],[\"每一个状态总结记录程序由开始到目前所有接到的输入\",{\"1\":{\"83\":1}}],[\"每一个网格中的活动都应该有相对应的部门来实施\",{\"1\":{\"58\":1}}],[\"每行数据占用空间越大\",{\"1\":{\"187\":1}}],[\"每行记录根据不同的行格式\",{\"1\":{\"154\":1}}],[\"每当产生一条\",{\"1\":{\"337\":1}}],[\"每当执行一个事务就会产生这样的一条或者多条物理日志\",{\"1\":{\"337\":1}}],[\"每当\",{\"1\":{\"334\":1}}],[\"每当插入的元素都是树内最大的元素\",{\"1\":{\"258\":1}}],[\"每当有一条新的数据插入时\",{\"1\":{\"226\":1}}],[\"每当我们插入一条记录\",{\"1\":{\"185\":1}}],[\"每当需要从磁盘中加载一个页到\",{\"1\":{\"176\":1}}],[\"每查询到一条二级索引记录\",{\"1\":{\"149\":1}}],[\"每条select\",{\"1\":{\"143\":1}}],[\"每天都有很多人要向它申请证书\",{\"1\":{\"109\":1}}],[\"每个master都可以有多个slave节点\",{\"1\":{\"400\":1}}],[\"每个master保存不同数据\",{\"1\":{\"400\":1}}],[\"每个语句执行前\",{\"1\":{\"357\":1}}],[\"每个事务都有一个完整的数据空间\",{\"1\":{\"352\":1}}],[\"每个事务各自执行\",{\"1\":{\"348\":1}}],[\"每个事务提交都会进行两次\",{\"1\":{\"347\":1}}],[\"每个阶段都有一个队列\",{\"1\":{\"348\":1}}],[\"每个阶段都由协调者\",{\"1\":{\"344\":1}}],[\"每个阶段有锁进行保护\",{\"1\":{\"348\":1}}],[\"每个线程一个\",{\"1\":{\"343\":1}}],[\"每个从库把\",{\"1\":{\"342\":1}}],[\"每个节点只能有\",{\"1\":{\"252\":1,\"258\":1}}],[\"每个节点的左子树和右子树的高度差不能超过\",{\"1\":{\"251\":1}}],[\"每个节点都是一个数据页\",{\"1\":{\"246\":1}}],[\"每个记录之间用单向链表的方式组织起来\",{\"1\":{\"246\":1}}],[\"每个记录组的最后一条记录就是组内最大的那条记录\",{\"1\":{\"243\":1}}],[\"每个数据页默认大小是\",{\"1\":{\"257\":1}}],[\"每个数据页之间通过双向链表的形式组织起来\",{\"1\":{\"246\":1}}],[\"每个数据库表的行格式都有\",{\"1\":{\"161\":1,\"162\":1}}],[\"每个槽相当于指针指向了不同组的最后一个记录\",{\"1\":{\"243\":1}}],[\"每个区的大小为\",{\"1\":{\"156\":1}}],[\"每个woker支持最大的连接数1024\",{\"1\":{\"49\":1}}],[\"每个并发会建立与客户端的连接和与后端服务的连接\",{\"1\":{\"48\":1}}],[\"每个进程里只有一个主线程\",{\"1\":{\"47\":1}}],[\"每个进程每次调用传输数量不能大于设定的值\",{\"1\":{\"32\":1}}],[\"每个\",{\"1\":{\"47\":2,\"339\":1}}],[\"每个请求按访问ip的hash结果分配\",{\"1\":{\"41\":1}}],[\"每个请求按时间顺序逐一分配到不\",{\"1\":{\"41\":1}}],[\"每个指令必须有分号结束\",{\"1\":{\"32\":1}}],[\"备主\",{\"1\":{\"342\":1}}],[\"备份数据库的工具是\",{\"1\":{\"307\":1}}],[\"备份期间业务依然可以对数据进行更新操作\",{\"1\":{\"307\":1}}],[\"备份就会花费很多的时间\",{\"1\":{\"307\":1}}],[\"备份的结果是用户表中该用户的余额并没有扣除\",{\"1\":{\"307\":1}}],[\"备份机值较小\",{\"1\":{\"43\":1}}],[\"备份服务器上将master\",{\"1\":{\"43\":1}}],[\"备机取不同的优先级\",{\"1\":{\"43\":1}}],[\"备机的virtual\",{\"1\":{\"43\":1}}],[\"改时导致幻读的问题\",{\"1\":{\"305\":1}}],[\"改操作的时候都会被阻塞\",{\"1\":{\"304\":1}}],[\"改操作的时候\",{\"1\":{\"299\":1}}],[\"改进一点东西\",{\"1\":{\"158\":1}}],[\"改为backup\",{\"1\":{\"43\":1}}],[\"改完bug后\",{\"1\":{\"15\":1}}],[\"权重\",{\"1\":{\"43\":1}}],[\"权重越高被分配的客户端越多\",{\"1\":{\"41\":1}}],[\"检查表或字段是否存在\",{\"1\":{\"150\":1}}],[\"检查\",{\"1\":{\"144\":1}}],[\"检测脚本执行的间隔\",{\"1\":{\"43\":1}}],[\"检出release\",{\"1\":{\"7\":1}}],[\"有代码侵入\",{\"1\":{\"456\":1}}],[\"有自己的replid和offset\",{\"1\":{\"384\":1}}],[\"有几个概念\",{\"1\":{\"384\":1}}],[\"有四个重要的字段\",{\"1\":{\"358\":1}}],[\"有四个woker\",{\"1\":{\"49\":1}}],[\"有动态函数的问题\",{\"1\":{\"341\":1}}],[\"有用户购买了商品\",{\"1\":{\"307\":1}}],[\"有用户购买了一件商品\",{\"1\":{\"307\":1}}],[\"有用的索引数据\",{\"1\":{\"252\":1}}],[\"有一点时间开销\",{\"1\":{\"516\":1}}],[\"有一点要注意的是\",{\"1\":{\"305\":1}}],[\"有一张账户余额表\",{\"1\":{\"357\":1}}],[\"有一个索引下推功能\",{\"1\":{\"239\":1}}],[\"有一个比较特殊的查询条件\",{\"1\":{\"239\":1}}],[\"有一个从上往下切入的视角\",{\"1\":{\"157\":1}}],[\"有些情况是可以成功插入的\",{\"1\":{\"298\":2}}],[\"有其他事务插入了与第一个事务相同的记录\",{\"1\":{\"280\":1}}],[\"有其他事务插入了记录\",{\"1\":{\"274\":1}}],[\"有关系\",{\"1\":{\"278\":1}}],[\"有可能出现这样的顺序\",{\"1\":{\"307\":1}}],[\"有可能出现幻读\",{\"1\":{\"274\":1}}],[\"有可能会被系统强制杀掉\",{\"1\":{\"139\":1}}],[\"有利于范围查询\",{\"1\":{\"258\":1}}],[\"有冗余节点\",{\"1\":{\"255\":1}}],[\"有时候我们会用一些\",{\"1\":{\"236\":1}}],[\"有时候很难对其进行抽象成类表达之间的关系\",{\"1\":{\"68\":1}}],[\"有重复\",{\"1\":{\"228\":1}}],[\"有两个事务的执行顺序如下\",{\"1\":{\"364\":1}}],[\"有两个原因\",{\"1\":{\"227\":1}}],[\"有两种开启事务的命令\",{\"1\":{\"357\":1}}],[\"有两种策略通过\",{\"1\":{\"281\":1}}],[\"有两种解决方式\",{\"1\":{\"139\":1}}],[\"有效提高索引的查询速度\",{\"1\":{\"224\":1}}],[\"有序的数组在使用二分查找的时候\",{\"1\":{\"250\":1}}],[\"有序排列存储的\",{\"1\":{\"235\":1}}],[\"有序\",{\"1\":{\"216\":2}}],[\"有这些行数据\",{\"1\":{\"204\":1}}],[\"有个秘书叫做钱秘书\",{\"1\":{\"506\":1}}],[\"有个事务\",{\"1\":{\"277\":1}}],[\"有个业务主要逻辑就是新增订单\",{\"1\":{\"273\":1}}],[\"有个优化\",{\"1\":{\"194\":1}}],[\"有个技巧\",{\"1\":{\"182\":1}}],[\"有多个服务需要同步\",{\"1\":{\"456\":1}}],[\"有多离谱呢\",{\"1\":{\"248\":1}}],[\"有多少个\",{\"1\":{\"191\":2}}],[\"有多大\",{\"0\":{\"173\":1}}],[\"有的数据库只实现了其中几种隔离级别\",{\"1\":{\"357\":1}}],[\"有的读者问\",{\"1\":{\"275\":1}}],[\"有的是说非叶子节点的子节点的个数为\",{\"1\":{\"255\":1}}],[\"有的\",{\"1\":{\"250\":1,\"307\":1}}],[\"有的同学可能会问\",{\"1\":{\"346\":1}}],[\"有的同学可能会说\",{\"1\":{\"237\":1}}],[\"有的同学会认为\",{\"1\":{\"219\":1}}],[\"有的部分占用的字节数是不确定的\",{\"1\":{\"185\":1}}],[\"有的部分占用的字节数是确定的\",{\"1\":{\"185\":1}}],[\"有的方法只需进行很少的步骤\",{\"1\":{\"58\":1}}],[\"有人统计过\",{\"1\":{\"183\":1}}],[\"有人说对这个密钥加密不就完了\",{\"1\":{\"106\":1}}],[\"有了\",{\"1\":{\"176\":1,\"177\":1,\"335\":1}}],[\"有了缓冲池后\",{\"1\":{\"172\":1}}],[\"有了正确而有效的算法\",{\"1\":{\"58\":1}}],[\"有不同的存储结构\",{\"1\":{\"154\":1}}],[\"有短连接和长连接的概念\",{\"1\":{\"139\":1}}],[\"有\",{\"1\":{\"107\":1,\"187\":1,\"197\":1,\"337\":1,\"341\":1,\"348\":2,\"352\":1}}],[\"有什么优化的方法\",{\"0\":{\"349\":1}}],[\"有什么优化索引的方法\",{\"0\":{\"223\":1},\"1\":{\"201\":1}}],[\"有什么命令可以分析加了什么锁\",{\"1\":{\"290\":1}}],[\"有什么方式可以避免回表呢\",{\"1\":{\"225\":1}}],[\"有什么用\",{\"0\":{\"333\":1},\"1\":{\"96\":1}}],[\"有什么区别\",{\"0\":{\"189\":1,\"341\":1},\"1\":{\"96\":1}}],[\"有哪些锁\",{\"0\":{\"306\":1},\"1\":{\"96\":1}}],[\"有需要的可以移步查看▼\",{\"1\":{\"70\":1}}],[\"有配置文件keepalived\",{\"1\":{\"43\":1}}],[\"有报告表明能支持高达50000个并发连接数\",{\"1\":{\"20\":1}}],[\"q70\",{\"1\":{\"436\":1,\"439\":1}}],[\"q4\",{\"1\":{\"216\":4}}],[\"q3\",{\"1\":{\"216\":4}}],[\"q2\",{\"1\":{\"216\":5}}],[\"q1\",{\"1\":{\"216\":7}}],[\"queue\",{\"1\":{\"522\":1}}],[\"queue=new\",{\"1\":{\"522\":1}}],[\"query\",{\"1\":{\"139\":2,\"140\":2,\"225\":1,\"277\":2,\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"298\":1,\"302\":1,\"322\":2,\"323\":2,\"363\":1,\"367\":5,\"419\":1}}],[\"quorum值最好超过sentinel实例数量的一半\",{\"1\":{\"392\":1}}],[\"quorum\",{\"1\":{\"392\":1}}],[\"quit\",{\"1\":{\"31\":1}}],[\"q\",{\"1\":{\"43\":1,\"306\":1}}],[\"实验环境\",{\"1\":{\"303\":1}}],[\"实验验证\",{\"0\":{\"303\":1}}],[\"实验三\",{\"1\":{\"294\":1}}],[\"实验二\",{\"1\":{\"293\":1,\"294\":1,\"297\":1}}],[\"实验一\",{\"1\":{\"293\":1,\"294\":1,\"296\":1}}],[\"实验一把看看\",{\"1\":{\"182\":1}}],[\"实验\",{\"0\":{\"182\":1}}],[\"实际过程中\",{\"1\":{\"228\":1}}],[\"实际开发工作中\",{\"1\":{\"218\":1}}],[\"实际情况下并不是连续的\",{\"1\":{\"187\":1}}],[\"实际中是\",{\"1\":{\"187\":1}}],[\"实际页的内部结构像是下面这样的\",{\"1\":{\"185\":1}}],[\"实际占用数据的大小\",{\"1\":{\"151\":1,\"169\":1}}],[\"实际上是会加锁的\",{\"1\":{\"365\":1}}],[\"实际上是会对记录加独占锁\",{\"1\":{\"329\":1}}],[\"实际上是在讨论存储引使用哪种数据结构作为索引\",{\"1\":{\"258\":1}}],[\"实际上\",{\"1\":{\"109\":1,\"337\":1}}],[\"实际上任何站点都可以向第三方权威机构申请证书\",{\"1\":{\"108\":1}}],[\"实际上此公钥是存在于\",{\"1\":{\"108\":1}}],[\"实际问题中客观存在的并且可以相互区别的事物称为实体\",{\"1\":{\"89\":1}}],[\"实际测试\",{\"1\":{\"42\":1}}],[\"实体与联系之间\",{\"1\":{\"90\":1}}],[\"实体与属性之间\",{\"1\":{\"90\":1}}],[\"实体之间的联系通常有3种类型\",{\"1\":{\"89\":1}}],[\"实体名\",{\"1\":{\"89\":1}}],[\"实体型\",{\"1\":{\"89\":1}}],[\"实体集\",{\"1\":{\"89\":1}}],[\"实体所具有的某一个特性称为属性\",{\"1\":{\"89\":1}}],[\"实体是现实世界中的对象\",{\"1\":{\"89\":1}}],[\"实体\",{\"1\":{\"89\":1}}],[\"实线关系\",{\"1\":{\"66\":1}}],[\"实现被代理类\",{\"1\":{\"507\":1}}],[\"实现类通过\",{\"1\":{\"463\":1}}],[\"实现最新的read\",{\"1\":{\"454\":1}}],[\"实现本地缓存查询\",{\"0\":{\"454\":1}}],[\"实现缓存功能\",{\"1\":{\"453\":1}}],[\"实现对redis的查询了\",{\"1\":{\"451\":1}}],[\"实现runnable接口的方法创建多线程\",{\"1\":{\"506\":1}}],[\"实现redis查询\",{\"0\":{\"451\":1}}],[\"实现rdb持久化\",{\"1\":{\"373\":1}}],[\"实现基于id做负载均衡\",{\"1\":{\"447\":1}}],[\"实现tomcat查询\",{\"0\":{\"444\":1}}],[\"实现商品查询\",{\"1\":{\"442\":1}}],[\"实现多级缓存\",{\"0\":{\"431\":1}}],[\"实现jvm进程缓存\",{\"0\":{\"417\":1}}],[\"实现nginx本地缓存\",{\"1\":{\"414\":1}}],[\"实现无感知的数据迁移\",{\"1\":{\"411\":1}}],[\"实现读写分离\",{\"1\":{\"382\":1}}],[\"实现事务的持久性\",{\"1\":{\"337\":1}}],[\"实现事务回滚\",{\"1\":{\"334\":1}}],[\"实现\",{\"0\":{\"419\":1,\"447\":1},\"1\":{\"334\":2}}],[\"实现这一机制就是\",{\"1\":{\"334\":1}}],[\"实现了事务中的持久性\",{\"1\":{\"333\":1}}],[\"实现了事务中的原子性\",{\"1\":{\"333\":1}}],[\"实现一致性读\",{\"1\":{\"311\":1}}],[\"实现的方式是启动事务后\",{\"1\":{\"364\":1}}],[\"实现的快照读\",{\"1\":{\"361\":1}}],[\"实现的\",{\"1\":{\"283\":1,\"334\":1,\"364\":1}}],[\"实现的一种延迟加锁机制\",{\"1\":{\"276\":1}}],[\"实现高可用集群\",{\"0\":{\"43\":1}}],[\"实现动静分离\",{\"0\":{\"42\":1}}],[\"实现效果\",{\"1\":{\"40\":1}}],[\"实现负载均衡\",{\"0\":{\"40\":1},\"1\":{\"446\":1}}],[\"实现反向代理\",{\"0\":{\"36\":1}}],[\"实现上非常注重效率\",{\"1\":{\"20\":1}}],[\"比官方客户端要简单好用很多\",{\"1\":{\"459\":1}}],[\"比事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"比\",{\"1\":{\"337\":1}}],[\"比方将\",{\"1\":{\"237\":1}}],[\"比较常见是\",{\"1\":{\"349\":1}}],[\"比较下\",{\"1\":{\"253\":1}}],[\"比较\",{\"1\":{\"205\":1}}],[\"比较方便\",{\"1\":{\"161\":1,\"163\":1}}],[\"比对服务器该文件最后更新时间没有变化\",{\"1\":{\"42\":1}}],[\"比如今天开会\",{\"1\":{\"506\":1}}],[\"比如拳套还没有带好\",{\"1\":{\"344\":1}}],[\"比如执行批量\",{\"1\":{\"341\":1}}],[\"比如你用了\",{\"1\":{\"341\":1}}],[\"比如你以为是在和某宝通信\",{\"1\":{\"103\":1}}],[\"比如对\",{\"1\":{\"337\":1,\"341\":1}}],[\"比如当\",{\"1\":{\"334\":1}}],[\"比如这一条\",{\"1\":{\"333\":1}}],[\"比如在用户表更新该用户的余额\",{\"1\":{\"307\":1}}],[\"比如在表里面有多个索引的时候\",{\"1\":{\"145\":1}}],[\"比如插入一个\",{\"1\":{\"297\":1}}],[\"比如一主二从的集群\",{\"1\":{\"342\":1}}],[\"比如一个事务执行了\",{\"1\":{\"275\":1}}],[\"比如一级\",{\"1\":{\"109\":1}}],[\"比如删除根节点的时候\",{\"1\":{\"258\":1}}],[\"比如删除根节点中的数据\",{\"1\":{\"255\":1}}],[\"比如数据库\",{\"1\":{\"256\":1}}],[\"比如红黑树\",{\"1\":{\"251\":1}}],[\"比如要查找节点\",{\"1\":{\"250\":1}}],[\"比如索引失效\",{\"1\":{\"246\":1}}],[\"比如槽\",{\"1\":{\"243\":1}}],[\"比如聚簇索引中的叶子节点则记录了主键值\",{\"1\":{\"232\":1}}],[\"比如进行索引统计时\",{\"1\":{\"227\":1}}],[\"比如不要对电商项目的用户余额建立索引\",{\"1\":{\"222\":1}}],[\"比如性别字段\",{\"1\":{\"222\":1}}],[\"比如商品编码\",{\"1\":{\"221\":1}}],[\"比如前面图的联合索引的\",{\"1\":{\"216\":1}}],[\"比如主键索引\",{\"1\":{\"214\":1}}],[\"比如搜索引擎在搜索关键词的时候\",{\"1\":{\"199\":1}}],[\"比如把内存当磁盘使\",{\"1\":{\"187\":1}}],[\"比如全部都是\",{\"1\":{\"161\":1}}],[\"比如下面有一个排序的数组\",{\"1\":{\"249\":1}}],[\"比如下面的的动图\",{\"1\":{\"252\":1}}],[\"比如下面的查询语句\",{\"1\":{\"240\":1}}],[\"比如下面的\",{\"1\":{\"235\":1}}],[\"比如下面这个顺序的场景\",{\"1\":{\"310\":1}}],[\"比如下面这个动图是删除\",{\"1\":{\"255\":3}}],[\"比如下面这张采用二分法的查询过程图\",{\"1\":{\"249\":1}}],[\"比如下面这条\",{\"1\":{\"239\":1}}],[\"比如下面这条语句查询条件中对\",{\"1\":{\"236\":1}}],[\"比如下面这条查询语句\",{\"1\":{\"206\":1}}],[\"比如下面这句查询语句\",{\"1\":{\"137\":1}}],[\"比如下面我这个案例\",{\"1\":{\"198\":1}}],[\"比如下图\",{\"1\":{\"178\":1,\"232\":1,\"275\":1}}],[\"比如下图的\",{\"1\":{\"145\":1}}],[\"比如我的\",{\"1\":{\"139\":1}}],[\"比如上图的显示结果\",{\"1\":{\"139\":1}}],[\"比如上图中的学生\",{\"1\":{\"89\":1}}],[\"比如加解密都是在\",{\"1\":{\"109\":1}}],[\"比如小明向小红借了\",{\"1\":{\"104\":1}}],[\"比如学生生活中的校园卡系统数据库\",{\"1\":{\"89\":1}}],[\"比如用例图\",{\"1\":{\"76\":1}}],[\"比如64主机\",{\"1\":{\"75\":1}}],[\"比如查询订单\",{\"1\":{\"53\":1}}],[\"比如\",{\"1\":{\"32\":2,\"54\":1,\"57\":1,\"66\":3,\"89\":2,\"138\":1,\"142\":1,\"152\":1,\"165\":1,\"178\":1,\"187\":2,\"189\":1,\"201\":1,\"205\":1,\"215\":3,\"218\":1,\"220\":1,\"228\":2,\"234\":1,\"237\":1,\"239\":1,\"251\":2,\"252\":1,\"256\":1,\"257\":1,\"275\":2,\"287\":1,\"290\":1,\"291\":1,\"302\":1,\"307\":2,\"316\":1,\"329\":1,\"334\":1,\"340\":1,\"352\":2,\"363\":1,\"365\":1,\"404\":1}}],[\"比如说我们想知道\",{\"1\":{\"256\":1}}],[\"比如说我们需要查找一个\",{\"1\":{\"187\":1}}],[\"比如说\",{\"1\":{\"12\":1}}],[\"发生幻读的现象\",{\"1\":{\"365\":1}}],[\"发生像主库那样两个\",{\"1\":{\"312\":1}}],[\"发生了回滚\",{\"1\":{\"354\":1}}],[\"发生了崩溃\",{\"1\":{\"334\":1}}],[\"发生了这种情况\",{\"1\":{\"312\":1}}],[\"发生了主键索引冲突\",{\"1\":{\"279\":1}}],[\"发生冲突\",{\"1\":{\"311\":1}}],[\"发生阻塞\",{\"1\":{\"277\":1}}],[\"发生错误时\",{\"1\":{\"272\":1}}],[\"发生索引失效的情况\",{\"1\":{\"228\":1}}],[\"发生行溢出\",{\"1\":{\"168\":1}}],[\"发现slave宕机时尽快实现故障恢复\",{\"1\":{\"387\":1}}],[\"发现不一致\",{\"1\":{\"384\":1}}],[\"发现这条记录的\",{\"1\":{\"359\":1}}],[\"发现这个节点还有子节点\",{\"1\":{\"187\":1}}],[\"发现和前一次读到的记录数量不一样了\",{\"1\":{\"356\":1}}],[\"发现共有\",{\"1\":{\"356\":1}}],[\"发现节点2有与林字前缀匹配的索引值\",{\"1\":{\"235\":1}}],[\"发现此节点为叶子节点\",{\"1\":{\"187\":1}}],[\"发现了一张小七以前的照片\",{\"1\":{\"95\":1}}],[\"发车\",{\"1\":{\"151\":1,\"171\":1,\"189\":1,\"233\":1,\"306\":1}}],[\"发布公钥给其他\",{\"1\":{\"107\":1}}],[\"发布的分支\",{\"1\":{\"6\":1}}],[\"发送http请求\",{\"1\":{\"442\":1,\"450\":1}}],[\"发送http请求的api\",{\"0\":{\"441\":1}}],[\"发送rdb到slave\",{\"1\":{\"384\":1,\"388\":1}}],[\"发送的replid和offset是自己的replid和offset\",{\"1\":{\"384\":1}}],[\"发送信号\",{\"1\":{\"88\":1}}],[\"发送人不需要等待消息的响应\",{\"1\":{\"81\":1}}],[\"发送人需要等待消息的响应\",{\"1\":{\"81\":1}}],[\"发送请求\",{\"1\":{\"49\":1}}],[\"发送一个请求\",{\"1\":{\"42\":1}}],[\"发\",{\"1\":{\"48\":1}}],[\"此方法也就作为了被代理类对象要调用的方法\",{\"1\":{\"507\":1}}],[\"此处要注意一点\",{\"1\":{\"498\":1}}],[\"此处需要注意的是\",{\"1\":{\"182\":1}}],[\"此次的事务\",{\"1\":{\"275\":1,\"291\":1,\"322\":1}}],[\"此项目已经在github上开源\",{\"1\":{\"98\":1}}],[\"此种方法非常适合不经常变动的资源\",{\"1\":{\"42\":1}}],[\"此时如果slave恢复\",{\"1\":{\"386\":1}}],[\"此时也发生了幻读现象\",{\"1\":{\"368\":1}}],[\"此时也不能插入记录\",{\"1\":{\"276\":1}}],[\"此时表中是没有该记录的\",{\"1\":{\"367\":1}}],[\"此时发现\",{\"1\":{\"359\":1}}],[\"此时查询到的记录数量有\",{\"1\":{\"356\":1}}],[\"此时查询复杂度就会从\",{\"1\":{\"258\":1}}],[\"此时数据库超过\",{\"1\":{\"356\":1}}],[\"此时后面到来的事务都是\",{\"1\":{\"348\":1}}],[\"此时的文件默认在当前的module下\",{\"1\":{\"496\":1}}],[\"此时的\",{\"1\":{\"346\":1}}],[\"此时记录的\",{\"1\":{\"343\":1,\"350\":1}}],[\"此时会停下来将\",{\"1\":{\"339\":1}}],[\"此时会生成一个插入意向锁\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"此时加了什么锁\",{\"1\":{\"322\":1,\"323\":1}}],[\"此时由于线程\",{\"1\":{\"310\":1}}],[\"此时并不会阻塞\",{\"1\":{\"310\":1}}],[\"此时就先对该表加上\",{\"1\":{\"310\":1}}],[\"此时还没有实际的锁结构\",{\"1\":{\"280\":1}}],[\"此时对应的唯一二级索引记录被\",{\"1\":{\"280\":1}}],[\"此时\",{\"1\":{\"280\":1,\"296\":1,\"303\":1,\"324\":1,\"325\":1,\"330\":2,\"367\":1,\"386\":1}}],[\"此时有个事务\",{\"1\":{\"279\":1}}],[\"此时插入就会失败\",{\"1\":{\"278\":1}}],[\"此时是不能插入记录的\",{\"1\":{\"276\":1}}],[\"此时事务\",{\"1\":{\"275\":1,\"280\":3,\"290\":1,\"291\":1,\"294\":1,\"304\":1,\"317\":1,\"322\":1,\"360\":1}}],[\"此时执行计划中\",{\"1\":{\"238\":1}}],[\"此时这些缓存页都是空闲的\",{\"1\":{\"174\":1,\"336\":1}}],[\"此时反向代理服务器和目标服务器对外就是一个服务器\",{\"1\":{\"22\":1}}],[\"此时线上环境出现bug需要修改代码重新部署时\",{\"1\":{\"7\":1}}],[\"能够到达到的对象都是存活的\",{\"1\":{\"517\":1}}],[\"能够保证\",{\"1\":{\"337\":1}}],[\"能大量减少对数据库的访问\",{\"1\":{\"416\":1}}],[\"能读取到的是\",{\"1\":{\"359\":1,\"360\":1}}],[\"能将\",{\"1\":{\"344\":1}}],[\"能使用\",{\"1\":{\"341\":1}}],[\"能力\",{\"1\":{\"340\":1}}],[\"能力的\",{\"1\":{\"340\":1}}],[\"能很好的利用二分查找快速定位数据\",{\"1\":{\"258\":1}}],[\"能在尽可能少的磁盘的\",{\"1\":{\"248\":1}}],[\"能放数据的空间也是\",{\"1\":{\"187\":1}}],[\"能\",{\"1\":{\"48\":1}}],[\"能建立的最大连接数\",{\"1\":{\"48\":1}}],[\"能自动剔除\",{\"1\":{\"41\":1}}],[\"能经受高负载的考验\",{\"1\":{\"20\":1}}],[\"同步锁\",{\"1\":{\"517\":1}}],[\"同步双写\",{\"1\":{\"456\":1}}],[\"同步到各从库\",{\"1\":{\"342\":1}}],[\"同步复制\",{\"1\":{\"342\":1}}],[\"同步\",{\"1\":{\"342\":1}}],[\"同步消息\",{\"1\":{\"81\":1}}],[\"同学总结的流程图\",{\"1\":{\"300\":1}}],[\"同样\",{\"1\":{\"187\":1}}],[\"同样一个\",{\"1\":{\"187\":1}}],[\"同样需要按\",{\"1\":{\"174\":1,\"336\":1}}],[\"同样的道理\",{\"1\":{\"161\":2}}],[\"同样的\",{\"1\":{\"109\":1}}],[\"同理\",{\"1\":{\"108\":1,\"124\":1,\"187\":2}}],[\"同office无缝集成\",{\"1\":{\"91\":1}}],[\"同一个叶子节点内的各个数据是按主键顺序存放的\",{\"1\":{\"226\":1}}],[\"同一个时刻的多个查询\",{\"1\":{\"197\":1}}],[\"同一路径的指示箭头应只有一个\",{\"1\":{\"57\":1}}],[\"同一流程图内\",{\"1\":{\"57\":1}}],[\"同时进入等待状态\",{\"1\":{\"365\":1}}],[\"同时将\",{\"1\":{\"345\":1}}],[\"同时还受限于主库的网络带宽\",{\"1\":{\"342\":1}}],[\"同时还能保证常用数据留在\",{\"1\":{\"178\":1}}],[\"同时性能方面比参数\",{\"1\":{\"338\":1}}],[\"同时标记为脏页\",{\"1\":{\"337\":1,\"343\":1,\"350\":1}}],[\"同时使用\",{\"1\":{\"330\":2}}],[\"同时执行向表\",{\"1\":{\"312\":1}}],[\"同时针对其他事务插入\",{\"1\":{\"296\":1}}],[\"同时\",{\"1\":{\"295\":1,\"297\":2,\"298\":2,\"300\":1,\"312\":1}}],[\"同时会对这两个索引都加锁\",{\"1\":{\"295\":1}}],[\"同时也会触发stw\",{\"1\":{\"528\":1}}],[\"同时也无法插入\",{\"1\":{\"294\":5}}],[\"同时也是为了自我监督和激励\",{\"1\":{\"1\":1}}],[\"同时无法插入\",{\"1\":{\"293\":3}}],[\"同时又保持着天然的二分结构\",{\"1\":{\"250\":1}}],[\"同时页空间的利用率下降\",{\"1\":{\"226\":1}}],[\"同时查表\",{\"1\":{\"197\":1}}],[\"同时主键\",{\"1\":{\"147\":1}}],[\"同时连接线不能交叉\",{\"1\":{\"57\":1}}],[\"同时在编程以及问题查找时\",{\"1\":{\"46\":1}}],[\"同的后端服务器\",{\"1\":{\"41\":1}}],[\"轮询\",{\"1\":{\"41\":1}}],[\"策略管理类\",{\"1\":{\"508\":1}}],[\"策略方法\",{\"1\":{\"508\":1}}],[\"策略模式详细介绍请移步观看\",{\"1\":{\"508\":1}}],[\"策略模式+反射去除冗余if\",{\"1\":{\"478\":1}}],[\"策略\",{\"1\":{\"41\":1,\"179\":1}}],[\"等注解完成item与数据库表字段的映射\",{\"1\":{\"462\":1}}],[\"等事务\",{\"1\":{\"357\":1}}],[\"等所有数据库操作执行完成后\",{\"1\":{\"351\":1}}],[\"等之后事务提交的时候\",{\"1\":{\"340\":1}}],[\"等之类的\",{\"1\":{\"235\":1}}],[\"等擦除完旧记录腾出了空间\",{\"1\":{\"339\":1}}],[\"等插入语句执行完成后\",{\"1\":{\"312\":1}}],[\"等语句\",{\"1\":{\"302\":1,\"307\":1,\"357\":1,\"361\":1,\"362\":1,\"369\":1}}],[\"等具有加锁性质的语句\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1}}],[\"等值连接\",{\"1\":{\"261\":1}}],[\"等同于对索引列使用了函数\",{\"1\":{\"241\":1}}],[\"等关键词\",{\"1\":{\"228\":1}}],[\"等于用户白嫖了一件商品\",{\"1\":{\"307\":1}}],[\"等于根节点\",{\"1\":{\"250\":1}}],[\"等于\",{\"1\":{\"215\":1,\"293\":1}}],[\"等这些热数据又被再次访问的时候\",{\"1\":{\"178\":1}}],[\"等等\",{\"1\":{\"174\":1}}],[\"等等服务可以提供负载均衡服务\",{\"1\":{\"41\":1}}],[\"等下会说为什么要这么设计\",{\"1\":{\"161\":1}}],[\"等变长字段也是这么实现的\",{\"1\":{\"161\":1}}],[\"等执行完后\",{\"1\":{\"140\":1}}],[\"等到客户端在发起下一个请求的时候\",{\"1\":{\"139\":1}}],[\"等多个存储引擎\",{\"1\":{\"138\":1}}],[\"等待数据被读走\",{\"1\":{\"124\":1}}],[\"等待数据被写入\",{\"1\":{\"124\":1}}],[\"等待消息的接收者放弃或者返回控制\",{\"1\":{\"81\":1}}],[\"等\",{\"1\":{\"109\":1,\"189\":1}}],[\"等做请求转发\",{\"1\":{\"45\":1}}],[\"等相关命令lib\",{\"1\":{\"34\":1}}],[\"基本数据类型\",{\"1\":{\"490\":1}}],[\"基本上没法用\",{\"1\":{\"342\":1}}],[\"基本概念\",{\"0\":{\"117\":1}}],[\"基本语法\",{\"1\":{\"39\":1}}],[\"基础篇👇\",{\"1\":{\"96\":1,\"97\":1}}],[\"基础面试题一\",{\"1\":{\"96\":1}}],[\"基础用例\",{\"1\":{\"62\":1}}],[\"基于数据库增量日志解析\",{\"1\":{\"458\":1}}],[\"基于数据结构的共享\",{\"1\":{\"122\":1}}],[\"基于canal的通知\",{\"1\":{\"456\":1}}],[\"基于mq的异步通知\",{\"1\":{\"456\":1}}],[\"基于master分支新建hotfix\",{\"1\":{\"10\":1}}],[\"基于id负载均衡\",{\"0\":{\"445\":1}}],[\"基于ngx\",{\"1\":{\"442\":1}}],[\"基于lua语言进行扩展\",{\"1\":{\"432\":1}}],[\"基于引用\",{\"1\":{\"416\":1}}],[\"基于时间\",{\"1\":{\"416\":1}}],[\"基于容量\",{\"1\":{\"416\":1}}],[\"基于前面的实验\",{\"1\":{\"296\":1}}],[\"基于查询成本的考虑\",{\"1\":{\"150\":1}}],[\"基于存储区的共享\",{\"1\":{\"122\":1}}],[\"基于java开发\",{\"1\":{\"91\":1,\"458\":1}}],[\"基于develop模块新建两个新分支\",{\"1\":{\"10\":1}}],[\"标记清除算法顾名思义\",{\"1\":{\"527\":1}}],[\"标记\",{\"0\":{\"527\":1,\"528\":1,\"529\":1}}],[\"标记为\",{\"1\":{\"163\":1}}],[\"标准的javase类加载器可以按要求查找类\",{\"1\":{\"493\":1}}],[\"标准中规定的各级隔离级别允许发生的现象却有些出入\",{\"1\":{\"357\":1}}],[\"标准中规定的\",{\"1\":{\"357\":1}}],[\"标准提出了四种隔离级别来规避这些现象\",{\"1\":{\"357\":1}}],[\"标准版永久2638\",{\"1\":{\"91\":1}}],[\"标量子查询\",{\"1\":{\"261\":1}}],[\"标示消息发生时的时间点\",{\"1\":{\"82\":1}}],[\"标识此条数据是否被删除\",{\"1\":{\"163\":1}}],[\"标识\",{\"1\":{\"39\":1,\"81\":1,\"166\":1,\"346\":1}}],[\"标签为xxx\",{\"1\":{\"9\":1}}],[\"标签规则\",{\"0\":{\"9\":1}}],[\"则立刻报\",{\"1\":{\"516\":1}}],[\"则此invoke\",{\"1\":{\"502\":1}}],[\"则先会初始化它的父类\",{\"1\":{\"492\":1}}],[\"则将冲突的\",{\"1\":{\"472\":1}}],[\"则访问第一个tomcat服务\",{\"1\":{\"446\":1}}],[\"则查询数据库\",{\"1\":{\"414\":1}}],[\"则查询tomcat\",{\"1\":{\"414\":1}}],[\"则去直接查询redis\",{\"1\":{\"414\":1}}],[\"则根据itcast计算\",{\"1\":{\"402\":1}}],[\"则判定服务下线\",{\"1\":{\"394\":1}}],[\"则判断slave节点的offset值\",{\"1\":{\"393\":1}}],[\"则该实例客观下线\",{\"1\":{\"392\":1}}],[\"则该行是\",{\"1\":{\"302\":1,\"363\":1}}],[\"则认为该实例主观下线\",{\"1\":{\"392\":1}}],[\"则可以采用主\",{\"1\":{\"387\":1}}],[\"则可以插入成功\",{\"1\":{\"296\":3,\"297\":2}}],[\"则表示禁用rdb\",{\"1\":{\"373\":1}}],[\"则表示这两个点是连接在一起的\",{\"1\":{\"58\":1}}],[\"则执行参数二的lambda表达式\",{\"1\":{\"416\":1}}],[\"则执行bgsave\",{\"1\":{\"373\":1}}],[\"则执行回表操作\",{\"1\":{\"149\":1}}],[\"则是不可达的\",{\"1\":{\"517\":1}}],[\"则是\",{\"1\":{\"359\":1}}],[\"则是在这些记录的索引上加\",{\"1\":{\"294\":1}}],[\"则商品在商家手中\",{\"1\":{\"352\":1}}],[\"则给商家付了钱\",{\"1\":{\"352\":1}}],[\"则提交事务\",{\"1\":{\"346\":1}}],[\"则回滚事务\",{\"1\":{\"346\":1}}],[\"则要执行这条命令\",{\"1\":{\"307\":2}}],[\"则要在两个实体连线方向各写n\",{\"1\":{\"90\":1}}],[\"则无法插入成功\",{\"1\":{\"296\":1,\"297\":1}}],[\"则只需开辟新的数据页\",{\"1\":{\"226\":1}}],[\"则需要先触发其父类的初始化\",{\"1\":{\"492\":1}}],[\"则需要判断\",{\"1\":{\"359\":1}}],[\"则需要把数据页分割为两个数据页\",{\"1\":{\"226\":1}}],[\"则需要安装\",{\"1\":{\"26\":1}}],[\"则就不会被统计进去\",{\"1\":{\"191\":1}}],[\"则性能会很差\",{\"1\":{\"179\":1}}],[\"则在左子树中进行查找\",{\"1\":{\"250\":1}}],[\"则在右子树中进行查找\",{\"1\":{\"250\":1}}],[\"则在字节的高位补\",{\"1\":{\"162\":1}}],[\"则在其名称下划一下划线\",{\"1\":{\"90\":1}}],[\"则每个列对应一个二进制位\",{\"1\":{\"162\":1}}],[\"则直接跳过该二级索引\",{\"1\":{\"149\":1}}],[\"则直接从服务器重新下载\",{\"1\":{\"42\":1}}],[\"则会退化为链表\",{\"1\":{\"473\":1}}],[\"则会排除该slave节点\",{\"1\":{\"393\":1}}],[\"则会拷贝一份数据\",{\"1\":{\"374\":1}}],[\"则会将我的余额改成\",{\"1\":{\"357\":1}}],[\"则会将存储的数据\",{\"1\":{\"152\":1}}],[\"则会报错\",{\"1\":{\"139\":1}}],[\"则会收到如下的报错\",{\"1\":{\"139\":1}}],[\"则选择协作图\",{\"1\":{\"86\":1}}],[\"则使用序列图\",{\"1\":{\"86\":1}}],[\"则包名称标在上面的小矩形内\",{\"1\":{\"73\":1}}],[\"则按照框图逐步检查程序是很容易发现其错误的\",{\"1\":{\"58\":1}}],[\"则不会从服务器抓取\",{\"1\":{\"42\":1}}],[\"则必须要有或者\",{\"1\":{\"39\":1}}],[\"而softreference和byte数组则是软引用\",{\"1\":{\"520\":1}}],[\"而李秘书是不是也要在接到预约赵老板a方面事情的电话时说自己不负责这方面呢\",{\"1\":{\"506\":1}}],[\"而1要求了构造器的权限\",{\"1\":{\"498\":1}}],[\"而红黑树的查找\",{\"1\":{\"473\":1}}],[\"而cleaner类为虚引用\",{\"1\":{\"522\":1}}],[\"而canal就是把自己伪装成mysql的一个slave节点\",{\"1\":{\"458\":1}}],[\"而content\",{\"1\":{\"435\":1}}],[\"而异步实现又可以基于mq或者canal来实现\",{\"1\":{\"456\":1}}],[\"而后修改商品查询\",{\"1\":{\"451\":1}}],[\"而默认的负载均衡规则是轮询模式\",{\"1\":{\"445\":1}}],[\"而nginx编程又离不开openresty\",{\"1\":{\"431\":1}}],[\"而变量的声明必须先知道数据的类型\",{\"1\":{\"423\":1}}],[\"而造成的幻读问题\",{\"1\":{\"365\":1}}],[\"而此时正好事务\",{\"1\":{\"354\":1}}],[\"而此证书\",{\"1\":{\"108\":1}}],[\"而已经持久化到磁盘的数据就不会有影响\",{\"1\":{\"343\":1}}],[\"而写入数据需要先找到写入位置\",{\"1\":{\"337\":1}}],[\"而内存总是不可靠\",{\"1\":{\"337\":1}}],[\"而对表中的所有记录加上锁\",{\"1\":{\"331\":1}}],[\"而对于幻读现象\",{\"1\":{\"361\":1}}],[\"而对于第一个不符合条件的二级索引记录\",{\"1\":{\"295\":1,\"300\":1}}],[\"而对于大量的单个索引查询的场景\",{\"1\":{\"256\":1}}],[\"而这期间除了\",{\"1\":{\"329\":1}}],[\"而这个场景下查询的记录是不存在的\",{\"1\":{\"291\":1}}],[\"而这个函数是在\",{\"1\":{\"144\":1}}],[\"而插入操作为了获取到插入意向锁\",{\"1\":{\"326\":1}}],[\"而插入意向锁和间隙锁是冲突的\",{\"1\":{\"325\":1}}],[\"而插入意向锁与间隙锁是冲突的\",{\"1\":{\"275\":1}}],[\"而普通的\",{\"1\":{\"311\":1}}],[\"而导致后续的申请读锁的查询操作也会被阻塞\",{\"1\":{\"310\":1}}],[\"而导致树的高度变高\",{\"1\":{\"251\":1}}],[\"而库存少了\",{\"1\":{\"307\":1}}],[\"而出现备份文件的数据与预期的不一样\",{\"1\":{\"307\":1}}],[\"而出现幻读的问题\",{\"1\":{\"274\":1}}],[\"而把整个表给锁住了呢\",{\"1\":{\"304\":1}}],[\"而把剩余的数据放在\",{\"1\":{\"168\":1,\"169\":1}}],[\"而锁范围的最左值为\",{\"1\":{\"304\":1}}],[\"而该位置的下一条是\",{\"1\":{\"296\":3,\"297\":1}}],[\"而间隙锁是前开后开区间\",{\"1\":{\"288\":1}}],[\"而间隙锁与间隙锁之间是兼容的\",{\"1\":{\"275\":1}}],[\"而接下来的插入操作为了获取到插入意向锁\",{\"1\":{\"275\":1,\"325\":1}}],[\"而正是因为这样的操作\",{\"1\":{\"273\":1}}],[\"而我们在日常开发使用时\",{\"1\":{\"264\":1}}],[\"而树的高度决定于磁盘\",{\"1\":{\"258\":1}}],[\"而存储功能是由\",{\"1\":{\"258\":1}}],[\"而索引的个数为\",{\"1\":{\"255\":1}}],[\"而从平均时间代价来看\",{\"1\":{\"254\":1}}],[\"而用户的记录数据的大小很有可能远远超过了索引数据\",{\"1\":{\"252\":1}}],[\"而用摘要的话\",{\"1\":{\"108\":1}}],[\"而磁盘\",{\"1\":{\"248\":1}}],[\"而磁盘访问的速度是毫秒级别的\",{\"1\":{\"248\":1}}],[\"而数据页中的页目录就是为了能快速找到记录\",{\"1\":{\"243\":1}}],[\"而数据页与此几乎大同小异\",{\"1\":{\"186\":1}}],[\"而条件语句中的输入参数是数字的话\",{\"1\":{\"241\":1}}],[\"而前面我们也说了\",{\"1\":{\"238\":1}}],[\"而没有走索引\",{\"1\":{\"235\":1}}],[\"而发生全表扫描\",{\"1\":{\"234\":1}}],[\"而聚簇索引记录的东西会更多\",{\"1\":{\"232\":1}}],[\"而第二个事务是想对该记录加上\",{\"1\":{\"280\":1}}],[\"而第二例子不会呢\",{\"1\":{\"238\":1}}],[\"而第一和第二条查询语句的执行计划中\",{\"1\":{\"232\":1}}],[\"而第三和第四条会发生索引失效\",{\"1\":{\"231\":1}}],[\"而在\",{\"1\":{\"228\":1,\"240\":1,\"241\":1,\"341\":1}}],[\"而有时需要访问到叶子节点才能找到索引\",{\"1\":{\"254\":1}}],[\"而有的数据库则不包含\",{\"1\":{\"216\":1}}],[\"而有些方法则需要较多的步骤\",{\"1\":{\"58\":1}}],[\"而二级索引可以创建多个\",{\"1\":{\"257\":1}}],[\"而二级索引的叶子节点存放的是主键值\",{\"1\":{\"192\":1,\"234\":1,\"257\":1}}],[\"而二叉树的每个父节点的儿子节点个数只能是\",{\"1\":{\"207\":1}}],[\"而非叶子节点存放的是主键和页号\",{\"1\":{\"188\":1}}],[\"而非叶子节点是用来存放索引数据的\",{\"1\":{\"187\":1}}],[\"而页号也是固定的\",{\"1\":{\"187\":1}}],[\"而新的页有两种可能\",{\"1\":{\"187\":1}}],[\"而将预读机制去掉\",{\"1\":{\"178\":1}}],[\"而末尾淘汰的页\",{\"1\":{\"178\":1}}],[\"而当带上\",{\"1\":{\"197\":1}}],[\"而当\",{\"1\":{\"178\":1,\"343\":1}}],[\"而如果同样的节点数量在平衡二叉树的场景下\",{\"1\":{\"252\":1}}],[\"而如果记录是顺序插入的\",{\"1\":{\"226\":1}}],[\"而如果接下来\",{\"1\":{\"178\":1}}],[\"而如果是http作为反向代理来说\",{\"1\":{\"49\":1}}],[\"而如果是\",{\"1\":{\"48\":1}}],[\"而链表末尾的节点是最久没被使用的\",{\"1\":{\"178\":1}}],[\"而一些情况则无法插入\",{\"1\":{\"298\":2}}],[\"而一些情况则无法成功插入\",{\"1\":{\"296\":2,\"297\":2}}],[\"而一些很少访问的数据希望可以在某些时机可以淘汰掉\",{\"1\":{\"178\":1}}],[\"而一个\",{\"1\":{\"168\":1}}],[\"而每个控制块包含着对应缓存页的地址\",{\"1\":{\"176\":1}}],[\"而使用的步骤与哨兵模式基本一致\",{\"1\":{\"412\":1}}],[\"而使用了单纯的\",{\"1\":{\"274\":1}}],[\"而使用到的物理内存空间却很小\",{\"1\":{\"174\":1,\"336\":1}}],[\"而使用索引下推后\",{\"1\":{\"149\":1}}],[\"而实际开发中\",{\"1\":{\"445\":1}}],[\"而实际的数据都存储在溢出页中\",{\"1\":{\"168\":1,\"169\":1}}],[\"而实际使用过程中\",{\"1\":{\"99\":1}}],[\"而是记录下这段内存的起始结束地址\",{\"1\":{\"527\":1}}],[\"而是用local来声明变量为局部变量\",{\"1\":{\"425\":1}}],[\"而是一个编写业务的web服务器了\",{\"1\":{\"414\":1}}],[\"而是与插槽绑定\",{\"1\":{\"402\":1}}],[\"而是当前读了\",{\"1\":{\"361\":1}}],[\"而是沿着\",{\"1\":{\"359\":1}}],[\"而是创建\",{\"1\":{\"358\":1}}],[\"而是推迟到组提交的\",{\"1\":{\"348\":1}}],[\"而是先快照读\",{\"1\":{\"369\":1}}],[\"而是先写\",{\"1\":{\"343\":1,\"350\":1}}],[\"而是先写日志\",{\"1\":{\"337\":1}}],[\"而是先记录在日志上\",{\"1\":{\"337\":1}}],[\"而是先判断一下该索引中包含的列\",{\"1\":{\"149\":1}}],[\"而是再执行完插入语句后就会立即释放\",{\"1\":{\"312\":1}}],[\"而是报主键冲突的错误\",{\"1\":{\"291\":1}}],[\"而是会等待一段时间\",{\"1\":{\"348\":1}}],[\"而是会等事务结束时才会释放\",{\"1\":{\"329\":1}}],[\"而是会报主键冲突的错误\",{\"1\":{\"285\":1}}],[\"而是会用隐式锁保护唯一二级索引的记录\",{\"1\":{\"280\":1}}],[\"而是允许\",{\"1\":{\"252\":1}}],[\"而是主键值则就是二级索引\",{\"1\":{\"246\":1}}],[\"而是逻辑上的连续\",{\"1\":{\"243\":1}}],[\"而是走全扫描二级索引树\",{\"1\":{\"232\":1}}],[\"而是二级索引\",{\"1\":{\"192\":1}}],[\"而是\",{\"1\":{\"187\":1,\"360\":1}}],[\"而是想少量\",{\"1\":{\"182\":1}}],[\"而是将\",{\"1\":{\"177\":1}}],[\"而是按照区\",{\"1\":{\"156\":1}}],[\"而是以页为单位\",{\"1\":{\"155\":1,\"243\":1}}],[\"而是在一次读或写操作后\",{\"1\":{\"416\":1}}],[\"而是在\",{\"1\":{\"144\":1}}],[\"而是指向被继承\",{\"1\":{\"61\":1}}],[\"而\",{\"1\":{\"110\":1,\"178\":1,\"180\":1,\"197\":1,\"207\":2,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"228\":1,\"238\":1,\"252\":1,\"256\":1,\"258\":1,\"283\":1,\"290\":1,\"296\":2,\"302\":2,\"313\":1,\"340\":1,\"344\":3,\"357\":1,\"361\":1,\"363\":2}}],[\"而私钥只有\",{\"1\":{\"107\":1}}],[\"而公钥是公开的\",{\"1\":{\"107\":1}}],[\"而rapidocr解决了这个问题\",{\"1\":{\"99\":1}}],[\"而通信图则关注的是对象之间的组织关系\",{\"1\":{\"86\":1}}],[\"而不会出现用户\",{\"1\":{\"352\":1}}],[\"而不能更新数据\",{\"1\":{\"307\":1}}],[\"而不能定位到页中的一条记录\",{\"1\":{\"174\":1}}],[\"而不同的存储引擎采用的索引数据结构也会不相同\",{\"1\":{\"234\":1}}],[\"而不扫描聚簇索引树呢\",{\"1\":{\"232\":1}}],[\"而不需要等待整个插入语句执行完后才释放锁\",{\"1\":{\"312\":1}}],[\"而不需要通过聚簇索引查询获得\",{\"1\":{\"225\":1}}],[\"而不需要从第一个\",{\"1\":{\"216\":2}}],[\"而不常查询的数据就淘汰出去\",{\"1\":{\"180\":1}}],[\"而不是用取模运算\",{\"1\":{\"475\":1}}],[\"而不是轮询\",{\"1\":{\"445\":1}}],[\"而不是索引的话\",{\"1\":{\"330\":1}}],[\"而不是记录锁的意思\",{\"1\":{\"275\":1,\"279\":1,\"280\":1,\"290\":1,\"304\":1,\"322\":1}}],[\"而不是经过函数计算后的值\",{\"1\":{\"236\":1}}],[\"而不是在整个字段上建立的索引\",{\"1\":{\"213\":1}}],[\"而不是实际数据\",{\"1\":{\"192\":1,\"206\":1,\"208\":1,\"234\":1,\"245\":1,\"257\":1}}],[\"而不是实际的类\",{\"1\":{\"68\":1}}],[\"而不是\",{\"1\":{\"161\":1,\"237\":1}}],[\"而不再使用location块中的正则uri和请求字符串做匹配\",{\"1\":{\"39\":1}}],[\"而且aof会记录对同一个key的多次写操作\",{\"1\":{\"379\":1}}],[\"而且最新记录的\",{\"1\":{\"359\":1}}],[\"而且事务在执行过程中发生错误\",{\"1\":{\"352\":1}}],[\"而且磁盘的运行速度远慢于内存\",{\"1\":{\"337\":1}}],[\"而且意向锁之间也不会发生冲突\",{\"1\":{\"311\":1}}],[\"而且由于\",{\"1\":{\"307\":1}}],[\"而且也没有达到终止扫描的条件\",{\"1\":{\"294\":1}}],[\"而且也要能高效地执行范围查找\",{\"1\":{\"248\":1}}],[\"而且记录锁是有\",{\"1\":{\"285\":1,\"314\":1}}],[\"而且会随着插入的元素越多\",{\"1\":{\"250\":1}}],[\"而且从\",{\"1\":{\"232\":1}}],[\"而且都是选择扫描二级索引\",{\"1\":{\"231\":1}}],[\"而且无法利用索引完成排序操作的时候\",{\"1\":{\"228\":1}}],[\"而且可以看到\",{\"1\":{\"216\":1}}],[\"而且可以在调试程序中用来检查程序的正确性\",{\"1\":{\"58\":1}}],[\"而且每个节点里的数据是按主键顺序存放\",{\"1\":{\"204\":1}}],[\"而且每一份都是\",{\"1\":{\"184\":1}}],[\"而且影响查询性能的还有很多其他因素\",{\"1\":{\"187\":1}}],[\"而且这个\",{\"1\":{\"187\":1}}],[\"而且\",{\"1\":{\"186\":1,\"194\":1,\"244\":1,\"252\":1,\"255\":1}}],[\"而且大小也是\",{\"1\":{\"186\":1}}],[\"而且还会比\",{\"1\":{\"178\":1}}],[\"而且是等值查询\",{\"1\":{\"147\":1}}],[\"而且nginx提供了以下几种分配方式\",{\"1\":{\"41\":1}}],[\"而结束符号可出现多次\",{\"1\":{\"57\":1}}],[\"而流程图则是承载上述程序的图形载体\",{\"1\":{\"54\":1}}],[\"而develop分支才是用于集成各种功能开发的分支\",{\"1\":{\"14\":1}}],[\"==\",{\"1\":{\"450\":2,\"473\":2,\"508\":1}}],[\"==两部分组成\",{\"1\":{\"272\":1}}],[\"=n\",{\"1\":{\"343\":1}}],[\"=22\",{\"1\":{\"296\":1}}],[\"=5\",{\"1\":{\"291\":1}}],[\"=512\",{\"1\":{\"182\":1}}],[\"=6\",{\"1\":{\"236\":1}}],[\"=<\",{\"1\":{\"216\":1}}],[\"=x^\",{\"1\":{\"187\":2}}],[\"=0\",{\"1\":{\"186\":1}}],[\"=100\",{\"1\":{\"182\":1}}],[\"=\",{\"1\":{\"39\":2,\"137\":2,\"145\":2,\"147\":3,\"148\":1,\"149\":2,\"161\":3,\"166\":8,\"169\":2,\"182\":2,\"187\":13,\"204\":3,\"206\":2,\"215\":3,\"216\":15,\"217\":1,\"219\":1,\"237\":5,\"238\":7,\"239\":4,\"240\":2,\"252\":1,\"263\":2,\"264\":3,\"265\":1,\"266\":1,\"275\":5,\"277\":1,\"280\":1,\"283\":2,\"285\":3,\"286\":1,\"287\":2,\"290\":8,\"291\":14,\"293\":14,\"294\":25,\"296\":35,\"297\":56,\"298\":22,\"303\":1,\"304\":6,\"312\":7,\"313\":1,\"314\":1,\"315\":1,\"316\":2,\"317\":1,\"322\":2,\"323\":2,\"329\":1,\"333\":2,\"343\":6,\"344\":5,\"347\":2,\"348\":1,\"350\":3,\"359\":1,\"365\":1,\"367\":11,\"405\":1,\"416\":7,\"425\":6,\"426\":2,\"439\":1,\"441\":3,\"442\":10,\"443\":7,\"444\":10,\"448\":5,\"450\":29,\"451\":18,\"453\":2,\"454\":19,\"462\":4,\"463\":6,\"473\":1,\"474\":1,\"480\":1,\"485\":1,\"486\":2,\"487\":1,\"488\":2,\"496\":9,\"498\":2,\"499\":16,\"501\":3,\"502\":7,\"503\":3,\"506\":2,\"507\":6,\"508\":11}}],[\"使得num这个key可以存储到7004实例\",{\"1\":{\"405\":1}}],[\"使得\",{\"1\":{\"348\":1}}],[\"使得之后的\",{\"1\":{\"187\":1}}],[\"使\",{\"1\":{\"341\":1}}],[\"使其起到索引作用\",{\"1\":{\"244\":1}}],[\"使其尽可能满足产业落地需求\",{\"1\":{\"99\":1}}],[\"使了用临时表保存中间结果\",{\"1\":{\"228\":1}}],[\"使流程图清晰\",{\"1\":{\"58\":1}}],[\"使计算机进行工作\",{\"1\":{\"58\":1}}],[\"使配置文件生效\",{\"1\":{\"38\":1}}],[\"使用一个代理将对象包装起来\",{\"1\":{\"505\":1}}],[\"使用classloader\",{\"1\":{\"496\":1}}],[\"使用classloader加载src目录下的配置文件\",{\"0\":{\"496\":1}}],[\"使用java\",{\"1\":{\"492\":1}}],[\"使用分片集群可以解决上述问题\",{\"1\":{\"400\":1}}],[\"使用全局锁会影响业务\",{\"1\":{\"307\":1}}],[\"使用了内部\",{\"1\":{\"345\":1}}],[\"使用了\",{\"1\":{\"274\":1,\"344\":1}}],[\"使用了索引下推功能\",{\"1\":{\"239\":1}}],[\"使用了索引下推后\",{\"1\":{\"149\":1}}],[\"使用逗号\",{\"1\":{\"263\":1}}],[\"使用关键字inner\",{\"1\":{\"263\":1}}],[\"使用哪种数据结构作为索引\",{\"1\":{\"258\":1}}],[\"使用哪种存储引擎有关\",{\"1\":{\"234\":1}}],[\"使用的思路为\",{\"1\":{\"520\":1}}],[\"使用的时候\",{\"1\":{\"442\":1}}],[\"使用的\",{\"1\":{\"257\":1}}],[\"使用的是\",{\"1\":{\"139\":1}}],[\"使用二分法快速定位要查询的记录在哪个槽\",{\"1\":{\"244\":1}}],[\"使用左模糊匹配\",{\"1\":{\"232\":1}}],[\"使用覆盖索引的好处就是\",{\"1\":{\"225\":1}}],[\"使用前缀索引可以帮助我们减小索引项的大小\",{\"1\":{\"224\":1}}],[\"使用前缀索引是为了减小索引字段大小\",{\"1\":{\"224\":1}}],[\"使用前缀索引的目的是为了减少索引占用的存储空间\",{\"1\":{\"213\":1}}],[\"使用到\",{\"1\":{\"218\":1}}],[\"使用联合索引时\",{\"1\":{\"215\":1}}],[\"使用长连接后可能会占用内存增多\",{\"1\":{\"139\":1}}],[\"使用长连接的好处就是可以减少建立连接和断开连接的过程\",{\"1\":{\"139\":1}}],[\"使用对称加密的通信双方使用同一把密钥进行加解密\",{\"1\":{\"106\":1}}],[\"使用对象图为这些对象建模\",{\"1\":{\"72\":1}}],[\"使用ncnn和onnx推理引擎方式\",{\"1\":{\"100\":1}}],[\"使用部署图不仅可以显示运行时系统的结构\",{\"1\":{\"74\":1}}],[\"使用yum命令进行安装\",{\"1\":{\"43\":1}}],[\"使用wget命令下载\",{\"1\":{\"28\":1}}],[\"使用\",{\"0\":{\"230\":1},\"1\":{\"26\":1,\"96\":1,\"108\":1,\"178\":1,\"197\":1,\"330\":2,\"340\":1,\"346\":1,\"519\":1,\"520\":1,\"521\":1}}],[\"使用版本号为master上的所有提交打标签\",{\"1\":{\"14\":1}}],[\"使用专门的一个分支来为发布做准备的好处是\",{\"1\":{\"12\":1}}],[\"重要步骤的注释说明已经写在了对应位置\",{\"1\":{\"494\":1}}],[\"重放\",{\"1\":{\"458\":1}}],[\"重新加载openresty\",{\"1\":{\"447\":1}}],[\"重新加载并测试\",{\"1\":{\"439\":1}}],[\"重新加载配置\",{\"1\":{\"436\":1}}],[\"重新夺回master地位\",{\"1\":{\"411\":1}}],[\"重启会进行回滚操作\",{\"1\":{\"346\":1}}],[\"重启就提交事务\",{\"1\":{\"346\":1}}],[\"重启后会按顺序扫描\",{\"1\":{\"346\":1}}],[\"重启后会通过\",{\"1\":{\"337\":2}}],[\"重启后之前已提交的记录都不会丢失\",{\"1\":{\"337\":1}}],[\"重启后\",{\"1\":{\"337\":1,\"344\":1,\"346\":1}}],[\"重启nginx服务器\",{\"1\":{\"38\":1}}],[\"重做日志文件组写入过程\",{\"1\":{\"339\":1}}],[\"重做日志文件组是以循环写的方式工作的\",{\"1\":{\"339\":1}}],[\"重做日志文件组\",{\"1\":{\"339\":2}}],[\"重做日志\",{\"1\":{\"272\":1,\"333\":2,\"352\":1}}],[\"重载\",{\"1\":{\"31\":1}}],[\"开车\",{\"1\":{\"351\":1}}],[\"开车速度不要超过\",{\"1\":{\"181\":1}}],[\"开启共享字典\",{\"1\":{\"453\":1}}],[\"开启\",{\"1\":{\"345\":1}}],[\"开启事务\",{\"1\":{\"343\":1,\"350\":1}}],[\"开启事务后\",{\"1\":{\"336\":1,\"337\":1}}],[\"开启事务和\",{\"1\":{\"334\":1}}],[\"开启事务的语句\",{\"1\":{\"283\":1}}],[\"开启安全更新模式\",{\"1\":{\"330\":1}}],[\"开启主动死锁检测\",{\"1\":{\"281\":1}}],[\"开启两个事务\",{\"1\":{\"280\":1}}],[\"开始从新的master上同步数据\",{\"1\":{\"393\":1}}],[\"开始事务\",{\"1\":{\"357\":1}}],[\"开始比赛之前\",{\"1\":{\"344\":1}}],[\"开始前\",{\"1\":{\"337\":1}}],[\"开始实验\",{\"0\":{\"320\":1}}],[\"开始回表\",{\"1\":{\"239\":1}}],[\"开始一个个回表\",{\"1\":{\"217\":1}}],[\"开始往上算\",{\"1\":{\"186\":1}}],[\"开始\",{\"1\":{\"140\":1,\"236\":1}}],[\"开始符号只能出现一次\",{\"1\":{\"57\":1}}],[\"开箱即用\",{\"1\":{\"99\":1}}],[\"开放对外访问的端口号9001\",{\"1\":{\"38\":1}}],[\"开发工具\",{\"2\":{\"50\":1,\"92\":1}}],[\"开发的一个二次开发库\",{\"1\":{\"26\":1}}],[\"开发新模块\",{\"1\":{\"15\":1}}],[\"开发完毕后才能合并\",{\"1\":{\"10\":1}}],[\"②通过运行时类的对象\",{\"0\":{\"486\":1}}],[\"②\",{\"0\":{\"502\":1,\"506\":1},\"1\":{\"89\":1,\"90\":1}}],[\"②配置nginx\",{\"0\":{\"38\":1}}],[\"②相关命令\",{\"0\":{\"35\":1}}],[\"①调用指定的属性\",{\"0\":{\"501\":1}}],[\"①\",{\"0\":{\"485\":1,\"505\":1},\"1\":{\"89\":1,\"90\":1}}],[\"①启动多个tomcat\",{\"0\":{\"37\":1}}],[\"①下载安装\",{\"0\":{\"34\":1}}],[\"注解\",{\"1\":{\"480\":1,\"490\":1,\"499\":1}}],[\"注释框\",{\"1\":{\"58\":1}}],[\"注意两点\",{\"1\":{\"463\":1}}],[\"注意是一个列表\",{\"1\":{\"358\":1}}],[\"注意是一行的总长度\",{\"1\":{\"165\":1}}],[\"注意是很大程度避免\",{\"1\":{\"357\":1}}],[\"注意下面的过程针对的是\",{\"1\":{\"348\":1}}],[\"注意写入到\",{\"1\":{\"338\":1,\"349\":1}}],[\"注意查询条件值的记录\",{\"1\":{\"294\":2}}],[\"注意这是接口函数不是命令\",{\"1\":{\"139\":1}}],[\"注意\",{\"1\":{\"39\":1,\"61\":1,\"81\":2,\"100\":1,\"178\":1,\"216\":2,\"255\":1,\"275\":1,\"279\":1,\"280\":2,\"285\":1,\"291\":1,\"324\":1,\"344\":1,\"357\":1,\"416\":1,\"441\":1}}],[\"注意此时是基于develop新建的\",{\"1\":{\"15\":1}}],[\"注\",{\"1\":{\"35\":1,\"75\":2,\"107\":1}}],[\"|grep\",{\"1\":{\"44\":1}}],[\"|\",{\"1\":{\"35\":1,\"39\":3,\"43\":1,\"49\":2,\"139\":12,\"152\":6,\"290\":8,\"293\":20,\"294\":24,\"297\":8,\"298\":12,\"367\":8,\"472\":1}}],[\"应用场景\",{\"1\":{\"520\":1,\"522\":1}}],[\"应用无需挂起\",{\"1\":{\"516\":1}}],[\"应用\",{\"1\":{\"432\":1}}],[\"应用部署目录\",{\"1\":{\"34\":1}}],[\"应该用质数作为容量\",{\"1\":{\"475\":1}}],[\"应该用2的n次幂作为容量\",{\"1\":{\"475\":1}}],[\"应该一眼就能看出会发生死锁\",{\"1\":{\"318\":1}}],[\"应该返回多少行\",{\"1\":{\"197\":1}}],[\"应该是可以做到索引扫描的\",{\"1\":{\"237\":1}}],[\"应该是\",{\"1\":{\"48\":1,\"359\":1}}],[\"应当整理好思路\",{\"1\":{\"58\":1}}],[\"应遵循从左到右\",{\"1\":{\"57\":1}}],[\"应在master分支上新建一个紧急分支\",{\"1\":{\"7\":1}}],[\"jihe\",{\"0\":{\"562\":1}}],[\"juc\",{\"0\":{\"566\":1},\"2\":{\"513\":1}}],[\"juc01\",{\"0\":{\"511\":1}}],[\"juejin\",{\"1\":{\"110\":1}}],[\"jvm整体架构\",{\"0\":{\"534\":1}}],[\"jvm概述\",{\"0\":{\"533\":1}}],[\"jvm内存不足\",{\"1\":{\"520\":1}}],[\"jvm首先将软引用中的对象引用置为null\",{\"1\":{\"520\":1}}],[\"jvm什么时候扫描回收对象是jvm自己的状态决定的\",{\"1\":{\"520\":1}}],[\"jvm\",{\"0\":{\"568\":1},\"1\":{\"483\":1,\"538\":3},\"2\":{\"532\":1,\"536\":1,\"541\":1}}],[\"jvm进程缓存\",{\"0\":{\"415\":1},\"1\":{\"2\":1,\"97\":1}}],[\"jdbc1\",{\"1\":{\"496\":2}}],[\"jdbc\",{\"1\":{\"478\":1,\"496\":1}}],[\"jdk1\",{\"1\":{\"472\":2}}],[\"jfs\",{\"1\":{\"436\":1,\"439\":1}}],[\"jsonprocessingexception\",{\"1\":{\"448\":1,\"463\":2}}],[\"json转化为lua的table\",{\"1\":{\"444\":1,\"451\":1,\"454\":1}}],[\"json为\",{\"1\":{\"443\":1}}],[\"json\",{\"1\":{\"435\":1,\"439\":1,\"443\":4,\"448\":4,\"463\":6}}],[\"join\",{\"1\":{\"263\":1,\"264\":3,\"265\":1}}],[\"join或者join\",{\"1\":{\"263\":1}}],[\"j\",{\"1\":{\"216\":12}}],[\"jgraph\",{\"1\":{\"91\":1}}],[\"jpg\",{\"1\":{\"42\":1,\"436\":2,\"439\":2}}],[\"jackson\",{\"1\":{\"448\":2,\"463\":2}}],[\"jack\",{\"1\":{\"379\":1,\"425\":1,\"426\":1,\"443\":2}}],[\"jay\",{\"1\":{\"344\":3}}],[\"jan06\",{\"1\":{\"44\":2}}],[\"java堆一般会分为新生代和老年代两个区域\",{\"1\":{\"525\":1}}],[\"java虚拟机就会把这个软引用加入到与之关联的引用队列中\",{\"1\":{\"520\":1}}],[\"java双亲委派机制及作用\",{\"1\":{\"508\":1}}],[\"java空参构造\",{\"1\":{\"498\":2,\"507\":1}}],[\"java类编译\",{\"0\":{\"495\":1}}],[\"java不是动态语言\",{\"1\":{\"480\":1}}],[\"javascript\",{\"1\":{\"480\":1}}],[\"java反射机制与策略模式\",{\"0\":{\"478\":1}}],[\"java的位运算比乘除的效率更高\",{\"1\":{\"473\":1}}],[\"javatool\",{\"1\":{\"463\":2}}],[\"javatool<\",{\"1\":{\"460\":1}}],[\"javax\",{\"1\":{\"462\":1}}],[\"java\",{\"0\":{\"98\":1,\"564\":1},\"1\":{\"34\":1,\"45\":1,\"425\":1,\"426\":1,\"448\":1,\"462\":1,\"463\":1,\"481\":2,\"487\":1,\"488\":1,\"494\":1,\"538\":1},\"2\":{\"111\":1,\"465\":1,\"466\":1,\"468\":1,\"469\":1,\"476\":1,\"477\":1,\"509\":1,\"510\":1,\"512\":1,\"513\":1,\"531\":1,\"532\":1,\"535\":1,\"536\":1,\"540\":1,\"541\":1}}],[\"javaweb\",{\"1\":{\"34\":1}}],[\"jar\",{\"1\":{\"34\":1}}],[\"runnable\",{\"1\":{\"506\":2}}],[\"runtimeexception\",{\"1\":{\"463\":1}}],[\"run\",{\"1\":{\"448\":1}}],[\"rimowa\",{\"1\":{\"436\":2,\"439\":2}}],[\"right\",{\"1\":{\"91\":2,\"264\":1,\"473\":1}}],[\"rdb和aof各有自己的优缺点\",{\"1\":{\"380\":1}}],[\"rdb与aof对比\",{\"0\":{\"380\":1}}],[\"rdb执行间隔时间长\",{\"1\":{\"375\":1}}],[\"rdb的缺点\",{\"1\":{\"375\":1}}],[\"rdb的其它配置也可以在redis\",{\"1\":{\"373\":1}}],[\"rdb会在什么时候执行\",{\"1\":{\"375\":1}}],[\"rdb方式bgsave的基本流程\",{\"1\":{\"375\":1}}],[\"rdb原理\",{\"0\":{\"374\":1}}],[\"rdb\",{\"1\":{\"373\":1,\"374\":1}}],[\"rdb文件名称\",{\"1\":{\"373\":1}}],[\"rdbcompression\",{\"1\":{\"373\":1}}],[\"rdb全称redis\",{\"1\":{\"372\":1}}],[\"rdb持久化在四种情况下会执行\",{\"1\":{\"373\":1}}],[\"rdb持久化\",{\"0\":{\"372\":1},\"1\":{\"371\":1}}],[\"rr\",{\"1\":{\"274\":1,\"320\":1}}],[\"r\",{\"1\":{\"234\":1}}],[\"range\",{\"1\":{\"228\":3,\"232\":1}}],[\"rand\",{\"1\":{\"182\":4}}],[\"rapidocr\",{\"0\":{\"98\":1}}],[\"r图的绘制步骤\",{\"1\":{\"91\":1}}],[\"r图的绘图规范\",{\"0\":{\"90\":1}}],[\"r图的定义\",{\"1\":{\"91\":1}}],[\"r图的具体绘制流程\",{\"0\":{\"91\":1}}],[\"r图中属性用来描述实体\",{\"1\":{\"89\":1}}],[\"r图中的基本元素\",{\"1\":{\"89\":1}}],[\"r图为例\",{\"1\":{\"89\":1}}],[\"r图又称实体关系图\",{\"1\":{\"89\":1}}],[\"r图\",{\"0\":{\"89\":1}}],[\"rodo\",{\"1\":{\"348\":1}}],[\"rollback\",{\"1\":{\"334\":1}}],[\"roll\",{\"1\":{\"164\":4,\"334\":3,\"358\":1}}],[\"rownum\",{\"1\":{\"182\":2}}],[\"rows\",{\"1\":{\"139\":1,\"199\":1,\"228\":1,\"275\":1,\"277\":2,\"290\":1,\"291\":1,\"293\":3,\"294\":4,\"296\":1,\"297\":1,\"298\":2,\"302\":1,\"322\":3,\"323\":3,\"324\":1,\"330\":1,\"363\":1,\"367\":4}}],[\"row\",{\"0\":{\"154\":1},\"1\":{\"139\":2,\"152\":1,\"153\":1,\"154\":1,\"158\":1,\"161\":1,\"164\":5,\"166\":1,\"197\":2,\"204\":1,\"275\":2,\"290\":1,\"293\":1,\"297\":1,\"302\":3,\"312\":2,\"324\":2,\"341\":5,\"363\":3,\"367\":3}}],[\"router\",{\"1\":{\"43\":3}}],[\"root引用的对象\",{\"1\":{\"529\":1}}],[\"root引用的对象从from放入to中\",{\"1\":{\"529\":1}}],[\"root的对象\",{\"1\":{\"517\":1}}],[\"roots\",{\"1\":{\"517\":3}}],[\"root\",{\"1\":{\"32\":1,\"38\":2,\"42\":2,\"44\":1,\"108\":1,\"109\":4,\"139\":2,\"152\":1,\"473\":3}}],[\"rpm\",{\"1\":{\"43\":1}}],[\"require\",{\"1\":{\"442\":1,\"443\":1,\"444\":2,\"450\":2,\"451\":3,\"454\":2}}],[\"requestmapping\",{\"1\":{\"419\":1}}],[\"requests\",{\"1\":{\"32\":1}}],[\"replica\",{\"1\":{\"398\":5}}],[\"replication\",{\"1\":{\"384\":1}}],[\"repl\",{\"0\":{\"386\":1},\"1\":{\"386\":1,\"388\":1}}],[\"repeatable\",{\"1\":{\"271\":1,\"353\":1,\"357\":1}}],[\"rewrite\",{\"1\":{\"379\":2}}],[\"reward列\",{\"1\":{\"149\":1}}],[\"reward\",{\"1\":{\"149\":11}}],[\"returnval\",{\"1\":{\"502\":2}}],[\"returnvalue\",{\"1\":{\"502\":1,\"507\":2}}],[\"return\",{\"1\":{\"398\":1,\"416\":1,\"419\":4,\"428\":1,\"442\":2,\"450\":7,\"451\":2,\"454\":2,\"507\":3,\"508\":4}}],[\"returned\",{\"1\":{\"302\":1,\"363\":1}}],[\"returns\",{\"1\":{\"302\":1,\"363\":1}}],[\"result\",{\"1\":{\"508\":2}}],[\"resultmap\",{\"1\":{\"508\":4}}],[\"resty\",{\"1\":{\"450\":2}}],[\"restcontroller\",{\"1\":{\"419\":1}}],[\"resp\",{\"1\":{\"441\":4,\"442\":3,\"450\":13}}],[\"respectively\",{\"1\":{\"275\":1,\"324\":1}}],[\"reset\",{\"1\":{\"139\":2}}],[\"reference\",{\"1\":{\"520\":1}}],[\"reference=referencequeue\",{\"1\":{\"520\":1}}],[\"reference<\",{\"1\":{\"520\":1}}],[\"referencequeue\",{\"1\":{\"520\":1,\"522\":2}}],[\"referencequeue<>\",{\"1\":{\"520\":1}}],[\"referencequeue<string>\",{\"1\":{\"520\":1}}],[\"referencequeue=new\",{\"1\":{\"520\":1}}],[\"referer\",{\"1\":{\"32\":1}}],[\"reflect包的方法对类进行反射调用\",{\"1\":{\"492\":1}}],[\"reflectiontest\",{\"1\":{\"488\":1}}],[\"reflection\",{\"1\":{\"480\":1}}],[\"ref\",{\"1\":{\"228\":7}}],[\"recollect\",{\"0\":{\"547\":1}}],[\"recordenum\",{\"1\":{\"508\":2}}],[\"recordstrategy\",{\"1\":{\"508\":2}}],[\"records\",{\"1\":{\"185\":4,\"243\":1,\"275\":1,\"324\":1}}],[\"record\",{\"0\":{\"285\":1,\"314\":1},\"1\":{\"147\":2,\"148\":3,\"163\":2,\"275\":3,\"279\":1,\"280\":1,\"284\":2,\"285\":1,\"287\":1,\"290\":1,\"293\":5,\"298\":2,\"304\":2,\"313\":2,\"314\":1,\"316\":1,\"322\":1}}],[\"rec\",{\"1\":{\"275\":1,\"279\":1,\"280\":2,\"290\":1,\"304\":1,\"322\":1}}],[\"recently\",{\"1\":{\"178\":1}}],[\"readfrom\",{\"1\":{\"398\":2}}],[\"readview来实现的\",{\"1\":{\"357\":1}}],[\"readview\",{\"1\":{\"334\":2,\"357\":1,\"367\":1}}],[\"read\",{\"0\":{\"358\":1},\"1\":{\"147\":2,\"148\":3,\"271\":3,\"302\":1,\"307\":4,\"309\":1,\"311\":1,\"334\":7,\"353\":3,\"357\":8,\"358\":14,\"359\":11,\"360\":14,\"361\":6,\"363\":1,\"364\":3,\"442\":7,\"444\":4,\"450\":11,\"451\":16,\"454\":12}}],[\"red\",{\"1\":{\"450\":14}}],[\"redundant\",{\"1\":{\"158\":4}}],[\"redolog\",{\"1\":{\"272\":1,\"346\":2,\"348\":2}}],[\"redo\",{\"0\":{\"333\":1,\"337\":1,\"338\":1,\"339\":1,\"341\":1},\"1\":{\"96\":1,\"179\":3,\"180\":1,\"272\":3,\"332\":1,\"333\":2,\"337\":24,\"338\":25,\"339\":14,\"340\":3,\"341\":8,\"343\":3,\"344\":9,\"345\":7,\"346\":19,\"347\":7,\"348\":12,\"349\":7,\"350\":7,\"352\":1}}],[\"redishandler\",{\"1\":{\"448\":1,\"463\":7}}],[\"redis中并没有缓存\",{\"1\":{\"448\":1}}],[\"redis查询失败\",{\"1\":{\"451\":4,\"454\":4}}],[\"redis查询\",{\"1\":{\"414\":1}}],[\"redis如何判断某个key应该在哪个实例\",{\"1\":{\"403\":1}}],[\"redis会根据key的有效部分计算插槽值\",{\"1\":{\"402\":1}}],[\"redis会把每一个master节点映射到0~16383共16384个插槽\",{\"1\":{\"402\":1}}],[\"redis分片集群\",{\"0\":{\"399\":1}}],[\"redis分布式缓存\",{\"0\":{\"370\":1}}],[\"redis<\",{\"1\":{\"396\":1,\"448\":1}}],[\"redis的客户端必须感知这种变化\",{\"1\":{\"395\":1}}],[\"redistemplate底层同样基于lettuce实现了分片集群的支持\",{\"1\":{\"412\":1}}],[\"redistemplate访问分片集群\",{\"0\":{\"412\":1}}],[\"redistemplate\",{\"0\":{\"395\":1},\"1\":{\"448\":3,\"463\":5}}],[\"redis提供了哨兵\",{\"1\":{\"389\":1}}],[\"redis哨兵\",{\"0\":{\"389\":1}}],[\"redis单节点上的内存占用不要太大\",{\"1\":{\"387\":1}}],[\"redis主从\",{\"0\":{\"381\":1}}],[\"redis也会在触发阈值时自动去重写aof文件\",{\"1\":{\"379\":1}}],[\"redis处理的每一个写命令都会记录在aof文件\",{\"1\":{\"377\":1}}],[\"redis内部有触发rdb的机制\",{\"1\":{\"373\":1}}],[\"redis停机时会执行一次save命令\",{\"1\":{\"373\":1}}],[\"redis停机时\",{\"1\":{\"373\":1}}],[\"redis数据备份文件\",{\"1\":{\"372\":1}}],[\"redis有两种持久化方案\",{\"1\":{\"371\":1}}],[\"redis持久化\",{\"0\":{\"371\":1}}],[\"redis常用场景\",{\"1\":{\"97\":1}}],[\"redis食用指南\",{\"0\":{\"97\":1}}],[\"redis面试题\",{\"1\":{\"3\":1}}],[\"redis缓存已经准备就绪\",{\"1\":{\"449\":1}}],[\"redis缓存会面临冷启动问题\",{\"1\":{\"448\":1}}],[\"redis缓存预热\",{\"0\":{\"448\":1}}],[\"redis缓存失效时\",{\"1\":{\"414\":1}}],[\"redis缓存\",{\"1\":{\"2\":1,\"97\":1,\"440\":1}}],[\"redis\",{\"1\":{\"2\":1,\"47\":1,\"397\":1,\"404\":1,\"406\":4,\"407\":2,\"410\":1,\"412\":1,\"414\":1,\"448\":5,\"450\":16,\"451\":6,\"454\":4,\"463\":1}}],[\"relay\",{\"1\":{\"342\":2,\"458\":2}}],[\"reload\",{\"1\":{\"31\":1,\"436\":1,\"439\":1,\"447\":1}}],[\"release<\",{\"1\":{\"460\":1}}],[\"releases\",{\"1\":{\"91\":1}}],[\"release\",{\"1\":{\"6\":1,\"7\":3,\"8\":1,\"12\":1,\"15\":5}}],[\"regular\",{\"1\":{\"26\":1}}],[\"^2\",{\"1\":{\"187\":2}}],[\"^1\",{\"1\":{\"187\":1}}],[\"^~\",{\"1\":{\"39\":2}}],[\"^\",{\"1\":{\"32\":1,\"474\":1}}],[\"~~21\",{\"1\":{\"183\":1}}],[\"~80\",{\"1\":{\"173\":1}}],[\"~为区分大小写\",{\"1\":{\"32\":1}}],[\"~\",{\"1\":{\"32\":2,\"38\":2,\"39\":4,\"439\":1}}],[\"热备\",{\"1\":{\"32\":1}}],[\"util\",{\"1\":{\"448\":1,\"462\":1,\"463\":1}}],[\"utf8mb4\",{\"1\":{\"216\":2,\"288\":1}}],[\"utf8\",{\"1\":{\"204\":2}}],[\"utf\",{\"1\":{\"166\":2}}],[\"uuid\",{\"1\":{\"218\":1,\"341\":1}}],[\"unlock\",{\"1\":{\"307\":1,\"309\":1}}],[\"uncommitted\",{\"1\":{\"271\":1,\"357\":1}}],[\"unicode\",{\"1\":{\"288\":2}}],[\"union\",{\"1\":{\"261\":2}}],[\"unique\",{\"1\":{\"211\":3,\"212\":1}}],[\"understand\",{\"1\":{\"110\":1}}],[\"undolog\",{\"1\":{\"272\":1,\"332\":1}}],[\"undo\",{\"0\":{\"333\":1,\"334\":1},\"1\":{\"96\":1,\"155\":1,\"174\":1,\"272\":1,\"333\":2,\"334\":21,\"336\":6,\"337\":9,\"340\":1,\"343\":5,\"350\":5,\"352\":1,\"358\":1,\"359\":2,\"360\":1,\"364\":1}}],[\"u$user\",{\"1\":{\"139\":1}}],[\"ult\",{\"1\":{\"130\":1}}],[\"u\",{\"1\":{\"109\":4,\"139\":1,\"181\":1}}],[\"updatetime\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"update当前读是不会加锁的\",{\"1\":{\"365\":1}}],[\"updates\",{\"1\":{\"330\":2,\"331\":1}}],[\"update等语句\",{\"1\":{\"307\":1}}],[\"update\",{\"0\":{\"328\":1},\"1\":{\"96\":1,\"273\":1,\"274\":2,\"275\":8,\"277\":1,\"280\":1,\"283\":3,\"285\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":1,\"297\":2,\"298\":1,\"299\":3,\"300\":2,\"302\":2,\"304\":3,\"305\":2,\"311\":1,\"313\":1,\"314\":1,\"322\":1,\"323\":1,\"325\":1,\"328\":1,\"329\":12,\"330\":4,\"331\":3,\"333\":5,\"334\":1,\"341\":2,\"343\":2,\"344\":1,\"350\":1,\"357\":2,\"359\":1,\"361\":3,\"362\":2,\"365\":4,\"367\":1,\"368\":2,\"369\":2,\"463\":1}}],[\"upstream\",{\"1\":{\"32\":1,\"41\":2,\"447\":1}}],[\"uml包用一大一小两个矩形组合而成\",{\"1\":{\"73\":1}}],[\"uml中的一种重要图形\",{\"1\":{\"64\":1}}],[\"uml类图\",{\"1\":{\"64\":1}}],[\"uml展现了一系列最佳工程实践\",{\"1\":{\"58\":1}}],[\"uml\",{\"1\":{\"58\":1},\"2\":{\"93\":1}}],[\"uri\",{\"1\":{\"39\":1,\"447\":1}}],[\"using\",{\"1\":{\"145\":1,\"149\":1,\"161\":1,\"204\":1,\"210\":1,\"217\":1,\"219\":1,\"228\":3,\"232\":2,\"274\":1,\"288\":1}}],[\"uses\",{\"1\":{\"330\":1}}],[\"used\",{\"1\":{\"178\":1,\"330\":1}}],[\"use\",{\"1\":{\"32\":1,\"330\":1}}],[\"user`\",{\"1\":{\"161\":1}}],[\"user\",{\"1\":{\"32\":3,\"139\":1,\"149\":1,\"161\":2,\"162\":1,\"178\":1,\"182\":2,\"185\":4,\"216\":1,\"228\":2,\"232\":1,\"234\":4,\"235\":2,\"236\":2,\"237\":1,\"238\":7,\"240\":1,\"243\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":1,\"297\":2,\"298\":1,\"303\":1,\"333\":1,\"343\":1,\"344\":1,\"350\":1,\"496\":4}}],[\"usr\",{\"1\":{\"31\":1,\"43\":3,\"44\":1,\"435\":4,\"436\":2,\"439\":2,\"442\":4,\"447\":1,\"450\":1,\"451\":1,\"454\":1}}],[\"即虚拟机会尽可能优先回收长时间闲置不用的软引用对象\",{\"1\":{\"520\":1}}],[\"即一般说的native方法\",{\"1\":{\"517\":1}}],[\"即一次将同组事务的\",{\"1\":{\"348\":1}}],[\"即钱秘书和李秘书共同的职责\",{\"1\":{\"507\":1}}],[\"即当下有两个问题需要我们去解决\",{\"1\":{\"507\":1}}],[\"即引用地址\",{\"1\":{\"492\":1}}],[\"即java有一定的动态性\",{\"1\":{\"480\":1}}],[\"即拉链法\",{\"1\":{\"472\":1}}],[\"即便被覆盖了也没什么影响\",{\"1\":{\"386\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"352\":1}}],[\"即便有重复值\",{\"1\":{\"228\":1}}],[\"即扫描到\",{\"1\":{\"296\":1}}],[\"即无法插入\",{\"1\":{\"291\":1}}],[\"即主键索引树\",{\"1\":{\"290\":1}}],[\"即能保护该记录\",{\"1\":{\"287\":1,\"316\":1}}],[\"即两个事务可以同时持有包含共同间隙范围的间隙锁\",{\"1\":{\"286\":1,\"315\":1}}],[\"即两个事务可以同时持有包含共同间隙的间隙锁\",{\"1\":{\"275\":1}}],[\"即这些操作要么同时成功\",{\"1\":{\"268\":1}}],[\"即叶子节点4\",{\"1\":{\"235\":1}}],[\"即用户数据的指针\",{\"1\":{\"234\":1}}],[\"即\",{\"1\":{\"225\":1,\"291\":1,\"322\":1}}],[\"即先写日志\",{\"1\":{\"179\":1}}],[\"即使内存够用\",{\"1\":{\"516\":1}}],[\"即使事务\",{\"1\":{\"364\":1}}],[\"即使事物\",{\"1\":{\"359\":1}}],[\"即使中途有其他事务插入了新纪录\",{\"1\":{\"364\":1}}],[\"即使中途有其他事务插入了一条数据\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"即使没有提交事务\",{\"1\":{\"354\":1}}],[\"即使主机发生异常重启\",{\"1\":{\"343\":1}}],[\"即使出现主库宕机\",{\"1\":{\"342\":1}}],[\"即使数据库崩溃了\",{\"1\":{\"338\":1}}],[\"即使数据达到千万级别时\",{\"1\":{\"207\":1}}],[\"即使其他事务更新了表的数据\",{\"1\":{\"307\":1}}],[\"即使是读已提交隔离级别也是加\",{\"1\":{\"278\":1}}],[\"即使查询过程中\",{\"1\":{\"232\":1}}],[\"即使查询出来的结果集很小\",{\"1\":{\"178\":1}}],[\"即使\",{\"1\":{\"216\":1}}],[\"即使管理员中途修改了该用户的权限\",{\"1\":{\"139\":1}}],[\"即教育部颁发\",{\"1\":{\"108\":1}}],[\"即可看到效果\",{\"1\":{\"436\":1}}],[\"即可以提交事务\",{\"1\":{\"346\":1}}],[\"即可以针对函数计算后的值建立一个索引\",{\"1\":{\"236\":1}}],[\"即可\",{\"1\":{\"107\":1,\"108\":1}}],[\"即对\",{\"1\":{\"297\":1,\"298\":2}}],[\"即对称加密的方式来给报文进行加解密\",{\"1\":{\"106\":1}}],[\"即对数据加密\",{\"1\":{\"104\":1}}],[\"即不可否认已发生的行为\",{\"1\":{\"104\":1}}],[\"即不设上限\",{\"1\":{\"32\":1}}],[\"即证明\",{\"1\":{\"104\":1}}],[\"即自我调用的同步消息\",{\"1\":{\"81\":1}}],[\"即公有访问\",{\"1\":{\"73\":1}}],[\"即确定类间的关系\",{\"1\":{\"72\":1}}],[\"即类之间的关系\",{\"1\":{\"66\":1}}],[\"即基础用例\",{\"1\":{\"61\":1,\"63\":1}}],[\"即试算\",{\"1\":{\"58\":1}}],[\"即为代理类对象调用的方法\",{\"1\":{\"507\":1}}],[\"即为\",{\"1\":{\"58\":1}}],[\"即建立数学模型\",{\"1\":{\"58\":1}}],[\"即完成上一个框中指定的操作才能再执行下一个动作\",{\"1\":{\"56\":1}}],[\"即在ssl协议上传输http\",{\"1\":{\"26\":1}}],[\"允许使用lua自定义业务逻辑\",{\"1\":{\"432\":1}}],[\"允许的ip\",{\"1\":{\"32\":1}}],[\"允许sendfile方式传输文件\",{\"1\":{\"32\":1}}],[\"允许生成的进程数\",{\"1\":{\"32\":1}}],[\"$a\",{\"1\":{\"43\":1}}],[\"$\",{\"1\":{\"43\":5}}],[\"$http\",{\"1\":{\"32\":3}}],[\"$body\",{\"1\":{\"32\":1}}],[\"$status\",{\"1\":{\"32\":1}}],[\"$request\",{\"1\":{\"32\":1,\"447\":1}}],[\"$remote\",{\"1\":{\"32\":2}}],[\"$time\",{\"1\":{\"32\":1}}],[\"默认调用super\",{\"1\":{\"498\":1}}],[\"默认容量为16\",{\"1\":{\"475\":1}}],[\"默认的响应类型\",{\"1\":{\"435\":1,\"439\":1}}],[\"默认的流程\",{\"1\":{\"411\":1}}],[\"默认的存储引擎是\",{\"1\":{\"234\":1}}],[\"默认的存储引擎\",{\"1\":{\"152\":1,\"258\":2}}],[\"默认隔离级\",{\"1\":{\"369\":1}}],[\"默认隔离级别\",{\"1\":{\"278\":1,\"279\":1,\"280\":1}}],[\"默认模型\",{\"1\":{\"342\":1}}],[\"默认格式\",{\"1\":{\"341\":1}}],[\"默认情况下\",{\"1\":{\"339\":1}}],[\"默认大小\",{\"1\":{\"337\":1}}],[\"默认就开启\",{\"1\":{\"281\":1}}],[\"默认值为\",{\"1\":{\"338\":1}}],[\"默认值时\",{\"1\":{\"281\":1}}],[\"默认值是\",{\"1\":{\"139\":1}}],[\"默认数据页大小为\",{\"1\":{\"246\":1}}],[\"默认行存储格式compact\",{\"1\":{\"227\":1}}],[\"默认会使用主键作为聚簇索引的索引键\",{\"1\":{\"204\":1,\"245\":1}}],[\"默认是no\",{\"1\":{\"378\":1}}],[\"默认是服务停止时\",{\"1\":{\"375\":1}}],[\"默认是保存在当前运行目录\",{\"1\":{\"372\":1}}],[\"默认是开启\",{\"1\":{\"334\":1}}],[\"默认是\",{\"1\":{\"178\":2,\"180\":1}}],[\"默认配置下\",{\"1\":{\"173\":1}}],[\"默认使用\",{\"1\":{\"158\":1}}],[\"默认使用onnx推理方式\",{\"1\":{\"100\":1}}],[\"默认每个页的大小为\",{\"1\":{\"155\":1}}],[\"默认安装路径\",{\"1\":{\"43\":1}}],[\"默认\",{\"1\":{\"41\":1,\"271\":1}}],[\"默认监听\",{\"1\":{\"35\":1}}],[\"默认文件类型\",{\"1\":{\"32\":1}}],[\"默认为75s\",{\"1\":{\"32\":1}}],[\"默认为0代表永不过期\",{\"1\":{\"453\":1}}],[\"默认为0\",{\"1\":{\"32\":1}}],[\"默认为text\",{\"1\":{\"32\":1}}],[\"默认为512\",{\"1\":{\"32\":1}}],[\"默认为off\",{\"1\":{\"32\":2}}],[\"默认为on\",{\"1\":{\"32\":1}}],[\"默认为1秒\",{\"1\":{\"180\":1}}],[\"默认为1\",{\"1\":{\"32\":1}}],[\"默认为nobody\",{\"1\":{\"32\":1}}],[\"tb\",{\"1\":{\"462\":1,\"463\":2}}],[\"t6934\",{\"1\":{\"436\":1,\"439\":1}}],[\"t3\",{\"1\":{\"368\":1}}],[\"twice\",{\"1\":{\"302\":1,\"363\":1}}],[\"thread\",{\"1\":{\"506\":5}}],[\"throwable\",{\"1\":{\"507\":1}}],[\"throw\",{\"1\":{\"463\":1}}],[\"throws\",{\"1\":{\"448\":1,\"463\":1,\"496\":1,\"507\":1}}],[\"this\",{\"1\":{\"275\":1,\"324\":1,\"330\":1,\"507\":1,\"508\":2}}],[\"that\",{\"1\":{\"275\":4,\"302\":1,\"323\":1,\"324\":3,\"330\":3,\"363\":1}}],[\"they\",{\"1\":{\"275\":3,\"323\":2,\"324\":1}}],[\"their\",{\"1\":{\"275\":1,\"323\":1}}],[\"there\",{\"1\":{\"194\":1,\"275\":2,\"323\":1,\"324\":1}}],[\"the\",{\"1\":{\"182\":2,\"194\":1,\"275\":11,\"302\":5,\"323\":3,\"324\":8,\"330\":2,\"363\":5}}],[\"then\",{\"1\":{\"43\":2,\"429\":1,\"430\":1,\"442\":1,\"450\":9,\"451\":2,\"454\":4}}],[\"t2\",{\"1\":{\"265\":2,\"266\":1,\"302\":4,\"312\":4,\"363\":4,\"368\":1}}],[\"t1\",{\"1\":{\"265\":2,\"266\":1,\"302\":4,\"363\":4,\"368\":1}}],[\"try\",{\"1\":{\"463\":1,\"508\":1}}],[\"true\",{\"1\":{\"425\":1,\"429\":1,\"501\":1,\"502\":2,\"503\":1,\"508\":1}}],[\"transient\",{\"1\":{\"462\":3}}],[\"transaction\",{\"0\":{\"558\":1},\"1\":{\"275\":2,\"283\":1,\"302\":1,\"307\":1,\"313\":1,\"323\":2,\"351\":1,\"357\":4,\"363\":1}}],[\"transactions\",{\"1\":{\"275\":3,\"323\":1,\"324\":2}}],[\"trailer\",{\"1\":{\"187\":1}}],[\"treenode\",{\"1\":{\"473\":1}}],[\"tree\",{\"1\":{\"207\":1,\"215\":1,\"216\":1}}],[\"trx\",{\"1\":{\"164\":4,\"276\":1,\"334\":3,\"338\":6,\"347\":2,\"348\":1,\"349\":1,\"358\":16,\"359\":15,\"360\":12,\"367\":1}}],[\"tmp\",{\"1\":{\"182\":1}}],[\"title\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"tinyint\",{\"1\":{\"182\":1,\"183\":1}}],[\"times\",{\"1\":{\"302\":1,\"363\":1}}],[\"time\",{\"0\":{\"322\":1,\"323\":1,\"324\":1,\"325\":1},\"1\":{\"139\":1,\"178\":1,\"180\":1,\"219\":5,\"302\":2,\"322\":1,\"323\":1,\"324\":2,\"325\":2,\"363\":2,\"450\":4}}],[\"timeouts\",{\"1\":{\"450\":2}}],[\"timeout\",{\"1\":{\"32\":1,\"43\":1,\"139\":3,\"281\":1}}],[\"temporary\",{\"1\":{\"228\":1}}],[\"text索引\",{\"1\":{\"203\":1}}],[\"text\",{\"1\":{\"161\":1,\"165\":2,\"166\":1,\"168\":1,\"204\":1,\"234\":1}}],[\"test1\",{\"1\":{\"499\":1}}],[\"test2\",{\"1\":{\"496\":1}}],[\"testbasicops\",{\"1\":{\"416\":1}}],[\"test表中插入一个\",{\"1\":{\"368\":1}}],[\"test\",{\"1\":{\"144\":3,\"152\":3,\"166\":1,\"285\":1,\"302\":1,\"314\":2,\"363\":1,\"368\":2,\"416\":1,\"496\":1,\"499\":1}}],[\"t\",{\"1\":{\"144\":1,\"149\":1,\"152\":7,\"161\":2,\"162\":1,\"178\":1,\"189\":1,\"191\":5,\"192\":1,\"193\":1,\"195\":1,\"197\":2,\"198\":2,\"199\":1,\"216\":4,\"232\":1,\"234\":4,\"235\":2,\"236\":2,\"237\":1,\"238\":7,\"240\":1,\"274\":1,\"275\":3,\"277\":3,\"279\":1,\"280\":3,\"285\":1,\"302\":1,\"303\":1,\"309\":3,\"312\":1,\"314\":2,\"319\":2,\"322\":2,\"323\":1,\"324\":1,\"325\":1,\"333\":1,\"343\":1,\"344\":1,\"350\":1,\"363\":1,\"364\":1,\"367\":4,\"368\":2,\"506\":2}}],[\"to中为空\",{\"1\":{\"529\":1}}],[\"tom\",{\"1\":{\"501\":1,\"503\":1}}],[\"tomcat总数为2台\",{\"1\":{\"446\":1}}],[\"tomcat一定是集群模式\",{\"1\":{\"445\":1}}],[\"tomcat是在windows电脑上\",{\"1\":{\"440\":1}}],[\"tomcat的查询\",{\"1\":{\"414\":1}}],[\"tomcat的性能成为整个系统的瓶颈\",{\"1\":{\"414\":1}}],[\"tomcat查询的业务逻辑\",{\"1\":{\"414\":1}}],[\"tomcat\",{\"1\":{\"34\":7,\"35\":1,\"45\":1,\"447\":2}}],[\"tomcat官网\",{\"1\":{\"34\":1}}],[\"top\",{\"1\":{\"463\":2}}],[\"total\",{\"1\":{\"182\":1,\"187\":6}}],[\"tool\",{\"0\":{\"543\":1}}],[\"too\",{\"1\":{\"139\":1}}],[\"to\",{\"1\":{\"139\":1,\"275\":6,\"323\":2,\"324\":4,\"330\":2}}],[\"tcp\",{\"1\":{\"139\":8}}],[\"tls\",{\"1\":{\"110\":2}}],[\"txt\",{\"1\":{\"32\":1}}],[\"typeid\",{\"1\":{\"403\":1}}],[\"type=all\",{\"1\":{\"232\":1,\"235\":1,\"236\":1}}],[\"type=index\",{\"1\":{\"232\":3,\"240\":1}}],[\"type=range\",{\"1\":{\"232\":1,\"235\":1}}],[\"type=\",{\"1\":{\"231\":1}}],[\"type\",{\"1\":{\"32\":1,\"43\":1,\"140\":1,\"145\":1,\"163\":1,\"228\":5,\"232\":2,\"237\":1,\"238\":1,\"275\":2,\"279\":1,\"280\":1,\"290\":1,\"304\":3,\"322\":1,\"324\":1,\"435\":1,\"439\":1,\"462\":1,\"490\":1,\"499\":3,\"508\":7}}],[\"types\",{\"1\":{\"32\":1}}],[\"taskid\",{\"1\":{\"508\":2}}],[\"tasktype\",{\"1\":{\"508\":3}}],[\"taobao\",{\"1\":{\"281\":1,\"350\":1}}],[\"takeover\",{\"1\":{\"411\":1}}],[\"taken\",{\"1\":{\"275\":1,\"323\":1}}],[\"taking\",{\"1\":{\"275\":1,\"323\":1}}],[\"tangocc\",{\"1\":{\"150\":1}}],[\"tablename\",{\"1\":{\"462\":2}}],[\"tableid\",{\"1\":{\"462\":2}}],[\"tablefield\",{\"1\":{\"462\":3}}],[\"tables\",{\"1\":{\"307\":2,\"309\":3,\"311\":2}}],[\"table2\",{\"1\":{\"263\":4,\"264\":6}}],[\"table1\",{\"1\":{\"263\":4,\"264\":6,\"265\":2}}],[\"table\",{\"1\":{\"144\":2,\"152\":2,\"161\":1,\"166\":1,\"182\":3,\"183\":1,\"199\":1,\"204\":1,\"210\":2,\"211\":3,\"212\":3,\"213\":3,\"216\":3,\"217\":1,\"236\":1,\"274\":1,\"283\":2,\"288\":1,\"304\":1,\"307\":2,\"319\":1,\"425\":1,\"426\":1,\"443\":2,\"473\":5,\"517\":1}}],[\"tar\",{\"1\":{\"28\":2,\"29\":2,\"34\":2}}],[\"tags\",{\"1\":{\"15\":1}}],[\"tag\",{\"1\":{\"14\":1,\"15\":1,\"91\":1}}],[\"最快\",{\"1\":{\"526\":1}}],[\"最快可以在\",{\"1\":{\"254\":1}}],[\"最慢\",{\"1\":{\"526\":1}}],[\"最近学习了一些设计模式以后\",{\"1\":{\"508\":1}}],[\"最近似地实现各种数值计算的\",{\"1\":{\"58\":1}}],[\"最先去尝试加载的就bootstrapclassloader\",{\"1\":{\"494\":1}}],[\"最小的事务\",{\"1\":{\"358\":1}}],[\"最小的二级索引进行扫描\",{\"1\":{\"194\":1,\"196\":1}}],[\"最新的余额数据才能被事务\",{\"1\":{\"357\":1}}],[\"最多丢失一个事务的\",{\"1\":{\"343\":1}}],[\"最多能存储的数据计算方式就不一样了\",{\"1\":{\"166\":1}}],[\"最开始\",{\"1\":{\"340\":1}}],[\"最开始要找的第一行是\",{\"1\":{\"293\":2,\"294\":3,\"297\":1,\"298\":1}}],[\"最好能在尽可能少的磁盘\",{\"1\":{\"258\":1}}],[\"最好就是让预读的页停留在\",{\"1\":{\"178\":1}}],[\"最底部的节点\",{\"1\":{\"253\":1}}],[\"最底层的节点\",{\"1\":{\"244\":1}}],[\"最简单办法就是从头依次遍历查询\",{\"1\":{\"249\":1}}],[\"最差的情况下需要遍历链表上的所有节点才能完成检索\",{\"1\":{\"243\":1}}],[\"最左匹配原则\",{\"1\":{\"215\":1}}],[\"最下面那一层的\",{\"1\":{\"186\":1}}],[\"最容易想到的就是\",{\"1\":{\"178\":1}}],[\"最常用的流程图符号见图\",{\"1\":{\"58\":1}}],[\"最重要的是学会针对各种类型的问题\",{\"1\":{\"58\":1}}],[\"最后根据要求通过反射查找相应的策略执行相应的逻辑\",{\"1\":{\"508\":1}}],[\"最后钱秘书5个小时后将这件事询问了赵老板意见并回电话告诉孙老板三天后见\",{\"1\":{\"506\":1}}],[\"最后是确定下线\",{\"1\":{\"410\":1}}],[\"最后是判断slave节点的运行id大小\",{\"1\":{\"393\":1}}],[\"最后\",{\"1\":{\"359\":1,\"393\":1,\"442\":1}}],[\"最后的结果是用户\",{\"1\":{\"352\":1}}],[\"最后的结果肯定是我的余额变为\",{\"1\":{\"351\":1}}],[\"最后进入\",{\"1\":{\"348\":1}}],[\"最后回答\",{\"1\":{\"325\":1}}],[\"最后附上\",{\"1\":{\"300\":1}}],[\"最后递归的进入子节点查找\",{\"1\":{\"256\":1}}],[\"最后在分组内进行遍历查找\",{\"1\":{\"244\":1}}],[\"最后一个分组中的记录条数范围只能在\",{\"1\":{\"243\":1}}],[\"最后将\",{\"1\":{\"192\":1}}],[\"最后由后台线程将脏页写入到磁盘\",{\"1\":{\"172\":1}}],[\"最后第三条记录\",{\"1\":{\"162\":1}}],[\"最后本末倒置\",{\"1\":{\"52\":1}}],[\"最后删除release\",{\"1\":{\"10\":1}}],[\"最终决定采用反射+策略模式来去除过多的if判断\",{\"1\":{\"508\":1}}],[\"最终都会被转发到正确节点\",{\"1\":{\"400\":1}}],[\"最终实现主从的数据一致性\",{\"1\":{\"342\":1}}],[\"最终用二进制来表示是酱紫的\",{\"1\":{\"162\":1}}],[\"最终采用的加密形式\",{\"1\":{\"106\":1}}],[\"最终流程创造的价值\",{\"1\":{\"54\":1}}],[\"最终要做的是软件而不是图表\",{\"1\":{\"52\":1}}],[\"最终测试\",{\"1\":{\"43\":1}}],[\"最大化组提交的效率\",{\"1\":{\"348\":1}}],[\"最大的优势在于查询效率很高\",{\"1\":{\"205\":1}}],[\"最大值\",{\"1\":{\"166\":1}}],[\"最大值时\",{\"1\":{\"166\":3,\"169\":1}}],[\"最大取值为\",{\"1\":{\"169\":1}}],[\"最大取值为多少\",{\"0\":{\"165\":1},\"1\":{\"151\":1,\"165\":1,\"169\":1}}],[\"最大取值就是\",{\"1\":{\"166\":1}}],[\"最大取值是\",{\"1\":{\"166\":1}}],[\"最大能允许存储的字节数\",{\"1\":{\"165\":1}}],[\"最大并发数量应该是worker\",{\"1\":{\"49\":1}}],[\"最大并发数量应该是\",{\"1\":{\"48\":1}}],[\"最大连接数\",{\"1\":{\"32\":1}}],[\"最\",{\"1\":{\"48\":1}}],[\"事项策略枚举类\",{\"1\":{\"508\":1}}],[\"事务每次读数据时都重新创建\",{\"1\":{\"360\":1}}],[\"事务处理结束后\",{\"1\":{\"352\":1}}],[\"事务处理过程中\",{\"1\":{\"334\":1}}],[\"事务看起来感觉简单\",{\"1\":{\"352\":1}}],[\"事务有哪些特性\",{\"0\":{\"352\":1}}],[\"事务啦\",{\"1\":{\"351\":1}}],[\"事务没提交的时候\",{\"1\":{\"346\":2}}],[\"事务由\",{\"1\":{\"345\":1}}],[\"事务线程不用等待所有的从库复制成功响应\",{\"1\":{\"342\":1}}],[\"事务提交后\",{\"1\":{\"344\":1}}],[\"事务提交\",{\"1\":{\"343\":1,\"350\":1}}],[\"事务提交的时候\",{\"1\":{\"343\":1}}],[\"事务提交完成后\",{\"1\":{\"342\":1}}],[\"事务提交之后发生了崩溃\",{\"1\":{\"337\":1}}],[\"事务提交之前发生了崩溃\",{\"1\":{\"337\":1}}],[\"事务恢复\",{\"1\":{\"337\":2}}],[\"事务期间的多次读取同一条数据\",{\"1\":{\"334\":1,\"360\":1,\"361\":1}}],[\"事务中\",{\"1\":{\"329\":1}}],[\"事务中就会出现所谓的幻象问题\",{\"1\":{\"302\":1,\"363\":1}}],[\"事务在执行\",{\"1\":{\"304\":1}}],[\"事务执行中间过程的\",{\"1\":{\"346\":1}}],[\"事务执行过程中\",{\"1\":{\"343\":1}}],[\"事务执行过程中看到的数据\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"事务执行了一条删除\",{\"1\":{\"303\":1}}],[\"事务执行了一条查询语句\",{\"1\":{\"303\":1}}],[\"事务执行前后\",{\"1\":{\"269\":1}}],[\"事务过程中生成的锁都会被释放\",{\"1\":{\"285\":1,\"314\":1}}],[\"事务会对表中主键\",{\"1\":{\"285\":1}}],[\"事务会把所有的操作作为一个整体一起向系\",{\"1\":{\"268\":1}}],[\"事务隔离级别为可重复读\",{\"1\":{\"279\":1,\"280\":1}}],[\"事务隔离级别是怎么实现的\",{\"0\":{\"351\":1},\"1\":{\"96\":1,\"334\":1}}],[\"事务的启动时机是不同的\",{\"1\":{\"357\":1}}],[\"事务的提交过程有两个阶段\",{\"1\":{\"345\":1}}],[\"事务的提交\",{\"1\":{\"345\":1}}],[\"事务的\",{\"1\":{\"334\":1,\"345\":1,\"346\":2,\"361\":1}}],[\"事务的删除语句就陷入了等待状态\",{\"1\":{\"303\":1}}],[\"事务的隔离级别有哪些\",{\"0\":{\"357\":1}}],[\"事务的隔离级别是靠什么保证的\",{\"0\":{\"272\":1}}],[\"事务的隔离级别\",{\"0\":{\"271\":1}}],[\"事务的四大特性是原子性\",{\"1\":{\"361\":1}}],[\"事务的四大特性\",{\"0\":{\"269\":1}}],[\"事务一旦提交\",{\"1\":{\"269\":1}}],[\"事务之间互不影响\",{\"1\":{\"269\":1}}],[\"事务是在\",{\"1\":{\"361\":1}}],[\"事务是由\",{\"1\":{\"352\":1}}],[\"事务是不可分割的最小单元\",{\"1\":{\"269\":1}}],[\"事务是一组操作的集合\",{\"1\":{\"268\":1}}],[\"事务是什么\",{\"0\":{\"268\":1}}],[\"事务\",{\"1\":{\"232\":1,\"275\":1,\"277\":4,\"280\":8,\"290\":2,\"293\":4,\"294\":3,\"296\":6,\"297\":4,\"298\":3,\"304\":5,\"317\":1,\"320\":2,\"322\":2,\"323\":4,\"324\":4,\"325\":5,\"329\":2,\"345\":3,\"351\":1,\"354\":1,\"355\":1,\"356\":2,\"357\":8,\"359\":14,\"360\":12,\"364\":1,\"365\":3,\"367\":9,\"368\":3}}],[\"事务id\",{\"1\":{\"164\":1,\"334\":1}}],[\"事务篇\",{\"1\":{\"96\":1}}],[\"事务面试题\",{\"1\":{\"96\":1}}],[\"事物内部和事物之间都有联系的\",{\"1\":{\"89\":1}}],[\"事\",{\"1\":{\"89\":1}}],[\"事件\",{\"1\":{\"87\":1}}],[\"事件驱动模型\",{\"1\":{\"32\":1}}],[\"事实上nginx的并发能力确实在同类型的网页服务器中表现较好\",{\"1\":{\"20\":1}}],[\"级别以此为\",{\"1\":{\"32\":1}}],[\"级别\",{\"1\":{\"32\":1}}],[\"制定日志路径\",{\"1\":{\"32\":1}}],[\"nation\",{\"1\":{\"502\":1}}],[\"name=tom\",{\"1\":{\"478\":1}}],[\"name=\",{\"1\":{\"234\":2,\"425\":1,\"426\":1}}],[\"name不是索引\",{\"1\":{\"195\":1}}],[\"name\",{\"1\":{\"32\":1,\"38\":1,\"139\":2,\"145\":4,\"148\":2,\"152\":1,\"161\":2,\"178\":2,\"182\":3,\"183\":1,\"191\":3,\"195\":1,\"210\":1,\"211\":3,\"212\":3,\"213\":5,\"215\":7,\"216\":21,\"228\":1,\"231\":2,\"232\":4,\"234\":3,\"235\":12,\"236\":7,\"275\":1,\"288\":1,\"290\":1,\"293\":2,\"294\":2,\"296\":3,\"297\":3,\"298\":1,\"304\":1,\"322\":1,\"324\":1,\"325\":1,\"330\":1,\"331\":1,\"333\":1,\"343\":1,\"344\":6,\"350\":1,\"367\":2,\"379\":1,\"425\":2,\"436\":1,\"439\":1,\"443\":3,\"448\":1,\"462\":3,\"501\":4,\"503\":1}}],[\"næl\",{\"1\":{\"458\":1}}],[\"nil\",{\"1\":{\"442\":2,\"444\":2,\"450\":4,\"451\":2,\"454\":2}}],[\"ngx\",{\"1\":{\"436\":1,\"439\":2,\"441\":2,\"442\":6,\"444\":2,\"450\":23,\"451\":6,\"453\":1,\"454\":12}}],[\"nginx本地缓存\",{\"0\":{\"452\":1}}],[\"nginx本身也是c语言开发\",{\"1\":{\"421\":1}}],[\"nginx根据请求路径做hash运算\",{\"1\":{\"446\":1}}],[\"nginx提供了基于请求路径做负载均衡的算法\",{\"1\":{\"446\":1}}],[\"nginx提供了内部api用以发送http请求\",{\"1\":{\"441\":1}}],[\"nginx目录创建文件夹\",{\"1\":{\"436\":1}}],[\"nginx的高性能\",{\"1\":{\"432\":1}}],[\"nginx编程需要用到lua语言\",{\"1\":{\"420\":1}}],[\"nginx内部需要编写本地缓存查询\",{\"1\":{\"414\":1}}],[\"nginx有一个master\",{\"1\":{\"49\":1}}],[\"nginx原理解析\",{\"0\":{\"44\":1}}],[\"nginx和keealived停止\",{\"1\":{\"43\":1}}],[\"nginx配置文件\",{\"0\":{\"32\":1}}],[\"nginx也需要此库\",{\"1\":{\"26\":1}}],[\"nginx安装\",{\"0\":{\"25\":1}}],[\"nginx专为性能优化而开发\",{\"1\":{\"20\":1}}],[\"nginx\",{\"1\":{\"20\":1,\"26\":4,\"28\":3,\"29\":1,\"31\":8,\"32\":4,\"39\":1,\"43\":6,\"44\":8,\"45\":1,\"47\":1,\"48\":1,\"435\":4,\"436\":2,\"439\":4,\"442\":2,\"447\":3},\"2\":{\"51\":1}}],[\"nginx基本概念\",{\"0\":{\"19\":1}}],[\"nginx从入门到实践\",{\"0\":{\"18\":1}}],[\"nginx缓存\",{\"1\":{\"2\":1,\"97\":1}}],[\"n>1\",{\"1\":{\"343\":1}}],[\"num的插槽为2765\",{\"1\":{\"408\":1}}],[\"num时\",{\"1\":{\"402\":1}}],[\"num\",{\"1\":{\"379\":3,\"402\":1,\"405\":1,\"425\":1}}],[\"number\",{\"1\":{\"182\":1,\"330\":1}}],[\"null值列表会占用\",{\"1\":{\"169\":1}}],[\"null值列表\",{\"1\":{\"169\":2}}],[\"null值列表所占用的字节数\",{\"1\":{\"167\":1,\"169\":3}}],[\"null值列表用十六进制表示是\",{\"1\":{\"162\":1}}],[\"null值列表中\",{\"1\":{\"162\":1}}],[\"null\",{\"0\":{\"162\":1,\"227\":1},\"1\":{\"145\":1,\"151\":1,\"160\":1,\"161\":8,\"162\":24,\"166\":9,\"169\":5,\"182\":2,\"183\":2,\"191\":5,\"192\":3,\"193\":1,\"196\":1,\"204\":5,\"216\":4,\"227\":5,\"228\":1,\"245\":1,\"274\":3,\"288\":3,\"319\":5,\"450\":2,\"473\":1,\"502\":1,\"508\":1,\"520\":1}}],[\"newproxyinstance\",{\"1\":{\"507\":1}}],[\"newinstance\",{\"1\":{\"498\":3,\"501\":1,\"502\":1,\"503\":1,\"508\":1}}],[\"new一个类的对象\",{\"1\":{\"492\":1}}],[\"new\",{\"1\":{\"448\":1,\"450\":2,\"463\":2,\"486\":1,\"489\":1,\"496\":3,\"506\":2,\"507\":2,\"508\":1,\"519\":1,\"520\":1}}],[\"newbuilder\",{\"1\":{\"416\":3,\"419\":2}}],[\"ne\",{\"1\":{\"419\":1}}],[\"neeo\",{\"1\":{\"350\":1}}],[\"need\",{\"1\":{\"275\":1,\"324\":1}}],[\"next\",{\"0\":{\"287\":1,\"316\":1},\"1\":{\"163\":1,\"275\":19,\"277\":2,\"278\":4,\"280\":6,\"282\":1,\"284\":1,\"287\":8,\"288\":4,\"289\":2,\"290\":3,\"291\":5,\"292\":8,\"293\":13,\"294\":23,\"295\":3,\"296\":2,\"297\":8,\"298\":9,\"299\":3,\"300\":8,\"302\":3,\"304\":24,\"305\":1,\"313\":1,\"316\":8,\"317\":1,\"322\":3,\"329\":5,\"357\":3,\"361\":4,\"362\":3,\"365\":3,\"368\":1,\"369\":2}}],[\"network\",{\"0\":{\"551\":1},\"2\":{\"112\":1}}],[\"net\",{\"1\":{\"91\":1,\"181\":1}}],[\"netstat\",{\"1\":{\"35\":1}}],[\"n\",{\"0\":{\"165\":2},\"1\":{\"151\":3,\"161\":2,\"165\":5,\"166\":16,\"168\":1,\"169\":8,\"207\":1,\"243\":2,\"249\":1,\"250\":2,\"258\":1,\"343\":1,\"348\":4,\"349\":2}}],[\"ncnn\",{\"1\":{\"99\":1}}],[\"normangyllenhaal\",{\"1\":{\"459\":1}}],[\"non\",{\"1\":{\"353\":1}}],[\"nonconflicting\",{\"1\":{\"275\":1,\"324\":1}}],[\"nosql\",{\"1\":{\"256\":1}}],[\"no`\",{\"1\":{\"204\":1,\"274\":2}}],[\"now\",{\"1\":{\"182\":2,\"275\":1,\"277\":1,\"341\":1}}],[\"not\",{\"0\":{\"227\":1},\"1\":{\"161\":1,\"162\":2,\"169\":1,\"182\":2,\"183\":2,\"204\":1,\"227\":1,\"274\":1,\"275\":6,\"279\":1,\"280\":2,\"288\":3,\"290\":1,\"302\":1,\"304\":1,\"319\":1,\"322\":1,\"323\":2,\"324\":3,\"330\":2,\"363\":1,\"430\":1,\"442\":1,\"450\":7,\"451\":2,\"454\":4}}],[\"notification\",{\"1\":{\"43\":2}}],[\"nodes\",{\"1\":{\"397\":1,\"407\":1,\"412\":1}}],[\"node\",{\"0\":{\"75\":2},\"1\":{\"407\":1}}],[\"no\",{\"1\":{\"43\":2,\"194\":1,\"206\":6,\"215\":9,\"274\":1,\"275\":7,\"277\":3,\"280\":15,\"281\":1,\"323\":1,\"324\":1,\"325\":1,\"348\":2,\"349\":1,\"378\":1,\"393\":1,\"394\":1}}],[\"nobody\",{\"1\":{\"32\":1}}],[\"npl\",{\"1\":{\"35\":1}}],[\"以cafe开头\",{\"1\":{\"492\":1}}],[\"以前的记录就变成旧版本记录了\",{\"1\":{\"359\":1}}],[\"以腾出空间记录新的更新操作\",{\"1\":{\"339\":1}}],[\"以此避免有几率锁全表带来的隐患\",{\"1\":{\"330\":1}}],[\"以此类推\",{\"1\":{\"162\":1}}],[\"以防止其他事务在这个空隙间插入新的数据\",{\"1\":{\"275\":1}}],[\"以下内容基于常用的\",{\"1\":{\"190\":1}}],[\"以后slave的replid就与master一致了\",{\"1\":{\"384\":1}}],[\"以后\",{\"1\":{\"182\":1,\"442\":1}}],[\"以页为单位缓冲数据\",{\"1\":{\"180\":1}}],[\"以页作为磁盘和内存交互的基本单位\",{\"1\":{\"174\":1,\"336\":1}}],[\"以本文开头查询语句为例\",{\"1\":{\"147\":1}}],[\"以实现他们之间的通信的一个共享文件\",{\"1\":{\"124\":1}}],[\"以上的隔离级别\",{\"1\":{\"357\":1}}],[\"以上的讲述过程中\",{\"1\":{\"109\":1}}],[\"以上图为例子\",{\"1\":{\"244\":1}}],[\"以上面那张图举个例子\",{\"1\":{\"243\":1}}],[\"以上面的学生饭卡e\",{\"1\":{\"89\":1}}],[\"以第一次调用runocr方法时的引擎配置为准\",{\"1\":{\"100\":1}}],[\"以及如何用命令分析加了什么行级锁\",{\"1\":{\"282\":1}}],[\"以及怎么避免死锁\",{\"1\":{\"273\":1}}],[\"以及重做日志文件\",{\"1\":{\"272\":1}}],[\"以及在索引页中增加了层级的信息\",{\"1\":{\"186\":1}}],[\"以及当前链表中节点的数量等信息\",{\"1\":{\"176\":1}}],[\"以及行记录在这个表空间文件中的哪个区域\",{\"1\":{\"157\":1}}],[\"以及流程图vs状态图\",{\"1\":{\"83\":1}}],[\"以及由于各种事件的发生而引起的状态之间的转移\",{\"1\":{\"83\":1}}],[\"以及各种页面的处理情况\",{\"1\":{\"32\":1}}],[\"以亿图图示绘制为例\",{\"1\":{\"72\":1}}],[\"以便帮助别人理解你编写程序的思路和结构\",{\"1\":{\"58\":1}}],[\"以帮助阅读流程图的人更好地理解流程图的作用\",{\"1\":{\"58\":1}}],[\"以表示执行的先后顺序\",{\"1\":{\"58\":1}}],[\"以结束符结束\",{\"1\":{\"57\":1}}],[\"以争抢的机制来抢夺任务\",{\"1\":{\"45\":1}}],[\"以高支模版本和v4\",{\"1\":{\"10\":1}}],[\"缓存服务接收到canal通知\",{\"1\":{\"456\":1}}],[\"缓存服务监听mq消息\",{\"1\":{\"456\":1}}],[\"缓存与数据库强一致\",{\"1\":{\"456\":1}}],[\"缓存过期之前可能不一致\",{\"1\":{\"456\":1}}],[\"缓存数据同步的常见方式有三种\",{\"1\":{\"456\":1}}],[\"缓存数据的一致性\",{\"1\":{\"455\":1}}],[\"缓存数据量较小\",{\"1\":{\"416\":1}}],[\"缓存数据量较大\",{\"1\":{\"416\":1}}],[\"缓存同步\",{\"0\":{\"455\":1}}],[\"缓存预热需要在项目启动时完成\",{\"1\":{\"448\":1}}],[\"缓存预热\",{\"1\":{\"448\":1}}],[\"缓存命中率太低了\",{\"1\":{\"445\":1}}],[\"缓存上限为10000\",{\"1\":{\"418\":1}}],[\"缓存初始大小为100\",{\"1\":{\"418\":1}}],[\"缓存未命中时查询数据库\",{\"1\":{\"418\":2}}],[\"缓存的key\",{\"1\":{\"416\":1}}],[\"缓存使用的基本api\",{\"1\":{\"416\":1}}],[\"缓存在日常开发中启动至关重要的作用\",{\"1\":{\"416\":1}}],[\"缓存在操作系统的文件系统中\",{\"1\":{\"348\":1}}],[\"缓存在\",{\"1\":{\"338\":1,\"349\":1}}],[\"缓存页地址\",{\"1\":{\"174\":1}}],[\"缓存页的表空间\",{\"1\":{\"174\":1}}],[\"缓存什么\",{\"0\":{\"174\":1,\"336\":1}}],[\"缓存内存中\",{\"1\":{\"172\":1}}],[\"缓存\",{\"1\":{\"32\":1,\"272\":1}}],[\"块\",{\"1\":{\"32\":1}}],[\"块又包括\",{\"1\":{\"32\":1}}],[\"块涉及的指令主要影响nginx服务器与用户的网络连接\",{\"1\":{\"32\":1}}],[\"第四条也是一样的结果\",{\"1\":{\"232\":1}}],[\"第四步\",{\"0\":{\"143\":1}}],[\"第二次会访问8082端口的tomcat服务\",{\"1\":{\"445\":1}}],[\"第二次会覆盖第一次的值\",{\"1\":{\"379\":1}}],[\"第二次读数据时\",{\"1\":{\"360\":1}}],[\"第二次去读取该记录\",{\"1\":{\"359\":1}}],[\"第二次的查询语句可能会返回之前不存在的行\",{\"1\":{\"329\":1}}],[\"第二个例子\",{\"1\":{\"369\":1}}],[\"第二个发生幻读现象的场景\",{\"0\":{\"368\":1}}],[\"第二个数值\",{\"1\":{\"296\":2}}],[\"第二个事务就会被阻塞\",{\"1\":{\"280\":1}}],[\"第二个原因\",{\"1\":{\"227\":1}}],[\"第二条查询语句的执行计划如下\",{\"1\":{\"232\":1}}],[\"第二条记录\",{\"1\":{\"162\":1}}],[\"第二件事情\",{\"1\":{\"142\":1}}],[\"第二步\",{\"0\":{\"140\":1}}],[\"第二种\",{\"0\":{\"200\":1},\"1\":{\"66\":1,\"139\":1,\"357\":1}}],[\"第二行\",{\"1\":{\"66\":1}}],[\"第二部分\",{\"1\":{\"32\":1}}],[\"第一次查询8081形成的jvm缓存并未生效\",{\"1\":{\"445\":1}}],[\"第一次会访问8081端口的tomcat服务\",{\"1\":{\"445\":1}}],[\"第一次执行普通的\",{\"1\":{\"367\":1}}],[\"第一次读小林的账户余额记录\",{\"1\":{\"359\":1}}],[\"第一个例子\",{\"1\":{\"369\":1}}],[\"第一个发生幻读现象的场景\",{\"0\":{\"367\":1}}],[\"第一个事务会成为\",{\"1\":{\"348\":1}}],[\"第一个事务插入的记录\",{\"1\":{\"280\":1}}],[\"第一个进入队列的事务会成为\",{\"1\":{\"348\":1}}],[\"第一个数值是\",{\"1\":{\"296\":1}}],[\"第一个数值\",{\"1\":{\"296\":2}}],[\"第一个分组中的记录只能有\",{\"1\":{\"243\":1}}],[\"第一列数据相同时才会按照第二列排序\",{\"1\":{\"239\":1}}],[\"第一条和第二条模糊查询语句也是一样可以走索引扫描\",{\"1\":{\"232\":1}}],[\"第一条和第二条都会走索引扫描\",{\"1\":{\"231\":1}}],[\"第一条记录所有列都有值\",{\"1\":{\"162\":1}}],[\"第一原因\",{\"1\":{\"227\":1}}],[\"第一件事情\",{\"1\":{\"142\":1}}],[\"第一步\",{\"0\":{\"139\":1}}],[\"第一行\",{\"1\":{\"66\":1}}],[\"第一种\",{\"0\":{\"199\":1},\"1\":{\"66\":1,\"139\":1,\"357\":1}}],[\"第一部分\",{\"1\":{\"32\":1}}],[\"第三次读取数据时创建的\",{\"1\":{\"360\":1}}],[\"第三次读取记录时\",{\"1\":{\"359\":1}}],[\"第三条记录\",{\"1\":{\"162\":1}}],[\"第三条记录中\",{\"1\":{\"161\":1}}],[\"第三步\",{\"0\":{\"141\":1}}],[\"第三方模块\",{\"1\":{\"432\":1}}],[\"第三方权威机构\",{\"1\":{\"108\":1}}],[\"第三方\",{\"1\":{\"41\":1}}],[\"第三部分\",{\"1\":{\"32\":1}}],[\"world\",{\"0\":{\"422\":1},\"1\":{\"422\":1,\"425\":1}}],[\"work绑定cpu\",{\"1\":{\"47\":2}}],[\"work\",{\"1\":{\"34\":1}}],[\"workers\",{\"0\":{\"46\":1}}],[\"worker\",{\"0\":{\"45\":1,\"47\":1,\"48\":1},\"1\":{\"32\":5,\"44\":5,\"45\":3,\"46\":3,\"47\":6,\"48\":9,\"49\":3}}],[\"would\",{\"1\":{\"330\":1}}],[\"within\",{\"1\":{\"275\":1,\"302\":1,\"324\":1,\"363\":1}}],[\"with\",{\"1\":{\"275\":3,\"307\":1,\"323\":1,\"324\":2,\"357\":2}}],[\"windows上的nginx用来做反向代理服务\",{\"1\":{\"433\":1}}],[\"windows\",{\"1\":{\"75\":1}}],[\"wal\",{\"1\":{\"337\":4}}],[\"warnings\",{\"1\":{\"322\":1,\"323\":1,\"367\":1}}],[\"was\",{\"1\":{\"302\":1,\"363\":1}}],[\"way\",{\"1\":{\"194\":1,\"275\":1,\"324\":1}}],[\"waiting\",{\"1\":{\"277\":1,\"324\":1}}],[\"wait\",{\"1\":{\"139\":3,\"275\":1,\"281\":1,\"324\":1}}],[\"writevalueasstring\",{\"1\":{\"448\":2,\"463\":3}}],[\"write技术\",{\"1\":{\"374\":1}}],[\"write\",{\"1\":{\"179\":1,\"309\":1,\"311\":1,\"337\":1,\"338\":1,\"339\":5,\"343\":5,\"348\":2,\"349\":1}}],[\"when\",{\"1\":{\"302\":1,\"363\":1}}],[\"where之后\",{\"1\":{\"261\":1}}],[\"where\",{\"0\":{\"240\":1},\"1\":{\"137\":1,\"142\":1,\"145\":2,\"147\":1,\"148\":1,\"149\":1,\"178\":1,\"182\":1,\"197\":1,\"206\":2,\"215\":7,\"216\":4,\"217\":1,\"219\":1,\"221\":1,\"222\":1,\"228\":3,\"232\":1,\"234\":3,\"235\":2,\"236\":1,\"237\":2,\"238\":6,\"239\":9,\"240\":2,\"241\":1,\"263\":1,\"266\":1,\"275\":3,\"277\":1,\"280\":1,\"283\":2,\"285\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":1,\"297\":2,\"298\":1,\"302\":1,\"314\":1,\"322\":1,\"323\":1,\"328\":1,\"329\":5,\"330\":10,\"331\":3,\"333\":2,\"343\":1,\"344\":1,\"350\":1,\"363\":1,\"367\":3,\"368\":2}}],[\"which\",{\"1\":{\"275\":1,\"323\":1}}],[\"while\",{\"1\":{\"147\":1,\"148\":1}}],[\"weakreference<>\",{\"1\":{\"521\":1}}],[\"weakreference<string>\",{\"1\":{\"521\":1}}],[\"weakreference=new\",{\"1\":{\"521\":1}}],[\"weakreference\",{\"1\":{\"521\":1}}],[\"webp\",{\"1\":{\"436\":1,\"439\":1}}],[\"web\",{\"1\":{\"432\":3}}],[\"web端在线编辑\",{\"1\":{\"91\":1}}],[\"weight和访问比率成正比\",{\"1\":{\"41\":1}}],[\"weight代表权重默认为1\",{\"1\":{\"41\":1}}],[\"weight\",{\"1\":{\"41\":1,\"43\":1}}],[\"wc\",{\"1\":{\"43\":2}}],[\"www\",{\"1\":{\"32\":1,\"42\":3,\"150\":1,\"350\":2,\"421\":1}}],[\"wget\",{\"1\":{\"28\":2}}],[\"主观下线\",{\"1\":{\"392\":1}}],[\"主进程可以持续处理用户请求\",{\"1\":{\"373\":1}}],[\"主库和备库的数据就保证了一致性\",{\"1\":{\"346\":1}}],[\"主库和所有从库任何一个数据库出问题\",{\"1\":{\"342\":1}}],[\"主库的事务线程就可以返回给客户端\",{\"1\":{\"342\":1}}],[\"主库的自增值是什么\",{\"1\":{\"312\":1}}],[\"主库提交事务的线程并不会等待\",{\"1\":{\"342\":1}}],[\"主库提交事务的线程要等待所有从库的复制成功响应\",{\"1\":{\"342\":1}}],[\"主库也要创建同样多的\",{\"1\":{\"342\":1}}],[\"主库在收到客户端提交事务的请求之后\",{\"1\":{\"342\":1}}],[\"主库写\",{\"1\":{\"342\":1}}],[\"主库\",{\"1\":{\"312\":1}}],[\"主动回滚死锁链条中的某一个事务\",{\"1\":{\"281\":1}}],[\"主动死锁检测在发现死锁后\",{\"1\":{\"281\":1}}],[\"主键冲突\",{\"1\":{\"278\":1,\"279\":1}}],[\"主键为\",{\"1\":{\"243\":1}}],[\"主键值大于\",{\"1\":{\"244\":1}}],[\"主键值\",{\"1\":{\"217\":1,\"243\":1}}],[\"主键索引和\",{\"1\":{\"304\":1}}],[\"主键索引会加如下的锁\",{\"1\":{\"304\":1}}],[\"主键索引为\",{\"1\":{\"279\":1}}],[\"主键索引冲突\",{\"0\":{\"279\":1}}],[\"主键索引最好是自增的\",{\"0\":{\"226\":1},\"1\":{\"223\":1}}],[\"主键索引就是建立在主键字段上的索引\",{\"1\":{\"210\":1}}],[\"主键索引的\",{\"1\":{\"204\":1,\"206\":2,\"208\":1}}],[\"主键索引\",{\"0\":{\"210\":1},\"1\":{\"193\":1,\"203\":3,\"204\":1,\"208\":1,\"217\":1,\"234\":1,\"294\":1,\"297\":1,\"298\":1}}],[\"主键索引查询\",{\"0\":{\"147\":1},\"1\":{\"146\":1}}],[\"主键字段长度越小\",{\"1\":{\"226\":1}}],[\"主键字段的长度不要太大\",{\"1\":{\"226\":1}}],[\"主键字段\",{\"0\":{\"192\":1},\"1\":{\"193\":2,\"195\":1,\"196\":2}}],[\"主键我们假设是\",{\"1\":{\"187\":1}}],[\"主键\",{\"1\":{\"182\":1,\"183\":1,\"243\":1}}],[\"主机掉电的时候会丢数据\",{\"1\":{\"349\":1}}],[\"主机掉电时会丢\",{\"1\":{\"349\":1}}],[\"主机名等信息\",{\"1\":{\"108\":1}}],[\"主机值较大\",{\"1\":{\"43\":1}}],[\"主要动态语言\",{\"1\":{\"480\":1}}],[\"主要有两个方面的影响\",{\"1\":{\"347\":1}}],[\"主要有三种\",{\"1\":{\"342\":1}}],[\"主要有下面几个时机\",{\"1\":{\"338\":1}}],[\"主要用于数据备份和主从复制\",{\"1\":{\"333\":1}}],[\"主要用于掉电等故障恢复\",{\"1\":{\"333\":1}}],[\"主要用于事务回滚和\",{\"1\":{\"333\":1}}],[\"主要要以避免幻读角度去分析\",{\"1\":{\"300\":1}}],[\"主要的区别在于处理行溢出数据时有些区别\",{\"1\":{\"168\":1}}],[\"主要是\",{\"1\":{\"255\":1,\"306\":1}}],[\"主要是以下这几点\",{\"1\":{\"253\":1}}],[\"主要是在二叉查找树的基础上增加了一些条件约束\",{\"1\":{\"251\":1}}],[\"主要是因为\",{\"1\":{\"161\":1}}],[\"主要是想让大家知道行记录是存储在哪个文件\",{\"1\":{\"157\":1}}],[\"主要包含表结构定义\",{\"1\":{\"152\":1}}],[\"主要包括连接器\",{\"1\":{\"138\":1}}],[\"主要存在三大风险\",{\"1\":{\"103\":1}}],[\"主要表现为两者建模元素的异同\",{\"1\":{\"69\":1}}],[\"主要分为4中\",{\"1\":{\"59\":1}}],[\"主要设置一些影响\",{\"1\":{\"32\":1}}],[\"主\",{\"1\":{\"43\":2,\"342\":1}}],[\"主从和哨兵可以解决高可用\",{\"1\":{\"400\":1}}],[\"主从从架构图\",{\"1\":{\"387\":1}}],[\"主从同步可以保证主从数据的一致性\",{\"1\":{\"387\":1}}],[\"主从同步优化\",{\"0\":{\"387\":1}}],[\"主从第一次建立连接时\",{\"1\":{\"384\":1}}],[\"主从数据同步原理\",{\"0\":{\"383\":1}}],[\"主从架构\",{\"1\":{\"342\":1}}],[\"主从复制还有哪些模型\",{\"1\":{\"342\":1}}],[\"主从复制过程\",{\"1\":{\"342\":1}}],[\"主从复制是怎么实现\",{\"0\":{\"342\":1}}],[\"主从复制\",{\"1\":{\"341\":1}}],[\"主从复制中\",{\"1\":{\"341\":1}}],[\"主从复制的场景\",{\"1\":{\"312\":1}}],[\"主从库就发生了数据不一致\",{\"1\":{\"312\":1}}],[\"主从配置\",{\"1\":{\"43\":1}}],[\"主从\",{\"1\":{\"2\":1,\"97\":1}}],[\"启动线程\",{\"1\":{\"506\":1}}],[\"启动一个新的redis实例\",{\"1\":{\"405\":1}}],[\"启动前提交过了\",{\"1\":{\"359\":1}}],[\"启动后\",{\"1\":{\"359\":1,\"360\":1}}],[\"启动了但还没提交的事务\",{\"1\":{\"358\":1}}],[\"启动事务时\",{\"1\":{\"357\":1}}],[\"启动两个事务\",{\"1\":{\"320\":1}}],[\"启动的时候\",{\"1\":{\"173\":1,\"174\":1,\"336\":1}}],[\"启动之后\",{\"1\":{\"44\":1}}],[\"启动\",{\"0\":{\"31\":1},\"1\":{\"31\":1,\"34\":1,\"35\":1,\"406\":1}}],[\"配置分片集群地址\",{\"1\":{\"412\":1}}],[\"配置读写分离\",{\"0\":{\"398\":1},\"1\":{\"412\":1}}],[\"配置redis地址\",{\"0\":{\"397\":1},\"1\":{\"448\":1}}],[\"配置高可用的准备工作\",{\"1\":{\"43\":1}}],[\"配置文件默认识别为\",{\"1\":{\"496\":1}}],[\"配置文件目录logs\",{\"1\":{\"34\":1}}],[\"配置文件由三部分组成\",{\"1\":{\"32\":1}}],[\"配置用户或者组\",{\"1\":{\"32\":1}}],[\"配置请求路由\",{\"1\":{\"32\":1}}],[\"配置虚拟主机的相关参数\",{\"1\":{\"32\":1}}],[\"配置\",{\"0\":{\"30\":1},\"1\":{\"347\":1,\"348\":1}}],[\"配置代理服务器\",{\"1\":{\"21\":1}}],[\"解读\",{\"1\":{\"456\":2}}],[\"解析\",{\"0\":{\"141\":1},\"1\":{\"150\":1,\"492\":1}}],[\"解析器会通过词法分析识别出关键字\",{\"1\":{\"333\":1}}],[\"解析器会做如下两件事情\",{\"1\":{\"142\":1}}],[\"解析器就会给报错\",{\"1\":{\"142\":1}}],[\"解析器\",{\"0\":{\"142\":1},\"1\":{\"138\":1,\"141\":1}}],[\"解析证书链的根证书得到一级证书的公钥+摘要验签\",{\"1\":{\"109\":1}}],[\"解密后即可拿到对称加密密钥\",{\"1\":{\"107\":1}}],[\"解决问题二\",{\"1\":{\"507\":1}}],[\"解决问题一\",{\"1\":{\"507\":1}}],[\"解决的方案有两种\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"解决办法是\",{\"1\":{\"243\":1}}],[\"解决这个问题也很简单\",{\"1\":{\"156\":1}}],[\"解决公钥传输信任问题\",{\"0\":{\"108\":1}}],[\"解决单向对称密钥的传输问题\",{\"0\":{\"107\":1}}],[\"解决了窃听风险\",{\"1\":{\"104\":1}}],[\"解决此问题的有效方法是用泳道图把流程图分栏\",{\"1\":{\"58\":1}}],[\"解决完毕后\",{\"1\":{\"10\":1}}],[\"解压\",{\"0\":{\"29\":1}}],[\"执行类构造器<clinit>\",{\"1\":{\"492\":1}}],[\"执行其中的业务\",{\"1\":{\"435\":1}}],[\"执行cluster\",{\"1\":{\"411\":1}}],[\"执行命令\",{\"1\":{\"407\":1}}],[\"执行get\",{\"1\":{\"402\":1}}],[\"执行写操作\",{\"1\":{\"374\":1}}],[\"执行下面的命令\",{\"1\":{\"373\":1}}],[\"执行bgsave命令\",{\"1\":{\"373\":1}}],[\"执行时机\",{\"0\":{\"373\":1}}],[\"执行查询\",{\"1\":{\"367\":1}}],[\"执行一个事务的过程中\",{\"1\":{\"337\":1}}],[\"执行一条语句是否自动提交事务\",{\"1\":{\"334\":1}}],[\"执行一条\",{\"0\":{\"137\":1},\"1\":{\"96\":1,\"137\":1,\"138\":1,\"140\":1,\"150\":1,\"333\":2,\"334\":1}}],[\"执行完就自动提交事务的\",{\"1\":{\"334\":1}}],[\"执行完这里的时候\",{\"1\":{\"280\":1}}],[\"执行以下语句\",{\"1\":{\"322\":1,\"323\":1}}],[\"执行顺序\",{\"1\":{\"320\":1}}],[\"执行向表\",{\"1\":{\"312\":1}}],[\"执行语句的\",{\"1\":{\"312\":1}}],[\"执行后\",{\"1\":{\"307\":1}}],[\"执行slaveof\",{\"1\":{\"394\":1}}],[\"执行save命令\",{\"1\":{\"373\":1}}],[\"执行select\",{\"1\":{\"296\":1}}],[\"执行sql\",{\"1\":{\"139\":4}}],[\"执行了这面这条锁定读语句后\",{\"1\":{\"365\":1}}],[\"执行了这条范围查询语句\",{\"1\":{\"293\":2,\"294\":2}}],[\"执行了这条等值查询语句\",{\"1\":{\"290\":1,\"291\":1}}],[\"执行了这条语句\",{\"1\":{\"178\":1}}],[\"执行了增删查改操作的\",{\"1\":{\"357\":1}}],[\"执行了读操作\",{\"1\":{\"357\":1}}],[\"执行了两次\",{\"1\":{\"302\":1,\"363\":1}}],[\"执行了相同的\",{\"1\":{\"280\":1}}],[\"执行了\",{\"1\":{\"280\":1,\"357\":2}}],[\"执行了下面这条语句\",{\"1\":{\"277\":1}}],[\"执行的结果如下图\",{\"1\":{\"238\":1}}],[\"执行同样的查询语句后\",{\"1\":{\"232\":1}}],[\"执行计划的结果\",{\"1\":{\"231\":1}}],[\"执行计划中的\",{\"1\":{\"235\":2,\"236\":1}}],[\"执行计划中\",{\"1\":{\"219\":1,\"237\":1}}],[\"执行计划如下\",{\"1\":{\"216\":2}}],[\"执行where\",{\"1\":{\"215\":1}}],[\"执行效率不稳定\",{\"1\":{\"527\":1}}],[\"执行效率是最差的\",{\"1\":{\"195\":1}}],[\"执行效率会比\",{\"1\":{\"193\":1}}],[\"执行过程中查询到的余额可能会不同\",{\"1\":{\"357\":1}}],[\"执行过程中产生的锁才会被释放\",{\"1\":{\"304\":1}}],[\"执行过程中使用了普通索引\",{\"1\":{\"145\":1}}],[\"执行过程基本一样的\",{\"1\":{\"194\":1}}],[\"执行过程跟\",{\"1\":{\"194\":1}}],[\"执行过程是怎样的\",{\"0\":{\"192\":1,\"193\":1,\"194\":1,\"195\":1}}],[\"执行阶段\",{\"1\":{\"150\":1}}],[\"执行器得到聚簇索引记录后\",{\"1\":{\"343\":1,\"350\":1}}],[\"执行器把\",{\"1\":{\"343\":1}}],[\"执行器负责具体执行\",{\"1\":{\"333\":1,\"343\":1,\"350\":1}}],[\"执行器与存储引擎的执行流程是这样的\",{\"1\":{\"149\":1}}],[\"执行器收到存储引擎报告的查询完毕的信息\",{\"1\":{\"148\":1}}],[\"执行器继续判断条件\",{\"1\":{\"148\":1}}],[\"执行器会判断读到的这条记录的\",{\"1\":{\"148\":1}}],[\"执行器就按照执行计划开始进行更新操作\",{\"1\":{\"343\":1}}],[\"执行器就退出循环\",{\"1\":{\"147\":1}}],[\"执行器就会和存储引擎交互了\",{\"1\":{\"146\":1}}],[\"执行器查询的过程是一个\",{\"1\":{\"147\":1,\"148\":1}}],[\"执行器从存储引擎读到记录后\",{\"1\":{\"147\":1}}],[\"执行器第一次查询\",{\"1\":{\"147\":1,\"148\":1}}],[\"执行器\",{\"0\":{\"146\":1},\"1\":{\"146\":1}}],[\"执行器等\",{\"1\":{\"138\":1}}],[\"执行流程是怎样的\",{\"0\":{\"138\":1}}],[\"执行\",{\"0\":{\"143\":1},\"1\":{\"28\":1,\"150\":2,\"182\":1,\"197\":2,\"199\":1,\"312\":1,\"357\":1}}],[\"还未提交事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"还小\",{\"1\":{\"359\":1,\"360\":1}}],[\"还提供了另外两种策略\",{\"1\":{\"338\":1}}],[\"还没提交事务\",{\"1\":{\"358\":1,\"360\":1}}],[\"还没提交事务的\",{\"1\":{\"346\":1}}],[\"还没提交的时候\",{\"1\":{\"317\":1}}],[\"还没有提交事务\",{\"1\":{\"354\":1}}],[\"还没有刷盘\",{\"1\":{\"346\":1}}],[\"还没有来得及写入\",{\"1\":{\"344\":2}}],[\"还没写入\",{\"1\":{\"346\":2}}],[\"还没写\",{\"1\":{\"344\":1}}],[\"还没持久化到磁盘的数据就会丢失\",{\"1\":{\"343\":1}}],[\"还没来得及落盘的脏页数据就会丢失\",{\"1\":{\"337\":1}}],[\"还没被使用的时候\",{\"1\":{\"140\":1}}],[\"还对主键索引\",{\"1\":{\"297\":1}}],[\"还做一个很重要的事情\",{\"1\":{\"279\":1,\"280\":1}}],[\"还给行记录两边的空隙也加上了间隙锁\",{\"1\":{\"275\":1}}],[\"还不如不要索引\",{\"1\":{\"218\":1,\"222\":1}}],[\"还能提高写性能\",{\"1\":{\"177\":1}}],[\"还能够传达构成应用程序的硬件和软件元素的配置和部署方式\",{\"1\":{\"74\":1}}],[\"还包括了\",{\"1\":{\"174\":1,\"336\":1}}],[\"还要有\",{\"1\":{\"340\":1}}],[\"还要看该新记录插入的位置的下一条记录是否有间隙锁\",{\"1\":{\"297\":1}}],[\"还要看插入的新记录的\",{\"1\":{\"297\":5}}],[\"还要看数据库表的字符集\",{\"1\":{\"165\":1}}],[\"还要考虑磁盘\",{\"1\":{\"247\":1}}],[\"还要考虑算法的质量\",{\"1\":{\"58\":1}}],[\"还要淘汰\",{\"1\":{\"178\":1}}],[\"还有下面这个场景也会发生幻读现象\",{\"1\":{\"368\":1}}],[\"还有这几种情况\",{\"1\":{\"358\":1}}],[\"还有\",{\"1\":{\"352\":1}}],[\"还有一件很重要的事情\",{\"1\":{\"300\":1}}],[\"还有一个作用\",{\"1\":{\"334\":1}}],[\"还有一个查询优化器\",{\"1\":{\"218\":1,\"222\":1}}],[\"还有一个头节点\",{\"1\":{\"176\":1}}],[\"还有间隙锁\",{\"1\":{\"284\":1}}],[\"还有很多自平衡的二叉树\",{\"1\":{\"251\":1}}],[\"还有三个隐藏字段\",{\"1\":{\"164\":1}}],[\"还有其他功能\",{\"1\":{\"109\":1}}],[\"还需要加一个锁来保证提交的原子性\",{\"1\":{\"347\":1}}],[\"还需要看新记录的\",{\"1\":{\"298\":2}}],[\"还需要考虑插入记录的\",{\"1\":{\"296\":1}}],[\"还需要判断其他条件是否满足\",{\"1\":{\"217\":1}}],[\"还需要把末尾的页淘汰掉\",{\"1\":{\"178\":1}}],[\"还需要为\",{\"1\":{\"145\":1}}],[\"还需要验证证书上的域名与自己的请求域名是否一致\",{\"1\":{\"108\":1}}],[\"还会把证书信任链也一起传给客户端\",{\"1\":{\"109\":1}}],[\"还是通过赵老板的例子来说明\",{\"1\":{\"507\":1}}],[\"还是基于启动事务时创建的\",{\"1\":{\"359\":1}}],[\"还是时刻\",{\"1\":{\"346\":1}}],[\"还是将\",{\"1\":{\"338\":1}}],[\"还是将数字转换成字符串处理\",{\"1\":{\"238\":1}}],[\"还是在内存中\",{\"1\":{\"338\":1}}],[\"还是在书的目录去找呢\",{\"1\":{\"202\":1}}],[\"还是选择缓存起来呢\",{\"1\":{\"335\":1}}],[\"还是全表扫描\",{\"1\":{\"329\":1}}],[\"还是轻量级的锁\",{\"1\":{\"312\":1}}],[\"还是\",{\"1\":{\"278\":2,\"292\":1,\"294\":2}}],[\"还是记录锁\",{\"1\":{\"275\":1,\"290\":1,\"322\":1}}],[\"还是间隙锁\",{\"1\":{\"275\":1,\"290\":1,\"322\":1}}],[\"还是可以走索引扫描\",{\"1\":{\"238\":1}}],[\"还是偷了这个懒\",{\"1\":{\"237\":1}}],[\"还是回主键索引去判断呢\",{\"1\":{\"217\":1}}],[\"还是按照\",{\"1\":{\"187\":1}}],[\"还是不行\",{\"1\":{\"166\":1}}],[\"还是以这张表作为例子\",{\"1\":{\"367\":1}}],[\"还是以\",{\"1\":{\"162\":1}}],[\"还是用证书\",{\"1\":{\"109\":1}}],[\"还是长期关注的朋友\",{\"1\":{\"1\":1}}],[\"还可以有其它的方法\",{\"1\":{\"58\":1}}],[\"还支持\",{\"1\":{\"26\":1}}],[\"并被告知联系哪个秘书\",{\"1\":{\"507\":1}}],[\"并将这些静态数据转换为方法区的运行时数据结构\",{\"1\":{\"493\":1}}],[\"并将这些静态数据转换成方法区的运行时数据结构\",{\"1\":{\"492\":1}}],[\"并将最中间的节点作为根节点\",{\"1\":{\"250\":1}}],[\"并能直接操作任意对象的内部属性及方法\",{\"1\":{\"480\":1}}],[\"并初始化redis对象\",{\"1\":{\"450\":1}}],[\"并设置基于路径做负载均衡\",{\"1\":{\"447\":1}}],[\"并解析响应\",{\"1\":{\"442\":1,\"450\":1}}],[\"并导入依赖\",{\"1\":{\"435\":1}}],[\"并作为一个master节点\",{\"1\":{\"405\":1}}],[\"并向其中存储\",{\"1\":{\"405\":1}}],[\"并持续将log中的命令发送给slave\",{\"1\":{\"384\":1}}],[\"并以链表的方式串联起来\",{\"1\":{\"359\":1}}],[\"并行事务会引发什么问题\",{\"0\":{\"353\":1}}],[\"并行事务导致的问题\",{\"0\":{\"270\":1}}],[\"并清空\",{\"1\":{\"343\":1}}],[\"并更新存储引擎中的数据\",{\"1\":{\"342\":1}}],[\"并更新本地存储数据\",{\"1\":{\"342\":1}}],[\"并提交了事务\",{\"1\":{\"334\":1,\"355\":1,\"356\":1,\"360\":2,\"361\":1}}],[\"并提供丰富的应用程序供测试或其它目的使用\",{\"1\":{\"26\":1}}],[\"并发事务时可能发生的现象也会不同\",{\"1\":{\"357\":1}}],[\"并发多个事务的时候\",{\"1\":{\"280\":1}}],[\"并发能力强\",{\"1\":{\"20\":1}}],[\"并未提交\",{\"1\":{\"280\":1}}],[\"并未去重\",{\"1\":{\"261\":1}}],[\"并没有执行当前读\",{\"1\":{\"369\":1}}],[\"并没有出现所谓的幻读现象\",{\"1\":{\"364\":1}}],[\"并没有提交事务\",{\"1\":{\"359\":1}}],[\"并没有刷新到硬盘上的\",{\"1\":{\"343\":1,\"350\":1}}],[\"并没有成功获取到插入意向锁\",{\"1\":{\"277\":1}}],[\"并没有退化为间隙锁\",{\"1\":{\"275\":1}}],[\"并没有被访问\",{\"1\":{\"178\":1}}],[\"并完成与存储引擎的交互\",{\"1\":{\"272\":1}}],[\"并不包含ip和端口\",{\"1\":{\"441\":1}}],[\"并不能完全避免幻读现象\",{\"1\":{\"367\":1,\"369\":1}}],[\"并不代表事务启动了\",{\"1\":{\"357\":1}}],[\"并不意味着启动了事务\",{\"1\":{\"357\":1}}],[\"并不意味着写入到了磁盘\",{\"1\":{\"338\":1,\"349\":1}}],[\"并不意味着任何查询语句都能走索引扫描\",{\"1\":{\"233\":1}}],[\"并不需要等语句执行后才释放\",{\"1\":{\"312\":1}}],[\"并不冲突\",{\"1\":{\"310\":1}}],[\"并不存在于表中\",{\"1\":{\"294\":1}}],[\"并不存在互斥关系\",{\"1\":{\"286\":1,\"315\":1}}],[\"并不一定会走全表扫描\",{\"1\":{\"232\":1}}],[\"并不会读取这个版本的记录\",{\"1\":{\"359\":1,\"360\":1}}],[\"并不会使用\",{\"1\":{\"357\":1}}],[\"并不会马上执行刷盘的操作\",{\"1\":{\"348\":1}}],[\"并不会全表扫描\",{\"1\":{\"304\":1}}],[\"并不会发生阻塞\",{\"1\":{\"291\":1}}],[\"并不会加锁\",{\"1\":{\"280\":1}}],[\"并不会停止匹配\",{\"1\":{\"216\":1}}],[\"并不会真正的删除记录\",{\"1\":{\"163\":1}}],[\"并不是没有无参的构造器就不能创建对象\",{\"1\":{\"498\":1}}],[\"并不是彻底避免\",{\"1\":{\"357\":1}}],[\"并不是针对输出的结果加锁\",{\"1\":{\"304\":1}}],[\"并不是完全解决了\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"并不是意味着事务成功获取到了锁\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"并不是一个真实的记录\",{\"1\":{\"275\":1}}],[\"并不是一条语句执行完就释放行锁\",{\"1\":{\"275\":1}}],[\"并不是将这个记录本身从磁盘读出来\",{\"1\":{\"243\":1}}],[\"并不是将这个行记录从磁盘读出来\",{\"1\":{\"155\":1}}],[\"并不是查询过程使用了联合索引查询\",{\"1\":{\"216\":1}}],[\"并不是所有的空间都是用来存放数据的\",{\"1\":{\"188\":1}}],[\"并不是字节大小哦\",{\"1\":{\"165\":1}}],[\"并不是在解析器里做的\",{\"1\":{\"142\":1}}],[\"并不是\",{\"1\":{\"140\":1,\"329\":1}}],[\"并报错提示\",{\"1\":{\"139\":1}}],[\"并编写了简单工具类\",{\"1\":{\"100\":1}}],[\"并在此基础上加以完善且提供了更友好的的调用方法\",{\"1\":{\"99\":1}}],[\"并在直线上标注联系的类型\",{\"1\":{\"90\":1}}],[\"并产生传递特定参与者的价值的可观察结果\",{\"1\":{\"59\":1}}],[\"并展示为那个过程负责的功能板块\",{\"1\":{\"58\":1}}],[\"并\",{\"1\":{\"48\":1}}],[\"并且限制了member\",{\"1\":{\"498\":1}}],[\"并且对于任意一个对象\",{\"1\":{\"481\":1}}],[\"并且必须是拿到redistemplate之后\",{\"1\":{\"448\":1}}],[\"并且没有数据统计相关功能\",{\"1\":{\"448\":1}}],[\"并且包含商品\",{\"1\":{\"442\":1}}],[\"并且返回\",{\"1\":{\"442\":1}}],[\"并且默认是一个master节点\",{\"1\":{\"407\":1}}],[\"并且在repl\",{\"1\":{\"388\":1}}],[\"并且在测试机确认该语句是否走的是索引扫描\",{\"1\":{\"331\":1}}],[\"并且提交了事务\",{\"1\":{\"367\":1}}],[\"并且\",{\"1\":{\"312\":1,\"329\":1,\"330\":1}}],[\"并且锁定记录本身\",{\"1\":{\"284\":1,\"287\":1,\"313\":1,\"316\":1}}],[\"并且已经存在\",{\"1\":{\"279\":1,\"280\":1}}],[\"并且树的分叉数\",{\"1\":{\"251\":1}}],[\"并且最后一条记录的头信息中会存储该组一共有多少条记录\",{\"1\":{\"243\":1}}],[\"并且是在程序运行时根据需要动态创建目标类的代理对象\",{\"1\":{\"507\":1}}],[\"并且是在子节点中所有索引的最大\",{\"1\":{\"253\":1}}],[\"并且是在我本机上\",{\"1\":{\"182\":1}}],[\"并且是一个全表扫描的查询语句\",{\"1\":{\"228\":1}}],[\"并且每一个叶子节点都指向下一个叶子节点\",{\"1\":{\"204\":1}}],[\"并且把该缓存页对应的控制块的信息填上\",{\"1\":{\"176\":1}}],[\"并且空闲的时长是\",{\"1\":{\"139\":1}}],[\"并且节点类型前会有冒号\",{\"1\":{\"75\":1}}],[\"并且使用下划线与类进行区分\",{\"1\":{\"70\":1}}],[\"并且不区分大小写\",{\"1\":{\"39\":1}}],[\"并且区分大小写\",{\"1\":{\"39\":1}}],[\"sweep\",{\"1\":{\"526\":1}}],[\"s720x720\",{\"1\":{\"436\":1,\"439\":1}}],[\"snapshot\",{\"1\":{\"357\":2}}],[\"synchronized\",{\"1\":{\"517\":1}}],[\"sync\",{\"1\":{\"343\":7,\"347\":2,\"348\":12,\"349\":3,\"387\":1}}],[\"system\",{\"1\":{\"416\":2,\"496\":1,\"499\":2,\"502\":2,\"503\":1,\"507\":2,\"520\":4}}],[\"systemctl\",{\"1\":{\"43\":2}}],[\"sysadmin\",{\"1\":{\"43\":1}}],[\"spec\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"specifically\",{\"1\":{\"330\":1}}],[\"spring\",{\"1\":{\"397\":1,\"412\":1,\"448\":1,\"460\":1}}],[\"springframework\",{\"1\":{\"396\":1,\"419\":2,\"448\":5,\"462\":2,\"463\":6}}],[\"spring的redistemplate底层利用lettuce实现了节点的感知和自动切换\",{\"1\":{\"395\":1}}],[\"space\",{\"1\":{\"185\":2}}],[\"salsa\",{\"1\":{\"436\":2,\"439\":2}}],[\"say\",{\"1\":{\"436\":2,\"439\":1,\"444\":1,\"451\":1,\"454\":1}}],[\"saveitem\",{\"1\":{\"463\":3}}],[\"save\",{\"1\":{\"373\":3,\"375\":1}}],[\"save命令会导致主进程执行rdb\",{\"1\":{\"373\":1}}],[\"save命令\",{\"1\":{\"373\":1}}],[\"safe\",{\"1\":{\"330\":2,\"331\":1,\"337\":2,\"340\":3}}],[\"same\",{\"1\":{\"194\":1,\"275\":4,\"302\":1,\"323\":2,\"324\":2,\"363\":1}}],[\"s0026\",{\"1\":{\"325\":1}}],[\"s0025\",{\"1\":{\"324\":1}}],[\"s型\",{\"1\":{\"323\":1}}],[\"s型锁\",{\"1\":{\"283\":1}}],[\"softreference=new\",{\"1\":{\"520\":1}}],[\"softreference<string>\",{\"1\":{\"520\":1}}],[\"softreference<>\",{\"1\":{\"520\":2}}],[\"softreference<byte\",{\"1\":{\"520\":1}}],[\"softreference\",{\"1\":{\"520\":2}}],[\"something\",{\"1\":{\"507\":3}}],[\"sold\",{\"1\":{\"436\":1,\"439\":1,\"444\":2,\"451\":2,\"454\":2,\"462\":1}}],[\"sony\",{\"1\":{\"324\":1}}],[\"so\",{\"1\":{\"302\":1,\"363\":1,\"435\":1}}],[\"sourcecode\",{\"1\":{\"150\":1}}],[\"source\",{\"1\":{\"150\":1}}],[\"s锁\",{\"1\":{\"283\":1,\"313\":1}}],[\"such\",{\"1\":{\"275\":1,\"324\":1}}],[\"superclass\",{\"1\":{\"499\":1}}],[\"supermum\",{\"1\":{\"187\":1}}],[\"suppose\",{\"1\":{\"275\":1,\"324\":1}}],[\"supremum\",{\"1\":{\"275\":1,\"293\":5,\"298\":2}}],[\"score\",{\"1\":{\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"schema\",{\"1\":{\"275\":1,\"277\":2,\"279\":1,\"280\":4,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":3,\"297\":1,\"304\":2,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"script\",{\"1\":{\"43\":2}}],[\"slave节点断开又恢复\",{\"1\":{\"388\":1}}],[\"slave节点断开时间太久\",{\"1\":{\"388\":1}}],[\"slave节点第一次连接master节点时\",{\"1\":{\"388\":1}}],[\"slave节点请求增量同步\",{\"1\":{\"384\":1}}],[\"slave提交自己的offset到master\",{\"1\":{\"388\":1}}],[\"slave也不断的拷贝\",{\"1\":{\"386\":1}}],[\"slave与master的offset之间的差异\",{\"1\":{\"386\":1}}],[\"slave执行接收到的命令\",{\"1\":{\"384\":1}}],[\"slave清空本地数据\",{\"1\":{\"384\":1}}],[\"slave保存这些信息\",{\"1\":{\"384\":1}}],[\"slave完成同步时也会记录当前同步的offset\",{\"1\":{\"384\":1}}],[\"slave则会继承master节点的replid\",{\"1\":{\"384\":1}}],[\"slave\",{\"1\":{\"341\":1,\"458\":2}}],[\"slot\",{\"1\":{\"243\":1,\"402\":1}}],[\"sleep\",{\"1\":{\"43\":1,\"139\":1}}],[\"single\",{\"1\":{\"307\":1}}],[\"signals\",{\"1\":{\"275\":1,\"324\":1}}],[\"signed\",{\"1\":{\"182\":3,\"238\":2}}],[\"size=\",{\"1\":{\"182\":1}}],[\"size\",{\"1\":{\"173\":1,\"180\":1,\"182\":2,\"187\":1,\"337\":1,\"343\":1,\"379\":1,\"450\":4}}],[\"sql语句中嵌套select语句\",{\"1\":{\"266\":1}}],[\"sql\",{\"0\":{\"141\":1,\"143\":1,\"283\":1},\"1\":{\"96\":1,\"137\":1,\"138\":3,\"139\":1,\"140\":7,\"141\":2,\"142\":4,\"143\":1,\"144\":2,\"145\":3,\"150\":7,\"178\":1,\"179\":2,\"180\":2,\"182\":2,\"183\":1,\"187\":2,\"218\":1,\"219\":2,\"225\":1,\"228\":1,\"230\":1,\"275\":1,\"290\":1,\"291\":1,\"304\":2,\"312\":2,\"318\":1,\"320\":1,\"321\":2,\"330\":2,\"331\":1,\"333\":1,\"341\":2,\"357\":3,\"361\":1}}],[\"src\",{\"1\":{\"43\":2,\"496\":1}}],[\"smtp\",{\"1\":{\"43\":2}}],[\"shared\",{\"1\":{\"275\":1,\"323\":1,\"453\":2,\"454\":2}}],[\"share\",{\"1\":{\"144\":1,\"275\":1,\"283\":1,\"311\":1,\"313\":1}}],[\"showdesc\",{\"1\":{\"502\":4}}],[\"show\",{\"1\":{\"139\":3,\"152\":1,\"199\":1,\"340\":1,\"502\":5}}],[\"showme\",{\"1\":{\"110\":1}}],[\"shutdown\",{\"1\":{\"35\":1,\"410\":1}}],[\"sh\",{\"1\":{\"35\":2,\"43\":2}}],[\"sed\",{\"1\":{\"406\":1}}],[\"session\",{\"1\":{\"312\":11}}],[\"separate\",{\"1\":{\"275\":1,\"324\":1}}],[\"serializable\",{\"1\":{\"271\":1,\"357\":1}}],[\"service服务中引入redis依赖\",{\"1\":{\"448\":1}}],[\"service中的接口都是\",{\"1\":{\"442\":1}}],[\"service包下的itemcontroller类\",{\"1\":{\"419\":1}}],[\"service包下定义caffeineconfig类\",{\"1\":{\"419\":1}}],[\"service\",{\"1\":{\"43\":2,\"109\":1,\"448\":2,\"463\":2}}],[\"server层\",{\"1\":{\"148\":2}}],[\"server全局块\",{\"1\":{\"32\":1}}],[\"server块\",{\"1\":{\"32\":4}}],[\"server\",{\"1\":{\"32\":8,\"38\":2,\"41\":6,\"43\":1,\"75\":1,\"107\":6,\"108\":6,\"109\":5,\"138\":5,\"139\":1,\"140\":2,\"148\":1,\"149\":10,\"192\":3,\"193\":2,\"239\":1,\"333\":1,\"340\":1,\"341\":1,\"343\":1,\"406\":1,\"447\":2,\"448\":1,\"461\":1}}],[\"selete\",{\"1\":{\"189\":1}}],[\"select之后\",{\"1\":{\"261\":1}}],[\"select\",{\"0\":{\"137\":1},\"1\":{\"137\":3,\"140\":1,\"144\":2,\"145\":2,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"178\":1,\"182\":3,\"191\":2,\"192\":1,\"193\":1,\"194\":3,\"195\":1,\"198\":1,\"206\":2,\"216\":4,\"217\":1,\"219\":1,\"228\":1,\"232\":4,\"234\":3,\"235\":2,\"236\":1,\"237\":1,\"238\":9,\"240\":1,\"263\":2,\"264\":3,\"265\":1,\"266\":2,\"273\":1,\"274\":3,\"275\":8,\"277\":3,\"279\":1,\"280\":3,\"283\":3,\"285\":1,\"290\":2,\"291\":2,\"293\":4,\"294\":6,\"296\":2,\"297\":3,\"298\":1,\"299\":1,\"300\":1,\"302\":6,\"304\":4,\"305\":1,\"310\":6,\"311\":5,\"312\":1,\"313\":3,\"314\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"329\":1,\"334\":3,\"340\":1,\"357\":2,\"361\":6,\"362\":3,\"363\":3,\"365\":1,\"367\":4,\"368\":3,\"369\":3}}],[\"select|poll|kqueue|epoll|resig|\",{\"1\":{\"32\":1}}],[\"segment\",{\"0\":{\"157\":1},\"1\":{\"153\":1,\"157\":1}}],[\"secondary\",{\"1\":{\"204\":1}}],[\"second\",{\"1\":{\"182\":3,\"302\":1,\"363\":1}}],[\"sec\",{\"1\":{\"139\":3,\"152\":1,\"277\":3,\"290\":2,\"291\":2,\"293\":4,\"294\":4,\"296\":2,\"297\":2,\"298\":2,\"322\":2,\"323\":2,\"367\":7}}],[\"setaccessible\",{\"1\":{\"501\":1,\"502\":2,\"503\":1,\"508\":1}}],[\"sets\",{\"1\":{\"302\":1,\"363\":1}}],[\"set\",{\"1\":{\"139\":2,\"152\":1,\"161\":1,\"166\":1,\"182\":3,\"204\":1,\"275\":1,\"277\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"298\":1,\"313\":1,\"322\":1,\"323\":1,\"324\":1,\"330\":1,\"333\":1,\"343\":1,\"344\":1,\"350\":1,\"367\":3,\"379\":1,\"448\":2,\"450\":4,\"453\":1,\"454\":2,\"463\":3,\"501\":1,\"517\":1}}],[\"senior\",{\"0\":{\"559\":1,\"567\":1}}],[\"sendfile\",{\"1\":{\"32\":2}}],[\"sentinel如何判断一个redis实例是否健康\",{\"1\":{\"394\":1}}],[\"sentinel的三个作用是什么\",{\"1\":{\"394\":1}}],[\"sentinel将故障节点标记为slave\",{\"1\":{\"393\":1}}],[\"sentinel给所有其它slave发送slaveof\",{\"1\":{\"393\":1}}],[\"sentinel给备选的slave1节点发送slaveof\",{\"1\":{\"393\":1}}],[\"sentinel需要在salve中选择一个作为新的master\",{\"1\":{\"393\":1}}],[\"sentinel基于心跳机制监测服务状态\",{\"1\":{\"392\":1}}],[\"sentinel充当redis客户端的服务发现来源\",{\"1\":{\"391\":1}}],[\"sentinel会将一个slave提升为master\",{\"1\":{\"391\":1}}],[\"sentinel\",{\"1\":{\"389\":1,\"391\":1,\"397\":1}}],[\"sent\",{\"1\":{\"32\":1}}],[\"stereotype\",{\"1\":{\"448\":1,\"463\":2}}],[\"structure\",{\"0\":{\"561\":1}}],[\"str=null\",{\"1\":{\"520\":2,\"521\":1}}],[\"str=new\",{\"1\":{\"520\":1,\"521\":1,\"522\":1}}],[\"strategysingleton\",{\"1\":{\"508\":1}}],[\"strategymanager\",{\"1\":{\"508\":1}}],[\"str2\",{\"1\":{\"425\":1}}],[\"str\",{\"1\":{\"425\":1,\"520\":1,\"521\":1,\"522\":1}}],[\"stringredistemplate\",{\"1\":{\"448\":2,\"463\":2}}],[\"string\",{\"0\":{\"487\":1},\"1\":{\"416\":2,\"448\":2,\"462\":6,\"463\":3,\"494\":1,\"496\":2,\"501\":1,\"502\":2,\"503\":2,\"507\":6,\"508\":8,\"517\":1,\"520\":2,\"521\":2,\"522\":2}}],[\"string>\",{\"1\":{\"416\":3,\"520\":1}}],[\"stream\",{\"1\":{\"32\":1}}],[\"stu\",{\"1\":{\"364\":1,\"367\":4}}],[\"student`\",{\"1\":{\"319\":1}}],[\"student\",{\"1\":{\"309\":3,\"319\":2,\"322\":2,\"323\":1,\"324\":1,\"325\":1}}],[\"stocklist\",{\"1\":{\"448\":2,\"463\":2}}],[\"stockjson\",{\"1\":{\"444\":1,\"451\":2,\"454\":2}}],[\"stock\",{\"1\":{\"419\":1,\"436\":1,\"439\":1,\"442\":1,\"444\":6,\"448\":4,\"451\":7,\"454\":7,\"462\":1,\"463\":4}}],[\"stockservice\",{\"1\":{\"419\":2,\"448\":2,\"463\":2}}],[\"stockcache\",{\"1\":{\"419\":3}}],[\"storage\",{\"1\":{\"166\":3}}],[\"stop\",{\"1\":{\"31\":1,\"43\":1}}],[\"starter<\",{\"1\":{\"460\":1}}],[\"starter客户端\",{\"1\":{\"459\":1}}],[\"starter\",{\"1\":{\"396\":1,\"448\":1}}],[\"start\",{\"1\":{\"43\":1,\"283\":1,\"313\":1,\"357\":4,\"506\":1}}],[\"startup\",{\"1\":{\"35\":1}}],[\"static\",{\"1\":{\"448\":1,\"463\":1,\"492\":1,\"507\":2,\"508\":1}}],[\"statements\",{\"1\":{\"330\":4}}],[\"statement\",{\"1\":{\"312\":1,\"341\":7}}],[\"state\",{\"1\":{\"43\":1}}],[\"status\",{\"1\":{\"15\":1,\"199\":1,\"219\":6,\"277\":1,\"280\":1,\"324\":1,\"419\":1,\"436\":1,\"439\":1,\"441\":1,\"462\":1}}],[\"s\",{\"1\":{\"31\":3,\"275\":2,\"278\":3,\"279\":5,\"280\":9,\"285\":8,\"286\":1,\"287\":1,\"314\":8,\"315\":1,\"316\":1,\"406\":1,\"436\":1,\"439\":1,\"447\":1}}],[\"sbin\",{\"1\":{\"31\":1,\"43\":1,\"44\":1}}],[\"ssl\",{\"1\":{\"26\":1,\"110\":2}}],[\"囊括主要的密码算法\",{\"1\":{\"26\":1}}],[\"os\",{\"0\":{\"553\":1}}],[\"oschina\",{\"1\":{\"181\":1}}],[\"oom\",{\"1\":{\"516\":1,\"519\":1}}],[\"override\",{\"1\":{\"448\":1,\"463\":4,\"507\":3,\"508\":1}}],[\"overhead\",{\"1\":{\"166\":3}}],[\"obj=new\",{\"1\":{\"519\":1}}],[\"object类有一个finalize方法\",{\"1\":{\"523\":1}}],[\"object>\",{\"1\":{\"508\":2}}],[\"object\",{\"0\":{\"565\":1},\"1\":{\"480\":1,\"502\":2,\"507\":8,\"508\":4,\"519\":2}}],[\"objectmapper\",{\"1\":{\"448\":3,\"463\":3}}],[\"obj\",{\"1\":{\"443\":4,\"498\":1,\"507\":11}}],[\"obtaining\",{\"1\":{\"275\":1,\"324\":1}}],[\"occurs\",{\"1\":{\"302\":1,\"363\":1}}],[\"octet\",{\"1\":{\"32\":1}}],[\"other\",{\"1\":{\"275\":4,\"323\":2,\"324\":2}}],[\"out\",{\"1\":{\"416\":2,\"496\":1,\"499\":2,\"502\":2,\"503\":1,\"507\":2,\"520\":2}}],[\"outer\",{\"1\":{\"264\":3}}],[\"outline\",{\"1\":{\"91\":2}}],[\"o次数会更少\",{\"1\":{\"254\":1,\"258\":1}}],[\"owned\",{\"1\":{\"243\":1}}],[\"ofseconds\",{\"1\":{\"416\":1}}],[\"of\",{\"1\":{\"182\":1,\"275\":3,\"302\":1,\"324\":3,\"330\":1,\"363\":1}}],[\"offset\",{\"1\":{\"384\":1}}],[\"office系列\",{\"1\":{\"91\":1}}],[\"off\",{\"1\":{\"32\":1}}],[\"oldcap\",{\"1\":{\"473\":2}}],[\"old\",{\"1\":{\"178\":19,\"180\":7}}],[\"o\",{\"0\":{\"349\":1},\"1\":{\"155\":1,\"156\":4,\"192\":2,\"197\":1,\"205\":4,\"207\":5,\"225\":1,\"243\":3,\"244\":2,\"247\":1,\"248\":6,\"249\":2,\"250\":4,\"251\":3,\"252\":6,\"254\":1,\"256\":1,\"258\":6,\"335\":1,\"337\":1,\"338\":1,\"342\":2,\"343\":4,\"347\":2,\"348\":1,\"349\":2,\"350\":1,\"473\":2,\"508\":1}}],[\"opsforvalue\",{\"1\":{\"448\":2,\"463\":3}}],[\"openresty为nginx提供了shard\",{\"1\":{\"453\":1}}],[\"openresty提供了操作redis的模块\",{\"1\":{\"450\":1}}],[\"openresty提供了一个cjson的模块用来处理json的序列化和反序列化\",{\"1\":{\"443\":1}}],[\"openresty需要对tomcat集群做负载均衡\",{\"1\":{\"445\":1}}],[\"openresty启动时会加载以下两个目录中的工具文件\",{\"1\":{\"442\":1}}],[\"openresty中提供了一些api用来获取不同类型的前端请求参数\",{\"1\":{\"438\":1}}],[\"openresty的很多功能都依赖于其目录下的lua库\",{\"1\":{\"435\":1}}],[\"openresty监听请求\",{\"0\":{\"435\":1}}],[\"openresty集群用来编写多级缓存业务\",{\"1\":{\"433\":1}}],[\"openresty快速入门\",{\"0\":{\"433\":1}}],[\"openresty\",{\"1\":{\"432\":1,\"435\":4,\"436\":2,\"439\":2,\"442\":4,\"443\":1,\"447\":1,\"450\":1,\"451\":1,\"454\":1}}],[\"openresty®\",{\"1\":{\"432\":1}}],[\"openssl\",{\"1\":{\"26\":4}}],[\"operations\",{\"1\":{\"194\":1,\"275\":1,\"324\":1}}],[\"opt\",{\"1\":{\"152\":2}}],[\"optimize\",{\"1\":{\"143\":1}}],[\"ok\",{\"1\":{\"139\":1,\"277\":2,\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"298\":1,\"322\":2,\"323\":2,\"367\":5,\"450\":8}}],[\"one命令\",{\"1\":{\"393\":1}}],[\"one\",{\"1\":{\"275\":1,\"323\":1,\"394\":1,\"419\":1}}],[\"only\",{\"1\":{\"275\":1,\"323\":1,\"377\":1}}],[\"onnx和demo\",{\"1\":{\"99\":1}}],[\"on\",{\"1\":{\"32\":3,\"42\":1,\"211\":1,\"212\":1,\"213\":1,\"215\":1,\"263\":1,\"264\":3,\"265\":1,\"275\":2,\"281\":1,\"323\":1,\"324\":1,\"374\":1}}],[\"oriented\",{\"0\":{\"565\":1}}],[\"origin\",{\"1\":{\"15\":1}}],[\"or\",{\"0\":{\"240\":1},\"1\":{\"228\":2,\"240\":4,\"241\":2,\"330\":6}}],[\"order`\",{\"1\":{\"274\":2}}],[\"order\",{\"1\":{\"152\":7,\"191\":5,\"192\":1,\"193\":1,\"195\":1,\"197\":2,\"198\":2,\"199\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"228\":1,\"274\":2,\"275\":11,\"277\":6,\"279\":1,\"280\":19,\"281\":1}}],[\"orange\",{\"1\":{\"91\":1}}],[\"org\",{\"1\":{\"28\":2,\"150\":1,\"281\":1,\"350\":1,\"419\":2,\"421\":1,\"432\":1,\"448\":4,\"462\":2,\"463\":6}}],[\"包\",{\"1\":{\"499\":1}}],[\"包之间可以有两种关系\",{\"1\":{\"73\":1}}],[\"包的前提是信任它们的\",{\"1\":{\"108\":1}}],[\"包的可见性用来控制包外界的元素对包内元素的可访问权限\",{\"1\":{\"73\":1}}],[\"包的内容进行\",{\"1\":{\"26\":1}}],[\"包拥有的元素\",{\"1\":{\"73\":1}}],[\"包等\",{\"1\":{\"73\":1}}],[\"包图通常用于描述系统的逻辑架构\",{\"1\":{\"73\":1}}],[\"包图\",{\"0\":{\"73\":1}}],[\"包含两个参数\",{\"1\":{\"416\":1}}],[\"包含了\",{\"1\":{\"216\":1,\"341\":1}}],[\"包含用例\",{\"1\":{\"62\":1}}],[\"包含关系\",{\"0\":{\"62\":1}}],[\"包含\",{\"1\":{\"59\":2,\"216\":1}}],[\"包conf\",{\"1\":{\"34\":1}}],[\"包括四种\",{\"1\":{\"398\":1}}],[\"包括master当前的offset\",{\"1\":{\"386\":1}}],[\"包括了所有的索引值信息\",{\"1\":{\"204\":1}}],[\"包括发送消息\",{\"1\":{\"79\":1,\"80\":1}}],[\"包括过程模型\",{\"1\":{\"76\":1}}],[\"包括输入账号\",{\"1\":{\"62\":1}}],[\"包括配置代理\",{\"1\":{\"32\":1}}],[\"包括\",{\"1\":{\"26\":1}}],[\"对那些刚构建的或刚使用过的\",{\"1\":{\"520\":1}}],[\"对一致性\",{\"1\":{\"456\":1}}],[\"对一张表做结构变更操作的时候\",{\"1\":{\"310\":1}}],[\"对一张表进行\",{\"1\":{\"310\":1}}],[\"对请求路径\",{\"1\":{\"446\":1}}],[\"对num做hash运算\",{\"1\":{\"402\":1}}],[\"对16384取余\",{\"1\":{\"402\":2,\"403\":1}}],[\"对a做hash运算\",{\"1\":{\"402\":1}}],[\"对没错\",{\"1\":{\"367\":1}}],[\"对数据的修改就是永久的\",{\"1\":{\"352\":1}}],[\"对数据的增删改操作\",{\"1\":{\"307\":1}}],[\"对其他并发事务是隔离的\",{\"1\":{\"352\":1}}],[\"对每个阶段引入了队列后\",{\"1\":{\"348\":1}}],[\"对每个分组中的记录条数都是有规定的\",{\"1\":{\"243\":1}}],[\"对主库资源消耗比较高\",{\"1\":{\"342\":1}}],[\"对主键索引和二级索引都加了\",{\"1\":{\"297\":1,\"298\":1}}],[\"对主键字段建立的索引叫做聚簇索引\",{\"1\":{\"239\":1}}],[\"对记录加锁带基本单位是\",{\"1\":{\"329\":1}}],[\"对记录一会加的是\",{\"1\":{\"282\":1}}],[\"对表结构的更改操作\",{\"1\":{\"307\":1}}],[\"对二级索引记录加锁都是加\",{\"1\":{\"298\":1}}],[\"对二级索引\",{\"1\":{\"297\":1}}],[\"对非唯一索引\",{\"1\":{\"296\":1,\"297\":1}}],[\"对扫描到的二级索引记录加的是\",{\"1\":{\"295\":1,\"300\":1}}],[\"对操作的记录加独占锁\",{\"1\":{\"283\":2}}],[\"对订单做幂等性校验的目的是为了保证不会出现重复的订单\",{\"1\":{\"281\":1}}],[\"对订单审核等\",{\"1\":{\"53\":1}}],[\"对读取的记录加独占锁\",{\"1\":{\"283\":1,\"313\":1}}],[\"对读取的记录加排他锁\",{\"1\":{\"275\":1}}],[\"对读取的记录加共享锁\",{\"1\":{\"275\":1,\"283\":1,\"313\":1}}],[\"对普通字段建立的索引叫做二级索引\",{\"1\":{\"239\":1}}],[\"对两张表进行联查\",{\"1\":{\"228\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"239\":1}}],[\"对索引隐式类型转换\",{\"0\":{\"238\":1}}],[\"对索引进行表达式计算\",{\"0\":{\"237\":1}}],[\"对索引使用函数是会导致索引失效的\",{\"1\":{\"238\":1}}],[\"对索引使用函数\",{\"0\":{\"236\":1}}],[\"对索引使用左或者左右模糊匹配\",{\"0\":{\"235\":1}}],[\"对索引表进行全扫描\",{\"1\":{\"228\":1}}],[\"对索引效率也有很大影响\",{\"1\":{\"218\":1}}],[\"对联合索引中包含的字段先做判断\",{\"1\":{\"217\":1}}],[\"对的\",{\"1\":{\"187\":1,\"278\":1}}],[\"对应事项类型具体的策略实现类\",{\"1\":{\"508\":1}}],[\"对应事务中的回滚操作\",{\"1\":{\"344\":1}}],[\"对应时刻\",{\"1\":{\"346\":2}}],[\"对应最大主键是\",{\"1\":{\"243\":1}}],[\"对应的事务状态设置为\",{\"1\":{\"345\":1,\"350\":1}}],[\"对应的记录也就没用了\",{\"1\":{\"339\":1}}],[\"对应的记录\",{\"1\":{\"243\":1}}],[\"对应的扫描区间是\",{\"1\":{\"216\":1}}],[\"对应的缓存页标记为脏页\",{\"1\":{\"177\":1}}],[\"对应页中记录的最小记录\",{\"1\":{\"186\":1}}],[\"对称加密的通信双方要使用同一把密钥\",{\"1\":{\"106\":1}}],[\"对称加密具有加解密速度快\",{\"1\":{\"106\":1}}],[\"对称加密\",{\"0\":{\"106\":1},\"1\":{\"102\":1}}],[\"对这三者的优势和局限性作进一步解读\",{\"1\":{\"83\":1}}],[\"对象只能由系统建立对象\",{\"1\":{\"483\":1}}],[\"对象间的消息存在于两条虚线间\",{\"1\":{\"81\":1}}],[\"对象代表时序图中的对象在交互中所扮演的角色\",{\"1\":{\"81\":1}}],[\"对象名\",{\"1\":{\"70\":1}}],[\"对象通过其类型\",{\"1\":{\"70\":1}}],[\"对象是类的实例\",{\"1\":{\"70\":1}}],[\"对象\",{\"1\":{\"70\":1,\"79\":1,\"81\":1,\"86\":1,\"480\":1}}],[\"对象图的建模过程如下\",{\"1\":{\"72\":1}}],[\"对象图的建模过程\",{\"0\":{\"72\":1}}],[\"对象图的组成元素\",{\"0\":{\"70\":1}}],[\"对象图实例\",{\"0\":{\"71\":1}}],[\"对象图中的建模元素主要有对象和链\",{\"1\":{\"70\":1}}],[\"对象图可以看做是类图的实例\",{\"1\":{\"69\":1}}],[\"对象图是表示在某一时刻一组对象以及它们之间关系的图形\",{\"1\":{\"68\":1}}],[\"对象图概念\",{\"0\":{\"68\":1}}],[\"对象图\",{\"0\":{\"67\":1},\"1\":{\"69\":1}}],[\"对同一个问题\",{\"1\":{\"58\":1}}],[\"对于任意一个类都能够知道这个类所有的属性和方法\",{\"1\":{\"481\":1}}],[\"对于table\",{\"1\":{\"426\":1}}],[\"对于当前读\",{\"1\":{\"369\":1}}],[\"对于快照读\",{\"1\":{\"369\":1}}],[\"对于使用\",{\"1\":{\"358\":1}}],[\"对于已经提交的事务来说\",{\"1\":{\"351\":1}}],[\"对于处于\",{\"1\":{\"346\":1}}],[\"对于这两个问题\",{\"1\":{\"507\":1}}],[\"对于这种范围为\",{\"1\":{\"275\":1}}],[\"对于这个查询来说\",{\"1\":{\"195\":1}}],[\"对于自连接查询\",{\"1\":{\"265\":1}}],[\"对于执行计划\",{\"1\":{\"228\":1}}],[\"对于联合索引\",{\"1\":{\"217\":1}}],[\"对于有\",{\"1\":{\"207\":1}}],[\"对于一些频繁访问的数据我们希望可以一直留在\",{\"1\":{\"178\":1}}],[\"对于一对多联系\",{\"1\":{\"90\":1}}],[\"对于一对一联系\",{\"1\":{\"90\":1}}],[\"对于第三条数据\",{\"1\":{\"162\":1}}],[\"对于第二条数据\",{\"1\":{\"162\":1}}],[\"对于第一条数据\",{\"1\":{\"162\":1}}],[\"对于\",{\"1\":{\"140\":1,\"144\":1,\"156\":1,\"194\":1,\"216\":1,\"307\":1,\"334\":1,\"347\":1,\"357\":3,\"361\":1}}],[\"对于更新比较频繁的表\",{\"1\":{\"140\":1}}],[\"对于多对多关系\",{\"1\":{\"90\":1}}],[\"对于主属性名\",{\"1\":{\"90\":1}}],[\"对于复杂的数据结构\",{\"1\":{\"68\":1}}],[\"对于http\",{\"1\":{\"48\":1}}],[\"对于每个\",{\"1\":{\"46\":1}}],[\"对\",{\"1\":{\"26\":1,\"180\":1,\"186\":1,\"236\":1,\"280\":2,\"290\":2,\"298\":2,\"304\":1,\"348\":2,\"367\":1}}],[\"zzz\",{\"1\":{\"337\":1,\"341\":1}}],[\"z\",{\"1\":{\"187\":7}}],[\"zhuanlan\",{\"1\":{\"110\":2}}],[\"zhihu\",{\"1\":{\"70\":1,\"110\":2}}],[\"zxvf\",{\"1\":{\"29\":1,\"34\":1}}],[\"zlib\",{\"1\":{\"26\":5}}],[\"zp\",{\"1\":{\"12\":1}}],[\"yml中指定redis的sentinel相关信息\",{\"1\":{\"397\":1}}],[\"yes启用无磁盘复制\",{\"1\":{\"387\":1}}],[\"yes\",{\"1\":{\"373\":1,\"378\":1,\"448\":1}}],[\"yyy\",{\"1\":{\"337\":1,\"341\":1}}],[\"y=15\",{\"1\":{\"187\":1}}],[\"y=\",{\"1\":{\"187\":1}}],[\"young\",{\"1\":{\"178\":26,\"180\":3}}],[\"y\",{\"1\":{\"26\":3,\"187\":6}}],[\"yum\",{\"1\":{\"26\":4,\"28\":1,\"43\":1}}],[\"是硬盘和\",{\"1\":{\"538\":1}}],[\"是非常重要的系统资源\",{\"1\":{\"538\":1}}],[\"是非常慢的\",{\"1\":{\"156\":1}}],[\"是被视为动态语言的关键\",{\"1\":{\"480\":1}}],[\"是保底策略\",{\"1\":{\"473\":2}}],[\"是保存到磁盘上的\",{\"1\":{\"248\":1}}],[\"是我们之前做缓存预热时编写的一个类\",{\"1\":{\"463\":1}}],[\"是我们常用的存储引擎\",{\"1\":{\"152\":1}}],[\"是数据集的标记\",{\"1\":{\"384\":1}}],[\"是默认方案\",{\"1\":{\"378\":1}}],[\"是间隙锁+记录锁的组合\",{\"1\":{\"365\":1}}],[\"是可见的\",{\"1\":{\"360\":1}}],[\"是活跃的\",{\"1\":{\"359\":1}}],[\"是事务\",{\"1\":{\"359\":3}}],[\"是还没提交事务的\",{\"1\":{\"354\":1}}],[\"是还没持久化到磁盘的\",{\"1\":{\"346\":1}}],[\"是最安全但是性能损耗最大的设置\",{\"1\":{\"343\":1}}],[\"是最坏的情况\",{\"1\":{\"228\":1}}],[\"是循环写\",{\"1\":{\"341\":1}}],[\"是循环写的方式\",{\"1\":{\"339\":1}}],[\"是追加写\",{\"1\":{\"341\":1}}],[\"是没有\",{\"1\":{\"340\":1}}],[\"是另一个公司以插件形式引入\",{\"1\":{\"340\":1}}],[\"是专门用来缓存文件数据的\",{\"1\":{\"338\":1}}],[\"是直接写入磁盘的吗\",{\"1\":{\"337\":1}}],[\"是物理日志\",{\"1\":{\"337\":1,\"341\":1}}],[\"是提高了读写效率没错\",{\"1\":{\"337\":1}}],[\"是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的\",{\"1\":{\"492\":1}}],[\"是由\",{\"1\":{\"334\":1}}],[\"是等值查询\",{\"1\":{\"329\":1}}],[\"是等待状态\",{\"1\":{\"280\":1}}],[\"是需要我们具体分析的\",{\"1\":{\"318\":1}}],[\"是性能最高的方式\",{\"1\":{\"312\":1}}],[\"是无锁的\",{\"1\":{\"311\":1}}],[\"是无法完全锁住\",{\"1\":{\"297\":1}}],[\"是无法利用到索引的\",{\"1\":{\"215\":1}}],[\"是为了防止\",{\"1\":{\"339\":1}}],[\"是为了保证当用户对表执行\",{\"1\":{\"310\":1}}],[\"是为了对流程图中某些框的操作做必要的补充说明\",{\"1\":{\"58\":1}}],[\"是查询不出来这条数据的\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1,\"364\":1}}],[\"是查询语句\",{\"1\":{\"140\":1}}],[\"是表中\",{\"1\":{\"291\":1}}],[\"是普通的列\",{\"1\":{\"288\":1}}],[\"是普通索引\",{\"1\":{\"288\":1}}],[\"是普通列\",{\"1\":{\"240\":1}}],[\"是前开后闭区间\",{\"1\":{\"288\":1}}],[\"是用来控制选择用\",{\"1\":{\"312\":1}}],[\"是用来设置超时时间的\",{\"1\":{\"281\":1}}],[\"是用整数字节的二进制位来表示\",{\"1\":{\"162\":1}}],[\"是与\",{\"1\":{\"280\":1}}],[\"是与常量进行比较\",{\"1\":{\"228\":1}}],[\"是先生成锁结构\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"是先按照\",{\"1\":{\"216\":5}}],[\"是先按\",{\"1\":{\"215\":2}}],[\"是包含间隙锁+记录锁的\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"是存在幻读的问题\",{\"1\":{\"275\":1}}],[\"是支持范围查找的\",{\"1\":{\"248\":1}}],[\"是走了全表扫描\",{\"1\":{\"240\":1}}],[\"是会边写边擦除日志的\",{\"1\":{\"341\":1}}],[\"是会把整个表的查询缓存清空的\",{\"1\":{\"333\":1}}],[\"是会把整个页的数据加载到\",{\"1\":{\"174\":1,\"336\":1}}],[\"是会被阻塞的\",{\"1\":{\"275\":1,\"287\":1,\"309\":1,\"316\":1}}],[\"是会将数据持久化在硬盘\",{\"1\":{\"258\":1}}],[\"是会将字符串转成数字处理\",{\"1\":{\"238\":1}}],[\"是整型\",{\"1\":{\"238\":1}}],[\"是能够实现\",{\"1\":{\"237\":1}}],[\"是的\",{\"1\":{\"237\":1,\"345\":1}}],[\"是的没错\",{\"1\":{\"148\":1}}],[\"是以\",{\"1\":{\"235\":1}}],[\"是二级索引且类型是\",{\"1\":{\"238\":1}}],[\"是二级索引\",{\"1\":{\"231\":1,\"277\":1}}],[\"是变长类型的字段\",{\"1\":{\"216\":1}}],[\"是变长的\",{\"1\":{\"161\":1}}],[\"是闭区间\",{\"1\":{\"216\":1}}],[\"是有序的\",{\"1\":{\"215\":1}}],[\"是全局是无序的\",{\"1\":{\"215\":1}}],[\"是全局有序的\",{\"1\":{\"215\":1}}],[\"是全局无序\",{\"1\":{\"215\":1}}],[\"是通过索引扫描的方式查询的\",{\"1\":{\"299\":1}}],[\"是通过\",{\"1\":{\"192\":1,\"283\":1,\"302\":2,\"334\":2,\"357\":2,\"361\":2,\"362\":2,\"369\":2}}],[\"是什么意思\",{\"1\":{\"296\":1}}],[\"是什么\",{\"0\":{\"191\":1}}],[\"是什么呢\",{\"1\":{\"166\":1}}],[\"是效率最差的\",{\"1\":{\"189\":1}}],[\"是主键索引\",{\"1\":{\"231\":1,\"288\":1,\"333\":1}}],[\"是主键\",{\"1\":{\"183\":1,\"240\":1}}],[\"是这样做的\",{\"1\":{\"178\":2}}],[\"是必需的\",{\"1\":{\"164\":1}}],[\"是固定\",{\"1\":{\"162\":1}}],[\"是因为针对\",{\"1\":{\"296\":1}}],[\"是因为\",{\"1\":{\"215\":1}}],[\"是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个\",{\"1\":{\"161\":1}}],[\"是因为客户端是等查询语句查询完成后\",{\"1\":{\"148\":1}}],[\"是怎样运行的\",{\"1\":{\"169\":1,\"281\":1,\"350\":1}}],[\"是怎样存储的\",{\"1\":{\"161\":1}}],[\"是怎么解决幻读的\",{\"1\":{\"302\":1}}],[\"是怎么加行级锁的时候\",{\"1\":{\"283\":1}}],[\"是怎么加行级锁的\",{\"0\":{\"288\":1},\"1\":{\"282\":2}}],[\"是怎么加锁的\",{\"0\":{\"282\":1},\"1\":{\"96\":1,\"275\":2}}],[\"是怎么确定的\",{\"1\":{\"275\":1,\"291\":1,\"322\":1}}],[\"是怎么组织数据的\",{\"1\":{\"243\":1}}],[\"是怎么来的\",{\"1\":{\"182\":1}}],[\"是怎么实现的\",{\"1\":{\"164\":1}}],[\"是怎么处理的\",{\"0\":{\"168\":1},\"1\":{\"151\":1,\"169\":1}}],[\"是定长的\",{\"1\":{\"161\":1}}],[\"是很古老的行格式了\",{\"1\":{\"158\":1}}],[\"是否开启aof功能\",{\"1\":{\"378\":1}}],[\"是否压缩\",{\"1\":{\"373\":1}}],[\"是否在\",{\"1\":{\"358\":1}}],[\"是否准备好了\",{\"1\":{\"344\":1}}],[\"是否有事务已经对表加上了\",{\"1\":{\"310\":1}}],[\"是否可以插入\",{\"1\":{\"297\":4}}],[\"是否可行\",{\"1\":{\"166\":2}}],[\"是否成立\",{\"1\":{\"149\":2}}],[\"是否等于\",{\"1\":{\"149\":4,\"217\":1}}],[\"是不影响其他消费者购买的\",{\"1\":{\"352\":1}}],[\"是不必写入磁盘\",{\"1\":{\"337\":1}}],[\"是不会加行级锁的\",{\"1\":{\"311\":1}}],[\"是不会发生阻塞的\",{\"1\":{\"280\":1}}],[\"是不会导致索引失效\",{\"1\":{\"238\":1}}],[\"是不会存放在行格式中记录的真实数据部分里的\",{\"1\":{\"161\":1}}],[\"是不是想到就很开心\",{\"1\":{\"351\":1}}],[\"是不是很多人都对\",{\"1\":{\"282\":1}}],[\"是不是很清晰了\",{\"1\":{\"150\":1}}],[\"是不是变成了二叉树\",{\"1\":{\"250\":1}}],[\"是不是在面试时经常出现\",{\"1\":{\"247\":1}}],[\"是不是大家觉得是读取记录中的所有字段值\",{\"1\":{\"194\":1}}],[\"是不是心里已经有谱了啊\",{\"1\":{\"187\":1}}],[\"是不是像一棵二叉树啊\",{\"1\":{\"186\":1}}],[\"是不是有点似曾相似的感觉\",{\"1\":{\"186\":1}}],[\"是不是经常听到过\",{\"1\":{\"181\":1}}],[\"是不是\",{\"1\":{\"148\":1,\"189\":1}}],[\"是不可行的\",{\"1\":{\"106\":1}}],[\"是唯一索引\",{\"1\":{\"228\":1,\"329\":1}}],[\"是唯一\",{\"1\":{\"147\":1}}],[\"是在事务提交后才会释放\",{\"1\":{\"310\":1}}],[\"是在\",{\"1\":{\"173\":1,\"202\":1,\"204\":1,\"296\":1}}],[\"是在词法分析\",{\"1\":{\"144\":1}}],[\"是在面向对象语言用中用来表示一个类\",{\"1\":{\"64\":1}}],[\"是基于内存的\",{\"1\":{\"337\":1}}],[\"是基于\",{\"1\":{\"139\":1}}],[\"是指在虚拟机执行垃圾回收的过程中\",{\"1\":{\"527\":1}}],[\"是指事务操作前和操作后\",{\"1\":{\"352\":1}}],[\"是指用于连接一个读进程和一个写进程\",{\"1\":{\"124\":1}}],[\"是指系统以外的\",{\"1\":{\"59\":1}}],[\"是加密的\",{\"1\":{\"110\":1}}],[\"是明文传输的\",{\"1\":{\"106\":1}}],[\"是如何给记录创建页目录的呢\",{\"1\":{\"243\":1}}],[\"是如何存储数据的\",{\"0\":{\"243\":1},\"1\":{\"243\":1}}],[\"是如何实现以满足以上四大安全通信原则的\",{\"1\":{\"104\":1}}],[\"是如何工作的\",{\"0\":{\"45\":1}}],[\"是时候该改变了\",{\"1\":{\"95\":1}}],[\"是学生实体集中的一个实体\",{\"1\":{\"89\":1}}],[\"是两个或多个对象之间的独立连接\",{\"1\":{\"70\":1}}],[\"是比聚合关系还要强的关系\",{\"1\":{\"66\":1}}],[\"是强的关联关系\",{\"1\":{\"66\":1}}],[\"是面向对象系统中最重要的构造块\",{\"1\":{\"65\":1}}],[\"是对包括变量在内的一组动作序列的描述\",{\"1\":{\"59\":1}}],[\"是一组活跃的引用\",{\"1\":{\"517\":1}}],[\"是一类在运行时可以改变其结构的语言\",{\"1\":{\"480\":1}}],[\"是一直持有的\",{\"1\":{\"310\":1}}],[\"是一样的\",{\"1\":{\"294\":1}}],[\"是一片连续的内存空间\",{\"1\":{\"176\":1}}],[\"是一种轻量小巧的脚本语言\",{\"1\":{\"421\":1}}],[\"是一种用于撤销回退的日志\",{\"1\":{\"334\":1}}],[\"是一种特殊的间隙锁\",{\"1\":{\"324\":1}}],[\"是一种多叉树\",{\"1\":{\"204\":1}}],[\"是一种紧凑的行格式\",{\"1\":{\"158\":1}}],[\"是一种提供了实体\",{\"1\":{\"89\":1}}],[\"是一种开放的方法\",{\"1\":{\"58\":1}}],[\"是一个table\",{\"1\":{\"441\":1}}],[\"是一个基于\",{\"1\":{\"432\":1}}],[\"是一个聚合函数\",{\"1\":{\"191\":1}}],[\"是一个封装了状态和行为的实体\",{\"1\":{\"70\":1}}],[\"是一个强大的安全套接字层密码库\",{\"1\":{\"26\":1}}],[\"是一个perl库\",{\"1\":{\"26\":1}}],[\"是一个高性能的http和反向代理服务器\",{\"1\":{\"20\":1}}],[\"是\",{\"1\":{\"48\":1,\"91\":8,\"187\":1,\"232\":2,\"258\":1,\"275\":2,\"287\":1,\"291\":2,\"304\":1,\"316\":1,\"322\":2,\"333\":3,\"341\":2,\"359\":2,\"360\":2,\"526\":2}}],[\"是给一个资源设定一个过期时间\",{\"1\":{\"42\":1}}],[\"是服务器配置中最频繁的部分\",{\"1\":{\"32\":1}}],[\"是使用\",{\"1\":{\"26\":1}}],[\"库存为1分钟\",{\"1\":{\"454\":1}}],[\"库存查询的业务\",{\"1\":{\"451\":1}}],[\"库存两个json字符串\",{\"1\":{\"442\":1}}],[\"库存的缓存数据\",{\"1\":{\"419\":1}}],[\"库提供了很多种压缩和解压缩的方式\",{\"1\":{\"26\":1}}],[\"库\",{\"1\":{\"26\":3,\"432\":1}}],[\"human\",{\"1\":{\"507\":4}}],[\"hello\",{\"0\":{\"422\":1},\"1\":{\"422\":1,\"425\":2}}],[\"heima\",{\"1\":{\"419\":3,\"448\":5,\"461\":1,\"462\":1,\"463\":8}}],[\"header|\",{\"1\":{\"43\":1}}],[\"header\",{\"1\":{\"43\":1,\"187\":2,\"243\":1,\"441\":1}}],[\"hy000\",{\"1\":{\"139\":1}}],[\"h$ip\",{\"1\":{\"139\":1}}],[\"h\",{\"1\":{\"58\":2,\"139\":1,\"474\":2}}],[\"h虛拟ip地址\",{\"1\":{\"43\":1}}],[\"hotspot算法细节\",{\"0\":{\"530\":1}}],[\"hotfix合并入master时\",{\"1\":{\"9\":1}}],[\"hotfix分支是用来做线上紧急bug\",{\"1\":{\"7\":1}}],[\"hotfix\",{\"1\":{\"6\":1,\"8\":1,\"15\":2}}],[\"host\",{\"1\":{\"448\":1}}],[\"hosts文件中看\",{\"1\":{\"43\":1}}],[\"have\",{\"1\":{\"330\":2}}],[\"handler\",{\"1\":{\"463\":1,\"507\":3}}],[\"handles\",{\"1\":{\"194\":1}}],[\"hand\",{\"1\":{\"91\":2}}],[\"hashcode\",{\"1\":{\"474\":3}}],[\"hashmap<>\",{\"1\":{\"508\":1}}],[\"hashmap的底层实现是什么\",{\"0\":{\"472\":1}}],[\"hashmap\",{\"0\":{\"471\":1},\"1\":{\"474\":1}}],[\"hash索引\",{\"1\":{\"203\":2}}],[\"hash\",{\"1\":{\"41\":2,\"170\":1,\"204\":1,\"207\":5,\"402\":1,\"447\":1,\"473\":1,\"474\":1}}],[\"haproxy\",{\"1\":{\"41\":1}}],[\"htm\",{\"1\":{\"38\":2,\"42\":1}}],[\"html文件夹\",{\"1\":{\"42\":1}}],[\"html目录\",{\"1\":{\"38\":2}}],[\"html\",{\"1\":{\"28\":1,\"38\":4,\"40\":1,\"42\":2,\"150\":2,\"350\":2,\"436\":1}}],[\"http查询失败\",{\"1\":{\"450\":1}}],[\"http这个函数\",{\"1\":{\"442\":1}}],[\"http函数封装到\",{\"1\":{\"442\":1}}],[\"http请求查询失败\",{\"1\":{\"442\":1}}],[\"http1\",{\"1\":{\"48\":1}}],[\"http全局块\",{\"1\":{\"32\":2}}],[\"http块\",{\"1\":{\"32\":3}}],[\"https\",{\"0\":{\"101\":1,\"105\":1,\"106\":1,\"109\":1},\"1\":{\"26\":1,\"28\":2,\"32\":1,\"91\":2,\"102\":7,\"103\":2,\"104\":2,\"106\":1,\"108\":4,\"110\":8,\"150\":2,\"181\":1,\"350\":3,\"416\":1,\"421\":1,\"432\":1,\"436\":1,\"439\":1,\"443\":1,\"458\":1,\"459\":1}}],[\"http\",{\"0\":{\"103\":1},\"1\":{\"26\":3,\"32\":5,\"38\":2,\"42\":2,\"43\":1,\"48\":1,\"102\":1,\"103\":1,\"106\":1,\"110\":2,\"139\":1,\"150\":1,\"281\":1,\"350\":1,\"436\":1,\"441\":2,\"442\":9,\"444\":4,\"447\":1,\"450\":6,\"451\":6,\"454\":4}}],[\"的桥梁\",{\"1\":{\"538\":1}}],[\"的返回值\",{\"1\":{\"507\":1}}],[\"的返回值即为对应类中调用的方法的返回值\",{\"1\":{\"502\":1}}],[\"的源码\",{\"1\":{\"498\":1}}],[\"的过程\",{\"1\":{\"492\":1}}],[\"的过程就是脏页刷新到磁盘中变成干净页\",{\"1\":{\"339\":1}}],[\"的配置文件\",{\"1\":{\"478\":1}}],[\"的元素留在原来位置\",{\"1\":{\"473\":1}}],[\"的链表出现概率是\",{\"1\":{\"473\":1}}],[\"的大\",{\"1\":{\"473\":1}}],[\"的大小是固定且一致的\",{\"1\":{\"339\":1}}],[\"的大小是有限的\",{\"1\":{\"178\":1}}],[\"的大小设置的刚刚好的话\",{\"1\":{\"174\":1}}],[\"的大小\",{\"1\":{\"173\":1}}],[\"的sentinel都认为该实例主观下线\",{\"1\":{\"392\":1}}],[\"的角度看\",{\"1\":{\"357\":1}}],[\"的角色\",{\"1\":{\"202\":1}}],[\"的隔离级别\",{\"1\":{\"357\":1}}],[\"的现象\",{\"1\":{\"357\":1}}],[\"的账户增加\",{\"1\":{\"352\":1}}],[\"的账户扣除\",{\"1\":{\"352\":1}}],[\"的引擎都是用\",{\"1\":{\"352\":1}}],[\"的引擎来实现的\",{\"1\":{\"352\":1}}],[\"的频率\",{\"1\":{\"349\":1}}],[\"的设置\",{\"1\":{\"348\":1}}],[\"的刷盘次数\",{\"1\":{\"349\":1}}],[\"的刷盘延迟到了\",{\"1\":{\"348\":1}}],[\"的刷盘时机如下图\",{\"1\":{\"338\":1}}],[\"的组提交\",{\"1\":{\"348\":2}}],[\"的组提交逻辑中\",{\"1\":{\"348\":1}}],[\"的组合\",{\"1\":{\"284\":1,\"287\":1,\"313\":1,\"316\":1}}],[\"的次数\",{\"1\":{\"348\":1}}],[\"的事务的事务\",{\"1\":{\"358\":1}}],[\"的事务\",{\"1\":{\"358\":1,\"359\":1,\"367\":1}}],[\"的事务并没有提交\",{\"1\":{\"310\":1}}],[\"的事情了\",{\"1\":{\"343\":1}}],[\"的流程如下\",{\"1\":{\"343\":1,\"350\":1}}],[\"的写入拆成了两个步骤\",{\"1\":{\"345\":1}}],[\"的写入速度还是比较快的\",{\"1\":{\"343\":1}}],[\"的写操作并不是立刻更新到磁盘上\",{\"1\":{\"337\":1}}],[\"的写操作并不是立刻写到磁盘上\",{\"1\":{\"337\":1,\"343\":1,\"350\":1}}],[\"的写操作从磁盘的\",{\"1\":{\"337\":1}}],[\"的中继日志里\",{\"1\":{\"342\":1}}],[\"的响应\",{\"1\":{\"342\":2}}],[\"的线程\",{\"1\":{\"342\":1}}],[\"的线程同步完成\",{\"1\":{\"342\":1}}],[\"的线程可以把一个\",{\"1\":{\"47\":1}}],[\"的主从复制依赖于\",{\"1\":{\"342\":1}}],[\"的主键索引上\",{\"1\":{\"293\":3}}],[\"的缺点是每行数据的变化结果都会被记录\",{\"1\":{\"341\":1}}],[\"的移动都是顺时针方向\",{\"1\":{\"339\":1}}],[\"的脏页刷新到了磁盘中\",{\"1\":{\"339\":1}}],[\"的脏页刷新到磁盘里\",{\"1\":{\"337\":1}}],[\"的操作\",{\"1\":{\"339\":1}}],[\"的操作次数内完成\",{\"1\":{\"258\":1}}],[\"的操作次数\",{\"1\":{\"258\":1}}],[\"的性能高\",{\"1\":{\"338\":1}}],[\"的性能发挥到极致\",{\"1\":{\"47\":1}}],[\"的策略\",{\"1\":{\"338\":2}}],[\"的后台线程每隔\",{\"1\":{\"338\":2}}],[\"的后面增加\",{\"1\":{\"182\":1}}],[\"的能力\",{\"1\":{\"337\":1,\"340\":1}}],[\"的方式\",{\"1\":{\"348\":1}}],[\"的方式使用了追加操作\",{\"1\":{\"337\":1}}],[\"的方式查询数据\",{\"1\":{\"232\":1}}],[\"的内容\",{\"1\":{\"337\":1}}],[\"的内容到内存中\",{\"1\":{\"155\":1,\"243\":1}}],[\"的比对\",{\"1\":{\"334\":1,\"361\":1}}],[\"的格式我就不详细介绍了\",{\"1\":{\"334\":1}}],[\"的格式也是不同的\",{\"1\":{\"334\":1}}],[\"的更新操作并不会阻塞\",{\"1\":{\"329\":1}}],[\"的更新操作采用的是\",{\"1\":{\"179\":1}}],[\"的日志格式是\",{\"1\":{\"312\":1}}],[\"的系统变量\",{\"1\":{\"312\":1}}],[\"的期间\",{\"1\":{\"310\":2}}],[\"的存储引擎\",{\"1\":{\"307\":1}}],[\"的存储方式根据存储引擎的不同而不同\",{\"1\":{\"257\":1}}],[\"的支持\",{\"1\":{\"307\":1}}],[\"的形式记录下来\",{\"1\":{\"337\":1}}],[\"的形式\",{\"1\":{\"306\":1}}],[\"的可重复读隔离级别下\",{\"1\":{\"305\":1}}],[\"的语句\",{\"1\":{\"303\":1}}],[\"的二级索引上\",{\"1\":{\"298\":1}}],[\"的二级索引记录\",{\"1\":{\"298\":1}}],[\"的二级索引记录的范围里\",{\"1\":{\"216\":2}}],[\"的加锁变化\",{\"1\":{\"298\":1}}],[\"的第二条查询语句查询到\",{\"1\":{\"365\":1}}],[\"的第二个数值\",{\"1\":{\"296\":1}}],[\"的第一条记录\",{\"1\":{\"149\":2}}],[\"的顺序存放\",{\"1\":{\"296\":1}}],[\"的位置\",{\"1\":{\"296\":1}}],[\"的唯一索引\",{\"1\":{\"294\":1}}],[\"的唯一索引范围查询\",{\"1\":{\"294\":1}}],[\"的间隙锁插入了一条记录\",{\"1\":{\"325\":1}}],[\"的间隙锁是没有区别的\",{\"1\":{\"323\":1}}],[\"的间隙锁范围都是一样的\",{\"1\":{\"323\":1}}],[\"的间隙锁后\",{\"1\":{\"297\":1}}],[\"的间隙锁\",{\"1\":{\"294\":4,\"297\":5,\"325\":1}}],[\"的锁\",{\"1\":{\"293\":1,\"306\":1}}],[\"的这些新记录\",{\"1\":{\"298\":1}}],[\"的这条查询语句是全表扫描\",{\"1\":{\"304\":1}}],[\"的这条范围查询语句\",{\"1\":{\"298\":1}}],[\"的这条记录进行更新和删除操作了\",{\"1\":{\"290\":1}}],[\"的这条记录\",{\"1\":{\"290\":1}}],[\"的这条记录就会加上\",{\"1\":{\"290\":1}}],[\"的这条记录加上\",{\"1\":{\"285\":1,\"314\":1}}],[\"的这条记录加上了\",{\"1\":{\"279\":1}}],[\"的这条记录中加了锁类型为\",{\"1\":{\"279\":1}}],[\"的这一些记录\",{\"1\":{\"298\":1}}],[\"的这一些新记录\",{\"1\":{\"293\":6,\"294\":7,\"297\":4,\"298\":2}}],[\"的这一行记录\",{\"1\":{\"297\":2,\"298\":2}}],[\"的这一条记录\",{\"1\":{\"293\":1,\"294\":5}}],[\"的范围查询中\",{\"1\":{\"298\":1}}],[\"的范围查询的条件改成\",{\"1\":{\"294\":1}}],[\"的范围查询的情况\",{\"1\":{\"293\":2}}],[\"的范围查询时\",{\"1\":{\"294\":3}}],[\"的范围查询\",{\"0\":{\"293\":1,\"294\":1},\"1\":{\"292\":2,\"294\":1}}],[\"的场景下\",{\"1\":{\"291\":1}}],[\"的上一条记录的值\",{\"1\":{\"304\":1}}],[\"的上一条记录的\",{\"1\":{\"291\":1,\"322\":1}}],[\"的新记录的时候\",{\"1\":{\"297\":1}}],[\"的新记录的\",{\"1\":{\"297\":1}}],[\"的新记录时\",{\"1\":{\"296\":1,\"297\":3}}],[\"的新记录就行了\",{\"1\":{\"291\":1}}],[\"的新记录\",{\"1\":{\"290\":1,\"297\":9,\"298\":2,\"317\":1}}],[\"的新记录并不会被阻塞\",{\"1\":{\"285\":1}}],[\"的文章\",{\"1\":{\"282\":1}}],[\"的文件大小非常重要\",{\"1\":{\"339\":1}}],[\"的文件中\",{\"1\":{\"184\":1}}],[\"的文件里的\",{\"1\":{\"152\":1}}],[\"的避免方式\",{\"1\":{\"281\":1}}],[\"的状态\",{\"1\":{\"280\":1}}],[\"的状态为等待状态\",{\"1\":{\"277\":1,\"324\":1}}],[\"的插入操作生成了一个插入意向锁\",{\"1\":{\"277\":1,\"324\":1}}],[\"的next\",{\"1\":{\"275\":1,\"293\":1}}],[\"的机制实现的快照读\",{\"1\":{\"275\":1}}],[\"的机制的好处\",{\"0\":{\"46\":1}}],[\"的mongodb\",{\"1\":{\"256\":1}}],[\"的冗余节点\",{\"1\":{\"255\":1}}],[\"的时间线有关系\",{\"1\":{\"340\":1}}],[\"的时间代价内就查到\",{\"1\":{\"254\":1}}],[\"的时机不同\",{\"1\":{\"334\":1,\"357\":1,\"361\":1}}],[\"的时候肯定要知道最新的数据\",{\"1\":{\"365\":1}}],[\"的时候性能就会很高\",{\"1\":{\"156\":1}}],[\"的时候\",{\"1\":{\"137\":1,\"162\":1,\"215\":1,\"216\":1,\"290\":1,\"334\":1,\"338\":1,\"343\":5,\"347\":1}}],[\"的节点\",{\"1\":{\"250\":1,\"252\":1}}],[\"的节点后\",{\"1\":{\"187\":1}}],[\"的意思是\",{\"1\":{\"296\":1}}],[\"的意思是查询\",{\"1\":{\"216\":1}}],[\"的意思就是对\",{\"1\":{\"240\":1}}],[\"的含义就是两个只要满足一个即可\",{\"1\":{\"240\":1}}],[\"的话\",{\"1\":{\"239\":1,\"294\":1}}],[\"的结论\",{\"1\":{\"303\":1}}],[\"的结果了\",{\"1\":{\"334\":1}}],[\"的结果集就不一样了\",{\"1\":{\"297\":1}}],[\"的结果集相同\",{\"1\":{\"291\":1}}],[\"的结果来知道mysql\",{\"1\":{\"238\":1}}],[\"的结构图\",{\"1\":{\"202\":1}}],[\"的计算结果建立一个名为\",{\"1\":{\"236\":1}}],[\"的回滚指针以及所有的剩余列\",{\"1\":{\"232\":1}}],[\"的高效稳定运行\",{\"1\":{\"538\":1}}],[\"的高一些\",{\"1\":{\"232\":1}}],[\"的高度依然维持在\",{\"1\":{\"207\":1}}],[\"的所有字段\",{\"1\":{\"225\":1}}],[\"的字符是\",{\"1\":{\"216\":1}}],[\"的字段\",{\"1\":{\"216\":1,\"221\":1,\"358\":1}}],[\"的查询语句是小于的范围查询\",{\"1\":{\"294\":1}}],[\"的查询语句很像\",{\"1\":{\"216\":1}}],[\"的查询效率会比\",{\"1\":{\"232\":1}}],[\"的查询速度要明显快于\",{\"1\":{\"197\":1}}],[\"的情况\",{\"1\":{\"216\":1,\"275\":1}}],[\"的情况下\",{\"1\":{\"166\":1,\"187\":1,\"279\":1,\"345\":1,\"347\":1,\"473\":1}}],[\"的例子\",{\"1\":{\"215\":1,\"279\":1,\"280\":1}}],[\"的单个节点的数据量更小\",{\"1\":{\"207\":1}}],[\"的非叶子节点也要存储数据\",{\"1\":{\"207\":1}}],[\"的索引数据结构\",{\"1\":{\"258\":1}}],[\"的索引\",{\"1\":{\"219\":1,\"236\":1}}],[\"的索引原理\",{\"1\":{\"207\":1}}],[\"的索引值\",{\"1\":{\"206\":1}}],[\"的索引内部用的是\",{\"1\":{\"184\":1}}],[\"的叶子节点\",{\"1\":{\"234\":1}}],[\"的叶子节点上\",{\"1\":{\"226\":1}}],[\"的叶子节点上都能找得到的那些索引\",{\"1\":{\"225\":1}}],[\"的叶子节点存放的是主键值\",{\"1\":{\"206\":1,\"208\":1}}],[\"的叶子节点存放的是实际数据\",{\"1\":{\"206\":1,\"208\":1}}],[\"的叶子节点里查询到\",{\"1\":{\"206\":1}}],[\"的叶子节点里\",{\"1\":{\"206\":1,\"208\":1,\"234\":2}}],[\"的商品\",{\"1\":{\"205\":1}}],[\"的原因\",{\"1\":{\"197\":1}}],[\"的原理有了很清楚的认识了\",{\"1\":{\"110\":1}}],[\"的原理\",{\"1\":{\"102\":1,\"190\":1}}],[\"的原理是怎样的吗\",{\"1\":{\"102\":1}}],[\"的执行效率相比前面的\",{\"1\":{\"195\":1}}],[\"的官方手册中有这么一句话\",{\"1\":{\"194\":1}}],[\"的变量\",{\"1\":{\"192\":1}}],[\"的变长字段的长度\",{\"1\":{\"161\":1}}],[\"的编写等等\",{\"1\":{\"187\":1}}],[\"的值是\",{\"1\":{\"357\":3}}],[\"的值都是\",{\"1\":{\"357\":1}}],[\"的值还是\",{\"1\":{\"357\":1}}],[\"的值原本是\",{\"1\":{\"344\":1}}],[\"的值\",{\"1\":{\"275\":1,\"349\":1}}],[\"的值为\",{\"1\":{\"215\":1}}],[\"的值来计算\",{\"1\":{\"187\":1}}],[\"的值时候假设的是\",{\"1\":{\"187\":1}}],[\"的乘积\",{\"1\":{\"187\":1}}],[\"的图例来说明一下查找一个行数据的过程\",{\"1\":{\"187\":1}}],[\"的也是顺序的\",{\"1\":{\"186\":1}}],[\"的版本链找到满足其可见性的记录\",{\"1\":{\"334\":1}}],[\"的版本\",{\"1\":{\"182\":1}}],[\"的预读机制\",{\"1\":{\"178\":1}}],[\"的页被预读了\",{\"1\":{\"178\":1}}],[\"的页\",{\"1\":{\"178\":1,\"187\":1}}],[\"的页来说\",{\"1\":{\"156\":1}}],[\"的最大值\",{\"1\":{\"358\":1}}],[\"的最小值\",{\"1\":{\"358\":1}}],[\"的最小主键\",{\"1\":{\"186\":1}}],[\"的最前面\",{\"1\":{\"174\":1}}],[\"的最终加密形式\",{\"0\":{\"106\":1}}],[\"的列会使索引\",{\"1\":{\"227\":1}}],[\"的列上\",{\"1\":{\"213\":1}}],[\"的列\",{\"1\":{\"169\":1}}],[\"的列存储到\",{\"1\":{\"162\":1}}],[\"的作用了\",{\"1\":{\"164\":1}}],[\"的空间不是固定\",{\"1\":{\"162\":1}}],[\"的命中率\",{\"1\":{\"161\":1}}],[\"的命令\",{\"1\":{\"139\":1}}],[\"的信息要按照逆序存放\",{\"1\":{\"161\":1}}],[\"的区别是什么\",{\"1\":{\"161\":1}}],[\"的行\",{\"1\":{\"227\":1}}],[\"的行数据\",{\"1\":{\"187\":1,\"205\":1}}],[\"的行格式了\",{\"1\":{\"157\":1}}],[\"的行为\",{\"1\":{\"62\":1}}],[\"的行为包含了另一个用例\",{\"1\":{\"62\":1}}],[\"的连续存储空间\",{\"1\":{\"155\":1}}],[\"的连接也跟\",{\"1\":{\"139\":1}}],[\"的连接数有限制吗\",{\"1\":{\"139\":1}}],[\"的表数据是以页的形式存放的\",{\"1\":{\"188\":1}}],[\"的表数据会保存在这个文件\",{\"1\":{\"152\":1}}],[\"的表结构会保存在这个文件\",{\"1\":{\"152\":1}}],[\"的数据状态\",{\"1\":{\"337\":2}}],[\"的数据类型转换规则是什么\",{\"1\":{\"238\":2}}],[\"的数据表\",{\"1\":{\"232\":1}}],[\"的数据表都有一个\",{\"1\":{\"197\":1}}],[\"的数据行\",{\"1\":{\"187\":1}}],[\"的数据\",{\"1\":{\"182\":1,\"187\":1,\"235\":1}}],[\"的数据是持久化的\",{\"1\":{\"248\":1}}],[\"的数据是存储在磁盘中的嘛\",{\"1\":{\"247\":1}}],[\"的数据是存储在磁盘里的\",{\"1\":{\"172\":1}}],[\"的数据是按\",{\"1\":{\"155\":1,\"243\":1,\"246\":1}}],[\"的数据都是存在磁盘中的\",{\"1\":{\"335\":1}}],[\"的数据都是存放在\",{\"1\":{\"168\":1}}],[\"的数据都是保存在磁盘的\",{\"1\":{\"152\":1}}],[\"的数据时\",{\"1\":{\"166\":1}}],[\"的数据库表特别之处在于\",{\"1\":{\"232\":1}}],[\"的数据库表如下\",{\"1\":{\"231\":1}}],[\"的数据库表\",{\"1\":{\"166\":1}}],[\"的数据存放在哪个文件\",{\"0\":{\"152\":1}}],[\"的条件\",{\"1\":{\"149\":1}}],[\"的工作交给了存储引擎层\",{\"1\":{\"149\":1}}],[\"的函数\",{\"1\":{\"147\":1}}],[\"的成本大\",{\"1\":{\"145\":1}}],[\"的用户记录\",{\"1\":{\"243\":1}}],[\"的用户\",{\"1\":{\"235\":1}}],[\"的用户的\",{\"1\":{\"139\":1}}],[\"的用户连接了\",{\"1\":{\"139\":1}}],[\"的用例\",{\"1\":{\"61\":1}}],[\"的错误\",{\"1\":{\"139\":1}}],[\"的默认存储引擎\",{\"1\":{\"138\":1}}],[\"的架构共分为两层\",{\"1\":{\"138\":1}}],[\"的记录并提交\",{\"1\":{\"367\":1,\"368\":1}}],[\"的记录存在并且属于等值查询\",{\"1\":{\"298\":1}}],[\"的记录不在表中\",{\"1\":{\"294\":1}}],[\"的记录了\",{\"1\":{\"291\":1}}],[\"的记录话\",{\"1\":{\"291\":1}}],[\"的记录的主键索引加上记录锁\",{\"1\":{\"297\":1}}],[\"的记录的时候\",{\"1\":{\"290\":2,\"296\":4,\"297\":1}}],[\"的记录的下一条记录就是槽\",{\"1\":{\"243\":1}}],[\"的记录时也会被阻塞\",{\"1\":{\"290\":1}}],[\"的记录时会被阻塞住\",{\"1\":{\"291\":1}}],[\"的记录时会被阻塞\",{\"1\":{\"290\":1}}],[\"的记录进行更新或者删除操作的话\",{\"1\":{\"290\":1}}],[\"的记录加\",{\"1\":{\"280\":1}}],[\"的记录加什么锁\",{\"1\":{\"280\":1}}],[\"的记录加了什么锁\",{\"1\":{\"280\":1}}],[\"的记录上的\",{\"1\":{\"280\":1}}],[\"的记录和已有记录存在唯一键冲突\",{\"1\":{\"276\":1}}],[\"的记录就会被锁住\",{\"1\":{\"275\":1}}],[\"的记录那么步骤可以分为以下几步\",{\"1\":{\"252\":1}}],[\"的记录在\",{\"1\":{\"243\":1}}],[\"的记录开始扫描\",{\"1\":{\"216\":2}}],[\"的记录总个数\",{\"1\":{\"197\":1}}],[\"的记录个数\",{\"1\":{\"196\":1}}],[\"的记录有多少个\",{\"1\":{\"191\":1}}],[\"的记录后\",{\"1\":{\"149\":1}}],[\"的记录\",{\"1\":{\"137\":1,\"191\":2,\"216\":3,\"243\":4,\"244\":2,\"278\":1,\"279\":2,\"280\":5,\"291\":2,\"293\":4,\"294\":1,\"296\":4,\"297\":6,\"298\":2,\"304\":13,\"359\":1,\"360\":1,\"367\":3}}],[\"的功能其实本质上是如何协商出安全的对称加密密钥以利用此密钥进行后续通讯的过程\",{\"1\":{\"110\":1}}],[\"的合法性\",{\"1\":{\"109\":1}}],[\"的证书外\",{\"1\":{\"109\":1}}],[\"的证书调包成自己的证书\",{\"1\":{\"108\":1}}],[\"的证书\",{\"1\":{\"108\":1}}],[\"的证书替换成自己的证书呢\",{\"1\":{\"108\":1}}],[\"的包之前我们先要做什么\",{\"1\":{\"108\":1}}],[\"的同学\",{\"1\":{\"108\":1}}],[\"的公钥\",{\"1\":{\"108\":1}}],[\"的公钥是无法解密的\",{\"1\":{\"108\":1}}],[\"的公钥才能解密签名\",{\"1\":{\"108\":1}}],[\"的公钥来给签名解密\",{\"1\":{\"108\":1}}],[\"的验签过程如下\",{\"1\":{\"108\":1}}],[\"的私钥给摘要进行加密生成签名\",{\"1\":{\"108\":1}}],[\"的问题\",{\"1\":{\"104\":1,\"296\":1,\"318\":1,\"353\":1}}],[\"的面纱\",{\"0\":{\"171\":1},\"1\":{\"96\":1}}],[\"的浏览器每次访问要占两个连接\",{\"1\":{\"48\":1}}],[\"的\",{\"1\":{\"26\":1,\"34\":1,\"45\":1,\"48\":1,\"151\":1,\"152\":1,\"166\":2,\"169\":3,\"171\":1,\"178\":1,\"182\":2,\"187\":1,\"192\":1,\"204\":1,\"215\":2,\"216\":11,\"234\":3,\"235\":1,\"244\":1,\"257\":1,\"275\":4,\"280\":1,\"283\":1,\"287\":2,\"289\":2,\"291\":2,\"293\":9,\"294\":13,\"296\":3,\"297\":6,\"298\":4,\"300\":2,\"302\":1,\"312\":5,\"316\":2,\"322\":1,\"329\":3,\"340\":1,\"341\":1,\"345\":2,\"358\":1,\"359\":9,\"360\":6,\"363\":1,\"365\":1,\"458\":1,\"474\":1}}],[\"erlang\",{\"1\":{\"480\":1}}],[\"err\",{\"1\":{\"442\":1,\"450\":21,\"451\":2,\"454\":4}}],[\"error\",{\"1\":{\"32\":3,\"139\":1,\"144\":1}}],[\"e9f2c55f\",{\"1\":{\"436\":1,\"439\":1}}],[\"else\",{\"1\":{\"429\":1}}],[\"else语法\",{\"1\":{\"429\":1}}],[\"everysec\",{\"1\":{\"378\":1}}],[\"events拷贝到它的中继日志\",{\"1\":{\"458\":1}}],[\"events块\",{\"1\":{\"32\":2}}],[\"events\",{\"1\":{\"32\":3,\"458\":1}}],[\"each\",{\"1\":{\"275\":4,\"323\":1,\"324\":3}}],[\"empty\",{\"1\":{\"277\":1,\"291\":1,\"296\":1,\"367\":1}}],[\"emoji同学提供的例子\",{\"1\":{\"167\":1}}],[\"email\",{\"1\":{\"43\":2}}],[\"exit\",{\"1\":{\"442\":1,\"450\":1}}],[\"exist\",{\"1\":{\"144\":1,\"275\":1,\"323\":1,\"462\":2}}],[\"example\",{\"1\":{\"302\":1,\"363\":1}}],[\"exception\",{\"1\":{\"448\":1,\"463\":1,\"496\":1,\"508\":1}}],[\"exceeds\",{\"1\":{\"182\":1}}],[\"exclusive\",{\"1\":{\"275\":2,\"323\":1,\"324\":1}}],[\"executor\",{\"1\":{\"150\":2}}],[\"executestrategy\",{\"1\":{\"508\":1}}],[\"executed\",{\"1\":{\"302\":1,\"363\":1}}],[\"execute\",{\"1\":{\"143\":1}}],[\"extends\",{\"1\":{\"520\":1,\"522\":1}}],[\"extent\",{\"0\":{\"156\":1},\"1\":{\"153\":1,\"156\":1,\"157\":1}}],[\"extra=using\",{\"1\":{\"239\":1}}],[\"extra\",{\"1\":{\"217\":1,\"219\":1,\"228\":1,\"232\":2}}],[\"extr\",{\"1\":{\"149\":1}}],[\"exta\",{\"1\":{\"145\":1}}],[\"expire\",{\"1\":{\"454\":4}}],[\"expireafterwrite\",{\"1\":{\"416\":1}}],[\"explain\",{\"1\":{\"145\":1,\"199\":3,\"228\":1,\"237\":1,\"238\":1}}],[\"expressions\",{\"1\":{\"26\":1}}],[\"e\",{\"0\":{\"90\":1,\"91\":1},\"1\":{\"89\":2,\"304\":1,\"463\":2,\"508\":2}}],[\"ef\",{\"1\":{\"43\":1,\"44\":1}}],[\"eq\",{\"1\":{\"43\":2,\"228\":5,\"419\":1}}],[\"etc\",{\"1\":{\"43\":2}}],[\"edu\",{\"1\":{\"38\":1,\"39\":1,\"40\":1}}],[\"epoll\",{\"1\":{\"32\":1}}],[\"enum\",{\"1\":{\"490\":1,\"508\":1}}],[\"entryhandler<item>\",{\"1\":{\"463\":1}}],[\"entryhandler\",{\"1\":{\"463\":1}}],[\"entryhandler的泛型是与表对应的实体类\",{\"1\":{\"463\":1}}],[\"encode\",{\"1\":{\"443\":1,\"444\":1,\"451\":1,\"454\":1}}],[\"end\",{\"1\":{\"426\":2,\"428\":3,\"429\":1,\"430\":3,\"442\":2,\"450\":14,\"451\":4,\"454\":6}}],[\"ens33\",{\"1\":{\"43\":1}}],[\"en\",{\"1\":{\"28\":1}}],[\"engine=innodb\",{\"1\":{\"274\":1,\"288\":1,\"319\":1}}],[\"engine\",{\"1\":{\"20\":1,\"161\":1,\"166\":1}}],[\"plus\",{\"0\":{\"560\":1}}],[\"plan\",{\"0\":{\"546\":1}}],[\"plain\",{\"1\":{\"32\":1}}],[\"p1\",{\"1\":{\"486\":2}}],[\"python\",{\"1\":{\"425\":1,\"426\":1,\"480\":1}}],[\"php\",{\"1\":{\"480\":1}}],[\"phantomreference<object>\",{\"1\":{\"522\":1}}],[\"phantomreference\",{\"1\":{\"522\":2}}],[\"phantom\",{\"1\":{\"302\":3,\"353\":1,\"363\":3}}],[\"phone\",{\"1\":{\"161\":3,\"162\":1,\"238\":7}}],[\"pct\",{\"1\":{\"178\":1,\"180\":1}}],[\"pcre\",{\"1\":{\"26\":7}}],[\"persistence\",{\"1\":{\"462\":1}}],[\"person\",{\"1\":{\"182\":11,\"183\":3,\"184\":1,\"485\":1,\"486\":2,\"487\":1,\"488\":1,\"498\":2,\"499\":1,\"501\":3,\"502\":4,\"503\":4}}],[\"percentage\",{\"1\":{\"379\":1}}],[\"perform\",{\"1\":{\"275\":1,\"323\":1}}],[\"performance\",{\"1\":{\"194\":1,\"275\":1,\"277\":2,\"279\":1,\"280\":4,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":3,\"297\":1,\"304\":2,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"per\",{\"1\":{\"152\":2,\"503\":2}}],[\"perl\",{\"1\":{\"26\":2}}],[\"p\",{\"1\":{\"110\":2,\"139\":2,\"350\":1,\"407\":1,\"410\":1,\"448\":1,\"501\":2,\"502\":3}}],[\"pr=new\",{\"1\":{\"522\":1}}],[\"preferred\",{\"1\":{\"398\":3}}],[\"prevent\",{\"1\":{\"275\":2,\"323\":2}}],[\"prepare\",{\"1\":{\"143\":1,\"144\":5,\"344\":1,\"345\":3,\"346\":4,\"347\":3,\"348\":5,\"350\":2}}],[\"primitive\",{\"1\":{\"490\":1}}],[\"primary\",{\"1\":{\"145\":1,\"161\":1,\"182\":1,\"183\":1,\"204\":1,\"210\":1,\"274\":1,\"288\":1,\"297\":1,\"304\":1,\"319\":1,\"322\":1}}],[\"price\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"printstacktrace\",{\"1\":{\"508\":1}}],[\"printarr\",{\"1\":{\"428\":1,\"430\":1}}],[\"print\",{\"1\":{\"422\":1,\"425\":3,\"426\":2,\"428\":1,\"430\":2,\"443\":1}}],[\"println\",{\"1\":{\"416\":2,\"496\":1,\"499\":2,\"502\":2,\"503\":1,\"507\":2,\"520\":2}}],[\"private\",{\"1\":{\"419\":4,\"448\":4,\"462\":13,\"463\":6,\"503\":1,\"507\":1,\"508\":2}}],[\"prior\",{\"1\":{\"275\":2,\"324\":2}}],[\"priority值\",{\"1\":{\"393\":1}}],[\"priority\",{\"1\":{\"43\":1}}],[\"pros\",{\"1\":{\"496\":5}}],[\"properties\",{\"1\":{\"478\":1,\"496\":5}}],[\"properly\",{\"1\":{\"330\":1}}],[\"prority一样\",{\"1\":{\"393\":1}}],[\"probably\",{\"1\":{\"330\":1}}],[\"problem\",{\"1\":{\"302\":1,\"363\":1}}],[\"produces\",{\"1\":{\"302\":1,\"363\":1}}],[\"product\",{\"1\":{\"137\":2,\"145\":4,\"147\":1,\"148\":1,\"206\":8,\"215\":10,\"228\":1}}],[\"processlist\",{\"1\":{\"139\":1}}],[\"processon\",{\"1\":{\"91\":1}}],[\"processon官方\",{\"1\":{\"52\":1}}],[\"process\",{\"1\":{\"44\":3,\"83\":1}}],[\"processes\",{\"1\":{\"32\":3,\"47\":1,\"48\":4,\"49\":2}}],[\"proxyinstance\",{\"1\":{\"507\":4}}],[\"proxytest\",{\"1\":{\"507\":1}}],[\"proxyfactory\",{\"1\":{\"507\":2}}],[\"proxy\",{\"1\":{\"32\":1,\"38\":2,\"441\":1,\"442\":1,\"447\":1,\"507\":2}}],[\"pojo\",{\"1\":{\"419\":2,\"448\":2,\"462\":1,\"463\":3}}],[\"poo\",{\"1\":{\"335\":1}}],[\"pool空间不够的时候\",{\"1\":{\"178\":1}}],[\"pool\",{\"0\":{\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"335\":1,\"336\":1},\"1\":{\"41\":2,\"96\":1,\"140\":1,\"171\":1,\"172\":4,\"173\":4,\"174\":10,\"176\":2,\"177\":2,\"178\":22,\"179\":4,\"180\":4,\"182\":1,\"335\":6,\"336\":8,\"337\":5,\"339\":3,\"343\":4,\"344\":1,\"350\":4,\"450\":8}}],[\"pos\",{\"1\":{\"339\":5}}],[\"position\",{\"1\":{\"275\":1,\"324\":1}}],[\"possible\",{\"1\":{\"228\":1,\"330\":1}}],[\"post\",{\"1\":{\"110\":1,\"150\":1}}],[\"poll\",{\"1\":{\"170\":1,\"520\":1}}],[\"poll|eventport\",{\"1\":{\"32\":1}}],[\"pointer\",{\"1\":{\"164\":4,\"334\":3,\"358\":1}}],[\"point\",{\"1\":{\"91\":2,\"339\":7}}],[\"port\",{\"1\":{\"43\":1,\"450\":4}}],[\"pack\",{\"1\":{\"499\":1}}],[\"package\",{\"1\":{\"419\":1,\"435\":2,\"448\":1,\"462\":1,\"463\":2,\"499\":1}}],[\"paramtype\",{\"1\":{\"499\":2}}],[\"parameterizedtype\",{\"1\":{\"499\":2}}],[\"params\",{\"1\":{\"442\":2,\"450\":2,\"451\":4,\"454\":4}}],[\"participant\",{\"1\":{\"344\":1}}],[\"pairs\",{\"1\":{\"426\":1}}],[\"paddleocr官方并未提供java版本\",{\"1\":{\"99\":1}}],[\"paddleocr在实现前沿算法的基础上\",{\"1\":{\"99\":1}}],[\"password\",{\"1\":{\"496\":4}}],[\"pass\",{\"1\":{\"32\":1,\"38\":2,\"43\":2,\"441\":1,\"442\":1,\"447\":1,\"508\":1}}],[\"pathvariable\",{\"1\":{\"419\":2}}],[\"path\",{\"1\":{\"32\":1,\"435\":1,\"441\":2,\"442\":4,\"450\":4,\"451\":4,\"454\":4}}],[\"pattern\",{\"1\":{\"32\":2}}],[\"page\",{\"0\":{\"155\":1},\"1\":{\"32\":1,\"153\":1,\"178\":3,\"186\":1,\"187\":1,\"338\":5,\"343\":1,\"348\":2,\"349\":3}}],[\"pid\",{\"1\":{\"32\":3}}],[\"pseudo\",{\"1\":{\"275\":1,\"293\":5,\"298\":2}}],[\"ps\",{\"1\":{\"31\":1,\"43\":1,\"44\":1,\"144\":1,\"146\":1,\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"put\",{\"1\":{\"416\":1,\"463\":2,\"508\":1}}],[\"purpose\",{\"1\":{\"275\":1,\"323\":1}}],[\"purely\",{\"1\":{\"275\":1,\"323\":1}}],[\"public\",{\"1\":{\"15\":1,\"398\":1,\"419\":6,\"448\":2,\"462\":1,\"463\":8,\"496\":1,\"499\":1,\"507\":7,\"508\":8,\"522\":1}}],[\"pushdown\",{\"1\":{\"217\":1}}],[\"push\",{\"1\":{\"15\":6}}],[\"pull\",{\"1\":{\"15\":1}}],[\"环境\",{\"1\":{\"26\":2}}],[\"加载\",{\"1\":{\"492\":1}}],[\"加载到内存中的类\",{\"1\":{\"483\":1}}],[\"加载完类之后\",{\"1\":{\"480\":1}}],[\"加载master的rdb\",{\"1\":{\"384\":1}}],[\"加的是\",{\"1\":{\"310\":2}}],[\"加的锁还是和范围查询条件为\",{\"1\":{\"294\":1}}],[\"加表锁\",{\"1\":{\"309\":1}}],[\"加全局锁又会带来什么缺点呢\",{\"1\":{\"307\":1}}],[\"加上完整\",{\"1\":{\"346\":1}}],[\"加上全局锁\",{\"1\":{\"307\":2}}],[\"加上锁后\",{\"1\":{\"304\":1}}],[\"加间隙锁\",{\"1\":{\"291\":1}}],[\"加行级锁的规则搞的迷迷糊糊\",{\"1\":{\"282\":1}}],[\"加锁机制比较熟悉的同学\",{\"1\":{\"318\":1}}],[\"加锁分析\",{\"0\":{\"304\":1}}],[\"加锁变化过程如下\",{\"1\":{\"293\":2,\"294\":3,\"296\":1,\"297\":1}}],[\"加锁的位置准确的说\",{\"1\":{\"329\":1}}],[\"加锁的对象是针对索引\",{\"1\":{\"290\":1}}],[\"加锁的对象是索引\",{\"1\":{\"288\":1}}],[\"加锁的规则也会不同\",{\"1\":{\"289\":1,\"295\":1}}],[\"加锁的基本单位是\",{\"1\":{\"288\":1}}],[\"加锁的形式是不同的\",{\"1\":{\"288\":1}}],[\"加锁的类型\",{\"1\":{\"280\":1}}],[\"加锁时\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"加了间隙锁\",{\"1\":{\"317\":1}}],[\"加了x\",{\"1\":{\"297\":1}}],[\"加了两个\",{\"1\":{\"297\":1}}],[\"加了范围\",{\"1\":{\"297\":2}}],[\"加了范围为\",{\"1\":{\"293\":4,\"294\":9,\"296\":2,\"297\":2,\"298\":3}}],[\"加了\",{\"1\":{\"293\":2,\"296\":3,\"365\":1}}],[\"加了记录锁\",{\"1\":{\"290\":1,\"293\":1,\"297\":2,\"298\":2}}],[\"加了什么类型的锁\",{\"1\":{\"277\":2}}],[\"加了什么锁\",{\"0\":{\"318\":1},\"1\":{\"96\":1,\"293\":2,\"294\":3,\"296\":1,\"297\":1,\"318\":1}}],[\"加了其他字段后\",{\"1\":{\"232\":1}}],[\"加\",{\"1\":{\"192\":1,\"275\":1,\"294\":1,\"310\":2}}],[\"加入了后台现线程后\",{\"1\":{\"338\":1}}],[\"加入缓冲池的页\",{\"1\":{\"180\":1}}],[\"加入此时高支模还没有开发完成\",{\"1\":{\"10\":1}}],[\"加个缓存就行了嘛\",{\"1\":{\"172\":1}}],[\"加快解析速度\",{\"1\":{\"24\":1}}],[\"为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知\",{\"1\":{\"522\":1}}],[\"为前缀\",{\"1\":{\"403\":1}}],[\"为52\",{\"1\":{\"359\":1,\"360\":1}}],[\"为51\",{\"1\":{\"359\":1,\"360\":1}}],[\"为唯一二级索引\",{\"1\":{\"280\":1}}],[\"为二级索引\",{\"1\":{\"236\":1}}],[\"为止\",{\"1\":{\"216\":1}}],[\"为主键索引\",{\"1\":{\"329\":1}}],[\"为主键\",{\"1\":{\"204\":1,\"364\":1}}],[\"为主键值\",{\"1\":{\"192\":1}}],[\"为每条记录保存多份历史数据\",{\"1\":{\"334\":1}}],[\"为每一个缓存页都创建了一个控制块\",{\"1\":{\"174\":1}}],[\"为每个对象设置生命线\",{\"1\":{\"82\":1}}],[\"为此\",{\"1\":{\"172\":1,\"335\":1}}],[\"为某个索引分配空间的时候就不再按照页为单位分配了\",{\"1\":{\"156\":1}}],[\"为单位分配\",{\"1\":{\"156\":1}}],[\"为单位的\",{\"1\":{\"155\":1,\"243\":1}}],[\"为单位来读写的\",{\"1\":{\"155\":1,\"243\":1,\"246\":1}}],[\"为单位\",{\"1\":{\"155\":1,\"243\":1}}],[\"为名的目录\",{\"1\":{\"152\":1}}],[\"为\",{\"1\":{\"139\":1,\"140\":2,\"145\":3,\"152\":1,\"187\":1,\"216\":10,\"217\":2,\"275\":5,\"279\":2,\"280\":7,\"286\":1,\"287\":1,\"290\":7,\"291\":2,\"294\":4,\"304\":3,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"322\":4,\"338\":1,\"348\":1,\"359\":2,\"360\":1,\"365\":1}}],[\"为啥能抓到明文的包呢\",{\"1\":{\"108\":1}}],[\"为啥要先生成摘要再加密呢\",{\"1\":{\"108\":1}}],[\"为什么在javabean中要求提供一个public的空参构造器\",{\"1\":{\"498\":1}}],[\"为什么还要进行扰动计算\",{\"1\":{\"474\":1}}],[\"为什么还要提供hash方法\",{\"1\":{\"474\":1}}],[\"为什么树化的阈值是8\",{\"1\":{\"473\":1}}],[\"为什么一上来不树化\",{\"1\":{\"473\":1}}],[\"为什么事务要有隔离性\",{\"1\":{\"352\":1}}],[\"为什么锁竞争激烈\",{\"1\":{\"347\":1}}],[\"为什么两阶段提交的磁盘\",{\"1\":{\"347\":1}}],[\"为什么有了\",{\"1\":{\"340\":1}}],[\"为什么比\",{\"1\":{\"337\":1}}],[\"为什么需要两阶段提交\",{\"0\":{\"344\":1}}],[\"为什么需要\",{\"0\":{\"334\":1,\"335\":1,\"337\":1,\"340\":1}}],[\"为什么线程\",{\"1\":{\"310\":1}}],[\"为什么只是查询年龄\",{\"1\":{\"304\":1}}],[\"为什么这个实验案例中\",{\"1\":{\"297\":1}}],[\"为什么这个数据表加了非索引字段\",{\"1\":{\"232\":1}}],[\"为什么不会冲突\",{\"1\":{\"323\":1}}],[\"为什么不会像唯一索引那样\",{\"1\":{\"298\":1}}],[\"为什么不可以针对不存在的记录加记录锁\",{\"1\":{\"291\":1}}],[\"为什么不安全\",{\"0\":{\"103\":1},\"1\":{\"102\":1}}],[\"为什么唯一索引等值查询并且查询记录\",{\"1\":{\"291\":1}}],[\"为什么唯一索引等值查询并且查询记录存在的场景下\",{\"1\":{\"290\":1}}],[\"为什么间隙锁与间隙锁之间是兼容的\",{\"1\":{\"275\":1}}],[\"为什么上面事务\",{\"1\":{\"275\":1}}],[\"为什么会发生这种的事故\",{\"0\":{\"329\":1},\"1\":{\"328\":1}}],[\"为什么会发生死锁\",{\"0\":{\"321\":1},\"1\":{\"325\":1}}],[\"为什么会产生死锁\",{\"0\":{\"275\":1}}],[\"为什么会有碎片空间呢\",{\"1\":{\"174\":1}}],[\"为什么联合索引不遵循最左匹配原则就会失效\",{\"1\":{\"239\":1}}],[\"为什么第一个例子会导致索引失效\",{\"1\":{\"238\":1}}],[\"为什么对索引进行表达式计算\",{\"1\":{\"237\":1}}],[\"为什么对索引使用函数\",{\"1\":{\"236\":1}}],[\"为什么选择全扫描二级索引树\",{\"1\":{\"232\":1}}],[\"为什么要这么设计\",{\"1\":{\"346\":1}}],[\"为什么要这样加锁\",{\"1\":{\"300\":1}}],[\"为什么要多此一举\",{\"1\":{\"337\":1}}],[\"为什么要引入间隙锁\",{\"1\":{\"297\":1}}],[\"为什么要引入线程\",{\"0\":{\"126\":1}}],[\"为什么要通过遍历的方式来计数\",{\"0\":{\"197\":1}}],[\"为什么要有\",{\"0\":{\"172\":1}}],[\"为什么进程通信需要操作系统支持\",{\"0\":{\"120\":1}}],[\"为什么\",{\"0\":{\"207\":1,\"247\":1},\"1\":{\"96\":1,\"161\":1,\"197\":1,\"201\":1,\"207\":1,\"234\":1,\"235\":1,\"247\":1,\"291\":1}}],[\"为什么单独出一个hotfix分支\",{\"0\":{\"13\":1}}],[\"为什么单独出一个发布分支\",{\"0\":{\"12\":1}}],[\"为世界各国程序工作者普遍采用\",{\"1\":{\"58\":1}}],[\"为了方便说明\",{\"1\":{\"350\":1}}],[\"为了保证这两个日志的一致性\",{\"1\":{\"345\":1}}],[\"为了保证安全\",{\"1\":{\"120\":1}}],[\"为了避免出现两份日志之间的逻辑不一致的问题\",{\"1\":{\"344\":1}}],[\"为了避免幻读现象的发生\",{\"1\":{\"297\":1}}],[\"为了避免幻读\",{\"1\":{\"276\":1}}],[\"为了减少磁盘i\",{\"1\":{\"335\":1,\"343\":1,\"350\":1}}],[\"为了让大家很清楚的知道\",{\"1\":{\"282\":1}}],[\"为了让大家理解\",{\"1\":{\"204\":1}}],[\"为了解决二分查找树退化成链表的问题\",{\"1\":{\"258\":1}}],[\"为了解决二叉查找树会在极端情况下退化成链表的问题\",{\"1\":{\"251\":1}}],[\"为了解决降低树的高度的问题\",{\"1\":{\"252\":1}}],[\"为了解决这个问题\",{\"1\":{\"244\":1}}],[\"为了解决这问题\",{\"1\":{\"185\":1}}],[\"为了高效查询记录所在的数据页\",{\"1\":{\"246\":1}}],[\"为了加快在数据页内高效查询记录\",{\"1\":{\"246\":1}}],[\"为了加快网站的解析速度\",{\"1\":{\"24\":1}}],[\"为了更好的利用索引\",{\"1\":{\"227\":1}}],[\"为了更好的管理这些在\",{\"1\":{\"174\":1}}],[\"为了提高写入的性能\",{\"1\":{\"343\":1}}],[\"为了提高性能\",{\"1\":{\"187\":1}}],[\"为了提高流程图的逻辑性\",{\"1\":{\"57\":1}}],[\"为了防止断电导致数据丢失的问题\",{\"1\":{\"337\":1}}],[\"为了防止\",{\"1\":{\"178\":1}}],[\"为了能够快速找到空闲的缓存页\",{\"1\":{\"176\":1}}],[\"为了展示\",{\"1\":{\"161\":1}}],[\"为了写好这一部分\",{\"1\":{\"146\":1}}],[\"为了密码安全\",{\"1\":{\"139\":1}}],[\"为了有效地进行解题\",{\"1\":{\"58\":1}}],[\"为反向代理来说\",{\"1\":{\"48\":1}}],[\"为不区分大小写\",{\"1\":{\"32\":1}}],[\"将内存分为等大小的两个区域\",{\"1\":{\"529\":1}}],[\"将软引用中的对象引用置为null\",{\"1\":{\"520\":1}}],[\"将该队列从队头的元素进行出队\",{\"1\":{\"520\":1}}],[\"将该记录的索引中的\",{\"1\":{\"289\":2,\"300\":2}}],[\"将各实现类放入到枚举类中\",{\"1\":{\"508\":1}}],[\"将被代理类要执行的方法a的功能就声明在invoke\",{\"1\":{\"507\":1}}],[\"将class文件字节码加载到内存中\",{\"1\":{\"493\":1}}],[\"将class文件字节码内容加载到内存中\",{\"1\":{\"492\":1}}],[\"将java类的二进制代码合并到jvm的运行状态之中的过程\",{\"1\":{\"492\":1}}],[\"将查询结果返回\",{\"1\":{\"451\":1}}],[\"将方法导出\",{\"1\":{\"442\":1,\"450\":2}}],[\"将前端的查询商品的ajax请求代理到openresty集群\",{\"1\":{\"433\":1}}],[\"将部分插槽分配到新插槽\",{\"1\":{\"405\":1}}],[\"将16384个插槽分配到不同的实例\",{\"1\":{\"403\":1}}],[\"将master节点的所有数据都拷贝给slave节点\",{\"1\":{\"384\":1}}],[\"将小林余额修改为\",{\"1\":{\"359\":1}}],[\"将小林的账户余额从\",{\"1\":{\"360\":1}}],[\"将小林的账户余额记录修改成\",{\"1\":{\"359\":1}}],[\"将小林的余额改成\",{\"1\":{\"359\":1}}],[\"将处于文件系统中\",{\"1\":{\"348\":2}}],[\"将绿色这一组事务执行过程中产生的\",{\"1\":{\"348\":1}}],[\"将事务设置为\",{\"1\":{\"345\":1,\"350\":1}}],[\"将缓存在操作系统中\",{\"1\":{\"338\":1}}],[\"将写操作从\",{\"1\":{\"337\":1}}],[\"将所有数据恢复到最新的状态\",{\"1\":{\"337\":1}}],[\"将所有的记录划分成几个组\",{\"1\":{\"243\":1}}],[\"将对应记录的主键索引加\",{\"1\":{\"290\":1}}],[\"将参数\",{\"1\":{\"281\":1}}],[\"将数据变更反映它自己的数据\",{\"1\":{\"458\":1}}],[\"将数据变更写入二进制日志\",{\"1\":{\"458\":1}}],[\"将数据页从磁盘读入到\",{\"1\":{\"343\":1,\"350\":1}}],[\"将数据\",{\"1\":{\"272\":1}}],[\"将商品表中的\",{\"1\":{\"215\":1}}],[\"将自动生成一个隐式自增\",{\"1\":{\"204\":1,\"245\":1}}],[\"将计数表中的计数字段\",{\"1\":{\"200\":1}}],[\"将读取到的记录返回给\",{\"1\":{\"192\":1,\"193\":1}}],[\"将最近且经常查询的数据缓存在其中\",{\"1\":{\"180\":1}}],[\"将脏页写入到磁盘\",{\"1\":{\"177\":1}}],[\"将空闲缓存页的\",{\"1\":{\"176\":1}}],[\"将页加载到\",{\"1\":{\"174\":1,\"336\":1}}],[\"将其整体读入内存\",{\"1\":{\"155\":1,\"243\":1}}],[\"将完成记录返回给\",{\"1\":{\"149\":1}}],[\"将完整的记录返回给\",{\"1\":{\"149\":2}}],[\"将\",{\"1\":{\"144\":1,\"150\":1,\"178\":1,\"180\":1,\"205\":1,\"240\":1,\"298\":1,\"338\":1,\"345\":2,\"348\":2,\"349\":2,\"350\":3,\"458\":1}}],[\"将导致\",{\"1\":{\"139\":1}}],[\"将证书传给\",{\"1\":{\"108\":1}}],[\"将证书明文\",{\"1\":{\"108\":1}}],[\"将属性名记入框中\",{\"1\":{\"90\":1}}],[\"将负载分发到不同的服务器\",{\"1\":{\"23\":1}}],[\"将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上\",{\"1\":{\"23\":1}}],[\"将代码合并到develop\",{\"1\":{\"10\":1}}],[\"然后垃圾收集器根据标识清除相应的内容\",{\"1\":{\"527\":1}}],[\"然后根据终结器引用对象找到它所引用的对象\",{\"1\":{\"523\":1}}],[\"然后通知垃圾回收器进行回收\",{\"1\":{\"520\":1}}],[\"然后通过\",{\"1\":{\"304\":1}}],[\"然后把每个if中的逻辑抽取出到各实现类中\",{\"1\":{\"508\":1}}],[\"然后把该缓存页对应的控制块从\",{\"1\":{\"176\":1}}],[\"然后帮你转接到负责这个业务的赵老板的秘书那里\",{\"1\":{\"507\":1}}],[\"然后生成一个代表这个类的java\",{\"1\":{\"492\":1}}],[\"然后完成对缓存的更新\",{\"1\":{\"456\":1}}],[\"然后代理给了openresty集群\",{\"1\":{\"434\":1}}],[\"然后是疑似宕机\",{\"1\":{\"410\":1}}],[\"然后拷贝到刚才的控制台后\",{\"1\":{\"408\":1}}],[\"然后让所有节点都执行slaveof\",{\"1\":{\"394\":1}}],[\"然后判断slave节点的slave\",{\"1\":{\"393\":1}}],[\"然后表示每隔1秒将缓冲区数据写到aof文件\",{\"1\":{\"378\":1}}],[\"然后这期间如果其他事务插入了一条记录\",{\"1\":{\"369\":1}}],[\"然后这个查询的数据都在二级索引的\",{\"1\":{\"232\":1}}],[\"然后有两个并发的事务\",{\"1\":{\"357\":1}}],[\"然后有用户发起了购买商品的操作\",{\"1\":{\"307\":1}}],[\"然后事务\",{\"1\":{\"356\":1,\"359\":1,\"367\":1}}],[\"然后事务b也按相同的搜索条件也是查询出了\",{\"1\":{\"356\":1}}],[\"然后继续执行代码逻辑处理\",{\"1\":{\"355\":1}}],[\"然后继续自己的活动\",{\"1\":{\"81\":1}}],[\"然后交由操作系统控制持久化到磁盘的时机\",{\"1\":{\"349\":1}}],[\"然后拳击手听到后做出应答\",{\"1\":{\"344\":1}}],[\"然后开始记录该语句对应的\",{\"1\":{\"343\":1,\"350\":1}}],[\"然后开始向下搜索\",{\"1\":{\"243\":1}}],[\"然后马上执行\",{\"1\":{\"343\":1}}],[\"然后回放\",{\"1\":{\"342\":1}}],[\"然后回表操作\",{\"1\":{\"149\":1}}],[\"然后标记\",{\"1\":{\"339\":2}}],[\"然后调用该对象的finalize方法\",{\"1\":{\"523\":1}}],[\"然后调用它的clean方法来释放直接内存\",{\"1\":{\"522\":1}}],[\"然后调用\",{\"1\":{\"338\":1}}],[\"然后等事务提交的时候\",{\"1\":{\"338\":1}}],[\"然后才写到磁盘\",{\"1\":{\"337\":1}}],[\"然后才能执行\",{\"1\":{\"139\":1}}],[\"然后整个事务期间都在用这个\",{\"1\":{\"334\":1,\"357\":1,\"359\":1,\"361\":1}}],[\"然后整个事务执行期间都在用这个\",{\"1\":{\"307\":1}}],[\"然后进行\",{\"1\":{\"334\":1}}],[\"然后进行回表操作\",{\"1\":{\"149\":1}}],[\"然后做原先相反操作\",{\"1\":{\"334\":1}}],[\"然后更新\",{\"1\":{\"333\":1}}],[\"然后插入意向锁和间隙锁之间是互斥的关系\",{\"1\":{\"326\":1}}],[\"然后两个\",{\"1\":{\"312\":1}}],[\"然后创建了一个相同结构的表\",{\"1\":{\"312\":1}}],[\"然后给该字段赋值一个自增的值\",{\"1\":{\"312\":1}}],[\"然后为被\",{\"1\":{\"312\":1}}],[\"然后执行回滚操作的时候\",{\"1\":{\"334\":1}}],[\"然后执行\",{\"1\":{\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"344\":1}}],[\"然后执行一条\",{\"1\":{\"310\":1}}],[\"然后执行计划中的\",{\"1\":{\"145\":1}}],[\"然后确定插入位置后\",{\"1\":{\"296\":1}}],[\"然后如果遇到下面这些情况\",{\"1\":{\"292\":1}}],[\"然后看事务\",{\"1\":{\"280\":1}}],[\"然后设置锁的状态\",{\"1\":{\"275\":1,\"277\":1,\"317\":1,\"324\":1}}],[\"然后锁范围的\",{\"1\":{\"291\":1}}],[\"然后锁范围的最左值是\",{\"1\":{\"275\":1,\"322\":1}}],[\"然后锁的状态设置为等待状态\",{\"1\":{\"275\":1,\"277\":1,\"324\":1}}],[\"然后会退化为间隙锁\",{\"1\":{\"275\":1}}],[\"然后被老板教育了一波\",{\"1\":{\"275\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"528\":1}}],[\"然后直接读取要查询的数据\",{\"1\":{\"234\":1}}],[\"然后直到事务结束才会释放锁\",{\"1\":{\"275\":1}}],[\"然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞\",{\"1\":{\"275\":1}}],[\"然后利用链表向右遍历\",{\"1\":{\"256\":1}}],[\"然后对16384取余\",{\"1\":{\"402\":1}}],[\"然后对读取的记录加独占锁\",{\"1\":{\"311\":1}}],[\"然后对读取的记录加共享锁\",{\"1\":{\"311\":1}}],[\"然后对该记录加独占锁\",{\"1\":{\"311\":1}}],[\"然后对扫描出来的记录进行加锁\",{\"1\":{\"299\":1}}],[\"然后对于这条记录加上了s\",{\"1\":{\"278\":1}}],[\"然后对比目标数据的范围\",{\"1\":{\"256\":1}}],[\"然后对记录挨个判断是不是我们想要的\",{\"1\":{\"185\":1}}],[\"然后该子节点的索引为\",{\"1\":{\"252\":1}}],[\"然后读入到内存\",{\"1\":{\"248\":1}}],[\"然后读取要查询的数据\",{\"1\":{\"234\":1}}],[\"然后读取记录中的\",{\"1\":{\"192\":1}}],[\"然后过滤出符合条件的数据后再返回给\",{\"1\":{\"239\":1}}],[\"然后依次进行表达式的计算来进行条件判断\",{\"1\":{\"237\":1}}],[\"然后我们使用java命令对某个字节码文件进行解释运行\",{\"1\":{\"483\":1}}],[\"然后我们找到了索引值\",{\"1\":{\"252\":1}}],[\"然后我们找到了索引值为\",{\"1\":{\"205\":1}}],[\"然后我把这两个隐藏列也画出来\",{\"1\":{\"358\":1}}],[\"然后我在条件查询中\",{\"1\":{\"238\":1}}],[\"然后我再用下面这条查询语句\",{\"1\":{\"236\":1}}],[\"然后用该代理对象取代原始对象\",{\"1\":{\"505\":1}}],[\"然后用上一步获取的主键值\",{\"1\":{\"234\":1}}],[\"然后用带箭头的线把它们连接起来\",{\"1\":{\"58\":1}}],[\"然后因为订单是不能重复的\",{\"1\":{\"273\":1}}],[\"然后因为记录都是单向链表串起来的\",{\"1\":{\"243\":1}}],[\"然后因为\",{\"1\":{\"216\":1}}],[\"然后在堆中生成一个代表这个类的java\",{\"1\":{\"493\":1}}],[\"然后在配置文件application\",{\"1\":{\"397\":1}}],[\"然后在可重复读隔离级别下\",{\"1\":{\"364\":1}}],[\"然后在合适的时间再将修改的行数据写到磁盘上\",{\"1\":{\"343\":1,\"350\":1}}],[\"然后在合适的时间再更新到磁盘上\",{\"1\":{\"337\":1}}],[\"然后在合适的时间再写到磁盘上\",{\"1\":{\"337\":1}}],[\"然后在内存中修改这条记录\",{\"1\":{\"335\":1}}],[\"然后在商品表更新被购买的商品的库存\",{\"1\":{\"307\":1}}],[\"然后在扫描的过程中\",{\"1\":{\"295\":1,\"300\":1}}],[\"然后在\",{\"1\":{\"216\":2}}],[\"然后沿着记录所在的链表向后扫描\",{\"1\":{\"216\":3}}],[\"然后获取要查询的数据\",{\"1\":{\"234\":1}}],[\"然后获取整行数据\",{\"1\":{\"206\":1}}],[\"然后获取主键值\",{\"1\":{\"206\":1}}],[\"然后再次查询\",{\"1\":{\"367\":1}}],[\"然后再做进一步的操作\",{\"1\":{\"365\":1}}],[\"然后再做表结构的变更\",{\"1\":{\"310\":1}}],[\"然后再执行更新操作\",{\"1\":{\"354\":1}}],[\"然后再执行这条查询语句\",{\"1\":{\"304\":1}}],[\"然后再一起刷盘\",{\"1\":{\"348\":1}}],[\"然后再比对\",{\"1\":{\"239\":1}}],[\"然后再进行比较\",{\"1\":{\"238\":1,\"241\":1}}],[\"然后再\",{\"1\":{\"215\":1}}],[\"然后再检索主键索引\",{\"1\":{\"208\":1}}],[\"然后再通过主键索引中的\",{\"1\":{\"206\":1}}],[\"然后再针对有相同特点的索引归为一类\",{\"1\":{\"203\":1}}],[\"然后再问你\",{\"1\":{\"203\":1}}],[\"然后再将\",{\"1\":{\"178\":1}}],[\"然后再由后台线程将脏页写入到磁盘\",{\"1\":{\"177\":1}}],[\"然后再用第三方权威机构的私钥对生成的摘要进行加密\",{\"1\":{\"108\":1}}],[\"然后按照默认的16kb的大小划分出一个个的页\",{\"1\":{\"174\":1,\"336\":1}}],[\"然后真实数据处用\",{\"1\":{\"168\":1,\"169\":1}}],[\"然后\",{\"1\":{\"152\":1,\"243\":1,\"274\":1,\"277\":1,\"303\":1,\"310\":1,\"312\":1,\"319\":1,\"339\":1,\"358\":1,\"365\":1,\"408\":1,\"419\":1,\"447\":1}}],[\"然后保存表结构和表数据的文件都会存放在这个目录里\",{\"1\":{\"152\":1}}],[\"然后保存起来\",{\"1\":{\"139\":1}}],[\"然后构建语法树\",{\"1\":{\"150\":1}}],[\"然后向存储引擎索要下一条记录\",{\"1\":{\"149\":1}}],[\"然后向执行器\",{\"1\":{\"148\":1}}],[\"然后向其发送消息\",{\"1\":{\"70\":1}}],[\"然后查询结束\",{\"1\":{\"147\":1}}],[\"然后后面的权限逻辑判断都基于此时读取到的权限\",{\"1\":{\"139\":1}}],[\"然后客户端程序结束执行\",{\"1\":{\"139\":1}}],[\"然后就可以通过替换证书的方式进行瞒天过海\",{\"1\":{\"108\":1}}],[\"然后将rdb文件通过网络传输个slave\",{\"1\":{\"385\":1}}],[\"然后将\",{\"1\":{\"345\":2,\"350\":1}}],[\"然后将记录写到\",{\"1\":{\"343\":1,\"350\":1}}],[\"然后将记录返回给\",{\"1\":{\"149\":1}}],[\"然后将本次对这个页的修改以\",{\"1\":{\"337\":1}}],[\"然后将锁的状态设置为等待状态\",{\"1\":{\"317\":1}}],[\"然后将组号\",{\"1\":{\"244\":1}}],[\"然后将这两个结果集进行了合并\",{\"1\":{\"240\":1}}],[\"然后将其页设置为脏页\",{\"1\":{\"172\":1,\"179\":1,\"335\":1}}],[\"然后将证书传给\",{\"1\":{\"108\":1}}],[\"然后将请求分发到各个服务器上\",{\"1\":{\"23\":1}}],[\"然后停止活动\",{\"1\":{\"81\":1}}],[\"然后拖拽至画布上即可\",{\"1\":{\"72\":1}}],[\"然后删除\",{\"1\":{\"7\":1}}],[\"由操作系统决定何时将缓冲区内容写回磁盘\",{\"1\":{\"378\":1}}],[\"由操作系统实现\",{\"1\":{\"124\":1}}],[\"由绿色事务组的\",{\"1\":{\"348\":1}}],[\"由有\",{\"1\":{\"339\":1}}],[\"由参数\",{\"1\":{\"338\":1}}],[\"由后台线程将缓存在\",{\"1\":{\"337\":1}}],[\"由表级锁保证一致性\",{\"1\":{\"197\":1}}],[\"由\",{\"1\":{\"139\":1}}],[\"由此可知\",{\"1\":{\"108\":1}}],[\"由对象的所有属性以及运行时的当前值组成\",{\"1\":{\"70\":1}}],[\"由于隔离级别是\",{\"1\":{\"360\":1}}],[\"由于隔离级别时\",{\"1\":{\"359\":1}}],[\"由于它是第一个启动的事务\",{\"1\":{\"359\":1}}],[\"由于此前事务\",{\"1\":{\"357\":1}}],[\"由于在对记录加独占锁前\",{\"1\":{\"311\":1}}],[\"由于在引擎层就过滤掉大量的数据\",{\"1\":{\"239\":1}}],[\"由于不是唯一索引\",{\"1\":{\"295\":1,\"297\":1,\"300\":1}}],[\"由于找到了第一条不满足\",{\"1\":{\"294\":1}}],[\"由于主键索引具有唯一性\",{\"1\":{\"294\":1}}],[\"由于主键具有唯一性\",{\"1\":{\"290\":1}}],[\"由于扫描到的第三行记录\",{\"1\":{\"294\":1}}],[\"由于扫描到的第二行记录\",{\"1\":{\"294\":1}}],[\"由于查询该记录是一个等值查询\",{\"1\":{\"293\":1}}],[\"由于查询该记录不是一个等值查询\",{\"1\":{\"293\":1}}],[\"由于是存储在内存中\",{\"1\":{\"416\":1}}],[\"由于是范围查询\",{\"1\":{\"298\":1}}],[\"由于是范围查找\",{\"1\":{\"293\":2,\"294\":3}}],[\"由于是明文传输\",{\"1\":{\"103\":1}}],[\"由于对\",{\"1\":{\"290\":1}}],[\"由于对象存在生命周期\",{\"1\":{\"68\":1}}],[\"由于事务\",{\"1\":{\"280\":1,\"359\":2}}],[\"由于存在冗余的节点\",{\"1\":{\"255\":1}}],[\"由于树的高度是\",{\"1\":{\"252\":1}}],[\"由于树是存储在磁盘中的\",{\"1\":{\"250\":1}}],[\"由于数据库的索引是保存到磁盘上的\",{\"1\":{\"248\":1}}],[\"由于数据是加密的\",{\"1\":{\"104\":1}}],[\"由于隐式类型转换是通过\",{\"1\":{\"241\":1}}],[\"由于每次插入主键的索引值都是随机的\",{\"1\":{\"226\":1}}],[\"由于要维护\",{\"1\":{\"222\":1}}],[\"由于联合索引\",{\"1\":{\"216\":3}}],[\"由于多版本并发控制\",{\"1\":{\"197\":1}}],[\"由于本机还跑着\",{\"1\":{\"182\":1}}],[\"由于缓存未命中\",{\"1\":{\"178\":1}}],[\"由于\",{\"1\":{\"158\":1,\"216\":1,\"344\":2,\"348\":2}}],[\"由于只有\",{\"1\":{\"108\":1}}],[\"由于内容是明文\",{\"1\":{\"103\":1}}],[\"由于单个服务器解决不了\",{\"1\":{\"23\":1}}],[\"由反向代理服务器去选择目标服务器获取数据后\",{\"1\":{\"22\":1}}],[\"暴露的是代理服务器地址\",{\"1\":{\"22\":1}}],[\"因而从这个角度来说\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"因为库存更新频率较高\",{\"1\":{\"454\":1}}],[\"因为initializingbean可以在对象被spring创建并且成员变量全部注入后执行\",{\"1\":{\"448\":1}}],[\"因为item\",{\"1\":{\"442\":1}}],[\"因为轮询的原因\",{\"1\":{\"445\":1}}],[\"因为jvm缓存无法共享\",{\"1\":{\"445\":1}}],[\"因为未同步的仅仅是红色部分\",{\"1\":{\"386\":1}}],[\"因为slave原本也是一个master\",{\"1\":{\"384\":1}}],[\"因为是记录命令\",{\"1\":{\"379\":1}}],[\"因为是当前读\",{\"1\":{\"365\":1}}],[\"因为没有提交事务\",{\"1\":{\"357\":1}}],[\"因为没必要\",{\"1\":{\"161\":1}}],[\"因为使用\",{\"1\":{\"357\":1}}],[\"因为使用非对称加密是非常耗时的\",{\"1\":{\"108\":1}}],[\"因为多个事务同时使用相同的数据时\",{\"1\":{\"352\":1}}],[\"因为一旦主机发生异常重启\",{\"1\":{\"343\":1}}],[\"因为一个数据页中的记录是有限的\",{\"1\":{\"244\":1}}],[\"因为数据还缓存在文件系统的\",{\"1\":{\"343\":1}}],[\"因为要复制到所有节点才返回响应\",{\"1\":{\"342\":1}}],[\"因为从库数量增加\",{\"1\":{\"342\":1}}],[\"因为参数\",{\"1\":{\"338\":1}}],[\"因为操作系统的文件系统中有个\",{\"1\":{\"338\":1,\"349\":1}}],[\"因为插入语句在碰到间隙锁时\",{\"1\":{\"326\":1}}],[\"因为插入一个元素\",{\"1\":{\"250\":1}}],[\"因为间隙锁目的是为了防止其他事务插入数据\",{\"1\":{\"326\":1}}],[\"因为间隙锁的目的是防止插入幻影记录而提出的\",{\"1\":{\"286\":1,\"315\":1}}],[\"因为另一个事务中的插入会被阻塞\",{\"1\":{\"312\":1}}],[\"因为申请不到\",{\"1\":{\"310\":1}}],[\"因为可以读到未提交事务修改的数据\",{\"1\":{\"357\":1}}],[\"因为可能这期间另外一个事务修改了该记录\",{\"1\":{\"334\":1,\"360\":2,\"361\":1}}],[\"因为可重复读隔离级别下\",{\"1\":{\"302\":1,\"357\":1,\"361\":1,\"362\":1}}],[\"因为可为\",{\"1\":{\"227\":1}}],[\"因为对于是否可以插入\",{\"1\":{\"297\":1}}],[\"因为对于联合索引\",{\"1\":{\"216\":2}}],[\"因为此时插入的位置的下一条记录是\",{\"1\":{\"297\":4}}],[\"因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是\",{\"1\":{\"280\":1}}],[\"因为不涉及磁盘\",{\"1\":{\"343\":1}}],[\"因为不存在满足查询条件的记录\",{\"1\":{\"295\":1,\"300\":1}}],[\"因为不符合最左匹配原则\",{\"1\":{\"215\":1,\"239\":1}}],[\"因为存在两个索引\",{\"1\":{\"295\":1}}],[\"因为存在等值查询的条件\",{\"1\":{\"292\":1}}],[\"因为存储引擎就是负责将数据持久化在磁盘中\",{\"1\":{\"234\":1}}],[\"因为表锁的颗粒度太大\",{\"1\":{\"309\":1}}],[\"因为表中有两个索引\",{\"1\":{\"304\":1}}],[\"因为表中已经存在\",{\"1\":{\"291\":1}}],[\"因为表的数据都是存放在聚簇索引的叶子节点里\",{\"1\":{\"245\":1,\"257\":1}}],[\"因为事务没提交的时候\",{\"1\":{\"346\":1}}],[\"因为事务\",{\"1\":{\"290\":1,\"291\":1,\"354\":1}}],[\"因为更新或者删除操作也会对记录加\",{\"1\":{\"290\":1}}],[\"因为当事务\",{\"1\":{\"369\":1}}],[\"因为当事务提交了\",{\"1\":{\"283\":1,\"313\":1}}],[\"因为当设置为\",{\"1\":{\"343\":1}}],[\"因为当我们对数据库表进行操作时\",{\"1\":{\"310\":1}}],[\"因为当我们执行以下插入语句时\",{\"1\":{\"275\":1}}],[\"因为当执行select\",{\"1\":{\"357\":1}}],[\"因为当执行\",{\"1\":{\"302\":1,\"361\":1,\"362\":1}}],[\"因为当其他事务插入一条\",{\"1\":{\"297\":1}}],[\"因为我自己写完这篇文章后\",{\"1\":{\"282\":1}}],[\"因为我们都已经知道了建立索引之后在\",{\"1\":{\"221\":1}}],[\"因为我们在算\",{\"1\":{\"166\":1}}],[\"因为我们这个案例是只有\",{\"1\":{\"166\":1}}],[\"因为向事务\",{\"1\":{\"277\":1,\"324\":1}}],[\"因为都在相互等待对方释放锁\",{\"1\":{\"274\":1,\"320\":1}}],[\"因为都是基于\",{\"1\":{\"158\":1}}],[\"因为需要对订单做幂等性校验\",{\"1\":{\"274\":1}}],[\"因为树是存储在磁盘中的\",{\"1\":{\"258\":1}}],[\"因为非叶子节点有\",{\"1\":{\"255\":1}}],[\"因为每个节点即存索引又存记录\",{\"1\":{\"254\":1}}],[\"因为每次插入一条新记录\",{\"1\":{\"226\":1}}],[\"因为每次增删改索引\",{\"1\":{\"220\":1}}],[\"因为二叉查找树是一个跳跃结构\",{\"1\":{\"250\":1}}],[\"因为二级索引树的记录东西很少\",{\"1\":{\"232\":1}}],[\"因为二级索引的\",{\"1\":{\"145\":1,\"232\":1}}],[\"因为该数组是有序的\",{\"1\":{\"249\":1}}],[\"因为磁盘的速度比内存慢几十万倍\",{\"1\":{\"250\":1}}],[\"因为磁盘\",{\"1\":{\"248\":1}}],[\"因为记录是按照\",{\"1\":{\"243\":1}}],[\"因为联合索引\",{\"1\":{\"239\":1}}],[\"因为查询的主键值为\",{\"1\":{\"244\":1}}],[\"因为查询的结果可能是\",{\"1\":{\"235\":1}}],[\"因为查询主键索引的\",{\"1\":{\"145\":1}}],[\"因为只考虑了\",{\"1\":{\"296\":1}}],[\"因为只在二级索引就能查询到\",{\"1\":{\"245\":1}}],[\"因为只有知道索引的存储结构\",{\"1\":{\"234\":1}}],[\"因为只要一个表有更新操作\",{\"1\":{\"140\":1}}],[\"因为虽然使用了索引\",{\"1\":{\"228\":1}}],[\"因为采用了全表扫描的方式\",{\"1\":{\"228\":1}}],[\"因为索引和记录都是存放在硬盘\",{\"1\":{\"258\":1}}],[\"因为索引保存的是索引字段的原始值\",{\"1\":{\"236\":1,\"237\":1}}],[\"因为索引\",{\"1\":{\"235\":1}}],[\"因为索引是有序的\",{\"1\":{\"228\":1}}],[\"因为索引是会占用物理空间的\",{\"1\":{\"222\":1}}],[\"因为索引字段频繁修改\",{\"1\":{\"222\":1}}],[\"因为在可重复读的隔离级别下\",{\"1\":{\"307\":1}}],[\"因为在查询时\",{\"1\":{\"219\":1}}],[\"因为在非叶子节点中存放的是页号和该页最小的\",{\"1\":{\"187\":1}}],[\"因为这种特殊现象的存在\",{\"1\":{\"367\":1}}],[\"因为这会导致数据库并发时性能很差\",{\"1\":{\"361\":1}}],[\"因为这是更新操作\",{\"1\":{\"343\":1,\"350\":1}}],[\"因为这是一条\",{\"1\":{\"333\":1}}],[\"因为这个比较简单\",{\"1\":{\"296\":1}}],[\"因为这个密钥会被中间人截获甚至替换掉\",{\"1\":{\"106\":1}}],[\"因为这里查询语句扫描的\",{\"1\":{\"290\":1}}],[\"因为这条语句想加\",{\"1\":{\"280\":1}}],[\"因为这样会产生大量的\",{\"1\":{\"337\":1}}],[\"因为这样即使设备断电了\",{\"1\":{\"248\":1}}],[\"因为这样可以避免\",{\"1\":{\"219\":1}}],[\"因为如果索引的区分度很小\",{\"1\":{\"218\":1}}],[\"因为有查询优化器\",{\"1\":{\"215\":1,\"239\":1}}],[\"因为即使在数据量很大的情况\",{\"1\":{\"205\":1}}],[\"因为即使被中间人窃听\",{\"1\":{\"104\":1}}],[\"因为它会对记录加\",{\"1\":{\"368\":1,\"369\":1}}],[\"因为它属于快照读\",{\"1\":{\"283\":1,\"313\":1}}],[\"因为它是通过\",{\"1\":{\"275\":1}}],[\"因为它并不会真正的去查询\",{\"1\":{\"199\":1}}],[\"因为它的效率是最差的\",{\"1\":{\"196\":1}}],[\"因为它将\",{\"1\":{\"149\":1}}],[\"因为认知上\",{\"1\":{\"189\":1}}],[\"因为简单的\",{\"1\":{\"178\":1}}],[\"因为字符集代表着\",{\"1\":{\"165\":1}}],[\"因为现在基本没人用了\",{\"1\":{\"158\":1}}],[\"因为优化器选择的访问类型为\",{\"1\":{\"147\":2,\"148\":2}}],[\"因为\",{\"1\":{\"139\":2,\"158\":1,\"174\":1,\"178\":2,\"193\":1,\"205\":1,\"218\":1,\"222\":1,\"226\":1,\"227\":1,\"238\":1,\"239\":1,\"243\":2,\"247\":1,\"252\":1,\"256\":1,\"275\":1,\"296\":1,\"297\":1,\"298\":1,\"310\":1,\"333\":1,\"338\":1,\"341\":1,\"346\":1,\"349\":1}}],[\"因为客户端除了通过验签的方式验证证书是否合法之外\",{\"1\":{\"108\":1}}],[\"因为客户端不需要任何配置就可以访问\",{\"1\":{\"22\":1}}],[\"因为摘要算法是公开的\",{\"1\":{\"108\":1}}],[\"因为私密加密的信息公钥是可以解密的\",{\"1\":{\"107\":1}}],[\"因为作为反向代理服务器\",{\"1\":{\"48\":1}}],[\"因此要想此方法正常的创建运行时类的对象\",{\"1\":{\"498\":1}}],[\"因此要存储到103节点\",{\"1\":{\"402\":1}}],[\"因此也允许基于lua做拓展\",{\"1\":{\"421\":1}}],[\"因此这样的业务nginx服务也需要搭建集群来提高并发\",{\"1\":{\"414\":1}}],[\"因此这样的nginx服务不再是一个反向代理服务器\",{\"1\":{\"414\":1}}],[\"因此这种插入数据的方法效率非常高\",{\"1\":{\"226\":1}}],[\"因此填写7001的id\",{\"1\":{\"408\":1}}],[\"因此需要先看看num的插槽是多少\",{\"1\":{\"408\":1}}],[\"因此需要切换到7001节点\",{\"1\":{\"402\":1}}],[\"因此没有任何数据可以存储到7004上\",{\"1\":{\"407\":1}}],[\"因此除了第一次做全量同步\",{\"1\":{\"385\":1}}],[\"因此slave做数据同步\",{\"1\":{\"384\":1}}],[\"因此第一个命令记录下来没有意义\",{\"1\":{\"379\":1}}],[\"因此额\",{\"1\":{\"357\":1}}],[\"因此可以利用正则表达式匹配的方式来获取id\",{\"1\":{\"439\":1}}],[\"因此可以采用这种方式来备份数据库\",{\"1\":{\"307\":1}}],[\"因此可能会增加语句的响应时间\",{\"1\":{\"349\":1}}],[\"因此保证了事务写入的顺序\",{\"1\":{\"348\":1}}],[\"因此所以针对并发量大的系统\",{\"1\":{\"339\":1}}],[\"因此间隙锁与间隙锁之间是相互兼容的\",{\"1\":{\"326\":1}}],[\"因此发生了死锁\",{\"1\":{\"325\":1,\"326\":1}}],[\"因此不会把整张表给锁住\",{\"1\":{\"304\":1}}],[\"因此对该二级索引记录加\",{\"1\":{\"298\":1}}],[\"因此对象图只能在系统某一时间段存在\",{\"1\":{\"68\":1}}],[\"因此事务\",{\"1\":{\"277\":1}}],[\"因此是可以共存的\",{\"1\":{\"275\":1,\"323\":1}}],[\"因此是可以走索引扫描的\",{\"1\":{\"238\":1}}],[\"因此只需要在\",{\"1\":{\"291\":1}}],[\"因此只能通过树的遍历来完成范围查询\",{\"1\":{\"256\":1,\"258\":1}}],[\"因此只有一个条件列是索引列是没有意义的\",{\"1\":{\"240\":1}}],[\"因此我们必须先入门lua的基本语法\",{\"1\":{\"420\":1}}],[\"因此我们需要尽量让\",{\"1\":{\"228\":1}}],[\"因此我本文关于\",{\"1\":{\"255\":1}}],[\"因此数据量相同的情况下\",{\"1\":{\"254\":1,\"258\":1}}],[\"因此当我们通过索引查找某行数据的时候\",{\"1\":{\"248\":1}}],[\"因此在构造索引的时候\",{\"1\":{\"244\":1}}],[\"因此在叶子节点中\",{\"1\":{\"204\":1}}],[\"因此采用的就是全表扫描的方式\",{\"1\":{\"237\":1}}],[\"因此每次插入新的数据时\",{\"1\":{\"226\":1}}],[\"因此二叉树检索到目标数据所经历的磁盘\",{\"1\":{\"207\":1}}],[\"因此一般都会在一定时机进行批量刷盘\",{\"1\":{\"179\":1}}],[\"因此从这个版本之后\",{\"1\":{\"152\":1}}],[\"因此本项目将kotlin部分移除\",{\"1\":{\"99\":1}}],[\"因此部署图也经常和构件图一起使用\",{\"1\":{\"78\":1}}],[\"因此参与者可以是人\",{\"1\":{\"59\":1}}],[\"因此用计算机解题应当先确定用哪一种方法来计算\",{\"1\":{\"58\":1}}],[\"因此\",{\"1\":{\"1\":1,\"47\":1,\"58\":2,\"70\":1,\"84\":1,\"85\":2,\"155\":1,\"174\":1,\"179\":1,\"192\":1,\"193\":1,\"215\":3,\"216\":5,\"226\":2,\"232\":1,\"243\":2,\"245\":1,\"250\":1,\"251\":1,\"254\":1,\"255\":1,\"256\":1,\"258\":1,\"275\":2,\"290\":1,\"291\":2,\"294\":2,\"296\":1,\"299\":1,\"303\":1,\"304\":2,\"312\":2,\"322\":2,\"329\":3,\"334\":1,\"336\":1,\"337\":1,\"347\":1,\"384\":1,\"440\":1,\"445\":1}}],[\"其效率高体现在\",{\"1\":{\"516\":1}}],[\"其设计目的是为了嵌入应用程序中\",{\"1\":{\"421\":1}}],[\"其流程如下\",{\"1\":{\"411\":1}}],[\"其节点会因为自动故障转移而发生变化\",{\"1\":{\"395\":1}}],[\"其offset就会覆盖旧的数据\",{\"1\":{\"386\":1}}],[\"其特点是只有在可能发生冲突时才加锁\",{\"1\":{\"276\":1}}],[\"其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集\",{\"1\":{\"275\":1}}],[\"其一是两个间隙锁的间隙区间完全一样\",{\"1\":{\"275\":1}}],[\"其存储结构是由\",{\"1\":{\"272\":1}}],[\"其次\",{\"1\":{\"250\":1}}],[\"其搜索复杂度为o\",{\"1\":{\"207\":1}}],[\"其能完成全加载进内存\",{\"1\":{\"187\":1}}],[\"其余都是非叶子节点\",{\"1\":{\"186\":1}}],[\"其数据和磁盘上的数据已经不一致\",{\"1\":{\"178\":1}}],[\"其他代码略\",{\"1\":{\"396\":1}}],[\"其他都是当前读\",{\"1\":{\"365\":1}}],[\"其他都是普通字段\",{\"1\":{\"234\":1}}],[\"其他语句都会被锁住不能执行\",{\"1\":{\"329\":1}}],[\"其他字段都是普通字段\",{\"1\":{\"319\":1}}],[\"其他字段都是非索引字段\",{\"1\":{\"231\":1}}],[\"其他扫描的记录\",{\"1\":{\"294\":1}}],[\"其他扫描到的记录\",{\"1\":{\"292\":3,\"294\":3}}],[\"其他事务的如果要向该表插入语句都会被阻塞\",{\"1\":{\"312\":1}}],[\"其他事务在对该表进行增\",{\"1\":{\"304\":1}}],[\"其他事务是无法插入一个\",{\"1\":{\"297\":1}}],[\"其他事务是有可能插入\",{\"1\":{\"297\":1}}],[\"其他事务是否可以插入\",{\"1\":{\"296\":1}}],[\"其他事务插入\",{\"1\":{\"297\":3}}],[\"其他事务插入一条\",{\"1\":{\"285\":1}}],[\"其他事务无法删除该记录\",{\"1\":{\"290\":1}}],[\"其他事务既不可以对该记录加\",{\"1\":{\"285\":1,\"314\":1}}],[\"其他事务也可以继续对该记录加\",{\"1\":{\"285\":1,\"314\":1}}],[\"其他上层节\",{\"1\":{\"244\":1}}],[\"其他所有的列\",{\"1\":{\"165\":1}}],[\"其他\",{\"1\":{\"107\":1,\"161\":1}}],[\"其它略\",{\"1\":{\"419\":1}}],[\"其它大多数时候slave与master都是做增量同步\",{\"1\":{\"385\":1}}],[\"其它索引都属于二级索引\",{\"1\":{\"234\":1}}],[\"其它索引都属于辅助索引\",{\"1\":{\"204\":1}}],[\"其它\",{\"0\":{\"109\":1},\"1\":{\"102\":1}}],[\"其它进程还在工作\",{\"1\":{\"46\":1}}],[\"其提供了kotlin和java混合版本的demo\",{\"1\":{\"99\":1}}],[\"其表示格式为\",{\"1\":{\"89\":1}}],[\"其最主要的就是程序目前的状态\",{\"1\":{\"83\":1}}],[\"其边框上会显示蓝边的空心圆\",{\"1\":{\"72\":1}}],[\"其实这也就是动态代理的核心思想\",{\"1\":{\"507\":1}}],[\"其实这个最大建议值也是不同的\",{\"1\":{\"187\":1}}],[\"其实理解\",{\"1\":{\"300\":1}}],[\"其实不单单要从数据结构的角度出发\",{\"1\":{\"247\":1}}],[\"其实\",{\"1\":{\"203\":1}}],[\"其实等于\",{\"1\":{\"194\":1}}],[\"其实并没有\",{\"1\":{\"185\":1}}],[\"其实分成了三个部分来存储\",{\"1\":{\"166\":1}}],[\"其实是放入连接池\",{\"1\":{\"450\":3}}],[\"其实是为了避免幻读现象的发生\",{\"1\":{\"297\":1}}],[\"其实是在说\",{\"1\":{\"283\":1}}],[\"其实是在统计\",{\"1\":{\"191\":1}}],[\"其实是很不好的\",{\"1\":{\"198\":1}}],[\"其实是包含\",{\"1\":{\"166\":1}}],[\"其实是是内置在操作系统中的\",{\"1\":{\"109\":1}}],[\"其实变长字段字节数列表不是必须的\",{\"1\":{\"161\":1}}],[\"其实都是在围绕\",{\"1\":{\"151\":1}}],[\"其实也是因为\",{\"1\":{\"109\":1}}],[\"其实就是多了缓存时间参数\",{\"1\":{\"454\":1}}],[\"其实就是\",{\"1\":{\"166\":1}}],[\"其实就是在内存中开辟一个大小固定的内存缓冲区\",{\"1\":{\"124\":1}}],[\"其实就是用了证书调包这一手法\",{\"1\":{\"108\":1}}],[\"其实就是连线\",{\"1\":{\"72\":1}}],[\"其实和流程图很相像\",{\"1\":{\"88\":1}}],[\"其实客户端对代理是无感知的\",{\"1\":{\"22\":1}}],[\"其中记录的数据叫做binary\",{\"1\":{\"458\":1}}],[\"其中nginx编程则会用到openresty框架结合lua这样的语言\",{\"1\":{\"414\":1}}],[\"其中只有分片集群的配置方式略有差异\",{\"1\":{\"412\":1}}],[\"其中7001\",{\"1\":{\"409\":1}}],[\"其中非叶子的\",{\"1\":{\"206\":1}}],[\"其中包含了\",{\"1\":{\"166\":1}}],[\"其中\",{\"1\":{\"139\":1,\"178\":1,\"202\":1,\"207\":1,\"234\":1,\"274\":1,\"288\":1,\"329\":1,\"364\":1,\"433\":1}}],[\"其中一个用户级线程被阻塞后\",{\"1\":{\"130\":2}}],[\"其中一个用例\",{\"1\":{\"62\":1}}],[\"其中最重要的部分是\",{\"1\":{\"83\":1}}],[\"其中消息又分为同步消息\",{\"1\":{\"79\":1}}],[\"其中xxx为对应的版本号或者模块名称\",{\"1\":{\"8\":1}}],[\"浏览器查询到的都是缓存数据\",{\"1\":{\"455\":1}}],[\"浏览器访问静态资源时\",{\"1\":{\"414\":1}}],[\"浏览器等各种工具\",{\"1\":{\"182\":1}}],[\"浏览器就使用信任的根证书\",{\"1\":{\"109\":1}}],[\"浏览器地址栏输入地址http\",{\"1\":{\"40\":1}}],[\"浏览器\",{\"1\":{\"21\":1}}],[\"浏览器缓存\",{\"1\":{\"2\":1,\"97\":1}}],[\"正好上次遇到了一个要分7个if判断的场景\",{\"1\":{\"508\":1}}],[\"正好该记录的二级索引上有间隙锁\",{\"1\":{\"296\":2,\"297\":1}}],[\"正是因为在读提交隔离级别下\",{\"1\":{\"360\":1}}],[\"正常\",{\"1\":{\"462\":1}}],[\"正常关闭时\",{\"1\":{\"338\":1}}],[\"正常关闭之前\",{\"1\":{\"179\":1}}],[\"正常站点和中间人都可以向\",{\"1\":{\"108\":1}}],[\"正在赶稿的路上\",{\"1\":{\"170\":1,\"332\":1}}],[\"正因为\",{\"1\":{\"144\":1}}],[\"正式为类变量\",{\"1\":{\"492\":1}}],[\"正式运行得到必要的运算结果\",{\"1\":{\"58\":1}}],[\"正式环境需要改bug\",{\"1\":{\"15\":1}}],[\"正则匹配\",{\"1\":{\"32\":1}}],[\"正向代理\",{\"0\":{\"21\":1}}],[\"xid\",{\"1\":{\"345\":2,\"346\":6}}],[\"xiaolin\",{\"1\":{\"178\":2,\"333\":1,\"343\":1,\"344\":3,\"350\":1}}],[\"xa\",{\"1\":{\"345\":6,\"346\":2}}],[\"x型\",{\"1\":{\"323\":1}}],[\"x型锁\",{\"1\":{\"283\":4}}],[\"x锁\",{\"1\":{\"283\":1,\"313\":1}}],[\"xx\",{\"1\":{\"228\":2,\"232\":2,\"235\":2,\"241\":2}}],[\"xxxbuilder类中查看是否有静态方法的存在\",{\"1\":{\"489\":1}}],[\"xxxfactory\",{\"1\":{\"489\":1}}],[\"xxxs\",{\"1\":{\"489\":1}}],[\"xxx对应版本号\",{\"1\":{\"7\":1}}],[\"xxx\",{\"1\":{\"7\":3,\"8\":3,\"12\":1,\"15\":10,\"40\":2,\"337\":1,\"341\":1,\"489\":1}}],[\"x=1280\",{\"1\":{\"187\":1}}],[\"x=15\",{\"1\":{\"187\":1}}],[\"xmind\",{\"1\":{\"91\":1}}],[\"x\",{\"0\":{\"230\":1},\"1\":{\"20\":1,\"32\":1,\"81\":1,\"96\":1,\"187\":3,\"216\":1,\"275\":17,\"277\":1,\"280\":8,\"285\":9,\"286\":1,\"287\":7,\"290\":10,\"291\":3,\"293\":3,\"294\":6,\"296\":6,\"297\":2,\"298\":1,\"304\":28,\"314\":9,\"315\":1,\"316\":7,\"322\":5,\"323\":1,\"329\":1}}],[\"iitemstockservice\",{\"1\":{\"419\":1,\"448\":2,\"463\":2}}],[\"iitemservice\",{\"1\":{\"419\":1,\"448\":2,\"463\":2}}],[\"ib\",{\"1\":{\"339\":7}}],[\"ibdata1\",{\"1\":{\"152\":1}}],[\"ibd\",{\"1\":{\"152\":5,\"184\":1}}],[\"itemhandler\",{\"1\":{\"463\":1}}],[\"item序列化为json\",{\"1\":{\"448\":2,\"463\":2}}],[\"itemlist\",{\"1\":{\"448\":2,\"463\":2}}],[\"itemjson\",{\"1\":{\"442\":1,\"444\":2,\"451\":2,\"454\":2}}],[\"item开头\",{\"1\":{\"442\":1}}],[\"item的代码\",{\"1\":{\"439\":1}}],[\"item这个路径的监听\",{\"1\":{\"435\":1}}],[\"item路径\",{\"1\":{\"435\":1,\"442\":1}}],[\"itemservice\",{\"1\":{\"419\":2,\"448\":2,\"463\":2}}],[\"itemstockjson\",{\"1\":{\"442\":1,\"444\":1}}],[\"itemstock>\",{\"1\":{\"419\":2}}],[\"itemstock\",{\"1\":{\"419\":2,\"448\":2,\"463\":2}}],[\"itemcontroller\",{\"1\":{\"419\":1}}],[\"itemcache\",{\"1\":{\"419\":3,\"463\":4}}],[\"item>\",{\"1\":{\"419\":2,\"463\":1}}],[\"item\",{\"1\":{\"419\":6,\"435\":5,\"436\":3,\"439\":4,\"442\":5,\"444\":6,\"445\":1,\"446\":2,\"447\":1,\"448\":12,\"451\":9,\"453\":6,\"454\":17,\"462\":3,\"463\":35}}],[\"itcast\",{\"1\":{\"402\":1}}],[\"it\",{\"1\":{\"330\":1}}],[\"i=1\",{\"1\":{\"182\":1}}],[\"i+1\",{\"1\":{\"182\":2}}],[\"isolation\",{\"1\":{\"352\":1}}],[\"is\",{\"1\":{\"194\":1,\"275\":3,\"302\":2,\"323\":2,\"324\":1,\"330\":1,\"363\":2,\"496\":2}}],[\"iskm\",{\"1\":{\"150\":1}}],[\"is09000系列国际标准中将流程定义为一组将输入转化为输出的相互群或相互作用的活动\",{\"1\":{\"54\":1}}],[\"implements\",{\"1\":{\"448\":1,\"463\":2,\"506\":2,\"507\":2,\"508\":1}}],[\"import\",{\"1\":{\"419\":6,\"448\":11,\"462\":9,\"463\":18}}],[\"img\",{\"1\":{\"55\":1,\"56\":1,\"57\":1,\"58\":3,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":7,\"69\":1,\"70\":1,\"71\":1,\"72\":3,\"73\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":2,\"80\":1,\"81\":4,\"84\":2,\"87\":1,\"89\":1,\"90\":4,\"103\":3,\"106\":2,\"107\":2,\"108\":8,\"109\":2,\"110\":1,\"285\":1,\"286\":1,\"287\":1}}],[\"image\",{\"1\":{\"42\":3,\"436\":1,\"439\":1,\"462\":1}}],[\"io\",{\"1\":{\"47\":1,\"91\":2,\"150\":1,\"178\":2,\"187\":3,\"250\":2,\"258\":1,\"337\":1}}],[\"iotfix\",{\"1\":{\"15\":1}}],[\"i\",{\"0\":{\"349\":1},\"1\":{\"43\":1,\"145\":1,\"155\":1,\"156\":3,\"182\":6,\"192\":2,\"205\":4,\"207\":3,\"225\":1,\"243\":2,\"244\":2,\"247\":1,\"248\":6,\"250\":1,\"251\":2,\"252\":6,\"254\":1,\"256\":1,\"258\":6,\"337\":1,\"338\":1,\"342\":2,\"343\":3,\"347\":2,\"348\":1,\"349\":2}}],[\"if\",{\"1\":{\"43\":2,\"275\":1,\"302\":1,\"324\":1,\"330\":1,\"363\":1,\"429\":1,\"430\":1,\"442\":1,\"450\":9,\"451\":2,\"454\":4,\"508\":1,\"520\":1}}],[\"idtype\",{\"1\":{\"462\":2}}],[\"idle\",{\"1\":{\"450\":4}}],[\"id一致则说明是同一数据集\",{\"1\":{\"384\":1}}],[\"id在事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"ids\",{\"1\":{\"358\":6,\"359\":2,\"360\":2}}],[\"id值\",{\"1\":{\"296\":1,\"360\":1}}],[\"id列\",{\"1\":{\"296\":1}}],[\"id2\",{\"1\":{\"217\":1}}],[\"idx\",{\"1\":{\"216\":2,\"236\":2}}],[\"id=\",{\"1\":{\"368\":1}}],[\"id=3\",{\"1\":{\"312\":1}}],[\"id=5\",{\"1\":{\"187\":1}}],[\"id=1001\",{\"1\":{\"436\":1}}],[\"id=1\",{\"1\":{\"187\":1,\"228\":1,\"234\":1,\"290\":2,\"343\":1,\"350\":1}}],[\"id=6\",{\"1\":{\"187\":3}}],[\"idea\",{\"1\":{\"182\":1}}],[\"id是必需的\",{\"1\":{\"164\":1}}],[\"id不是必需的\",{\"1\":{\"164\":1}}],[\"id必须相同\",{\"1\":{\"43\":1}}],[\"id\",{\"1\":{\"43\":2,\"137\":2,\"139\":2,\"145\":4,\"147\":5,\"161\":1,\"164\":7,\"182\":6,\"183\":3,\"186\":5,\"187\":3,\"192\":4,\"204\":2,\"205\":1,\"206\":1,\"217\":1,\"228\":2,\"231\":1,\"232\":3,\"234\":3,\"237\":5,\"238\":4,\"240\":3,\"245\":1,\"263\":4,\"264\":6,\"265\":2,\"274\":1,\"275\":3,\"276\":1,\"279\":4,\"283\":2,\"285\":3,\"286\":2,\"287\":3,\"288\":1,\"290\":13,\"291\":19,\"293\":24,\"294\":46,\"296\":14,\"297\":29,\"298\":10,\"302\":1,\"303\":1,\"304\":6,\"312\":3,\"314\":2,\"315\":2,\"316\":3,\"317\":2,\"319\":1,\"322\":3,\"323\":1,\"324\":1,\"325\":1,\"329\":3,\"333\":3,\"334\":3,\"343\":2,\"344\":4,\"345\":1,\"350\":2,\"358\":22,\"359\":28,\"360\":13,\"363\":1,\"364\":1,\"365\":3,\"367\":13,\"368\":2,\"384\":2,\"419\":9,\"436\":1,\"439\":3,\"442\":3,\"444\":3,\"448\":2,\"451\":7,\"454\":7,\"462\":4,\"463\":6,\"508\":2}}],[\"ip和port是redis地址\",{\"1\":{\"450\":2}}],[\"ipairs\",{\"1\":{\"426\":1,\"428\":1,\"430\":1}}],[\"ipaddress\",{\"1\":{\"43\":1}}],[\"iphone\",{\"1\":{\"148\":2}}],[\"ip\",{\"1\":{\"41\":2,\"139\":1,\"450\":4}}],[\"invocationhandler\",{\"1\":{\"507\":1}}],[\"invoke\",{\"1\":{\"502\":3,\"507\":3,\"508\":1}}],[\"invalidate\",{\"1\":{\"463\":1}}],[\"inputstream\",{\"1\":{\"496\":1}}],[\"inhibitive\",{\"1\":{\"275\":1,\"323\":1}}],[\"inner\",{\"1\":{\"263\":1,\"265\":1}}],[\"innodb引擎的默认隔离级别虽然是\",{\"1\":{\"357\":1}}],[\"innodb会跳过加锁环节\",{\"1\":{\"276\":1}}],[\"innodb以相同的方式处理select\",{\"1\":{\"194\":1}}],[\"innodb存储引擎\",{\"1\":{\"169\":1}}],[\"innodb存储引擎的逻辑存储结构大致如下图\",{\"1\":{\"153\":1}}],[\"innodb\",{\"0\":{\"158\":1,\"207\":1,\"243\":1},\"1\":{\"138\":4,\"140\":1,\"147\":1,\"148\":2,\"152\":4,\"154\":1,\"155\":2,\"156\":1,\"157\":1,\"158\":1,\"161\":1,\"162\":1,\"164\":1,\"166\":1,\"168\":2,\"169\":1,\"172\":1,\"173\":1,\"174\":4,\"178\":2,\"179\":1,\"180\":7,\"182\":1,\"184\":3,\"185\":1,\"187\":1,\"190\":1,\"192\":4,\"193\":3,\"194\":1,\"197\":6,\"201\":1,\"202\":2,\"204\":4,\"226\":2,\"227\":1,\"234\":7,\"235\":1,\"242\":1,\"243\":5,\"244\":2,\"245\":3,\"246\":2,\"257\":6,\"258\":2,\"274\":1,\"275\":2,\"276\":1,\"281\":3,\"283\":3,\"293\":1,\"298\":1,\"302\":1,\"307\":1,\"309\":2,\"311\":2,\"312\":9,\"313\":1,\"317\":1,\"323\":1,\"328\":1,\"329\":4,\"333\":2,\"334\":1,\"335\":1,\"336\":4,\"337\":6,\"338\":10,\"339\":3,\"340\":4,\"341\":1,\"343\":4,\"345\":2,\"347\":2,\"348\":2,\"349\":1,\"350\":4,\"352\":3,\"357\":1,\"358\":1,\"361\":3,\"362\":1,\"365\":1,\"367\":1,\"369\":1}}],[\"infimum\",{\"1\":{\"187\":1}}],[\"init\",{\"1\":{\"182\":1}}],[\"initializingbean\",{\"1\":{\"448\":2,\"463\":2}}],[\"initialcapacity\",{\"1\":{\"419\":2}}],[\"initial\",{\"1\":{\"15\":1}}],[\"inserted\",{\"1\":{\"275\":1,\"324\":1}}],[\"insertion\",{\"1\":{\"275\":1,\"324\":1}}],[\"inserting\",{\"1\":{\"275\":3,\"323\":1,\"324\":2}}],[\"insert\",{\"0\":{\"276\":1},\"1\":{\"182\":2,\"275\":7,\"276\":3,\"277\":3,\"280\":4,\"307\":1,\"312\":7,\"320\":1,\"324\":8,\"325\":1,\"334\":1,\"365\":1,\"367\":1,\"463\":1}}],[\"instance\",{\"0\":{\"75\":1},\"1\":{\"43\":1,\"508\":2}}],[\"install\",{\"1\":{\"26\":4,\"28\":1,\"30\":1,\"43\":1}}],[\"inc\",{\"0\":{\"312\":1},\"1\":{\"308\":1,\"312\":8}}],[\"increment\",{\"1\":{\"182\":1,\"183\":1,\"274\":1,\"288\":1,\"312\":4}}],[\"include\",{\"1\":{\"32\":1}}],[\"in\",{\"1\":{\"139\":2,\"152\":1,\"194\":1,\"228\":1,\"275\":3,\"283\":1,\"290\":1,\"293\":2,\"294\":2,\"297\":1,\"298\":1,\"311\":1,\"313\":1,\"323\":1,\"324\":1,\"330\":1,\"367\":1,\"426\":2,\"428\":1,\"430\":1}}],[\"integer\",{\"1\":{\"462\":3,\"508\":2}}],[\"intent\",{\"1\":{\"275\":1,\"324\":1}}],[\"intention\",{\"1\":{\"275\":2,\"277\":1,\"324\":3}}],[\"interview\",{\"0\":{\"542\":1,\"556\":1}}],[\"interval\",{\"1\":{\"43\":1,\"182\":3}}],[\"interfaces1\",{\"1\":{\"499\":1}}],[\"interfaces\",{\"1\":{\"499\":1}}],[\"interface\",{\"1\":{\"43\":1,\"490\":2,\"507\":1,\"508\":1}}],[\"into\",{\"1\":{\"182\":2,\"275\":2,\"277\":1,\"324\":2,\"325\":1,\"367\":1}}],[\"int\",{\"1\":{\"43\":1,\"161\":3,\"182\":1,\"183\":2,\"204\":1,\"216\":2,\"238\":2,\"274\":2,\"288\":1,\"319\":3}}],[\"index\",{\"0\":{\"555\":1},\"1\":{\"32\":1,\"38\":6,\"40\":1,\"42\":4,\"145\":1,\"149\":1,\"170\":1,\"204\":1,\"210\":1,\"211\":6,\"212\":7,\"213\":3,\"215\":2,\"217\":2,\"228\":4,\"231\":1,\"232\":3,\"235\":1,\"239\":1,\"240\":1,\"275\":5,\"280\":1,\"296\":6,\"297\":3,\"304\":1,\"322\":1,\"324\":2,\"330\":2,\"331\":2,\"426\":2,\"428\":1,\"430\":1}}],[\"新的问题来了\",{\"1\":{\"408\":1}}],[\"新master\",{\"1\":{\"394\":2}}],[\"新增\",{\"1\":{\"334\":2}}],[\"新记录的插入\",{\"1\":{\"297\":1}}],[\"新记录的\",{\"1\":{\"297\":4}}],[\"新记录的语句\",{\"1\":{\"297\":1}}],[\"新记录时\",{\"1\":{\"296\":2}}],[\"新记录\",{\"1\":{\"296\":1}}],[\"新节点可以放在任何位置\",{\"1\":{\"250\":1}}],[\"新建文件\",{\"1\":{\"436\":1}}],[\"新建一个common\",{\"1\":{\"442\":1}}],[\"新建一个hello\",{\"1\":{\"422\":1}}],[\"新建一张空白画布\",{\"1\":{\"72\":1}}],[\"新建>软件>uml图>+\",{\"1\":{\"72\":1}}],[\"新建分支\",{\"1\":{\"15\":1}}],[\"新模块提交测试\",{\"1\":{\"15\":1}}],[\"ai\",{\"0\":{\"550\":1}}],[\"air系列果绿色\",{\"1\":{\"436\":1,\"439\":1}}],[\"air\",{\"1\":{\"436\":1,\"439\":1}}],[\"about\",{\"0\":{\"545\":1}}],[\"aborts\",{\"1\":{\"330\":1}}],[\"abc\",{\"1\":{\"520\":2,\"521\":1,\"522\":1}}],[\"a方面的事情\",{\"1\":{\"507\":1}}],[\"a方面有事找李秘书巴拉巴拉\",{\"1\":{\"506\":1}}],[\"ajax查询数据\",{\"1\":{\"414\":1}}],[\"afterpropertiesset\",{\"1\":{\"448\":1,\"463\":1}}],[\"after\",{\"1\":{\"393\":1,\"463\":4}}],[\"affected\",{\"1\":{\"139\":1,\"277\":2,\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"298\":1,\"322\":2,\"323\":2,\"367\":5}}],[\"affinity\",{\"1\":{\"47\":2}}],[\"aof原本有三个命令\",{\"1\":{\"379\":1}}],[\"aof原理\",{\"0\":{\"377\":1}}],[\"aof文件体积最小多大以上才触发重写\",{\"1\":{\"379\":1}}],[\"aof文件比上次文件\",{\"1\":{\"379\":1}}],[\"aof文件内容就是\",{\"1\":{\"379\":1}}],[\"aof文件会比rdb文件大的多\",{\"1\":{\"379\":1}}],[\"aof文件重写\",{\"0\":{\"379\":1}}],[\"aof文件的名称\",{\"1\":{\"378\":1}}],[\"aof的命令记录的频率也可以通过redis\",{\"1\":{\"378\":1}}],[\"aof\",{\"1\":{\"378\":1,\"379\":2}}],[\"aof默认是关闭的\",{\"1\":{\"378\":1}}],[\"aof配置\",{\"0\":{\"378\":1}}],[\"aof全称为append\",{\"1\":{\"377\":1}}],[\"aof持久化\",{\"0\":{\"376\":1},\"1\":{\"371\":1}}],[\"a的\",{\"1\":{\"329\":1}}],[\"atguigu\",{\"1\":{\"488\":1}}],[\"atomicity\",{\"1\":{\"334\":1,\"352\":1}}],[\"attempt\",{\"1\":{\"275\":1,\"324\":1}}],[\"at\",{\"1\":{\"275\":1,\"302\":1,\"324\":1,\"338\":6,\"347\":2,\"348\":1,\"349\":1,\"363\":1}}],[\"annotations\",{\"1\":{\"499\":1}}],[\"annotation\",{\"1\":{\"419\":2,\"448\":1,\"462\":6,\"463\":3,\"490\":1,\"499\":1}}],[\"an\",{\"1\":{\"275\":1,\"324\":1}}],[\"another\",{\"1\":{\"275\":1,\"323\":1}}],[\"and\",{\"1\":{\"145\":1,\"149\":1,\"194\":1,\"215\":5,\"216\":11,\"217\":1,\"239\":6,\"275\":5,\"323\":2,\"324\":3,\"330\":1}}],[\"args\",{\"1\":{\"441\":1,\"442\":3,\"450\":3,\"507\":3}}],[\"argumentn\",{\"1\":{\"428\":1}}],[\"argument2\",{\"1\":{\"428\":1}}],[\"argument1\",{\"1\":{\"428\":1}}],[\"arraylist<>\",{\"1\":{\"520\":1}}],[\"arr\",{\"1\":{\"425\":2,\"426\":2,\"428\":2,\"430\":3}}],[\"articles\",{\"1\":{\"350\":1}}],[\"article\",{\"1\":{\"350\":1}}],[\"artifactid>\",{\"1\":{\"396\":1,\"448\":1,\"460\":1}}],[\"artifact\",{\"0\":{\"76\":1},\"1\":{\"76\":1}}],[\"are\",{\"1\":{\"275\":4,\"323\":1,\"324\":3,\"330\":1}}],[\"avl\",{\"1\":{\"251\":1}}],[\"a>=\",{\"1\":{\"216\":2}}],[\"a=1\",{\"1\":{\"215\":3,\"239\":3,\"441\":1}}],[\"a=`ps\",{\"1\":{\"43\":1}}],[\"ahead\",{\"1\":{\"179\":1,\"337\":1}}],[\"asc\",{\"1\":{\"219\":1}}],[\"ascii\",{\"1\":{\"161\":2,\"165\":1,\"166\":6,\"169\":1}}],[\"as\",{\"1\":{\"182\":6,\"238\":2}}],[\"association\",{\"0\":{\"77\":1}}],[\"age=21\",{\"1\":{\"425\":1,\"426\":1}}],[\"age列\",{\"1\":{\"296\":2}}],[\"age`\",{\"1\":{\"288\":1}}],[\"age字段的值是\",{\"1\":{\"216\":1}}],[\"age\",{\"1\":{\"149\":7,\"161\":1,\"162\":2,\"216\":11,\"240\":4,\"288\":1,\"290\":1,\"293\":2,\"294\":2,\"296\":38,\"297\":52,\"298\":23,\"304\":17,\"324\":1,\"325\":1,\"367\":1,\"443\":2}}],[\"agent\",{\"1\":{\"32\":1}}],[\"alarm\",{\"1\":{\"508\":1}}],[\"alarmpassstrategy\",{\"1\":{\"508\":2}}],[\"alibaba\",{\"1\":{\"458\":1}}],[\"aliyun\",{\"1\":{\"350\":1}}],[\"always\",{\"1\":{\"378\":1}}],[\"alter\",{\"1\":{\"236\":1,\"307\":1}}],[\"all\",{\"1\":{\"145\":1,\"148\":3,\"228\":3,\"231\":1,\"237\":1,\"238\":1,\"261\":1,\"408\":1}}],[\"allow\",{\"1\":{\"32\":1}}],[\"alexandre\",{\"1\":{\"43\":1}}],[\"actualtypearguments\",{\"1\":{\"499\":3}}],[\"acid\",{\"1\":{\"334\":1}}],[\"ace\",{\"1\":{\"325\":1}}],[\"acassen\",{\"1\":{\"43\":1}}],[\"access\",{\"1\":{\"32\":3,\"139\":1}}],[\"accept\",{\"1\":{\"32\":2}}],[\"autowired\",{\"1\":{\"419\":4,\"448\":4,\"463\":7}}],[\"autocommit\",{\"1\":{\"313\":1,\"334\":1}}],[\"autoinc\",{\"1\":{\"312\":7}}],[\"autoindex\",{\"1\":{\"42\":1}}],[\"auto\",{\"0\":{\"312\":1},\"1\":{\"182\":1,\"183\":1,\"274\":1,\"288\":1,\"308\":1,\"312\":12,\"379\":2,\"462\":1}}],[\"author\",{\"0\":{\"544\":1}}],[\"authority\",{\"1\":{\"108\":2}}],[\"auth\",{\"1\":{\"43\":2}}],[\"authentication\",{\"1\":{\"43\":1}}],[\"aux|grep\",{\"1\":{\"31\":1}}],[\"api取得任何类的内部信息\",{\"1\":{\"480\":1}}],[\"api\",{\"1\":{\"435\":4,\"439\":2}}],[\"appendfsync\",{\"1\":{\"378\":3}}],[\"appendfilename\",{\"1\":{\"378\":1}}],[\"appendonly\",{\"1\":{\"378\":2,\"448\":1}}],[\"app\",{\"1\":{\"91\":1}}],[\"application\",{\"1\":{\"32\":1,\"435\":1,\"439\":1}}],[\"apache\",{\"1\":{\"34\":1}}],[\"advance\",{\"0\":{\"548\":1}}],[\"advert\",{\"1\":{\"43\":1}}],[\"adaptive\",{\"1\":{\"170\":1}}],[\"administrators\",{\"1\":{\"32\":1}}],[\"administrator\",{\"1\":{\"32\":1}}],[\"addr\",{\"1\":{\"32\":1}}],[\"add\",{\"1\":{\"15\":1,\"182\":3,\"236\":1,\"407\":1}}],[\"a\",{\"1\":{\"15\":1,\"28\":1,\"43\":1,\"56\":1,\"58\":2,\"161\":1,\"197\":1,\"215\":11,\"216\":46,\"217\":3,\"239\":8,\"252\":3,\"275\":12,\"277\":4,\"280\":8,\"290\":7,\"291\":4,\"293\":9,\"294\":16,\"296\":8,\"297\":8,\"298\":3,\"302\":4,\"303\":1,\"304\":8,\"306\":1,\"310\":2,\"312\":3,\"317\":4,\"320\":1,\"322\":5,\"323\":3,\"324\":8,\"325\":2,\"329\":1,\"330\":6,\"346\":4,\"352\":6,\"354\":6,\"355\":3,\"356\":3,\"357\":11,\"359\":14,\"360\":7,\"363\":4,\"364\":1,\"365\":5,\"367\":10,\"368\":2,\"369\":2,\"402\":1}}],[\"需求\",{\"0\":{\"418\":1},\"1\":{\"405\":1,\"430\":1}}],[\"需求分析\",{\"0\":{\"405\":1}}],[\"需求原型\",{\"1\":{\"76\":1}}],[\"需要使用被代理类的对象进行赋值\",{\"1\":{\"507\":1}}],[\"需要使用中序遍历\",{\"1\":{\"252\":1}}],[\"需要确保windows防火墙处于关闭状态\",{\"1\":{\"441\":1}}],[\"需要在nginx\",{\"1\":{\"435\":1}}],[\"需要在集群间共享\",{\"1\":{\"416\":1}}],[\"需要在二级索引索引上加范围\",{\"1\":{\"297\":1}}],[\"需要同步\",{\"1\":{\"386\":1}}],[\"需要更新\",{\"1\":{\"384\":1}}],[\"需要修改redis\",{\"1\":{\"378\":1}}],[\"需要判断\",{\"1\":{\"358\":1}}],[\"需要判断插入位置是否已被其他事务加了间隙锁\",{\"1\":{\"317\":1}}],[\"需要的\",{\"1\":{\"337\":1}}],[\"需要记录对应的\",{\"1\":{\"337\":1,\"343\":1,\"350\":1}}],[\"需要记录对应\",{\"1\":{\"337\":1}}],[\"需要记录的内容也是不同的\",{\"1\":{\"334\":1}}],[\"需要把被更新的列的旧值记下来\",{\"1\":{\"336\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"需要先对表加上\",{\"1\":{\"311\":1}}],[\"需要先在表级别加上一个\",{\"1\":{\"311\":2}}],[\"需要先定位到该记录在\",{\"1\":{\"296\":1}}],[\"需要先将脏页同步到磁盘\",{\"1\":{\"179\":1}}],[\"需要先将官网下载的源码进行编译\",{\"1\":{\"26\":1}}],[\"需要等待其它事务释放间隙锁之后\",{\"1\":{\"275\":1}}],[\"需要去聚簇索引中获得数据行\",{\"1\":{\"245\":1,\"246\":1}}],[\"需要说明的是\",{\"1\":{\"228\":1}}],[\"需要占用物理空间\",{\"1\":{\"220\":1}}],[\"需要再加\",{\"1\":{\"216\":1}}],[\"需要注意的是\",{\"1\":{\"187\":1,\"215\":1,\"239\":1,\"275\":1,\"309\":1,\"440\":1}}],[\"需要将\",{\"1\":{\"349\":1}}],[\"需要将这个元素之后的所有元素后移一位\",{\"1\":{\"250\":1}}],[\"需要将一个页的记录移动到另外一个页\",{\"1\":{\"226\":1}}],[\"需要将一部分数据页淘汰掉\",{\"1\":{\"179\":1}}],[\"需要将流程放在同一高度\",{\"1\":{\"57\":1}}],[\"需要用多少字节表示\",{\"1\":{\"166\":1}}],[\"需要用一种方法来表示这种需求\",{\"1\":{\"89\":1}}],[\"需要减去这两个列表所占用的字节数\",{\"1\":{\"169\":1}}],[\"需要减去\",{\"1\":{\"166\":3}}],[\"需要变态\",{\"1\":{\"130\":1}}],[\"需要依赖其他的类\",{\"1\":{\"66\":1}}],[\"需要反复试算修改\",{\"1\":{\"58\":1}}],[\"需要牢记\",{\"1\":{\"55\":1}}],[\"需要哪些设计图\",{\"1\":{\"52\":1}}],[\"需要两台服务器192\",{\"1\":{\"43\":1}}],[\"需要上线\",{\"1\":{\"15\":1}}],[\"需建立分支并且提交代码\",{\"1\":{\"15\":1}}],[\"d+\",{\"1\":{\"439\":1}}],[\"duration\",{\"1\":{\"416\":1}}],[\"durability\",{\"1\":{\"352\":1}}],[\"during\",{\"1\":{\"139\":1}}],[\"dump\",{\"1\":{\"342\":2,\"373\":1}}],[\"drop\",{\"1\":{\"307\":1}}],[\"drawio\",{\"1\":{\"91\":1}}],[\"draw\",{\"1\":{\"91\":1}}],[\"date`\",{\"1\":{\"274\":1}}],[\"date\",{\"1\":{\"182\":3,\"275\":1,\"277\":1,\"462\":3}}],[\"datetime\",{\"1\":{\"182\":2,\"183\":2,\"274\":1}}],[\"data函数\",{\"1\":{\"454\":1}}],[\"data查询函数\",{\"1\":{\"454\":1}}],[\"databind\",{\"1\":{\"448\":1,\"463\":1}}],[\"database\",{\"1\":{\"152\":4,\"372\":1}}],[\"datadir\",{\"1\":{\"152\":2}}],[\"data\",{\"0\":{\"561\":1},\"1\":{\"42\":4,\"184\":1,\"275\":3,\"277\":2,\"279\":2,\"280\":4,\"290\":1,\"291\":3,\"293\":2,\"294\":3,\"296\":12,\"297\":4,\"304\":5,\"321\":1,\"322\":3,\"323\":1,\"324\":1,\"325\":1,\"396\":1,\"448\":2,\"451\":4,\"454\":4,\"462\":4,\"463\":1}}],[\"dict\",{\"1\":{\"453\":1}}],[\"dict的功能\",{\"1\":{\"453\":1}}],[\"diskless\",{\"1\":{\"387\":1}}],[\"directbytebuffer其构造函数使用了cleaner类\",{\"1\":{\"522\":1}}],[\"dir\",{\"1\":{\"373\":1}}],[\"dirty\",{\"1\":{\"178\":1,\"353\":1}}],[\"different\",{\"1\":{\"302\":2,\"363\":2}}],[\"difference\",{\"1\":{\"194\":1,\"275\":1,\"323\":1}}],[\"diagrams\",{\"1\":{\"91\":1}}],[\"dynamic\",{\"1\":{\"158\":3,\"168\":1,\"169\":1,\"204\":1}}],[\"dynamic和\",{\"1\":{\"158\":1}}],[\"dbfilename\",{\"1\":{\"373\":1}}],[\"db\",{\"1\":{\"152\":2}}],[\"dos\",{\"1\":{\"473\":1}}],[\"docker\",{\"1\":{\"448\":1}}],[\"done\",{\"1\":{\"408\":1}}],[\"down\",{\"1\":{\"393\":1}}],[\"download\",{\"1\":{\"28\":2}}],[\"do\",{\"1\":{\"275\":2,\"323\":1,\"324\":1,\"330\":1,\"426\":2,\"428\":1,\"430\":1}}],[\"does\",{\"1\":{\"275\":1,\"323\":1}}],[\"doesn\",{\"1\":{\"144\":1}}],[\"doublewrite\",{\"1\":{\"170\":1}}],[\"dns主机名等\",{\"1\":{\"108\":1}}],[\"dns\",{\"1\":{\"108\":1}}],[\"deal\",{\"1\":{\"507\":3}}],[\"deadlock\",{\"1\":{\"281\":1}}],[\"destination\",{\"1\":{\"461\":1}}],[\"desktop\",{\"1\":{\"91\":1}}],[\"declaredconstructors\",{\"1\":{\"499\":1}}],[\"declaredmethods\",{\"1\":{\"499\":1}}],[\"declaredfields\",{\"1\":{\"499\":1}}],[\"declared\",{\"1\":{\"498\":1}}],[\"decode\",{\"1\":{\"443\":1,\"444\":2,\"451\":2,\"454\":2}}],[\"decimal\",{\"1\":{\"204\":1}}],[\"dependency>\",{\"1\":{\"396\":1,\"448\":1,\"460\":1}}],[\"delay=\",{\"1\":{\"348\":1}}],[\"delay\",{\"1\":{\"348\":4,\"349\":2}}],[\"deleteitembyid\",{\"1\":{\"463\":2}}],[\"delete\",{\"1\":{\"163\":2,\"283\":2,\"299\":2,\"300\":1,\"304\":1,\"305\":1,\"307\":1,\"330\":5,\"334\":1,\"365\":2,\"463\":2}}],[\"detect\",{\"1\":{\"281\":1}}],[\"detele\",{\"1\":{\"163\":1}}],[\"demand\",{\"1\":{\"140\":1}}],[\"denied\",{\"1\":{\"139\":1}}],[\"deny\",{\"1\":{\"32\":1}}],[\"defs\",{\"1\":{\"43\":1}}],[\"defaultmap\",{\"1\":{\"508\":1}}],[\"defaultgf\",{\"1\":{\"416\":4}}],[\"default\",{\"1\":{\"32\":1,\"161\":4,\"166\":1,\"204\":3,\"274\":2,\"288\":1,\"319\":5,\"330\":1,\"435\":1,\"439\":1}}],[\"dev\",{\"1\":{\"32\":1}}],[\"devel这字段在\",{\"1\":{\"43\":1}}],[\"devel\",{\"1\":{\"26\":4,\"43\":1}}],[\"developer\",{\"1\":{\"350\":1}}],[\"develop合并入master\",{\"1\":{\"10\":1}}],[\"develop则是最新的开发进度\",{\"1\":{\"7\":1}}],[\"develop\",{\"1\":{\"6\":1,\"7\":3,\"15\":7}}],[\"debug|info|notice|warn|error|crit|alert|emerg\",{\"1\":{\"32\":1}}],[\"debug\",{\"1\":{\"32\":1}}],[\"d\",{\"1\":{\"15\":3,\"58\":2,\"207\":3,\"304\":1,\"448\":1}}],[\"m这个table类型的变量中\",{\"1\":{\"442\":1}}],[\"mkdir\",{\"1\":{\"406\":1}}],[\"mb\",{\"1\":{\"337\":1}}],[\"mdl\",{\"1\":{\"308\":1,\"310\":22}}],[\"md5\",{\"1\":{\"108\":1}}],[\"m个\",{\"1\":{\"252\":1}}],[\"m=3\",{\"1\":{\"251\":1}}],[\"m>2\",{\"1\":{\"251\":1,\"252\":1}}],[\"moreinformation\",{\"1\":{\"508\":3}}],[\"mobilecms\",{\"1\":{\"436\":1,\"439\":1}}],[\"monthly\",{\"1\":{\"281\":1,\"350\":1}}],[\"monster~\",{\"1\":{\"152\":1}}],[\"monster\",{\"1\":{\"49\":1,\"487\":1}}],[\"mode\",{\"1\":{\"275\":6,\"277\":1,\"279\":1,\"280\":2,\"283\":1,\"290\":4,\"291\":1,\"296\":1,\"304\":4,\"311\":1,\"312\":7,\"313\":1,\"322\":5,\"324\":1}}],[\"modified\",{\"1\":{\"182\":3,\"183\":1}}],[\"mset\",{\"1\":{\"379\":1}}],[\"ms\",{\"1\":{\"178\":1}}],[\"mvcc实现的\",{\"1\":{\"272\":1}}],[\"mvcc\",{\"0\":{\"358\":1},\"1\":{\"157\":1,\"164\":3,\"197\":1,\"232\":1,\"275\":1,\"283\":1,\"302\":1,\"307\":1,\"311\":1,\"333\":1,\"334\":4,\"352\":1,\"357\":2,\"358\":1,\"361\":3,\"362\":1,\"364\":1,\"367\":1,\"369\":2}}],[\"methods\",{\"1\":{\"499\":1}}],[\"method\",{\"1\":{\"441\":1,\"442\":1,\"450\":1,\"499\":2,\"502\":2,\"507\":4,\"508\":4}}],[\"meta\",{\"1\":{\"197\":1}}],[\"mengxinj\",{\"1\":{\"350\":1}}],[\"means\",{\"1\":{\"275\":1,\"323\":1}}],[\"me\",{\"1\":{\"150\":1}}],[\"memory\",{\"1\":{\"138\":1,\"202\":1,\"204\":1}}],[\"merge\",{\"1\":{\"15\":5,\"240\":2}}],[\"milliseconds\",{\"1\":{\"393\":1}}],[\"min\",{\"1\":{\"358\":3,\"359\":4,\"360\":4,\"379\":1}}],[\"mindmanager\",{\"1\":{\"91\":1}}],[\"mixed\",{\"1\":{\"341\":2}}],[\"mime\",{\"1\":{\"32\":1}}],[\"myinvocationhandler\",{\"1\":{\"507\":3}}],[\"myisam一样\",{\"1\":{\"197\":1}}],[\"myisam\",{\"1\":{\"138\":1,\"197\":5,\"202\":1,\"204\":1,\"234\":5,\"283\":1,\"307\":1,\"313\":1,\"340\":2,\"352\":1}}],[\"mythread\",{\"1\":{\"506\":3}}],[\"mybatisplus\",{\"1\":{\"462\":4}}],[\"mymaster\",{\"1\":{\"397\":1}}],[\"my\",{\"1\":{\"152\":3,\"181\":1}}],[\"mysql主从同步的原理如下\",{\"1\":{\"458\":1}}],[\"mysql会在重启后通过\",{\"1\":{\"348\":1}}],[\"mysql提供一个\",{\"1\":{\"343\":1}}],[\"mysql实战45讲\",{\"1\":{\"317\":1}}],[\"mysqldump\",{\"1\":{\"307\":2}}],[\"mysql默认为innodb引擎\",{\"1\":{\"272\":1}}],[\"mysql可分为连接层\",{\"1\":{\"272\":1}}],[\"mysql45讲的时候\",{\"1\":{\"238\":1}}],[\"mysql技术内幕\",{\"1\":{\"169\":1,\"317\":1}}],[\"mysql5\",{\"1\":{\"158\":1}}],[\"mysql56\",{\"1\":{\"150\":1}}],[\"mysql是怎样运行的\",{\"1\":{\"150\":1}}],[\"mysql>\",{\"1\":{\"139\":3,\"144\":1,\"152\":1,\"277\":4,\"290\":2,\"291\":2,\"293\":4,\"294\":4,\"296\":2,\"297\":2,\"298\":2,\"322\":2,\"323\":2,\"324\":1,\"325\":1,\"367\":7}}],[\"mysql服务\",{\"1\":{\"139\":1}}],[\"mysql\",{\"0\":{\"138\":1,\"151\":1,\"152\":1,\"168\":1,\"181\":1,\"207\":1,\"230\":1,\"247\":1,\"257\":1,\"273\":1,\"282\":1,\"288\":1,\"301\":1,\"306\":1,\"333\":1,\"349\":1,\"362\":1},\"1\":{\"96\":8,\"137\":4,\"138\":6,\"139\":27,\"140\":7,\"141\":1,\"142\":5,\"144\":8,\"146\":2,\"149\":2,\"150\":4,\"151\":6,\"152\":12,\"158\":3,\"165\":1,\"168\":1,\"169\":6,\"171\":1,\"172\":1,\"173\":1,\"174\":2,\"176\":1,\"178\":7,\"179\":4,\"181\":1,\"182\":2,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"192\":1,\"194\":3,\"201\":3,\"202\":3,\"204\":5,\"207\":2,\"216\":3,\"217\":2,\"218\":1,\"219\":1,\"222\":1,\"228\":1,\"232\":2,\"234\":5,\"236\":2,\"237\":1,\"238\":7,\"239\":2,\"241\":1,\"242\":1,\"243\":1,\"247\":2,\"248\":3,\"253\":1,\"255\":1,\"257\":1,\"258\":6,\"275\":3,\"277\":1,\"279\":1,\"280\":1,\"281\":2,\"282\":5,\"283\":1,\"285\":2,\"288\":1,\"297\":1,\"300\":3,\"301\":1,\"302\":3,\"303\":3,\"305\":1,\"306\":2,\"308\":2,\"312\":1,\"314\":2,\"317\":1,\"318\":2,\"320\":1,\"324\":1,\"330\":2,\"331\":1,\"333\":2,\"334\":5,\"335\":1,\"336\":2,\"337\":8,\"338\":4,\"339\":3,\"340\":5,\"341\":1,\"342\":11,\"343\":2,\"344\":4,\"345\":4,\"346\":6,\"347\":1,\"348\":7,\"349\":2,\"350\":4,\"351\":1,\"352\":3,\"353\":2,\"357\":6,\"359\":1,\"361\":2,\"362\":1,\"363\":1,\"365\":1,\"367\":1,\"369\":2,\"458\":3}}],[\"mysql介绍\",{\"0\":{\"96\":1}}],[\"mysvr\",{\"1\":{\"32\":2}}],[\"myformat\",{\"1\":{\"32\":2}}],[\"must\",{\"1\":{\"330\":2}}],[\"multiple\",{\"1\":{\"275\":1,\"324\":1}}],[\"multi\",{\"1\":{\"32\":1}}],[\"mutex\",{\"1\":{\"32\":1,\"347\":1}}],[\"mark\",{\"1\":{\"526\":2}}],[\"mattertype\",{\"1\":{\"508\":3}}],[\"matched\",{\"1\":{\"322\":1,\"323\":1,\"367\":1}}],[\"main\",{\"1\":{\"506\":1,\"507\":1}}],[\"map<string\",{\"1\":{\"508\":2}}],[\"map接口\",{\"0\":{\"470\":1}}],[\"mapper\",{\"1\":{\"448\":3,\"463\":4}}],[\"map\",{\"1\":{\"425\":3,\"426\":2}}],[\"manes\",{\"1\":{\"416\":1}}],[\"many\",{\"1\":{\"139\":1}}],[\"mask\",{\"1\":{\"163\":2}}],[\"master之间通过ping监测彼此健康状态\",{\"1\":{\"400\":1}}],[\"master不可用才读取replica\",{\"1\":{\"398\":1}}],[\"master获取repl\",{\"1\":{\"388\":1}}],[\"master的offset逐渐变大\",{\"1\":{\"386\":1}}],[\"master的作用\",{\"0\":{\"14\":1}}],[\"master怎么知道slave与自己的数据差异在哪里呢\",{\"1\":{\"386\":1}}],[\"master将rdb期间的命令记录在repl\",{\"1\":{\"384\":1}}],[\"master将完整内存数据生成rdb\",{\"1\":{\"384\":1,\"388\":1}}],[\"master节点判断replid\",{\"1\":{\"384\":1}}],[\"master判断一个节点是否是第一次同步的依据\",{\"1\":{\"384\":1}}],[\"master判断发现slave发送来的replid与自己的不一致\",{\"1\":{\"384\":1}}],[\"master会将自己的replid和offset都发送给这个slave\",{\"1\":{\"384\":1}}],[\"master才可以判断到底需要同步哪些数据\",{\"1\":{\"384\":1}}],[\"master如何得知salve是第一次来连接呢\",{\"1\":{\"384\":1}}],[\"master只是用于保存官方的发布历史\",{\"1\":{\"14\":1}}],[\"master此时最新代码对应版本为master\",{\"1\":{\"7\":1}}],[\"master分支上最新版本为3\",{\"1\":{\"7\":1}}],[\"master分支上的最新代码永远是版本发布状态\",{\"1\":{\"7\":1}}],[\"master\",{\"0\":{\"46\":1},\"1\":{\"6\":1,\"7\":2,\"15\":4,\"44\":3,\"45\":1,\"46\":1,\"397\":1,\"398\":2,\"458\":2}}],[\"mac\",{\"1\":{\"108\":1}}],[\"maximumsize\",{\"1\":{\"416\":1,\"419\":2}}],[\"max\",{\"1\":{\"32\":1,\"139\":3,\"358\":3,\"359\":2,\"360\":2,\"450\":4}}],[\"makes\",{\"1\":{\"330\":1}}],[\"make\",{\"1\":{\"30\":2}}],[\"m\",{\"1\":{\"15\":1,\"90\":1,\"180\":1,\"187\":1,\"251\":3,\"252\":5,\"255\":2,\"358\":4,\"359\":2,\"360\":2,\"436\":1,\"439\":1,\"442\":3,\"450\":4}}],[\"cjson\",{\"1\":{\"443\":5,\"444\":5,\"451\":5,\"454\":5}}],[\"cjson工具类\",{\"0\":{\"443\":1}}],[\"c模块\",{\"1\":{\"435\":1}}],[\"cpath\",{\"1\":{\"435\":1}}],[\"cp\",{\"1\":{\"406\":1}}],[\"cpu就会去执行另一个线程中的代码\",{\"1\":{\"539\":1}}],[\"cpu会为每个线程分配时间片\",{\"1\":{\"539\":1}}],[\"cpu\",{\"1\":{\"47\":6,\"161\":3,\"516\":1,\"538\":1}}],[\"creator\",{\"1\":{\"358\":1}}],[\"createtime\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"create\",{\"1\":{\"161\":1,\"166\":1,\"182\":4,\"183\":2,\"204\":1,\"210\":1,\"211\":2,\"212\":2,\"213\":2,\"215\":1,\"219\":5,\"274\":1,\"275\":1,\"277\":1,\"288\":1,\"319\":1}}],[\"crash\",{\"1\":{\"337\":2,\"340\":3}}],[\"crud\",{\"1\":{\"310\":4}}],[\"c=3\",{\"1\":{\"215\":3,\"239\":3}}],[\"ci\",{\"1\":{\"204\":1,\"288\":2}}],[\"cnblogs\",{\"1\":{\"350\":2}}],[\"cn\",{\"1\":{\"110\":1,\"432\":1}}],[\"cfo\",{\"1\":{\"109\":1}}],[\"cto\",{\"1\":{\"109\":3}}],[\"capacity\",{\"1\":{\"474\":1}}],[\"capture来实现查询tomcat\",{\"1\":{\"442\":1}}],[\"capture\",{\"1\":{\"441\":1,\"442\":2,\"450\":1}}],[\"category\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"catch\",{\"1\":{\"330\":1,\"463\":1,\"508\":1}}],[\"caffeineconfig\",{\"1\":{\"419\":1}}],[\"caffeine不会自动立即将其清理和驱逐\",{\"1\":{\"416\":1}}],[\"caffeine提供了三种缓存驱逐策略\",{\"1\":{\"416\":1}}],[\"caffeine既然是缓存的一种\",{\"1\":{\"416\":1}}],[\"caffeine的性能非常好\",{\"1\":{\"416\":1}}],[\"caffeine\",{\"1\":{\"416\":4,\"419\":5,\"463\":1}}],[\"caffeine是一个基于java8开发的\",{\"1\":{\"416\":1}}],[\"cach\",{\"1\":{\"343\":1}}],[\"cache<long\",{\"1\":{\"419\":4,\"463\":1}}],[\"cache<string\",{\"1\":{\"416\":3}}],[\"cache\",{\"1\":{\"140\":2,\"161\":3,\"338\":5,\"343\":12,\"347\":2,\"348\":3,\"349\":3,\"350\":1,\"416\":6,\"419\":3,\"453\":6,\"454\":8,\"463\":2}}],[\"called\",{\"1\":{\"302\":1,\"363\":1}}],[\"canaltable\",{\"1\":{\"463\":3}}],[\"canal服务地址\",{\"1\":{\"461\":1}}],[\"canal的集群名字\",{\"1\":{\"461\":1}}],[\"canal提供了各种语言的客户端\",{\"1\":{\"459\":1}}],[\"canal是基于mysql的主从同步来实现的\",{\"1\":{\"458\":1}}],[\"canal是阿里巴巴旗下的一款开源项目\",{\"1\":{\"458\":1}}],[\"canal\",{\"1\":{\"458\":2,\"459\":1,\"461\":1,\"463\":3}}],[\"canal监听mysql变化\",{\"1\":{\"456\":1}}],[\"can\",{\"1\":{\"275\":1,\"323\":1}}],[\"cast\",{\"1\":{\"182\":3,\"238\":4,\"241\":1}}],[\"cassen\",{\"1\":{\"43\":1}}],[\"ca\",{\"1\":{\"108\":18,\"109\":16}}],[\"ceo\",{\"1\":{\"109\":1}}],[\"certificate\",{\"1\":{\"108\":2}}],[\"centos\",{\"1\":{\"26\":2}}],[\"centos7默认已经安装了lua语言环境\",{\"1\":{\"422\":1}}],[\"centos7\",{\"1\":{\"25\":1}}],[\"clear\",{\"1\":{\"508\":1}}],[\"cleaner\",{\"1\":{\"522\":1}}],[\"clean\",{\"1\":{\"178\":1}}],[\"close\",{\"1\":{\"450\":4}}],[\"cluster\",{\"1\":{\"407\":2,\"412\":1,\"447\":2}}],[\"cluster提供了很多操作集群的命令\",{\"1\":{\"404\":1}}],[\"cli连接7002这个节点\",{\"1\":{\"411\":1}}],[\"cli\",{\"1\":{\"404\":1,\"407\":2,\"410\":1}}],[\"clientconfigurationbuilder\",{\"1\":{\"398\":2}}],[\"clientconfigurationbuildercustomizer\",{\"1\":{\"398\":1}}],[\"client\",{\"1\":{\"107\":4,\"108\":13,\"109\":3,\"459\":1,\"463\":2}}],[\"clazz\",{\"1\":{\"498\":2,\"499\":14,\"501\":3,\"502\":4,\"503\":2,\"508\":9}}],[\"clazz4\",{\"1\":{\"488\":1}}],[\"clazz3\",{\"1\":{\"487\":1}}],[\"clazz2\",{\"1\":{\"486\":1}}],[\"clazz1\",{\"1\":{\"485\":1}}],[\"clause\",{\"1\":{\"330\":4}}],[\"class<person>\",{\"1\":{\"498\":1}}],[\"class不能被篡改\",{\"1\":{\"494\":1}}],[\"class对象\",{\"1\":{\"492\":1,\"493\":1}}],[\"class实例可以是哪些结构的说明\",{\"0\":{\"490\":1}}],[\"classloadertest\",{\"1\":{\"496\":1}}],[\"classloader加载过了\",{\"1\":{\"494\":1}}],[\"classloader\",{\"0\":{\"488\":1},\"1\":{\"488\":3,\"496\":3}}],[\"classpath\",{\"0\":{\"487\":1}}],[\"class文件时\",{\"1\":{\"494\":1}}],[\"class文件\",{\"1\":{\"483\":1}}],[\"class本身也是一个类\",{\"1\":{\"483\":1}}],[\"class结尾\",{\"1\":{\"483\":1}}],[\"class类的理解\",{\"0\":{\"483\":1}}],[\"class类\",{\"0\":{\"482\":1}}],[\"class\",{\"0\":{\"485\":1},\"1\":{\"34\":1,\"419\":2,\"448\":1,\"462\":1,\"463\":2,\"483\":1,\"485\":2,\"486\":1,\"487\":2,\"488\":2,\"490\":1,\"494\":1,\"496\":1,\"498\":1,\"499\":6,\"501\":2,\"502\":4,\"503\":3,\"506\":2,\"507\":4,\"508\":8,\"522\":1}}],[\"c是三个连续的步骤\",{\"1\":{\"56\":1}}],[\"chn\",{\"1\":{\"502\":2}}],[\"changed\",{\"1\":{\"322\":1,\"323\":1,\"367\":1}}],[\"change\",{\"1\":{\"170\":2,\"330\":1}}],[\"charset=utf8mb4\",{\"1\":{\"288\":1,\"319\":1}}],[\"character\",{\"1\":{\"161\":1,\"166\":1,\"204\":1}}],[\"char\",{\"1\":{\"161\":2,\"213\":1}}],[\"charles\",{\"1\":{\"108\":8,\"110\":1}}],[\"check\",{\"1\":{\"43\":2,\"339\":7}}],[\"checkout\",{\"1\":{\"15\":8}}],[\"chk\",{\"1\":{\"43\":1}}],[\"chunk\",{\"1\":{\"32\":1}}],[\"cd\",{\"1\":{\"31\":1}}],[\"copying\",{\"1\":{\"526\":1}}],[\"core\",{\"1\":{\"448\":2,\"463\":2}}],[\"coordinator\",{\"1\":{\"344\":1}}],[\"co\",{\"1\":{\"275\":1,\"323\":1}}],[\"collection接口\",{\"0\":{\"467\":1}}],[\"collate=utf8mb4\",{\"1\":{\"288\":1}}],[\"collate\",{\"1\":{\"204\":1,\"288\":1}}],[\"column1\",{\"1\":{\"266\":2}}],[\"column\",{\"1\":{\"210\":1,\"211\":4,\"212\":4,\"213\":3,\"218\":1,\"462\":3}}],[\"codes\",{\"1\":{\"110\":1}}],[\"count值\",{\"1\":{\"197\":1}}],[\"count\",{\"0\":{\"189\":2,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"198\":1},\"1\":{\"96\":2,\"189\":8,\"190\":1,\"191\":5,\"192\":7,\"193\":7,\"194\":12,\"195\":5,\"196\":7,\"197\":7,\"198\":2,\"227\":1,\"348\":2,\"349\":1}}],[\"content\",{\"1\":{\"435\":1,\"439\":1}}],[\"context\",{\"1\":{\"419\":2}}],[\"consistent\",{\"1\":{\"357\":2}}],[\"consistency\",{\"1\":{\"352\":1}}],[\"constructors\",{\"1\":{\"499\":1}}],[\"constructor\",{\"1\":{\"499\":2,\"503\":4}}],[\"const\",{\"1\":{\"147\":3,\"228\":4}}],[\"concat\",{\"1\":{\"182\":1}}],[\"condition\",{\"1\":{\"149\":1,\"217\":2,\"239\":1}}],[\"connection\",{\"0\":{\"48\":1},\"1\":{\"139\":5}}],[\"connections\",{\"1\":{\"32\":2,\"48\":4,\"49\":2,\"139\":4}}],[\"connect\",{\"1\":{\"43\":1,\"450\":2}}],[\"conf的http下添加配置\",{\"1\":{\"453\":1}}],[\"conf的server下面\",{\"1\":{\"435\":1}}],[\"conf中指定依赖库的目录\",{\"1\":{\"435\":1}}],[\"conf中配置\",{\"1\":{\"379\":1}}],[\"configuration\",{\"1\":{\"419\":2}}],[\"configure\",{\"1\":{\"30\":1}}],[\"config\",{\"1\":{\"419\":1,\"448\":1,\"463\":2}}],[\"conf文件\",{\"1\":{\"435\":2,\"442\":1,\"447\":1}}],[\"conf文件来配\",{\"1\":{\"378\":1}}],[\"conf文件中监听\",{\"1\":{\"439\":1}}],[\"conf文件中设置\",{\"1\":{\"373\":1}}],[\"conf文件中找到\",{\"1\":{\"373\":1}}],[\"conf配置文件来开启aof\",{\"1\":{\"378\":1}}],[\"conflict\",{\"1\":{\"275\":1,\"323\":1}}],[\"conf为\",{\"1\":{\"43\":1}}],[\"conf\",{\"1\":{\"43\":1,\"406\":3,\"435\":2,\"442\":1,\"447\":1}}],[\"computer\",{\"0\":{\"552\":1}}],[\"component\",{\"1\":{\"448\":2,\"463\":4}}],[\"compressed\",{\"1\":{\"158\":3,\"168\":1,\"169\":1}}],[\"compact\",{\"0\":{\"159\":1},\"1\":{\"158\":9,\"159\":1,\"161\":2,\"162\":1,\"166\":1,\"168\":2,\"169\":3,\"526\":1}}],[\"compatible\",{\"1\":{\"26\":1}}],[\"commonvo\",{\"1\":{\"508\":4}}],[\"common中获取read\",{\"1\":{\"442\":1}}],[\"common\",{\"1\":{\"442\":5,\"444\":3,\"450\":1,\"451\":8,\"454\":4}}],[\"comment\",{\"1\":{\"182\":6,\"183\":6}}],[\"command\",{\"1\":{\"139\":1}}],[\"committed\",{\"1\":{\"271\":1,\"357\":1}}],[\"commit\",{\"1\":{\"15\":1,\"275\":3,\"285\":1,\"314\":1,\"334\":1,\"338\":6,\"344\":5,\"345\":6,\"346\":1,\"347\":4,\"348\":15,\"349\":3,\"350\":3,\"367\":1}}],[\"com\",{\"1\":{\"32\":1,\"70\":1,\"91\":1,\"110\":2,\"350\":3,\"416\":1,\"419\":5,\"436\":1,\"439\":1,\"443\":1,\"448\":7,\"458\":1,\"459\":1,\"462\":5,\"463\":11,\"487\":1,\"488\":1}}],[\"combined为日志格式的默认值\",{\"1\":{\"32\":1}}],[\"c\",{\"1\":{\"28\":1,\"43\":2,\"58\":2,\"215\":4,\"239\":8,\"290\":1,\"304\":1,\"310\":4,\"480\":3}}],[\"c++\",{\"1\":{\"26\":1,\"480\":1}}],[\"flag\",{\"1\":{\"425\":1}}],[\"flush\",{\"1\":{\"177\":4,\"178\":1,\"180\":1,\"307\":1,\"338\":6,\"347\":2,\"348\":8,\"349\":1}}],[\"follower\",{\"1\":{\"348\":1}}],[\"forname\",{\"0\":{\"487\":1},\"1\":{\"487\":1}}],[\"fork子进程\",{\"1\":{\"375\":1}}],[\"fork主进程得到一个子进程\",{\"1\":{\"375\":1}}],[\"fork采用的是copy\",{\"1\":{\"374\":1}}],[\"force\",{\"1\":{\"330\":1,\"331\":1,\"411\":1}}],[\"form\",{\"1\":{\"142\":1}}],[\"format=statement\",{\"1\":{\"312\":1}}],[\"format\",{\"1\":{\"32\":1,\"158\":1,\"161\":1,\"166\":1,\"204\":1,\"312\":1}}],[\"for\",{\"1\":{\"32\":1,\"139\":1,\"273\":1,\"274\":2,\"275\":6,\"277\":1,\"280\":1,\"283\":1,\"285\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":1,\"297\":2,\"298\":1,\"299\":1,\"300\":1,\"302\":3,\"304\":2,\"305\":1,\"311\":1,\"313\":1,\"314\":1,\"324\":1,\"357\":2,\"361\":3,\"362\":2,\"363\":1,\"365\":2,\"368\":2,\"369\":2,\"426\":2,\"428\":1,\"430\":1,\"448\":2,\"463\":2}}],[\"forwarded\",{\"1\":{\"32\":1}}],[\"fsync\",{\"1\":{\"338\":2,\"343\":5,\"347\":1,\"348\":5,\"349\":1}}],[\"function\",{\"1\":{\"275\":1,\"323\":1,\"428\":2,\"430\":1,\"442\":1,\"450\":5,\"451\":2,\"454\":2}}],[\"full\",{\"1\":{\"203\":1,\"204\":1,\"234\":1,\"264\":1}}],[\"free链表中取一个空闲的缓存页\",{\"1\":{\"176\":1}}],[\"free\",{\"1\":{\"176\":6,\"177\":1,\"178\":2,\"180\":1,\"185\":2}}],[\"frm\",{\"1\":{\"152\":3}}],[\"from和to\",{\"1\":{\"529\":1}}],[\"from之后\",{\"1\":{\"261\":1}}],[\"from\",{\"1\":{\"43\":1,\"137\":1,\"142\":1,\"144\":1,\"145\":2,\"147\":1,\"148\":1,\"149\":1,\"178\":1,\"182\":2,\"189\":1,\"191\":2,\"192\":1,\"193\":1,\"195\":1,\"198\":1,\"206\":2,\"216\":4,\"217\":1,\"219\":1,\"228\":1,\"232\":1,\"234\":3,\"235\":2,\"236\":1,\"237\":1,\"238\":6,\"240\":1,\"263\":2,\"264\":3,\"265\":1,\"266\":2,\"275\":4,\"277\":3,\"279\":1,\"280\":3,\"283\":1,\"285\":1,\"290\":2,\"291\":2,\"293\":4,\"294\":6,\"296\":4,\"297\":3,\"298\":1,\"302\":1,\"304\":2,\"314\":1,\"321\":1,\"322\":1,\"323\":3,\"324\":1,\"325\":1,\"329\":1,\"363\":1,\"367\":2,\"368\":2}}],[\"factory\",{\"1\":{\"448\":2,\"463\":3}}],[\"fasterxml\",{\"1\":{\"448\":2,\"463\":2}}],[\"false\",{\"1\":{\"429\":1,\"462\":2}}],[\"fa\",{\"1\":{\"91\":2}}],[\"far\",{\"1\":{\"91\":2}}],[\"failover命令\",{\"1\":{\"411\":1}}],[\"failover命令的这个slave节点\",{\"1\":{\"411\":1}}],[\"failover命令可以手动让集群中的某个master宕机\",{\"1\":{\"411\":1}}],[\"failover\",{\"1\":{\"43\":1}}],[\"fair\",{\"1\":{\"41\":2}}],[\"f\",{\"1\":{\"58\":2}}],[\"fieldname\",{\"1\":{\"501\":1}}],[\"fields\",{\"1\":{\"499\":1}}],[\"field\",{\"1\":{\"499\":2,\"501\":1}}],[\"fis\",{\"1\":{\"496\":3}}],[\"final\",{\"1\":{\"448\":1,\"463\":1}}],[\"findstockbyid\",{\"1\":{\"419\":1}}],[\"findbyid\",{\"1\":{\"419\":1}}],[\"fileinputstream\",{\"1\":{\"496\":4}}],[\"filesort\",{\"1\":{\"219\":2,\"228\":1}}],[\"file\",{\"1\":{\"152\":2,\"187\":2,\"243\":1,\"272\":1,\"339\":2,\"372\":1,\"377\":1,\"435\":2,\"439\":1}}],[\"file>\",{\"1\":{\"15\":1}}],[\"first\",{\"1\":{\"147\":1,\"148\":1,\"302\":1,\"363\":1}}],[\"firewall\",{\"1\":{\"43\":4}}],[\"fi\",{\"1\":{\"43\":2}}],[\"feature\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"10\":1,\"15\":3}}],[\"brand\",{\"1\":{\"436\":1,\"439\":1,\"462\":1}}],[\"branch\",{\"1\":{\"15\":3}}],[\"bosszhao\",{\"1\":{\"507\":5}}],[\"body\",{\"1\":{\"441\":1,\"442\":1,\"450\":1}}],[\"boot\",{\"1\":{\"396\":1,\"448\":1,\"460\":1}}],[\"boot<\",{\"1\":{\"396\":1,\"448\":1}}],[\"both\",{\"1\":{\"330\":2}}],[\"bgsave开始时会fork主进程得到子进程\",{\"1\":{\"374\":1}}],[\"bgsave命令\",{\"1\":{\"373\":1}}],[\"bb\",{\"1\":{\"306\":1}}],[\"belief\",{\"1\":{\"507\":2}}],[\"before\",{\"1\":{\"463\":1}}],[\"benmanes\",{\"1\":{\"419\":2,\"463\":1}}],[\"ben\",{\"1\":{\"416\":1}}],[\"beans\",{\"1\":{\"448\":2,\"463\":3}}],[\"bean\",{\"1\":{\"398\":1,\"419\":3}}],[\"because\",{\"1\":{\"275\":1,\"324\":1}}],[\"begin\",{\"1\":{\"275\":2,\"277\":2,\"283\":1,\"285\":1,\"290\":1,\"291\":1,\"293\":2,\"294\":2,\"296\":1,\"297\":1,\"298\":1,\"313\":1,\"314\":1,\"322\":1,\"323\":1,\"334\":1,\"357\":2,\"367\":2}}],[\"between\",{\"1\":{\"216\":8,\"228\":1,\"275\":2,\"323\":1,\"324\":1}}],[\"by\",{\"1\":{\"219\":1,\"221\":2,\"222\":2,\"224\":1,\"228\":3,\"275\":2,\"323\":1,\"324\":1,\"435\":2,\"439\":1}}],[\"bytebuffer使用了实现类directbytebuffer\",{\"1\":{\"522\":1}}],[\"bytebuffer就会被回收\",{\"1\":{\"522\":1}}],[\"byte\",{\"1\":{\"187\":4,\"520\":1}}],[\"bytes\",{\"1\":{\"32\":1}}],[\"b=2\",{\"1\":{\"215\":4,\"239\":4,\"441\":1}}],[\"b的最后一个时刻\",{\"1\":{\"197\":1}}],[\"block\",{\"1\":{\"248\":1,\"275\":1,\"324\":1}}],[\"blocks\",{\"1\":{\"178\":2,\"180\":2}}],[\"blog\",{\"1\":{\"181\":1}}],[\"blobs\",{\"1\":{\"165\":2,\"166\":1}}],[\"blob\",{\"1\":{\"161\":1,\"168\":1}}],[\"bigint\",{\"1\":{\"183\":2,\"187\":1,\"288\":1}}],[\"bit\",{\"1\":{\"162\":1}}],[\"bind\",{\"1\":{\"507\":2}}],[\"binary\",{\"1\":{\"213\":1,\"458\":2}}],[\"binlog\",{\"0\":{\"333\":1,\"340\":1,\"341\":1,\"343\":1},\"1\":{\"96\":1,\"312\":7,\"332\":1,\"333\":2,\"340\":7,\"341\":11,\"342\":16,\"343\":30,\"344\":12,\"345\":5,\"346\":17,\"347\":9,\"348\":26,\"349\":11,\"350\":6}}],[\"bin\",{\"1\":{\"34\":1,\"43\":1}}],[\"btree\",{\"1\":{\"161\":1,\"204\":1,\"210\":1,\"274\":1,\"288\":1}}],[\"btn\",{\"1\":{\"91\":2}}],[\"build\",{\"1\":{\"416\":3,\"419\":2}}],[\"but\",{\"1\":{\"275\":1,\"302\":1,\"324\":1,\"363\":1}}],[\"buffer\",{\"0\":{\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"335\":1,\"336\":1},\"1\":{\"96\":1,\"140\":1,\"170\":4,\"171\":1,\"172\":4,\"173\":4,\"174\":10,\"176\":2,\"177\":2,\"178\":23,\"179\":4,\"180\":4,\"182\":1,\"187\":1,\"272\":1,\"335\":7,\"336\":8,\"337\":9,\"338\":11,\"339\":3,\"343\":4,\"344\":1,\"346\":2,\"347\":2,\"349\":1,\"350\":4}}],[\"bug\",{\"1\":{\"46\":1}}],[\"b+tree的有序性\",{\"1\":{\"222\":1}}],[\"b+tree的搜索逻辑\",{\"1\":{\"205\":1}}],[\"b+tree索引\",{\"1\":{\"203\":1}}],[\"b+tree\",{\"0\":{\"207\":1},\"1\":{\"201\":1,\"204\":9,\"205\":2,\"206\":13,\"207\":12,\"208\":3,\"215\":3,\"216\":9,\"217\":1,\"221\":1,\"225\":1,\"226\":1,\"234\":1}}],[\"b+树的非叶子节点可以存放更多的索引\",{\"1\":{\"254\":1,\"258\":1}}],[\"b+树索引等等\",{\"1\":{\"203\":1}}],[\"b+树\",{\"1\":{\"138\":1,\"256\":1,\"296\":1}}],[\"b+\",{\"0\":{\"242\":1,\"244\":1,\"247\":1,\"253\":1,\"257\":1},\"1\":{\"96\":2,\"138\":1,\"145\":3,\"147\":1,\"149\":1,\"155\":1,\"156\":2,\"174\":1,\"184\":1,\"186\":1,\"187\":5,\"188\":1,\"192\":1,\"207\":1,\"215\":1,\"216\":1,\"220\":1,\"232\":4,\"234\":13,\"235\":3,\"242\":3,\"244\":6,\"245\":4,\"246\":1,\"247\":1,\"253\":5,\"254\":3,\"255\":12,\"256\":3,\"257\":7,\"258\":9,\"290\":1,\"296\":1,\"336\":1}}],[\"base\",{\"0\":{\"554\":1,\"563\":1}}],[\"baserecordcommonvo\",{\"1\":{\"508\":1}}],[\"bash\",{\"1\":{\"43\":1}}],[\"baomidou\",{\"1\":{\"462\":4}}],[\"backlog原理\",{\"0\":{\"386\":1}}],[\"backup\",{\"1\":{\"32\":1,\"43\":1,\"372\":1}}],[\"baklog的大小\",{\"1\":{\"387\":1}}],[\"baklog中能找到offset时\",{\"1\":{\"388\":1}}],[\"baklog中的offset已经被覆盖时\",{\"1\":{\"388\":1}}],[\"baklog中的数据增多而逐渐增大\",{\"1\":{\"384\":1}}],[\"baklog中从offset之后的命令给slave\",{\"1\":{\"388\":1}}],[\"baklog中会记录redis处理过的命令日志及offset\",{\"1\":{\"386\":1}}],[\"baklog文件了\",{\"1\":{\"386\":1}}],[\"baklog\",{\"1\":{\"384\":1,\"388\":1}}],[\"baidu\",{\"1\":{\"32\":1}}],[\"b\",{\"0\":{\"252\":1},\"1\":{\"15\":3,\"28\":1,\"56\":1,\"58\":2,\"157\":2,\"188\":1,\"205\":1,\"207\":4,\"215\":12,\"216\":33,\"217\":4,\"239\":4,\"252\":11,\"253\":3,\"254\":4,\"255\":4,\"256\":3,\"258\":5,\"275\":2,\"277\":8,\"280\":13,\"290\":1,\"291\":1,\"303\":2,\"304\":1,\"310\":1,\"312\":5,\"317\":3,\"320\":1,\"323\":4,\"324\":1,\"325\":8,\"329\":2,\"346\":4,\"352\":6,\"354\":4,\"355\":1,\"356\":2,\"357\":6,\"359\":20,\"360\":19,\"364\":1,\"365\":4,\"367\":4,\"368\":1,\"369\":1}}],[\"也无法通过虚引用取得一个对象\",{\"1\":{\"522\":1}}],[\"也无法插入\",{\"1\":{\"297\":1,\"298\":1}}],[\"也即赵老板的信息跟公司前台的电话是绑定的\",{\"1\":{\"507\":1}}],[\"也被叫做redis数据快照\",{\"1\":{\"372\":1}}],[\"也被称为二级索引或非聚簇索引\",{\"1\":{\"204\":1}}],[\"也启动了\",{\"1\":{\"359\":1,\"360\":1}}],[\"也从数据库中读取小林的余额数据\",{\"1\":{\"354\":1}}],[\"也从图中可以看到\",{\"1\":{\"138\":1}}],[\"也正是这样\",{\"1\":{\"352\":1}}],[\"也没有丢失数据的风险\",{\"1\":{\"349\":1}}],[\"也意味着\",{\"1\":{\"334\":1,\"360\":1,\"361\":1}}],[\"也包含间隙锁\",{\"1\":{\"317\":1}}],[\"也执行了同样的\",{\"1\":{\"310\":1}}],[\"也知道如何如何用命令分析加了什么类型的行级锁\",{\"1\":{\"282\":1}}],[\"也插入\",{\"1\":{\"280\":1}}],[\"也属于间隙锁\",{\"1\":{\"275\":1,\"317\":1,\"324\":1}}],[\"也能向左遍历\",{\"1\":{\"257\":1}}],[\"也占用内存资源\",{\"1\":{\"252\":1}}],[\"也要能高效地执行范围查找\",{\"1\":{\"248\":1}}],[\"也要把数据占用的大小存起来\",{\"1\":{\"161\":1}}],[\"也叫组合索引\",{\"1\":{\"239\":1}}],[\"也叫做表空间\",{\"1\":{\"184\":1}}],[\"也有外部\",{\"1\":{\"345\":1}}],[\"也有自己的缓存\",{\"1\":{\"337\":1}}],[\"也有不少读者私聊我答案到底是什么\",{\"1\":{\"230\":1}}],[\"也有被使用的\",{\"1\":{\"176\":1}}],[\"也只是推荐值\",{\"1\":{\"188\":1}}],[\"也只有公钥可以解密\",{\"1\":{\"107\":1}}],[\"也大概知道查询数据是个怎么的过程了\",{\"1\":{\"187\":1}}],[\"也许你在执行到近\",{\"1\":{\"182\":1}}],[\"也就没有间隙锁了\",{\"1\":{\"296\":1}}],[\"也就扫描到了这个特殊记录的时候\",{\"1\":{\"293\":1,\"298\":1}}],[\"也就避免了幻读的问题\",{\"1\":{\"290\":2}}],[\"也就需要将字符串转为数字\",{\"1\":{\"238\":1}}],[\"也就不会发生页分裂\",{\"1\":{\"226\":1}}],[\"也就减少了大量的\",{\"1\":{\"225\":1}}],[\"也就意味着这个页使用完了\",{\"1\":{\"185\":1}}],[\"也就说\",{\"1\":{\"178\":1}}],[\"也就是当我想预约赵老板的时候\",{\"1\":{\"507\":1}}],[\"也就是缓存一段时间\",{\"1\":{\"493\":1}}],[\"也就是原本的树结构可能会变\",{\"1\":{\"473\":1}}],[\"也就是本地缓存\",{\"1\":{\"453\":1}}],[\"也就是nginx的本地缓存了\",{\"1\":{\"452\":1}}],[\"也就是8081\",{\"1\":{\"446\":1}}],[\"也就是table\",{\"1\":{\"426\":1}}],[\"也就是三个节点各转移一部分\",{\"1\":{\"408\":1}}],[\"也就是每次读都是拿到最新版本的数据\",{\"1\":{\"361\":1}}],[\"也就是每个节点只能保存\",{\"1\":{\"251\":1}}],[\"也就是不会加锁的\",{\"1\":{\"361\":1}}],[\"也就是不做任何强制性的磁盘刷新指令\",{\"1\":{\"343\":1}}],[\"也就是小林余额是\",{\"1\":{\"359\":1,\"360\":1}}],[\"也就是事务\",{\"1\":{\"359\":1}}],[\"也就是全局事务中最大的事务\",{\"1\":{\"358\":1}}],[\"也就是全表扫描的方式查询\",{\"1\":{\"148\":1}}],[\"也就是它随时可能发生回滚操作\",{\"1\":{\"354\":1}}],[\"也就是将\",{\"1\":{\"348\":1}}],[\"也就是各自将\",{\"1\":{\"348\":1}}],[\"也就是主库上执行事务操作的线程不会等待复制\",{\"1\":{\"342\":1}}],[\"也就是主键为\",{\"1\":{\"243\":1}}],[\"也就是记录\",{\"1\":{\"342\":1}}],[\"也就是保存了所有数据变更的情况\",{\"1\":{\"341\":1}}],[\"也就是要生成一条\",{\"1\":{\"336\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"也就是表里的索引项都加锁\",{\"1\":{\"329\":1}}],[\"也就是这条\",{\"1\":{\"329\":1}}],[\"也就是只会给一行记录加锁\",{\"1\":{\"329\":1}}],[\"也就是只需要查一个\",{\"1\":{\"206\":1,\"245\":1}}],[\"也就是写锁\",{\"1\":{\"309\":1}}],[\"也就是读锁\",{\"1\":{\"309\":1}}],[\"也就是查询记录的时候\",{\"1\":{\"299\":1}}],[\"也就是仅锁住\",{\"1\":{\"293\":1}}],[\"也就是仅仅把一条记录锁上\",{\"1\":{\"284\":2,\"313\":1}}],[\"也就是发生了死锁\",{\"1\":{\"274\":1,\"320\":1}}],[\"也就是非唯一索引进行范围查询时\",{\"1\":{\"298\":1}}],[\"也就是非唯一索引\",{\"1\":{\"274\":1}}],[\"也就是把一张表连接查询多次\",{\"1\":{\"265\":1}}],[\"也就是找到了这个节点\",{\"1\":{\"250\":1}}],[\"也就是数据库的数据\",{\"1\":{\"243\":1}}],[\"也就是对索引使用了函数\",{\"1\":{\"238\":1}}],[\"也就是聚簇索引\",{\"1\":{\"234\":1}}],[\"也就是利用了索引树的有序性的特点\",{\"1\":{\"232\":1}}],[\"也就是遍历了整颗索引树\",{\"1\":{\"232\":1}}],[\"也就是使用了覆盖索引\",{\"1\":{\"228\":1}}],[\"也就是使用主键索引查询一条记录\",{\"1\":{\"147\":1}}],[\"也就是在备份用户表和商品表之间\",{\"1\":{\"307\":1}}],[\"也就是在\",{\"1\":{\"219\":1}}],[\"也就是范围查询的字段可以用到联合索引\",{\"1\":{\"216\":2}}],[\"也就是可能存在部分字段用到联合索引的\",{\"1\":{\"216\":1}}],[\"也就是联合索引生效了\",{\"1\":{\"215\":1}}],[\"也就是按照最左优先的方式进行索引的匹配\",{\"1\":{\"215\":1,\"228\":1,\"239\":1,\"241\":1}}],[\"也就是进行了\",{\"1\":{\"205\":1}}],[\"也就是叶子节点\",{\"1\":{\"186\":1}}],[\"也就是尚未使用的存储空间中申请一个记录大小的空间划分到\",{\"1\":{\"185\":1}}],[\"也就是页被访问的时候\",{\"1\":{\"178\":1}}],[\"也就是更新数据的时候\",{\"1\":{\"177\":1}}],[\"也就是最多能保证\",{\"1\":{\"155\":1}}],[\"也就是一次磁盘\",{\"1\":{\"248\":1}}],[\"也就是一次\",{\"1\":{\"155\":1,\"243\":1}}],[\"也就是定位到\",{\"1\":{\"149\":2}}],[\"也就是结束查询了\",{\"1\":{\"147\":1}}],[\"也就是执行阶段\",{\"1\":{\"143\":1}}],[\"也就是优化阶段\",{\"1\":{\"143\":1}}],[\"也就是预处理阶段\",{\"1\":{\"143\":1}}],[\"也就是\",{\"1\":{\"140\":1,\"149\":1,\"166\":1,\"168\":1,\"183\":1,\"216\":5,\"228\":1,\"235\":2,\"241\":1,\"275\":1,\"296\":2,\"310\":1,\"311\":1,\"358\":1}}],[\"也就是说它只能存活到下一次垃圾回收发生之前\",{\"1\":{\"521\":1}}],[\"也就是说创建一个链表数组\",{\"1\":{\"472\":1}}],[\"也就是说角标到达数组末尾后\",{\"1\":{\"386\":1}}],[\"也就是说这\",{\"1\":{\"351\":1}}],[\"也就是说这是一个空闲的连接\",{\"1\":{\"139\":1}}],[\"也就是说如果本线程对学生表加了\",{\"1\":{\"309\":1}}],[\"也就是说节点的左子树和右子树仍然为平衡二叉树\",{\"1\":{\"251\":1}}],[\"也就是说树的高度就等于每次查询数据时磁盘\",{\"1\":{\"250\":1,\"258\":1}}],[\"也就是说查询过程中会发生多次磁盘\",{\"1\":{\"248\":1}}],[\"也就是说读取同样大小的数据\",{\"1\":{\"248\":1}}],[\"也就是说该索引的值是函数计算后的值\",{\"1\":{\"236\":1}}],[\"也就是说用上了二级索引\",{\"1\":{\"232\":1}}],[\"也就是说一次数据查询操作只需要做\",{\"1\":{\"207\":1}}],[\"也就是说一行数据的最大字节数\",{\"1\":{\"166\":1}}],[\"也就是说要查两个\",{\"1\":{\"206\":1,\"245\":1}}],[\"也就是说总数会等于\",{\"1\":{\"187\":1}}],[\"也就是说主键的大小可以限制表的上限\",{\"1\":{\"183\":1}}],[\"也就是说在数据表中创建的主键索引和二级索引默认使用的是\",{\"1\":{\"138\":1}}],[\"也就是说\",{\"1\":{\"66\":1,\"140\":1,\"155\":1,\"165\":1,\"191\":1,\"194\":1,\"200\":1,\"215\":1,\"216\":2,\"226\":1,\"239\":1,\"243\":1,\"297\":1,\"339\":1,\"346\":1,\"348\":1,\"352\":1,\"357\":1,\"445\":1}}],[\"也就是说无需去服务端验证\",{\"1\":{\"42\":1}}],[\"也就是我们所说的负载均衡\",{\"1\":{\"23\":1}}],[\"也不是直接写入磁盘的\",{\"1\":{\"337\":1}}],[\"也不能修改\",{\"1\":{\"316\":1}}],[\"也不能修改和删除\",{\"1\":{\"287\":1}}],[\"也不可以对该记录加\",{\"1\":{\"285\":1,\"314\":1}}],[\"也不会回收强引用所指向对象\",{\"1\":{\"519\":1}}],[\"也不会丢失数据\",{\"1\":{\"338\":1}}],[\"也不会发生冲突\",{\"1\":{\"326\":1}}],[\"也不会影响读请求的执行\",{\"1\":{\"342\":1}}],[\"也不会影响备份数据库时的\",{\"1\":{\"307\":1}}],[\"也不会影响已经存在连接的权限\",{\"1\":{\"139\":1}}],[\"也不会有什么影响\",{\"1\":{\"291\":1}}],[\"也不会走全表扫描\",{\"1\":{\"232\":1}}],[\"也不要求字段为\",{\"1\":{\"212\":1}}],[\"也不太合理\",{\"1\":{\"187\":1}}],[\"也不必等待下一次的产品发布周期\",{\"1\":{\"13\":1}}],[\"也称\",{\"1\":{\"108\":1}}],[\"也会被\",{\"1\":{\"346\":1}}],[\"也会释放所有表锁\",{\"1\":{\"309\":1}}],[\"也会限制本线程接下来的读写操作\",{\"1\":{\"309\":1}}],[\"也会清楚每个索引失效的原因\",{\"1\":{\"233\":1}}],[\"也会造成\",{\"1\":{\"178\":1}}],[\"也会存在被中间人调包的风险\",{\"1\":{\"107\":1}}],[\"也会方便很多\",{\"1\":{\"46\":1}}],[\"也是和引用队列referencequeue联合使用\",{\"1\":{\"521\":1}}],[\"也是可能被持久化到磁盘的\",{\"1\":{\"346\":1}}],[\"也是可以对记录加共享锁和独占锁的\",{\"1\":{\"311\":1}}],[\"也是直接写在\",{\"1\":{\"346\":1}}],[\"也是发生了幻读的问题\",{\"1\":{\"302\":1,\"363\":1}}],[\"也是通过二分法快速定位到包含该记录的页\",{\"1\":{\"244\":1}}],[\"也是无法走索引的\",{\"1\":{\"237\":1,\"241\":1}}],[\"也是走全扫描二级索引树\",{\"1\":{\"232\":1}}],[\"也是在一个非常小的范围内扫描\",{\"1\":{\"228\":1}}],[\"也是不确定的\",{\"1\":{\"197\":1}}],[\"也是本文重点介绍的内容\",{\"1\":{\"154\":1}}],[\"也是第一次看哈哈\",{\"1\":{\"146\":1}}],[\"也是\",{\"1\":{\"106\":1,\"152\":1}}],[\"也逐步把网站升级到\",{\"1\":{\"102\":1}}],[\"也可能不会产生碎片\",{\"1\":{\"174\":1}}],[\"也可以不和引用队列联合使用\",{\"1\":{\"521\":1}}],[\"也可以不和引用队列\",{\"1\":{\"520\":1}}],[\"也可以称为根搜索算法\",{\"1\":{\"517\":1}}],[\"也可以回滚事务\",{\"1\":{\"346\":1}}],[\"也可以得知事务\",{\"1\":{\"294\":1}}],[\"也可以得到事务\",{\"1\":{\"293\":1}}],[\"也可以是外连接查询\",{\"1\":{\"265\":1}}],[\"也可以是其他任意表达式\",{\"1\":{\"191\":1}}],[\"也可以是时间或其他系统等等\",{\"1\":{\"59\":1}}],[\"也可以存放在独占表空间文件\",{\"1\":{\"152\":1}}],[\"也可以使用普通索引\",{\"1\":{\"145\":1}}],[\"也可以向\",{\"1\":{\"108\":1}}],[\"也可归纳为登录系统\",{\"1\":{\"61\":1}}],[\"也可采取100+\",{\"1\":{\"58\":1}}],[\"也很方便\",{\"1\":{\"14\":1}}],[\"让所有存活的对象都向一端移动\",{\"1\":{\"528\":1}}],[\"让这些slave成为新master的从节点\",{\"1\":{\"393\":1}}],[\"让该节点成为master\",{\"1\":{\"393\":1}}],[\"让大家了解了唯一索引和非唯一索引的行级锁的加锁规则\",{\"1\":{\"300\":1}}],[\"让其他事务得以继续执行\",{\"1\":{\"281\":1}}],[\"让程序员自己保证在查询条件中不要对索引进行表达式计算\",{\"1\":{\"237\":1}}],[\"让真正被访问的页才移动到\",{\"1\":{\"178\":1}}],[\"让存储引擎读取表中的第一条记录\",{\"1\":{\"148\":1}}],[\"让存储引擎定位符合条件的第一条记录\",{\"1\":{\"147\":1}}],[\"让一级\",{\"1\":{\"109\":1}}],[\"让\",{\"1\":{\"109\":1,\"337\":1,\"343\":1,\"350\":1}}],[\"让团队不必打乱当前的工作流程\",{\"1\":{\"13\":1}}],[\"让志同道合的朋友们可以一起讨论\",{\"1\":{\"1\":1}}],[\"团队在汇报状态时可以轻松使用这样的措辞\",{\"1\":{\"12\":1}}],[\"常量在链接阶段就存入调用类的常量池中了\",{\"1\":{\"492\":1}}],[\"常量名\",{\"1\":{\"492\":1}}],[\"常用的密钥和证书封装管理功能及\",{\"1\":{\"26\":1}}],[\"常用分支概览\",{\"0\":{\"6\":1}}],[\"常见多表查询方式\",{\"0\":{\"260\":1}}],[\"常见于排序\",{\"1\":{\"228\":1}}],[\"常见扫描类型的执行效率从低到高的顺序为\",{\"1\":{\"228\":1}}],[\"常见的\",{\"1\":{\"233\":1}}],[\"常见的存储引擎\",{\"1\":{\"204\":1}}],[\"常见的有数据页\",{\"1\":{\"155\":1}}],[\"常见索引有\",{\"1\":{\"204\":1}}],[\"常见操作场景\",{\"0\":{\"15\":1}}],[\"常见问题\",{\"0\":{\"11\":1}}],[\"gcroots\",{\"1\":{\"519\":1}}],[\"gc\",{\"1\":{\"517\":3,\"520\":3}}],[\"gcc\",{\"1\":{\"26\":3}}],[\"genericsuperclass\",{\"1\":{\"499\":3}}],[\"general\",{\"1\":{\"204\":1}}],[\"getstrategy\",{\"1\":{\"508\":1}}],[\"getsuperclass\",{\"1\":{\"499\":2}}],[\"gettaskid\",{\"1\":{\"508\":1}}],[\"gettasktype\",{\"1\":{\"508\":1}}],[\"gettype\",{\"1\":{\"508\":1}}],[\"gettypename\",{\"1\":{\"499\":1}}],[\"getbelief\",{\"1\":{\"507\":3}}],[\"getbyid\",{\"1\":{\"419\":1}}],[\"getname\",{\"1\":{\"499\":1}}],[\"getactualtypearguments\",{\"1\":{\"499\":1}}],[\"getannotations\",{\"1\":{\"499\":1}}],[\"getproxyinstance\",{\"1\":{\"507\":2}}],[\"getproperty\",{\"1\":{\"496\":2}}],[\"getpackage\",{\"1\":{\"499\":1}}],[\"getgenericsuperclass\",{\"1\":{\"499\":2}}],[\"getclazz\",{\"1\":{\"508\":1}}],[\"getclassloader\",{\"1\":{\"488\":1,\"496\":1,\"507\":1}}],[\"getclass\",{\"0\":{\"486\":1},\"1\":{\"486\":1,\"507\":2}}],[\"getconstructors\",{\"1\":{\"499\":2}}],[\"getdeclaredconstructor\",{\"1\":{\"503\":1}}],[\"getdeclaredconstructors\",{\"1\":{\"499\":2}}],[\"getdeclaredmethod\",{\"1\":{\"502\":3,\"508\":1}}],[\"getdeclaredmethods\",{\"1\":{\"499\":2}}],[\"getdeclaredfield\",{\"1\":{\"501\":2}}],[\"getdeclaredfields\",{\"1\":{\"499\":2}}],[\"getmattertype\",{\"1\":{\"508\":1}}],[\"getmapping\",{\"1\":{\"419\":2,\"435\":1}}],[\"getmethods\",{\"1\":{\"499\":2}}],[\"getfields\",{\"1\":{\"499\":2}}],[\"getresourceasstream\",{\"1\":{\"496\":1}}],[\"getinstance\",{\"1\":{\"508\":1}}],[\"getinterfaces\",{\"1\":{\"499\":2,\"507\":1}}],[\"getid\",{\"1\":{\"448\":2,\"463\":7}}],[\"getifpresent\",{\"1\":{\"416\":1}}],[\"get方式传参数\",{\"1\":{\"441\":1}}],[\"get\",{\"1\":{\"416\":1,\"419\":2,\"441\":1,\"442\":1,\"450\":3,\"453\":1,\"454\":2,\"520\":1}}],[\"gf\",{\"1\":{\"416\":5}}],[\"guavacache\",{\"1\":{\"416\":1}}],[\"gb\",{\"1\":{\"339\":1}}],[\"gap\",{\"0\":{\"286\":1,\"315\":1},\"1\":{\"275\":14,\"279\":1,\"280\":2,\"284\":2,\"286\":1,\"287\":1,\"290\":2,\"296\":1,\"304\":2,\"313\":2,\"315\":1,\"316\":1,\"322\":2,\"323\":7,\"324\":4}}],[\"groupid>\",{\"1\":{\"396\":1,\"448\":1,\"460\":1}}],[\"group\",{\"1\":{\"221\":1,\"222\":1,\"228\":2,\"339\":1,\"348\":6,\"349\":2}}],[\"green\",{\"1\":{\"91\":1}}],[\"grep\",{\"1\":{\"35\":1,\"43\":1}}],[\"gmt\",{\"1\":{\"182\":6,\"183\":2}}],[\"gohalo\",{\"1\":{\"150\":1}}],[\"gpu版本请自行编译\",{\"1\":{\"100\":1}}],[\"g\",{\"1\":{\"58\":2,\"275\":1,\"277\":2,\"279\":1,\"280\":2,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":3,\"297\":1,\"304\":2,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"406\":1}}],[\"global\",{\"1\":{\"43\":1,\"182\":2}}],[\"gz\",{\"1\":{\"28\":1,\"29\":1,\"34\":1}}],[\"gz安装包\",{\"1\":{\"28\":1}}],[\"gzip\",{\"1\":{\"26\":1}}],[\"gzm分支重复234的过程\",{\"1\":{\"10\":1}}],[\"gzm\",{\"1\":{\"10\":1}}],[\"github的地址\",{\"1\":{\"458\":1}}],[\"github地址\",{\"1\":{\"416\":1}}],[\"github\",{\"0\":{\"549\":1},\"1\":{\"91\":1,\"150\":1,\"416\":1,\"419\":2,\"443\":1,\"458\":1,\"459\":1,\"463\":1}}],[\"git三部曲\",{\"1\":{\"15\":1}}],[\"git\",{\"1\":{\"15\":27},\"2\":{\"16\":1,\"17\":1}}],[\"gitflow工作流程\",{\"1\":{\"4\":1}}],[\"gitflow\",{\"0\":{\"4\":1},\"1\":{\"6\":1}}],[\"git工作流\",{\"0\":{\"4\":1}}],[\"version>\",{\"1\":{\"460\":1}}],[\"void\",{\"1\":{\"416\":1,\"448\":1,\"463\":6,\"490\":1,\"496\":1,\"499\":1,\"507\":4}}],[\"vod\",{\"1\":{\"38\":1,\"39\":1}}],[\"v3\",{\"1\":{\"357\":4}}],[\"v2\",{\"1\":{\"357\":4}}],[\"val\",{\"1\":{\"451\":8,\"453\":1,\"454\":14}}],[\"value2\",{\"1\":{\"216\":3}}],[\"value1\",{\"1\":{\"216\":3}}],[\"values\",{\"1\":{\"182\":1,\"275\":3,\"277\":1,\"324\":2,\"367\":1}}],[\"value\",{\"1\":{\"139\":2,\"140\":3,\"152\":1,\"324\":1,\"325\":1,\"330\":1,\"426\":4,\"428\":2,\"430\":2,\"453\":2}}],[\"varbinary\",{\"1\":{\"213\":1}}],[\"var\",{\"1\":{\"152\":4,\"439\":1,\"442\":1,\"444\":1,\"451\":1,\"454\":1}}],[\"varchar\",{\"0\":{\"165\":1},\"1\":{\"151\":2,\"161\":4,\"165\":4,\"166\":15,\"168\":1,\"169\":5,\"182\":1,\"183\":1,\"204\":2,\"213\":1,\"216\":1,\"238\":1,\"288\":1,\"319\":2}}],[\"variable\",{\"1\":{\"139\":2,\"152\":1}}],[\"variables\",{\"1\":{\"139\":2,\"152\":1}}],[\"vs\",{\"0\":{\"84\":1,\"85\":1},\"1\":{\"207\":3}}],[\"view\",{\"0\":{\"358\":1},\"1\":{\"307\":3,\"334\":7,\"357\":5,\"358\":14,\"359\":11,\"360\":14,\"361\":6,\"364\":3}}],[\"visio\",{\"1\":{\"91\":1}}],[\"vip会员和普通用户\",{\"1\":{\"61\":1}}],[\"virtual\",{\"1\":{\"43\":2}}],[\"vi\",{\"1\":{\"43\":1,\"442\":1}}],[\"vrrp\",{\"1\":{\"43\":3}}],[\"vv\",{\"1\":{\"32\":1}}],[\"v\",{\"1\":{\"31\":1}}],[\"v4\",{\"1\":{\"10\":8}}],[\"v14\",{\"1\":{\"91\":1}}],[\"v1\",{\"1\":{\"7\":1,\"357\":4}}],[\"lua代码\",{\"1\":{\"451\":1}}],[\"lua工具库中\",{\"1\":{\"450\":1}}],[\"lua这个文件\",{\"1\":{\"435\":1}}],[\"lua则相当于调用item\",{\"1\":{\"435\":1}}],[\"lualib目录下\",{\"1\":{\"442\":1}}],[\"lualib\",{\"1\":{\"435\":2,\"442\":1,\"450\":1}}],[\"lua数组的角标从1开始\",{\"1\":{\"425\":1}}],[\"lua中查询商品和库存的业务\",{\"1\":{\"454\":1}}],[\"lua中\",{\"1\":{\"436\":1}}],[\"lua中的业务\",{\"1\":{\"444\":1}}],[\"lua中的条件控制和函数声明与java类似\",{\"1\":{\"427\":1}}],[\"lua中的table可以用key来访问\",{\"1\":{\"425\":1}}],[\"lua中的table类型既可以作为数组\",{\"1\":{\"425\":1}}],[\"lua中的数组角标是从1开始\",{\"1\":{\"425\":1}}],[\"lua中支持的常见数据类型包括\",{\"1\":{\"424\":1}}],[\"lua声明变量的时候无需指定数据类型\",{\"1\":{\"425\":1}}],[\"lua提供了type\",{\"1\":{\"424\":1}}],[\"lua的数据类型\",{\"0\":{\"424\":1}}],[\"lua文件夹下\",{\"1\":{\"436\":1}}],[\"lua文件来决定\",{\"1\":{\"435\":1,\"439\":1}}],[\"lua文件\",{\"1\":{\"422\":1,\"439\":1,\"442\":2,\"450\":1,\"451\":2,\"454\":2}}],[\"lua经常嵌入到c语言开发的程序中\",{\"1\":{\"421\":1}}],[\"lua\",{\"0\":{\"436\":1},\"1\":{\"421\":2,\"425\":1,\"426\":1,\"432\":1,\"435\":9,\"436\":3,\"439\":4,\"442\":2,\"443\":1,\"450\":1,\"451\":1,\"453\":1,\"454\":1}}],[\"lua语法入门\",{\"0\":{\"420\":1}}],[\"lang\",{\"1\":{\"492\":2,\"493\":1}}],[\"lambda表达式\",{\"1\":{\"416\":1}}],[\"large\",{\"1\":{\"330\":1}}],[\"larger\",{\"1\":{\"91\":2}}],[\"lettuceclientconfigurationbuildercustomizer\",{\"1\":{\"398\":1}}],[\"leader领导所在队列的所有事务\",{\"1\":{\"348\":1}}],[\"leader\",{\"1\":{\"348\":3}}],[\"least\",{\"1\":{\"178\":1}}],[\"length\",{\"1\":{\"213\":2,\"236\":6,\"473\":5}}],[\"len\",{\"1\":{\"194\":1,\"196\":1,\"216\":13,\"228\":1}}],[\"level\",{\"1\":{\"186\":1}}],[\"left有一个为\",{\"1\":{\"473\":1}}],[\"left\",{\"1\":{\"182\":1,\"264\":1,\"473\":2}}],[\"lru\",{\"1\":{\"178\":22,\"180\":5}}],[\"ls\",{\"1\":{\"152\":1}}],[\"l\",{\"1\":{\"58\":1}}],[\"lvs\",{\"1\":{\"41\":1,\"43\":2}}],[\"limit\",{\"1\":{\"330\":5}}],[\"list<softreference<byte\",{\"1\":{\"520\":1}}],[\"list<itemstock>\",{\"1\":{\"448\":1,\"463\":1}}],[\"list<item>\",{\"1\":{\"448\":1,\"463\":1}}],[\"list是强引用\",{\"1\":{\"520\":1}}],[\"list\",{\"1\":{\"180\":3,\"213\":1,\"448\":3,\"463\":3}}],[\"listen\",{\"1\":{\"32\":1,\"38\":1}}],[\"line\",{\"1\":{\"161\":1}}],[\"linux\",{\"1\":{\"26\":1,\"44\":1,\"139\":1,\"248\":1}}],[\"lib\",{\"1\":{\"152\":4}}],[\"like\",{\"0\":{\"230\":1},\"1\":{\"96\":1,\"139\":2,\"145\":1,\"152\":1,\"178\":1,\"216\":4,\"228\":2,\"232\":2,\"235\":8,\"241\":2}}],[\"load\",{\"1\":{\"496\":2}}],[\"loadclass\",{\"1\":{\"488\":1}}],[\"lombok\",{\"1\":{\"462\":1}}],[\"long\",{\"1\":{\"419\":2,\"462\":2,\"463\":1}}],[\"lost\",{\"1\":{\"139\":1}}],[\"lock锁范围内插入了一条记录\",{\"1\":{\"357\":1}}],[\"lock\",{\"0\":{\"285\":1,\"286\":1,\"287\":1,\"314\":1,\"315\":1,\"316\":1,\"557\":1},\"1\":{\"182\":1,\"275\":27,\"277\":2,\"279\":3,\"280\":4,\"281\":1,\"283\":1,\"284\":5,\"285\":1,\"286\":1,\"287\":10,\"288\":4,\"289\":2,\"290\":6,\"291\":7,\"296\":10,\"297\":3,\"298\":1,\"300\":4,\"302\":3,\"304\":17,\"307\":1,\"309\":2,\"311\":3,\"312\":7,\"313\":6,\"314\":1,\"315\":1,\"316\":10,\"317\":1,\"322\":8,\"323\":2,\"324\":7,\"357\":2,\"361\":4,\"362\":3,\"365\":3,\"368\":1,\"369\":2}}],[\"locks\",{\"1\":{\"182\":1,\"275\":5,\"277\":2,\"279\":1,\"280\":4,\"290\":1,\"291\":1,\"293\":2,\"294\":3,\"296\":3,\"297\":1,\"304\":2,\"321\":1,\"322\":1,\"323\":4,\"324\":2,\"325\":1}}],[\"loc\",{\"1\":{\"43\":4}}],[\"loca\",{\"1\":{\"436\":2,\"439\":2}}],[\"location相关指令\",{\"1\":{\"39\":1}}],[\"location块\",{\"1\":{\"32\":4}}],[\"location\",{\"1\":{\"32\":3,\"38\":2,\"39\":1,\"42\":2,\"435\":1,\"439\":1,\"441\":2,\"442\":4,\"447\":1,\"450\":1}}],[\"localhost\",{\"1\":{\"42\":1,\"436\":1}}],[\"local\",{\"1\":{\"31\":1,\"32\":1,\"43\":3,\"425\":6,\"426\":2,\"435\":4,\"439\":1,\"441\":1,\"442\":12,\"443\":5,\"444\":8,\"447\":1,\"450\":23,\"451\":15,\"453\":2,\"454\":14}}],[\"log2​n\",{\"1\":{\"473\":1}}],[\"log变化\",{\"1\":{\"458\":1}}],[\"logfile1\",{\"1\":{\"339\":3}}],[\"logfile0\",{\"1\":{\"339\":4}}],[\"log文件\",{\"1\":{\"338\":1,\"349\":1}}],[\"logging\",{\"1\":{\"337\":1}}],[\"log实现的\",{\"1\":{\"272\":1}}],[\"logn\",{\"1\":{\"207\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"258\":2}}],[\"logdn\",{\"1\":{\"207\":1}}],[\"log\",{\"0\":{\"333\":2,\"334\":1,\"337\":1,\"338\":1,\"339\":1,\"341\":1},\"1\":{\"32\":8,\"96\":2,\"179\":4,\"180\":1,\"272\":4,\"332\":1,\"333\":4,\"334\":21,\"336\":3,\"337\":31,\"338\":30,\"339\":13,\"340\":4,\"341\":8,\"342\":4,\"343\":5,\"344\":9,\"345\":7,\"346\":19,\"347\":9,\"348\":14,\"349\":7,\"350\":9,\"352\":2,\"359\":2,\"360\":1,\"364\":1,\"442\":1,\"450\":9,\"451\":2,\"454\":4,\"458\":5}}],[\"lc\",{\"1\":{\"12\":1}}],[\"lc和zp负责高支模\",{\"1\":{\"10\":1}}],[\"lzy\",{\"1\":{\"12\":1}}],[\"lzy开发完毕v4\",{\"1\":{\"10\":1}}],[\"lzy负责4\",{\"1\":{\"10\":1}}],[\"2的n次幂有什么好坏处\",{\"1\":{\"475\":1}}],[\"2999\",{\"1\":{\"436\":1,\"439\":1}}],[\"27003\",{\"1\":{\"397\":1}}],[\"27002\",{\"1\":{\"397\":1}}],[\"27001\",{\"1\":{\"397\":1}}],[\"2～3\",{\"1\":{\"342\":1}}],[\"2gb\",{\"1\":{\"339\":1}}],[\"2>\",{\"1\":{\"338\":1}}],[\"28\",{\"1\":{\"324\":1,\"325\":1}}],[\"28800\",{\"1\":{\"139\":1}}],[\"28880秒\",{\"1\":{\"139\":1}}],[\"2=\",{\"1\":{\"243\":1}}],[\"2=2\",{\"1\":{\"243\":1}}],[\"2+4\",{\"1\":{\"243\":1}}],[\"2+98\",{\"1\":{\"58\":1}}],[\"2号槽里最大的记录为\",{\"1\":{\"243\":1}}],[\"26\",{\"1\":{\"187\":1,\"234\":1,\"288\":1,\"296\":2,\"300\":1,\"320\":1,\"323\":1,\"325\":1}}],[\"2^62\",{\"1\":{\"183\":1}}],[\"2^32\",{\"1\":{\"183\":1}}],[\"24576000\",{\"1\":{\"187\":1}}],[\"24\",{\"1\":{\"178\":1,\"296\":2,\"297\":2,\"298\":1}}],[\"23\",{\"1\":{\"178\":1,\"182\":2,\"296\":2,\"297\":2,\"298\":1,\"304\":4}}],[\"25\",{\"1\":{\"178\":1,\"296\":4,\"298\":1,\"322\":1,\"324\":1}}],[\"255\",{\"1\":{\"166\":2,\"204\":1,\"319\":2}}],[\"259元\",{\"1\":{\"91\":1}}],[\"2表示最小记录\",{\"1\":{\"163\":1}}],[\"2或者4个\",{\"1\":{\"49\":1}}],[\"2048\",{\"1\":{\"182\":1}}],[\"20473\",{\"1\":{\"44\":3}}],[\"2018\",{\"1\":{\"150\":1}}],[\"2013\",{\"1\":{\"139\":1}}],[\"2017\",{\"1\":{\"110\":1}}],[\"2019\",{\"1\":{\"44\":1,\"436\":2,\"439\":2}}],[\"20\",{\"0\":{\"101\":1},\"1\":{\"110\":1,\"149\":3,\"161\":2,\"168\":2,\"169\":2,\"178\":3,\"182\":2,\"187\":1,\"204\":1,\"205\":1,\"207\":1,\"293\":25,\"296\":8,\"297\":7,\"298\":4,\"303\":1,\"304\":1,\"322\":4,\"323\":1,\"324\":1,\"325\":2}}],[\"2021\",{\"1\":{\"350\":1}}],[\"2020\",{\"1\":{\"281\":1}}],[\"2023年6月5日\",{\"0\":{\"95\":1}}],[\"2023年6月\",{\"0\":{\"94\":1}}],[\"2024\",{\"1\":{\"2\":1}}],[\"200万\",{\"1\":{\"357\":1}}],[\"200\",{\"1\":{\"182\":1,\"183\":1,\"352\":4,\"357\":6,\"359\":3,\"360\":2,\"368\":1}}],[\"2000w\",{\"0\":{\"181\":1},\"1\":{\"96\":1,\"181\":3,\"182\":2,\"187\":1,\"188\":1}}],[\"2000\",{\"1\":{\"89\":1}}],[\"2008操作系统\",{\"1\":{\"75\":1}}],[\"2s\",{\"1\":{\"43\":1}}],[\"22\",{\"1\":{\"41\":2,\"178\":1,\"216\":3,\"296\":17,\"297\":44,\"298\":16,\"312\":1}}],[\"21寸托运箱拉杆箱\",{\"1\":{\"436\":1,\"439\":1}}],[\"21844\",{\"1\":{\"166\":1}}],[\"21\",{\"1\":{\"41\":2,\"178\":1,\"294\":2,\"296\":1,\"297\":13,\"298\":3,\"304\":4,\"425\":1,\"443\":2}}],[\"2分支用于解决线上bug\",{\"1\":{\"10\":1}}],[\"2分支入develop分支\",{\"1\":{\"10\":1}}],[\"2上线后\",{\"1\":{\"10\":1}}],[\"2测试完毕\",{\"1\":{\"10\":1}}],[\"2可以进行测试了\",{\"1\":{\"10\":1}}],[\"2和feature\",{\"1\":{\"10\":1}}],[\"2\",{\"0\":{\"61\":1,\"66\":1,\"70\":1,\"76\":1,\"81\":1,\"113\":1,\"114\":1,\"115\":2,\"116\":1,\"119\":1,\"123\":1,\"125\":1,\"129\":1,\"132\":1,\"133\":2,\"134\":2,\"135\":3,\"136\":2,\"155\":1,\"162\":1,\"255\":1,\"264\":1,\"278\":1,\"291\":1,\"294\":1,\"297\":1,\"323\":1,\"374\":1,\"376\":1,\"377\":1,\"378\":2,\"379\":1,\"382\":1,\"383\":2,\"384\":2,\"385\":3,\"386\":2,\"387\":1,\"388\":1,\"392\":1,\"395\":1,\"396\":1,\"397\":2,\"398\":1,\"401\":1,\"402\":1,\"403\":1,\"406\":1,\"411\":1,\"416\":1,\"417\":2,\"418\":2,\"419\":3,\"423\":1,\"424\":1,\"425\":2,\"426\":1,\"429\":1,\"433\":1,\"434\":1,\"435\":2,\"436\":1,\"439\":1,\"442\":1,\"447\":1,\"451\":1,\"454\":1,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"461\":2,\"462\":1,\"473\":1,\"481\":1,\"483\":1,\"484\":2,\"489\":1,\"490\":1,\"493\":1,\"499\":1,\"518\":1},\"1\":{\"10\":4,\"32\":1,\"41\":1,\"42\":1,\"43\":7,\"48\":1,\"49\":1,\"56\":1,\"57\":1,\"66\":1,\"72\":1,\"81\":1,\"103\":1,\"108\":1,\"162\":1,\"166\":4,\"169\":1,\"178\":2,\"180\":1,\"182\":2,\"186\":1,\"187\":3,\"204\":1,\"207\":2,\"211\":2,\"212\":2,\"215\":7,\"216\":15,\"217\":3,\"232\":2,\"235\":1,\"243\":5,\"251\":1,\"252\":3,\"258\":1,\"275\":1,\"291\":5,\"293\":1,\"294\":5,\"298\":1,\"303\":1,\"304\":3,\"312\":7,\"323\":1,\"338\":9,\"339\":1,\"341\":1,\"342\":1,\"344\":1,\"347\":1,\"349\":1,\"365\":1,\"373\":1,\"410\":1,\"411\":1,\"412\":1,\"422\":1,\"435\":1,\"436\":1,\"439\":1,\"442\":1,\"443\":1,\"448\":8,\"450\":1,\"451\":1,\"453\":1,\"454\":1,\"456\":1,\"458\":1,\"460\":1,\"462\":1,\"463\":7,\"473\":4,\"501\":1,\"502\":1,\"503\":1,\"517\":2,\"523\":1,\"526\":1}}],[\"2版本并行开发为例\",{\"1\":{\"10\":1}}],[\"666\",{\"1\":{\"379\":1}}],[\"666都是对num的操作\",{\"1\":{\"379\":1}}],[\"617776\",{\"1\":{\"350\":1}}],[\"6<7\",{\"1\":{\"187\":1}}],[\"6>5\",{\"1\":{\"187\":2}}],[\"6379\",{\"1\":{\"406\":1,\"448\":2,\"451\":2,\"454\":2}}],[\"63\",{\"1\":{\"178\":1}}],[\"600\",{\"1\":{\"352\":3}}],[\"60\",{\"1\":{\"173\":1,\"187\":2,\"373\":1,\"375\":1,\"454\":1}}],[\"64mb\",{\"1\":{\"379\":1}}],[\"64\",{\"1\":{\"156\":1}}],[\"67199487\",{\"1\":{\"110\":1}}],[\"6844903958863937550\",{\"1\":{\"110\":1}}],[\"65533\",{\"1\":{\"166\":1}}],[\"65532字节\",{\"1\":{\"168\":1}}],[\"65532\",{\"1\":{\"166\":3,\"169\":2}}],[\"65535\",{\"1\":{\"165\":2,\"166\":9,\"167\":1,\"169\":4}}],[\"65\",{\"1\":{\"32\":1}}],[\"6\",{\"0\":{\"129\":1,\"449\":1,\"450\":1,\"451\":1},\"1\":{\"10\":11,\"66\":1,\"91\":1,\"139\":1,\"149\":2,\"152\":2,\"164\":2,\"178\":1,\"205\":2,\"215\":1,\"216\":1,\"217\":2,\"233\":1,\"239\":1,\"241\":1,\"244\":3,\"274\":1,\"275\":1,\"294\":9,\"302\":1,\"303\":1,\"304\":3,\"324\":1,\"348\":2,\"356\":2,\"363\":1,\"473\":1}}],[\"​\",{\"1\":{\"8\":1,\"10\":1,\"12\":3,\"13\":1,\"14\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"39\":6,\"42\":1,\"44\":1,\"45\":1,\"47\":1,\"48\":1,\"54\":1,\"58\":9,\"69\":3,\"74\":2,\"78\":1,\"89\":6,\"263\":1,\"264\":4,\"265\":2,\"492\":3}}],[\"4在保证hash冲突小的情况下兼顾了效率\",{\"1\":{\"473\":1}}],[\"4可以被优化为\",{\"1\":{\"473\":1}}],[\"43\",{\"1\":{\"304\":2}}],[\"4kb\",{\"1\":{\"248\":1}}],[\"4次\",{\"1\":{\"205\":1}}],[\"4915200\",{\"1\":{\"187\":1}}],[\"49+51\",{\"1\":{\"58\":1}}],[\"4byte\",{\"1\":{\"187\":1}}],[\"4090830\",{\"1\":{\"181\":1}}],[\"404\",{\"1\":{\"32\":1,\"442\":1,\"450\":1}}],[\"4被访问了才会\",{\"1\":{\"178\":1}}],[\"42s02\",{\"1\":{\"144\":1}}],[\"45kw\",{\"1\":{\"187\":1}}],[\"45\",{\"1\":{\"142\":1,\"150\":1,\"350\":1}}],[\"4545\",{\"1\":{\"32\":1}}],[\"4work绑定8cpu中的4个\",{\"1\":{\"47\":1}}],[\"4work绑定4cpu\",{\"1\":{\"47\":1}}],[\"4629\",{\"1\":{\"44\":1}}],[\"4628\",{\"1\":{\"44\":1}}],[\"4\",{\"0\":{\"63\":1,\"72\":1,\"78\":1,\"119\":1,\"136\":1,\"157\":1,\"266\":1,\"325\":1,\"388\":1,\"394\":1,\"400\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"405\":1,\"406\":1,\"407\":1,\"408\":2,\"409\":2,\"410\":2,\"411\":2,\"412\":1,\"432\":1,\"433\":1,\"434\":1,\"435\":1,\"436\":1,\"437\":1,\"438\":1,\"439\":1,\"440\":2,\"441\":2,\"442\":2,\"443\":2,\"444\":3,\"445\":2,\"448\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"463\":1,\"475\":1,\"490\":1,\"495\":1,\"498\":1,\"499\":1,\"500\":1,\"504\":2,\"530\":1,\"560\":1},\"1\":{\"7\":1,\"41\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"57\":1,\"66\":1,\"72\":1,\"158\":1,\"178\":2,\"187\":1,\"205\":7,\"215\":1,\"216\":5,\"235\":1,\"243\":3,\"252\":1,\"275\":2,\"286\":1,\"287\":1,\"291\":1,\"294\":3,\"302\":1,\"304\":2,\"312\":4,\"315\":1,\"316\":1,\"317\":1,\"324\":2,\"325\":2,\"329\":1,\"341\":1,\"352\":1,\"357\":2,\"363\":1,\"365\":1,\"368\":1,\"373\":1,\"410\":1,\"436\":2,\"439\":1,\"448\":2,\"450\":1,\"463\":1,\"508\":1,\"520\":1,\"523\":1}}],[\"不堆积碎片\",{\"1\":{\"526\":2}}],[\"不难想到\",{\"1\":{\"507\":1}}],[\"不难猜到\",{\"1\":{\"104\":1}}],[\"不利于程序的扩展\",{\"1\":{\"506\":1}}],[\"不经过tomcat\",{\"1\":{\"414\":1}}],[\"不受影响\",{\"1\":{\"373\":1}}],[\"不建议使用\",{\"1\":{\"416\":1}}],[\"不建议使用expires来缓存\",{\"1\":{\"42\":1}}],[\"不建议将隔离级别升级为串行化\",{\"1\":{\"361\":1}}],[\"不允许出现中间状态的数据\",{\"1\":{\"351\":1}}],[\"不允许插入的新记录的\",{\"1\":{\"296\":1}}],[\"不再锁住提交事务的整个过程\",{\"1\":{\"348\":1}}],[\"不刷盘\",{\"1\":{\"348\":1}}],[\"不管是时刻\",{\"1\":{\"346\":1}}],[\"不管平衡二叉查找树还是红黑树\",{\"1\":{\"251\":1}}],[\"不带索引就是全表扫扫描\",{\"1\":{\"329\":1}}],[\"不连续\",{\"1\":{\"312\":1}}],[\"不必等插入语句执行完\",{\"1\":{\"312\":1}}],[\"不必连续排列\",{\"1\":{\"250\":1}}],[\"不只是锁定读查询语句不加索引才会导致这种情况\",{\"1\":{\"299\":1}}],[\"不具有唯一性\",{\"1\":{\"298\":1}}],[\"不在m\",{\"1\":{\"358\":1}}],[\"不在二级索引索引上加范围\",{\"1\":{\"297\":1}}],[\"不在\",{\"1\":{\"294\":1}}],[\"不满足\",{\"1\":{\"294\":1}}],[\"不相同时\",{\"1\":{\"290\":1}}],[\"不论是哪个隔离级别\",{\"1\":{\"278\":1}}],[\"不然的话内存总会有耗尽的时候\",{\"1\":{\"416\":1}}],[\"不然会造成业务停滞\",{\"1\":{\"275\":1}}],[\"不然证书信任链是走不下去的\",{\"1\":{\"109\":1}}],[\"不可以使用\",{\"1\":{\"341\":1}}],[\"不可强占用\",{\"1\":{\"281\":1,\"325\":1,\"326\":1}}],[\"不可重复读和幻读现象都不可能会发生\",{\"1\":{\"357\":1}}],[\"不可重复读和幻读现象\",{\"1\":{\"357\":1}}],[\"不可重复读\",{\"0\":{\"355\":1},\"1\":{\"270\":1,\"271\":1,\"353\":1,\"355\":1,\"357\":2,\"361\":1}}],[\"不可否认\",{\"1\":{\"104\":1}}],[\"不行不行\",{\"1\":{\"250\":1}}],[\"不用再去聚簇索引查\",{\"1\":{\"245\":1}}],[\"不用执行回表操作\",{\"1\":{\"232\":1}}],[\"不须要再到表中取数据\",{\"1\":{\"228\":1}}],[\"不适合建立索引或不适合排在联合索引列的靠前的位置\",{\"1\":{\"218\":1}}],[\"不多\",{\"1\":{\"306\":1}}],[\"不多说\",{\"1\":{\"189\":1}}],[\"不多不少\",{\"1\":{\"104\":1}}],[\"不\",{\"1\":{\"187\":1,\"343\":1}}],[\"不开车\",{\"1\":{\"181\":1}}],[\"不就丢失数据了吗\",{\"1\":{\"179\":1}}],[\"不包含父类中声明的方法\",{\"1\":{\"499\":1}}],[\"不包含父类中声明的属性\",{\"1\":{\"499\":1}}],[\"不包含\",{\"1\":{\"166\":1}}],[\"不包括隐藏列和记录头信息\",{\"1\":{\"165\":1}}],[\"不着急说结论\",{\"1\":{\"166\":1}}],[\"不存在数据丢失的风险\",{\"1\":{\"342\":1}}],[\"不存在才插入记录\",{\"1\":{\"274\":1}}],[\"不存在\",{\"1\":{\"162\":1,\"275\":2,\"289\":1,\"291\":2,\"294\":1,\"295\":1,\"300\":2}}],[\"不如去掉以节省空间\",{\"1\":{\"161\":1}}],[\"不固定的\",{\"1\":{\"161\":1}}],[\"不使用索引下推\",{\"1\":{\"149\":1}}],[\"不符合查询条件即跳过该记录\",{\"1\":{\"148\":1}}],[\"不会存在内存溢出\",{\"1\":{\"539\":1}}],[\"不会存在两个\",{\"1\":{\"294\":1}}],[\"不会扫描全部对象\",{\"1\":{\"516\":1}}],[\"不会触发此类的初始化\",{\"1\":{\"492\":1}}],[\"不会导致子类初始化\",{\"1\":{\"492\":1}}],[\"不会发生类的初始化\",{\"1\":{\"492\":1}}],[\"不会相互干扰\",{\"1\":{\"352\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"352\":1}}],[\"不会调用\",{\"1\":{\"348\":1}}],[\"不会覆盖以前的日志\",{\"1\":{\"341\":1}}],[\"不会出现半成功的状态\",{\"1\":{\"344\":1}}],[\"不会出现\",{\"1\":{\"341\":1}}],[\"不会出现前后两次查询的结果集不同\",{\"1\":{\"290\":2}}],[\"不会记录查询类的操作\",{\"1\":{\"340\":1}}],[\"不会立即将脏页写入磁盘\",{\"1\":{\"335\":1,\"343\":1,\"350\":1}}],[\"不会产生冲突\",{\"1\":{\"323\":1}}],[\"不会和行级的共享锁和独占锁发生冲突\",{\"1\":{\"311\":1}}],[\"不会因为数据或表结构的更新\",{\"1\":{\"307\":1}}],[\"不会因为满了而导致无法再缓存新的数据\",{\"1\":{\"178\":1}}],[\"不会退化为间隙锁和记录锁\",{\"1\":{\"300\":1}}],[\"不会\",{\"1\":{\"294\":1,\"312\":1}}],[\"不会冲突\",{\"1\":{\"275\":1}}],[\"不会像\",{\"1\":{\"258\":1}}],[\"不会像线性结构那样插入一个元素\",{\"1\":{\"250\":1}}],[\"不会给你这个局面\",{\"1\":{\"185\":1}}],[\"不会被访问的预读页却占用了\",{\"1\":{\"178\":1}}],[\"不会有退化为间隙锁和记录锁的情况\",{\"1\":{\"298\":1}}],[\"不会有\",{\"1\":{\"147\":1}}],[\"不会再走到查询缓存这个阶段了\",{\"1\":{\"140\":1}}],[\"不是对象\",{\"1\":{\"517\":1}}],[\"不是构造该类对象的构造器\",{\"1\":{\"492\":1}}],[\"不是大于等于条件查询\",{\"1\":{\"293\":1}}],[\"不是唯一二级索引\",{\"1\":{\"280\":1}}],[\"不是本篇的重点重点\",{\"1\":{\"251\":1}}],[\"不是实际数据\",{\"1\":{\"245\":1}}],[\"不是字段\",{\"1\":{\"193\":1}}],[\"不是的\",{\"1\":{\"174\":1,\"336\":1,\"337\":1,\"342\":1}}],[\"不是一列\",{\"1\":{\"165\":1}}],[\"不是一种紧凑的行格式\",{\"1\":{\"158\":1}}],[\"不是在解析器里做的\",{\"1\":{\"144\":2}}],[\"不是特指人\",{\"1\":{\"59\":1}}],[\"不需要显示调用\",{\"1\":{\"310\":1}}],[\"不需要像更多复杂的算法\",{\"1\":{\"255\":1}}],[\"不需要计算中间节点的位置了\",{\"1\":{\"250\":1}}],[\"不需要重新移动数据\",{\"1\":{\"226\":1}}],[\"不需要移动已有的数据\",{\"1\":{\"226\":1}}],[\"不需要查询出包含整行记录的所有信息\",{\"1\":{\"225\":1}}],[\"不需要创建索引\",{\"0\":{\"220\":1},\"1\":{\"222\":2}}],[\"不需要每次都要写入磁盘\",{\"1\":{\"177\":1}}],[\"不需要变态\",{\"1\":{\"130\":1}}],[\"不需要加锁\",{\"1\":{\"46\":1}}],[\"不过jvm垃圾回收机制可以回收这些class对象\",{\"1\":{\"493\":1}}],[\"不过这里我们会使用github上的第三方开源的canal\",{\"1\":{\"459\":1}}],[\"不过这两个类型有所区别\",{\"1\":{\"228\":1}}],[\"不过目前我们还未建立nginx\",{\"1\":{\"440\":1}}],[\"不过数组和普通table遍历略有差异\",{\"1\":{\"426\":1}}],[\"不过并不是所有的引擎都能支持事务\",{\"1\":{\"352\":1}}],[\"不过在浏览器中\",{\"1\":{\"434\":1}}],[\"不过在内存修改该\",{\"1\":{\"343\":1,\"350\":1}}],[\"不过在这里大家要考虑两个问题\",{\"1\":{\"108\":1}}],[\"不过就是对写入性能影响太大\",{\"1\":{\"343\":1}}],[\"不过尽量避免在使用\",{\"1\":{\"309\":1}}],[\"不过对于是否可以插入\",{\"1\":{\"298\":2}}],[\"不过对于插入\",{\"1\":{\"296\":2,\"297\":2}}],[\"不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常\",{\"1\":{\"281\":1}}],[\"不过可以有多条记录的唯一二级索引列的值同时为null\",{\"1\":{\"278\":1}}],[\"不过红黑树的约束条件比较复杂\",{\"1\":{\"251\":1}}],[\"不过它不是普通的二叉树\",{\"1\":{\"250\":1}}],[\"不过\",{\"1\":{\"144\":1,\"206\":1,\"224\":1,\"236\":1,\"245\":1,\"311\":1,\"333\":1,\"337\":1,\"348\":1,\"386\":1}}],[\"不过不会影响到所有请求\",{\"1\":{\"46\":1}}],[\"不能再执行新的更新操作\",{\"1\":{\"339\":1}}],[\"不能直接加密\",{\"1\":{\"108\":1}}],[\"不能公开\",{\"1\":{\"107\":1}}],[\"不能这么颓废下去了\",{\"1\":{\"95\":1}}],[\"不想额外再部署ocr服务\",{\"1\":{\"99\":1}}],[\"不想了解ocr相关知识\",{\"1\":{\"99\":1}}],[\"不做另行说明\",{\"1\":{\"96\":1}}],[\"不重复的学生号\",{\"1\":{\"89\":1}}],[\"不等待接受者返回消息或者控制\",{\"1\":{\"81\":1}}],[\"不同版本的加锁规则可能是不同的\",{\"1\":{\"288\":1}}],[\"不同版本处理方式也不一样\",{\"1\":{\"239\":1}}],[\"不同隔离级别下\",{\"1\":{\"284\":1}}],[\"不同之处在于\",{\"1\":{\"234\":1,\"298\":1}}],[\"不同值的个数\",{\"1\":{\"218\":1}}],[\"不同的数据库厂商对\",{\"1\":{\"357\":1}}],[\"不同的数据库对\",{\"1\":{\"216\":1}}],[\"不同的操作\",{\"1\":{\"334\":1}}],[\"不同的场景\",{\"1\":{\"288\":1}}],[\"不同的存储引擎具有不同的功能\",{\"1\":{\"272\":1}}],[\"不同的存储引擎\",{\"1\":{\"243\":1}}],[\"不同的存储引擎保存的文件自然也不同\",{\"1\":{\"152\":1}}],[\"不同的存储引擎支持的索引类型也不相同\",{\"1\":{\"138\":1}}],[\"不同的存储引擎共用一个\",{\"1\":{\"138\":1}}],[\"不同在于对象图显示类的多个对象实例\",{\"1\":{\"68\":1}}],[\"不同部门或不同功能区域时\",{\"1\":{\"58\":1}}],[\"不反映流程和操作\",{\"1\":{\"58\":1}}],[\"不仅给行记录加上了行锁\",{\"1\":{\"275\":1}}],[\"不仅仅考虑数据结构增删改的时间复杂度\",{\"1\":{\"258\":1}}],[\"不仅会用实验案例给大家说明\",{\"1\":{\"233\":1}}],[\"不仅需要保证算法正确\",{\"1\":{\"58\":1}}],[\"不仅支持\",{\"1\":{\"26\":1}}],[\"不要把提交\",{\"1\":{\"344\":1}}],[\"不要小看一条\",{\"1\":{\"331\":1}}],[\"不要上来去想要实现什么功能\",{\"1\":{\"53\":1}}],[\"不要为了做图而做图\",{\"1\":{\"52\":1}}],[\"不影响下一个版本功能并行开发\",{\"1\":{\"7\":1}}],[\"不断进步\",{\"1\":{\"1\":1}}],[\"不断学习\",{\"1\":{\"1\":1}}],[\"和静态方法\",{\"1\":{\"492\":1}}],[\"和slave已经拷贝到的offset\",{\"1\":{\"386\":1}}],[\"和select\",{\"1\":{\"194\":1}}],[\"和offset\",{\"1\":{\"384\":1}}],[\"和用户\",{\"1\":{\"352\":1}}],[\"和时刻\",{\"1\":{\"346\":1}}],[\"和参与者\",{\"1\":{\"344\":1}}],[\"和排他\",{\"1\":{\"323\":1}}],[\"和独占表锁\",{\"1\":{\"311\":1}}],[\"和事务\",{\"1\":{\"275\":1,\"325\":1,\"359\":1}}],[\"和二级索引\",{\"1\":{\"234\":1}}],[\"和二级索引的\",{\"1\":{\"206\":1}}],[\"和分组查询\",{\"1\":{\"228\":1}}],[\"和会话\",{\"1\":{\"197\":1}}],[\"和页号\",{\"1\":{\"186\":1}}],[\"和普通索引\",{\"1\":{\"145\":1}}],[\"和所有跨存储引擎的功能\",{\"1\":{\"138\":1}}],[\"和文档图标\",{\"1\":{\"76\":1}}],[\"和先执行后判断的循环结构\",{\"1\":{\"56\":1}}],[\"和192\",{\"1\":{\"43\":1}}],[\"和8081端口中\",{\"1\":{\"40\":1}}],[\"和\",{\"0\":{\"189\":1,\"341\":1},\"1\":{\"7\":1,\"47\":1,\"96\":1,\"149\":1,\"158\":2,\"159\":1,\"161\":3,\"162\":1,\"163\":1,\"164\":1,\"166\":4,\"168\":1,\"169\":2,\"174\":1,\"178\":3,\"180\":1,\"186\":1,\"194\":1,\"204\":1,\"205\":2,\"215\":3,\"216\":12,\"219\":2,\"221\":1,\"228\":1,\"234\":1,\"238\":1,\"239\":1,\"240\":1,\"253\":1,\"283\":1,\"291\":1,\"294\":1,\"296\":1,\"297\":4,\"298\":2,\"299\":1,\"302\":1,\"320\":1,\"323\":1,\"330\":2,\"334\":3,\"336\":1,\"337\":1,\"338\":1,\"339\":2,\"340\":2,\"341\":1,\"344\":5,\"345\":1,\"346\":3,\"347\":2,\"348\":2,\"349\":3,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":1,\"359\":4,\"360\":2,\"361\":2,\"363\":1,\"379\":1}}],[\"在运行过程中内存申请\",{\"1\":{\"538\":1}}],[\"在运行时代码可以根据某些条件改变自身结构\",{\"1\":{\"480\":1}}],[\"在任何时候都可能被垃圾回收器回收\",{\"1\":{\"522\":1}}],[\"在任何时间段突然崩溃\",{\"1\":{\"337\":1}}],[\"在垃圾回收过程中\",{\"1\":{\"516\":1}}],[\"在堆内存的方法区中就产生了一个class类型的对象\",{\"1\":{\"480\":1}}],[\"在工程或module的src目录下有名为\",{\"1\":{\"478\":1}}],[\"在工作中\",{\"1\":{\"233\":1}}],[\"在负载因子\",{\"1\":{\"473\":1}}],[\"在项目启动时将这些热点数据提前查询并保存到redis中\",{\"1\":{\"448\":1}}],[\"在项目的启动类中\",{\"1\":{\"398\":1}}],[\"在项目的pom文件中引入依赖\",{\"1\":{\"396\":1}}],[\"在该服务内部就形成了jvm进程缓存\",{\"1\":{\"445\":1}}],[\"在该记录上持有了\",{\"1\":{\"280\":1}}],[\"在前端发起的ajax请求如图\",{\"1\":{\"439\":1}}],[\"在前面分析输出结果的时候\",{\"1\":{\"296\":1}}],[\"在前面我也提到了\",{\"1\":{\"163\":1}}],[\"在nginx\",{\"1\":{\"435\":1,\"453\":1}}],[\"在nginx配置文件中进行配置\",{\"1\":{\"42\":1}}],[\"在其中的http下面\",{\"1\":{\"435\":1}}],[\"在其生命线\",{\"1\":{\"81\":1}}],[\"在item\",{\"1\":{\"419\":1,\"448\":1}}],[\"在默认情况下\",{\"1\":{\"416\":1}}],[\"在7002这个slave节点执行手动故障转移\",{\"1\":{\"411\":1}}],[\"在7001这个节点执行set\",{\"1\":{\"402\":1}}],[\"在sentinel集群监管下的redis主从集群\",{\"1\":{\"395\":1}}],[\"在做一遍实验\",{\"1\":{\"365\":1}}],[\"在做等值查询的时候效率贼快\",{\"1\":{\"207\":1}}],[\"在每次读数据的时候\",{\"1\":{\"360\":1}}],[\"在找到小林这条记录时\",{\"1\":{\"360\":2}}],[\"在找到记录后\",{\"1\":{\"359\":1}}],[\"在master中配置repl\",{\"1\":{\"387\":1}}],[\"在m\",{\"1\":{\"358\":1}}],[\"在mysql中系统默认的设置是\",{\"1\":{\"343\":1}}],[\"在mysql的官方文档中有以下重要描述\",{\"1\":{\"275\":1,\"324\":1}}],[\"在mysql官网上还有一段非常关键的描述\",{\"1\":{\"275\":1,\"323\":1}}],[\"在不同隔离级别下\",{\"1\":{\"357\":1}}],[\"在不同的阶段\",{\"1\":{\"58\":1}}],[\"在银行分别有\",{\"1\":{\"352\":1}}],[\"在等待的过程中\",{\"1\":{\"348\":1}}],[\"在早期的\",{\"1\":{\"347\":1}}],[\"在内存中都对应的缓存空间\",{\"1\":{\"347\":1}}],[\"在内存修改该\",{\"1\":{\"337\":1}}],[\"在持久化\",{\"1\":{\"344\":1}}],[\"在主库上也要提交这个事务\",{\"1\":{\"346\":1}}],[\"在主从架构中\",{\"1\":{\"344\":2}}],[\"在主键索引\",{\"1\":{\"304\":1,\"322\":1}}],[\"在主键索引加的三个锁\",{\"1\":{\"294\":1}}],[\"在主键索引上加了两种\",{\"1\":{\"294\":1}}],[\"在主键索引上加了两个\",{\"1\":{\"293\":2,\"294\":1}}],[\"在主键索引上加了\",{\"1\":{\"294\":2}}],[\"在主键索引上加了三个\",{\"1\":{\"293\":1,\"294\":1}}],[\"在读数据时只读从库\",{\"1\":{\"342\":1}}],[\"在读已提交隔离级别下\",{\"1\":{\"284\":1}}],[\"在完成主从复制之后\",{\"1\":{\"342\":1}}],[\"在完成一条更新操作后\",{\"1\":{\"340\":1}}],[\"在重做日志组中\",{\"1\":{\"339\":1}}],[\"在事务\",{\"1\":{\"359\":3,\"360\":2}}],[\"在事务提交的时候\",{\"1\":{\"343\":1}}],[\"在事务提交时才会统一将该事务运行过程中的所有\",{\"1\":{\"343\":1,\"350\":1}}],[\"在事务提交时\",{\"1\":{\"337\":1}}],[\"在事务没提交之前\",{\"1\":{\"334\":1}}],[\"在发生回滚时\",{\"1\":{\"334\":1}}],[\"在更新一条记录时\",{\"1\":{\"334\":1}}],[\"在还没有提交事务之前\",{\"1\":{\"334\":1}}],[\"在生产机上使用不当可能会导致业务停滞\",{\"1\":{\"331\":1}}],[\"在生成插入意向锁时而导致被阻塞\",{\"1\":{\"325\":1}}],[\"在扫描过程中会对索引加锁\",{\"1\":{\"329\":1}}],[\"在多级缓存架构中\",{\"1\":{\"414\":1}}],[\"在多个事务对这条记录进行读写操作时\",{\"1\":{\"357\":1}}],[\"在多个事务并发的时候\",{\"1\":{\"329\":1}}],[\"在多次查询\",{\"1\":{\"290\":2}}],[\"在获取插入意向锁时就陷入了等待状态\",{\"1\":{\"325\":1}}],[\"在获取什么锁而导致被阻塞\",{\"1\":{\"324\":1,\"325\":1}}],[\"在实际的生产应用中总想着尝试用上一些设计模式\",{\"1\":{\"508\":1}}],[\"在实际的应用当中\",{\"1\":{\"207\":1}}],[\"在实际开发中\",{\"1\":{\"448\":1}}],[\"在实际开发中往往会结合两者来使用\",{\"1\":{\"380\":1}}],[\"在实验开始前\",{\"1\":{\"320\":1}}],[\"在此期间会生成一个插入意向锁\",{\"1\":{\"317\":1}}],[\"在此分支上进行测试\",{\"1\":{\"10\":1}}],[\"在备库上执行了\",{\"1\":{\"312\":1}}],[\"在备份数据库时就要使用全局锁的方法\",{\"1\":{\"307\":1}}],[\"在从库上\",{\"1\":{\"312\":1}}],[\"在全库逻辑备份期间\",{\"1\":{\"307\":2}}],[\"在特殊的记录\",{\"1\":{\"298\":1}}],[\"在特殊记录\",{\"1\":{\"293\":3}}],[\"在非唯一索引上加了范围为\",{\"1\":{\"297\":1}}],[\"在非叶子节点\",{\"1\":{\"244\":1}}],[\"在可重复读隔离级别中\",{\"1\":{\"361\":1}}],[\"在可重复读隔离级别之下\",{\"1\":{\"300\":1}}],[\"在可重复读隔离级别下\",{\"1\":{\"284\":1,\"359\":1,\"367\":1}}],[\"在可重复读的隔离级别场景下\",{\"1\":{\"297\":1}}],[\"在相同的二级索引值情况下\",{\"1\":{\"296\":1}}],[\"在相同的磁盘\",{\"1\":{\"207\":1}}],[\"在分析二级索引的间隙锁是否可以成功插入记录时\",{\"1\":{\"296\":1}}],[\"在符合查询条件的记录的主键索引上加记录锁\",{\"1\":{\"295\":1,\"300\":1}}],[\"在针对\",{\"1\":{\"294\":1}}],[\"在插入数据时\",{\"1\":{\"312\":1}}],[\"在插入\",{\"1\":{\"296\":1}}],[\"在插入一条记录时\",{\"1\":{\"334\":1}}],[\"在插入一条\",{\"1\":{\"291\":1}}],[\"在插入二级索引记录时会遇到重复的唯一二级索引列值\",{\"1\":{\"280\":1}}],[\"在删除一条记录时\",{\"1\":{\"334\":1}}],[\"在删除\",{\"1\":{\"290\":1}}],[\"在修改数据库的同时\",{\"1\":{\"456\":1}}],[\"在修改\",{\"1\":{\"290\":1}}],[\"在能使用记录锁或者间隙锁就能避免幻读现象的场景下\",{\"1\":{\"288\":1}}],[\"在说\",{\"1\":{\"283\":1}}],[\"在隔离级别可重复读的情况下\",{\"1\":{\"280\":1}}],[\"在隔离级别是\",{\"1\":{\"279\":1}}],[\"在二级索引树上定位到插入的位置\",{\"1\":{\"296\":4,\"297\":1}}],[\"在二级索引\",{\"1\":{\"275\":1}}],[\"在自连接查询中\",{\"1\":{\"265\":1}}],[\"在同样的节点个数情况下\",{\"1\":{\"251\":1}}],[\"在创建\",{\"1\":{\"358\":1}}],[\"在创建聚簇索引时\",{\"1\":{\"245\":1}}],[\"在创建表时\",{\"1\":{\"204\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"234\":1}}],[\"在定位记录所在哪一个页时\",{\"1\":{\"244\":1}}],[\"在叶子节点\",{\"1\":{\"244\":1}}],[\"在叶子节点的索引数据\",{\"1\":{\"205\":1}}],[\"在联合索引的情况下\",{\"1\":{\"239\":1}}],[\"在联合索引找到主键值后\",{\"1\":{\"239\":1}}],[\"在遇到字符串和数字比较的时候\",{\"1\":{\"238\":1,\"241\":1}}],[\"在遇到范围查询\",{\"1\":{\"216\":1}}],[\"在代码特殊处理下\",{\"1\":{\"237\":1}}],[\"在代码里调用\",{\"1\":{\"139\":1}}],[\"在查询条件中对索引进行表达式计算\",{\"1\":{\"237\":1}}],[\"在查询时使用了二级索引\",{\"1\":{\"208\":1}}],[\"在我们查询位于底层的某个节点\",{\"1\":{\"252\":1}}],[\"在我们使用\",{\"1\":{\"234\":3}}],[\"在我们开启了慢\",{\"1\":{\"179\":1}}],[\"在索引树找到第一条大于该查询记录的记录后\",{\"1\":{\"289\":1,\"291\":1,\"300\":1}}],[\"在索引树上定位到这一条记录后\",{\"1\":{\"289\":1,\"300\":1}}],[\"在索引\",{\"1\":{\"225\":1}}],[\"在索引页中主要记录的是主键与页号\",{\"1\":{\"187\":1}}],[\"在确定需要扫描的二级索引的范围时\",{\"1\":{\"216\":2}}],[\"在第二层的索引数据\",{\"1\":{\"205\":1}}],[\"在上面两个都没有的情况下\",{\"1\":{\"204\":1,\"245\":1}}],[\"在新增和删除操作时\",{\"1\":{\"200\":1}}],[\"在使用二级索引进行查找数据时\",{\"1\":{\"246\":1}}],[\"在使用的时候会存在差别\",{\"1\":{\"239\":1}}],[\"在使用联合索引进行查询的时候\",{\"1\":{\"215\":1,\"216\":1}}],[\"在使用\",{\"1\":{\"197\":1,\"226\":1,\"307\":1,\"311\":2}}],[\"在使用系统或与系统交互中所扮演的角色\",{\"1\":{\"59\":1}}],[\"在会话\",{\"1\":{\"197\":1}}],[\"在通过\",{\"1\":{\"192\":1}}],[\"在行数据大小不同的情况下\",{\"1\":{\"187\":1}}],[\"在保持相同的层级\",{\"1\":{\"187\":1}}],[\"在文章的开头已经介绍了页的结构\",{\"1\":{\"187\":1}}],[\"在磁盘中存储也不一定是顺序的\",{\"1\":{\"187\":1}}],[\"在它的内容区中有\",{\"1\":{\"186\":1}}],[\"在数据库层面\",{\"1\":{\"281\":1}}],[\"在数据库表只有一个\",{\"1\":{\"166\":1}}],[\"在数据量小的时候\",{\"1\":{\"185\":1}}],[\"在页的\",{\"1\":{\"185\":1}}],[\"在表空间中还有段\",{\"1\":{\"184\":1}}],[\"在表中数据量大的时候\",{\"1\":{\"156\":1}}],[\"在硬盘上存储也是类似如此的\",{\"1\":{\"184\":1}}],[\"在开启了慢\",{\"1\":{\"180\":1}}],[\"在对表结构变更前\",{\"1\":{\"310\":1}}],[\"在对\",{\"1\":{\"304\":1}}],[\"在对查询结果排序时使用临时表\",{\"1\":{\"228\":1}}],[\"在对某个处在\",{\"1\":{\"178\":1}}],[\"在对象图中\",{\"1\":{\"70\":1}}],[\"在对象名后跟一个冒号加上类型名\",{\"1\":{\"70\":1}}],[\"在批量访问这些数据的时候\",{\"1\":{\"178\":1}}],[\"在加载数据页时\",{\"1\":{\"178\":1}}],[\"在未来很大概率会被访问到\",{\"1\":{\"178\":1}}],[\"在记录的真实数据处只会保存该列的一部分数据\",{\"1\":{\"168\":1,\"169\":1}}],[\"在一条更新语句执行完成后\",{\"1\":{\"343\":1,\"350\":1}}],[\"在一行行扫描的过程中\",{\"1\":{\"275\":1}}],[\"在一些可以容忍数据库崩溃时丢失\",{\"1\":{\"338\":1}}],[\"在一些对数据安全性要求比较高的场景中\",{\"1\":{\"338\":1}}],[\"在一些情况是可以成功插入的\",{\"1\":{\"296\":2,\"297\":2}}],[\"在一些场景下会退化成记录锁或间隙锁\",{\"1\":{\"275\":1,\"288\":1}}],[\"在一些大字符串的字段作为索引时\",{\"1\":{\"224\":1}}],[\"在一个事务内多次查询某个符合查询条件的\",{\"1\":{\"356\":1}}],[\"在一个事务内多次读取同一个数据\",{\"1\":{\"355\":1}}],[\"在一个事务获取到锁时才能进入\",{\"1\":{\"347\":1}}],[\"在一个数据量非常大的表\",{\"1\":{\"178\":1}}],[\"在一个团队\",{\"1\":{\"12\":1}}],[\"在一般情况下\",{\"1\":{\"168\":1}}],[\"在算\",{\"1\":{\"166\":1}}],[\"在存储数据的时候\",{\"1\":{\"161\":1}}],[\"在这种机制下这些系统的类已经被bootstrap\",{\"1\":{\"494\":1}}],[\"在这种情况下\",{\"1\":{\"166\":1}}],[\"在这里对redis的操作都封装到了redishandler这个对象中\",{\"1\":{\"463\":1}}],[\"在这里插入图片描述\",{\"1\":{\"329\":1}}],[\"在这过程中如果事务b\",{\"1\":{\"355\":1}}],[\"在这些情况里\",{\"1\":{\"228\":1}}],[\"在这些情况下\",{\"1\":{\"218\":1,\"222\":1}}],[\"在这部分非常适合讲索引下推\",{\"1\":{\"149\":1}}],[\"在这个时刻\",{\"1\":{\"367\":1}}],[\"在这个间隙锁中\",{\"1\":{\"277\":1}}],[\"在这个分支上只能进行修复bug\",{\"1\":{\"10\":1}}],[\"在这个快节奏的世界里\",{\"1\":{\"1\":1}}],[\"在执行插入语句的时候\",{\"1\":{\"365\":1}}],[\"在执行插入语句时\",{\"1\":{\"326\":1}}],[\"在执行第一个查询语句后\",{\"1\":{\"364\":1}}],[\"在执行将余额\",{\"1\":{\"357\":1}}],[\"在执行更新语句的过程中\",{\"1\":{\"338\":1}}],[\"在执行快照读\",{\"1\":{\"334\":1}}],[\"在执行以下语句都会被阻塞\",{\"1\":{\"304\":1}}],[\"在执行下面这条查询语句后\",{\"1\":{\"304\":1}}],[\"在执行下面这条语句的时候\",{\"1\":{\"275\":1}}],[\"在执行完后\",{\"1\":{\"275\":1,\"325\":1}}],[\"在执行\",{\"1\":{\"217\":1,\"305\":1}}],[\"在执行的时候\",{\"1\":{\"196\":1}}],[\"在执行的过程中\",{\"1\":{\"146\":1}}],[\"在执行查询过程中临时使用内存管理连接对象\",{\"1\":{\"139\":1}}],[\"在下图中执行计划\",{\"1\":{\"145\":1}}],[\"在正式执行\",{\"1\":{\"141\":1}}],[\"在用\",{\"1\":{\"108\":1}}],[\"在用线将表示联系的菱形框联系到实体集时\",{\"1\":{\"91\":1}}],[\"在证书中附上公钥\",{\"1\":{\"108\":1}}],[\"在线上执行一条\",{\"1\":{\"328\":1}}],[\"在线上在执行\",{\"1\":{\"299\":1,\"300\":1,\"304\":1}}],[\"在线画图快捷方便真的香\",{\"1\":{\"91\":1}}],[\"在线旁注明是1或n\",{\"1\":{\"91\":1}}],[\"在框中记入联系名\",{\"1\":{\"90\":1}}],[\"在框中记入实体名\",{\"1\":{\"90\":1}}],[\"在框内写出各个步骤\",{\"1\":{\"58\":1}}],[\"在描述实体集的所有属性中\",{\"1\":{\"89\":1}}],[\"在er图中有如下四个成分\",{\"1\":{\"90\":1}}],[\"在e\",{\"1\":{\"89\":1}}],[\"在etc里面生成目录keepalived\",{\"1\":{\"43\":1}}],[\"在语义上这两个图是等价的可以互相转换而不会丢失信息\",{\"1\":{\"86\":1}}],[\"在矩形框的顶端显示\",{\"1\":{\"70\":1}}],[\"在组合中\",{\"1\":{\"66\":1}}],[\"在连接点圈中写上\",{\"1\":{\"58\":1}}],[\"在编写程序之前\",{\"1\":{\"58\":1}}],[\"在得到一个基本的物理模型后\",{\"1\":{\"58\":1}}],[\"在绘制任何图形之前\",{\"1\":{\"52\":1}}],[\"在浏览器地址栏输入虚拟ip地址192\",{\"1\":{\"43\":1}}],[\"在路径\",{\"1\":{\"43\":1}}],[\"在两阶段提交的流程基础上\",{\"1\":{\"347\":1}}],[\"在两台服务器安装keepalived\",{\"1\":{\"43\":1}}],[\"在两台服务器安装nginx\",{\"1\":{\"43\":1}}],[\"在两合服务器安装keepalived\",{\"1\":{\"43\":1}}],[\"在linux虚拟机的任意目录下\",{\"1\":{\"422\":1}}],[\"在linux下有nginx\",{\"1\":{\"41\":1}}],[\"在liunx系统中准备静态资源\",{\"1\":{\"42\":1}}],[\"在客户端\",{\"1\":{\"21\":1}}],[\"在测试的时候\",{\"1\":{\"7\":1}}],[\"在\",{\"0\":{\"358\":1},\"1\":{\"7\":1,\"44\":1,\"137\":2,\"152\":1,\"166\":1,\"174\":1,\"178\":2,\"186\":1,\"187\":1,\"188\":1,\"194\":1,\"205\":2,\"215\":3,\"216\":1,\"217\":1,\"219\":1,\"228\":1,\"234\":1,\"238\":1,\"240\":1,\"241\":1,\"243\":1,\"244\":1,\"281\":1,\"290\":1,\"291\":2,\"293\":4,\"294\":10,\"296\":4,\"297\":6,\"298\":5,\"305\":1,\"306\":1,\"312\":2,\"329\":3,\"333\":1,\"336\":1,\"345\":1,\"346\":1,\"348\":2,\"357\":11,\"436\":2,\"442\":1,\"481\":1}}],[\"从一定程度上防止了危险代码的植入\",{\"1\":{\"494\":1}}],[\"从一般到特殊的过程\",{\"1\":{\"61\":1}}],[\"从最后一次写入开始计时\",{\"1\":{\"416\":1}}],[\"从slave\",{\"1\":{\"398\":1}}],[\"从主节点读取\",{\"1\":{\"398\":1}}],[\"从链式结构\",{\"1\":{\"387\":1}}],[\"从磁盘读取快照文件\",{\"1\":{\"372\":1}}],[\"从磁盘读到的页加入到\",{\"1\":{\"178\":1}}],[\"从左往右隔离级别顺序递增\",{\"1\":{\"361\":1}}],[\"从头开始写\",{\"1\":{\"339\":1}}],[\"从库执行了这条更新语句\",{\"1\":{\"344\":1}}],[\"从库的这一行\",{\"1\":{\"344\":1}}],[\"从库的自增值就是什么\",{\"1\":{\"312\":1}}],[\"从库连接上来的\",{\"1\":{\"342\":1}}],[\"从库是不是越多越好\",{\"1\":{\"342\":1}}],[\"从库会创建一个用于回放\",{\"1\":{\"342\":1}}],[\"从库会创建一个专门的\",{\"1\":{\"342\":1}}],[\"从库\",{\"1\":{\"312\":1}}],[\"从前面我们也知道了\",{\"1\":{\"296\":1}}],[\"从下图可以看到\",{\"1\":{\"280\":2}}],[\"从根节点开始\",{\"1\":{\"244\":1}}],[\"从根儿上理解mysql\",{\"1\":{\"150\":1,\"317\":1}}],[\"从小到大排序的\",{\"1\":{\"243\":1}}],[\"从图中可看出\",{\"1\":{\"345\":1}}],[\"从图中可以看出\",{\"1\":{\"185\":1}}],[\"从图可以看到\",{\"1\":{\"243\":1}}],[\"从执行计划的结果看\",{\"1\":{\"240\":1}}],[\"从执行计划的结果中\",{\"1\":{\"232\":1}}],[\"从这篇\",{\"1\":{\"333\":1}}],[\"从这里我们也可以得知\",{\"1\":{\"290\":1}}],[\"从这里可以知道\",{\"1\":{\"163\":2}}],[\"从这个实验结果可以看到\",{\"1\":{\"364\":1}}],[\"从这个实验可以得知\",{\"1\":{\"280\":1}}],[\"从这个思考题我们知道了\",{\"1\":{\"232\":1}}],[\"从这一级别开始\",{\"1\":{\"228\":1}}],[\"从二级索引中查询得到记录\",{\"1\":{\"225\":1}}],[\"从符合\",{\"1\":{\"216\":2}}],[\"从字段个数的角度来看\",{\"1\":{\"214\":1}}],[\"从字段特性的角度来看\",{\"1\":{\"209\":1}}],[\"从物理存储的角度来看\",{\"1\":{\"208\":1}}],[\"从数据结构的角度来看\",{\"1\":{\"204\":1}}],[\"从数据页的角度看\",{\"0\":{\"242\":1},\"1\":{\"96\":1,\"257\":1}}],[\"从上面这个过程\",{\"1\":{\"348\":1}}],[\"从上面输出的信息可以看到\",{\"1\":{\"304\":1}}],[\"从上面的过程\",{\"1\":{\"348\":1}}],[\"从上面的分析中\",{\"1\":{\"294\":2}}],[\"从上面的图解我们知道\",{\"1\":{\"187\":1}}],[\"从上图的分析\",{\"1\":{\"296\":1,\"297\":1}}],[\"从上图中的分析中\",{\"1\":{\"293\":1,\"294\":3}}],[\"从上图可以看到\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"322\":1,\"323\":1}}],[\"从上述的过程中发现\",{\"1\":{\"187\":1}}],[\"从上到下的顺序排列\",{\"1\":{\"57\":1}}],[\"从而监听master的binary\",{\"1\":{\"458\":1}}],[\"从而为应用程序提供灵活的扩展和定制功能\",{\"1\":{\"421\":1}}],[\"从而降低磁盘\",{\"1\":{\"349\":1}}],[\"从而降低树的高度\",{\"1\":{\"252\":1}}],[\"从而提升效率\",{\"1\":{\"348\":1}}],[\"从而提升了性能\",{\"1\":{\"239\":1}}],[\"从而减少\",{\"1\":{\"349\":1}}],[\"从而减少磁盘\",{\"1\":{\"348\":1}}],[\"从而减少了锁的数量\",{\"1\":{\"276\":1}}],[\"从而控制并发事务访问同一个记录时的行为\",{\"1\":{\"334\":1}}],[\"从而影响数据查询的效率\",{\"1\":{\"252\":1}}],[\"从而影响查询效率\",{\"1\":{\"226\":1}}],[\"从而走了全表扫描\",{\"1\":{\"233\":1}}],[\"从而避免其他事务插入一条新记录\",{\"1\":{\"368\":1,\"369\":1}}],[\"从而避免了幻读现象\",{\"1\":{\"329\":1}}],[\"从而避免幻读现象\",{\"1\":{\"275\":1}}],[\"从而避免写出索引失效的查询语句\",{\"1\":{\"228\":1}}],[\"从而避免回表\",{\"1\":{\"225\":1}}],[\"从而导致死锁的\",{\"1\":{\"318\":1}}],[\"从而导致整体速度下降\",{\"1\":{\"252\":1}}],[\"从而导致性能下降\",{\"1\":{\"187\":1}}],[\"从而导致热点数据被替换了\",{\"1\":{\"178\":1}}],[\"从而腾出空间\",{\"1\":{\"178\":1}}],[\"从而保证多事务的情况下\",{\"1\":{\"347\":1}}],[\"从而保证插入数据时\",{\"1\":{\"312\":1}}],[\"从而保证真正被读取的热数据留在\",{\"1\":{\"178\":1}}],[\"从而保证\",{\"1\":{\"178\":1}}],[\"从而可以找到剩余数据所在的页\",{\"1\":{\"168\":1,\"169\":1}}],[\"从报错信息就可以知道一行数据的最大字节数是\",{\"1\":{\"166\":1}}],[\"从存储引擎读取记录\",{\"1\":{\"150\":1}}],[\"从管道读数据是一次性操作\",{\"1\":{\"124\":1}}],[\"从现实生活中的场景找答案\",{\"1\":{\"108\":1}}],[\"从来判定接收报文不合法\",{\"1\":{\"104\":1}}],[\"从初始消息开始\",{\"1\":{\"82\":1}}],[\"从发送方指向接收方\",{\"1\":{\"81\":1}}],[\"从代码仓库的结构上也能直接反映出来\",{\"1\":{\"12\":1}}],[\"从develop模块克隆新分支\",{\"1\":{\"10\":1}}],[\"从\",{\"1\":{\"7\":1,\"138\":1,\"152\":1,\"158\":2,\"186\":1,\"236\":1,\"239\":1,\"297\":3,\"342\":1,\"348\":1,\"352\":1,\"387\":1,\"442\":1}}],[\"提供增量数据订阅\",{\"1\":{\"458\":1}}],[\"提供了近乎最佳命中率的高性能的本地缓存库\",{\"1\":{\"416\":1}}],[\"提供了\",{\"1\":{\"158\":1}}],[\"提出了四种隔离级别\",{\"1\":{\"361\":1}}],[\"提升服务性能\",{\"1\":{\"414\":1}}],[\"提升\",{\"1\":{\"337\":1}}],[\"提升语句的执行性能\",{\"1\":{\"337\":1}}],[\"提升查询效率\",{\"1\":{\"213\":1}}],[\"提交后\",{\"1\":{\"357\":1,\"360\":2}}],[\"提交完后\",{\"1\":{\"357\":1}}],[\"提交阶段\",{\"1\":{\"344\":1}}],[\"提交\",{\"1\":{\"344\":1}}],[\"提交事务后\",{\"1\":{\"357\":1,\"359\":1}}],[\"提交事务\",{\"1\":{\"334\":1,\"342\":1,\"359\":1,\"360\":1}}],[\"提交了事务\",{\"1\":{\"304\":1,\"317\":1,\"365\":1}}],[\"提交测试之后\",{\"1\":{\"7\":1}}],[\"提高效率\",{\"1\":{\"475\":1}}],[\"提高了系统整体性能\",{\"1\":{\"276\":1}}],[\"提高了查询效率\",{\"1\":{\"219\":1}}],[\"提高查询的效率\",{\"1\":{\"149\":1}}],[\"提高资源利用率和系统吞吐量\",{\"1\":{\"126\":1}}],[\"提示\",{\"1\":{\"140\":1,\"275\":1,\"329\":1}}],[\"提醒我保持好奇心\",{\"1\":{\"1\":1}}],[\"1分代收集理论\",{\"1\":{\"525\":1}}],[\"1代表xxx\",{\"1\":{\"508\":1}}],[\"1时\",{\"1\":{\"402\":1}}],[\"1s\",{\"1\":{\"338\":1}}],[\"1的记录加了\",{\"1\":{\"290\":1}}],[\"1的第一条记录\",{\"1\":{\"147\":1}}],[\"1w\",{\"1\":{\"282\":1}}],[\"1个\",{\"1\":{\"252\":1}}],[\"1个字符要占用多少字节\",{\"1\":{\"165\":1}}],[\"150m\",{\"1\":{\"453\":1}}],[\"150\",{\"1\":{\"393\":1,\"397\":3,\"407\":2,\"412\":6,\"441\":1,\"442\":1,\"447\":2,\"448\":1,\"461\":1}}],[\"15\",{\"1\":{\"187\":4,\"293\":14}}],[\"15k\",{\"1\":{\"187\":2}}],[\"151\",{\"1\":{\"139\":2}}],[\"1k\",{\"1\":{\"187\":5}}],[\"1g\",{\"1\":{\"182\":1}}],[\"1表示b+树非叶子节点记录\",{\"1\":{\"163\":1}}],[\"1字节8位\",{\"1\":{\"162\":1}}],[\"1mb\",{\"1\":{\"156\":1}}],[\"16\",{\"1\":{\"246\":1,\"257\":1,\"293\":3,\"337\":1,\"474\":1}}],[\"16384字节\",{\"1\":{\"168\":1}}],[\"16k\",{\"1\":{\"155\":2,\"184\":1,\"186\":1,\"187\":2,\"188\":1,\"243\":2}}],[\"16kb\",{\"1\":{\"155\":3,\"156\":1,\"168\":1,\"174\":1,\"243\":2,\"336\":1}}],[\"168\",{\"1\":{\"32\":1,\"40\":1,\"41\":4,\"43\":7,\"393\":1,\"397\":3,\"407\":2,\"412\":6,\"441\":1,\"442\":1,\"447\":2,\"448\":1,\"461\":1}}],[\"1195375010\",{\"1\":{\"436\":1,\"439\":1}}],[\"11\",{\"1\":{\"150\":1,\"161\":2,\"204\":1,\"243\":5,\"304\":1}}],[\"1146\",{\"1\":{\"144\":1}}],[\"11111\",{\"1\":{\"461\":1}}],[\"1111\",{\"1\":{\"43\":1}}],[\"13883976\",{\"1\":{\"350\":1}}],[\"1300000001\",{\"1\":{\"238\":3}}],[\"13\",{\"1\":{\"91\":1}}],[\"131\",{\"1\":{\"43\":1}}],[\"1设备\",{\"1\":{\"91\":1}}],[\"1+99\",{\"1\":{\"58\":1}}],[\"1`\",{\"1\":{\"43\":2}}],[\"17900\",{\"1\":{\"436\":1,\"439\":1}}],[\"17\",{\"1\":{\"43\":7,\"293\":3}}],[\"172\",{\"1\":{\"32\":1}}],[\"1ocalhost\",{\"1\":{\"42\":1}}],[\"18446744073709551615\",{\"1\":{\"183\":1}}],[\"1800\",{\"1\":{\"454\":1}}],[\"180\",{\"1\":{\"181\":1}}],[\"18\",{\"1\":{\"32\":1,\"240\":1,\"293\":3,\"367\":2}}],[\"126\",{\"1\":{\"216\":1}}],[\"122\",{\"1\":{\"216\":2}}],[\"12≈1280\",{\"1\":{\"187\":1}}],[\"12byte\",{\"1\":{\"187\":1}}],[\"1280\",{\"1\":{\"187\":3}}],[\"128\",{\"1\":{\"180\":1}}],[\"128mb\",{\"1\":{\"173\":1}}],[\"123\",{\"1\":{\"161\":1,\"379\":1}}],[\"12\",{\"1\":{\"89\":2,\"215\":1,\"243\":3,\"252\":1,\"256\":5,\"296\":1,\"297\":3}}],[\"129\",{\"1\":{\"43\":3}}],[\"1200\",{\"1\":{\"352\":1}}],[\"1200+\",{\"1\":{\"198\":1}}],[\"120\",{\"1\":{\"32\":1,\"181\":1,\"216\":1}}],[\"121\",{\"1\":{\"32\":1}}],[\"127\",{\"1\":{\"32\":3,\"38\":2,\"39\":2,\"451\":2,\"454\":2}}],[\"101\",{\"1\":{\"393\":1,\"397\":3,\"407\":2,\"412\":6,\"448\":1,\"461\":1}}],[\"1010\",{\"1\":{\"275\":1,\"277\":1}}],[\"10号\",{\"1\":{\"178\":1}}],[\"1081一年\",{\"1\":{\"91\":1}}],[\"100~1000\",{\"1\":{\"343\":1,\"349\":1}}],[\"1001做hash运算求余的结果为1\",{\"1\":{\"446\":1}}],[\"1001\",{\"1\":{\"280\":5}}],[\"1005\",{\"1\":{\"275\":1,\"277\":2}}],[\"1006\",{\"1\":{\"275\":9,\"277\":1,\"280\":8}}],[\"1008\",{\"1\":{\"274\":1,\"275\":2}}],[\"1007\",{\"1\":{\"274\":1,\"275\":1}}],[\"100w\",{\"1\":{\"182\":1}}],[\"10001时\",{\"1\":{\"445\":1}}],[\"10001\",{\"1\":{\"436\":1,\"446\":1}}],[\"1000代表什么含义\",{\"1\":{\"375\":1}}],[\"10000\",{\"1\":{\"373\":1,\"450\":2}}],[\"1000000\",{\"1\":{\"182\":1}}],[\"100000\",{\"1\":{\"149\":6}}],[\"1000w\",{\"1\":{\"182\":1}}],[\"1000\",{\"1\":{\"47\":1,\"104\":1,\"178\":1,\"187\":1,\"450\":6,\"453\":1}}],[\"100\",{\"1\":{\"43\":1,\"165\":2,\"182\":2,\"197\":1,\"302\":1,\"322\":1,\"323\":1,\"351\":6,\"356\":4,\"357\":5,\"358\":1,\"359\":5,\"360\":4,\"363\":1,\"368\":2,\"379\":1,\"419\":2,\"450\":2}}],[\"100k\",{\"1\":{\"32\":1}}],[\"10\",{\"1\":{\"32\":1,\"34\":1,\"150\":1,\"178\":1,\"182\":2,\"183\":1,\"187\":1,\"204\":1,\"205\":2,\"215\":1,\"216\":1,\"237\":4,\"238\":4,\"252\":2,\"275\":1,\"287\":1,\"294\":6,\"296\":1,\"297\":15,\"298\":4,\"304\":1,\"316\":1,\"348\":3,\"350\":1,\"373\":1,\"393\":1,\"405\":1,\"416\":2,\"419\":2}}],[\"1024\",{\"1\":{\"32\":2,\"182\":5,\"187\":2,\"520\":2}}],[\"19200\",{\"1\":{\"187\":1}}],[\"192\",{\"1\":{\"32\":1,\"40\":1,\"41\":4,\"43\":3,\"393\":1,\"397\":3,\"407\":2,\"412\":6,\"441\":1,\"442\":1,\"447\":2,\"448\":1,\"461\":1}}],[\"19\",{\"1\":{\"28\":1,\"29\":1,\"290\":1,\"293\":3,\"294\":2,\"304\":2}}],[\"1\",{\"0\":{\"60\":1,\"65\":1,\"68\":1,\"75\":1,\"80\":1,\"113\":1,\"114\":2,\"115\":1,\"116\":1,\"119\":1,\"122\":1,\"125\":1,\"129\":1,\"132\":1,\"134\":1,\"154\":1,\"161\":1,\"189\":1,\"193\":1,\"254\":1,\"263\":1,\"277\":1,\"290\":1,\"293\":1,\"296\":1,\"322\":1,\"372\":2,\"373\":3,\"374\":2,\"375\":2,\"376\":1,\"377\":2,\"378\":1,\"379\":1,\"380\":1,\"382\":1,\"384\":1,\"390\":1,\"391\":2,\"392\":1,\"393\":1,\"394\":1,\"396\":1,\"400\":1,\"402\":1,\"403\":1,\"405\":1,\"410\":1,\"416\":1,\"418\":1,\"421\":1,\"422\":1,\"424\":1,\"428\":1,\"432\":1,\"434\":1,\"438\":1,\"441\":1,\"446\":1,\"450\":1,\"453\":1,\"456\":1,\"458\":1,\"460\":1,\"472\":1,\"480\":1,\"483\":1,\"492\":1,\"498\":1,\"515\":1},\"1\":{\"7\":4,\"15\":1,\"28\":1,\"29\":1,\"32\":4,\"38\":2,\"39\":4,\"40\":2,\"41\":1,\"42\":3,\"43\":6,\"44\":1,\"48\":1,\"56\":1,\"57\":1,\"66\":1,\"72\":1,\"81\":1,\"96\":1,\"103\":1,\"108\":1,\"137\":2,\"139\":2,\"145\":2,\"147\":3,\"152\":3,\"158\":1,\"161\":2,\"162\":4,\"163\":1,\"165\":2,\"166\":5,\"169\":3,\"178\":3,\"182\":5,\"183\":2,\"187\":4,\"189\":1,\"191\":4,\"192\":2,\"193\":6,\"194\":4,\"195\":1,\"196\":2,\"197\":1,\"200\":1,\"205\":4,\"207\":2,\"210\":1,\"211\":2,\"212\":2,\"215\":1,\"216\":17,\"217\":1,\"219\":1,\"227\":1,\"231\":1,\"237\":5,\"238\":8,\"239\":2,\"240\":1,\"243\":3,\"244\":1,\"251\":1,\"254\":1,\"255\":1,\"256\":2,\"275\":2,\"283\":2,\"285\":3,\"287\":1,\"290\":13,\"291\":7,\"293\":1,\"294\":31,\"297\":1,\"304\":2,\"312\":5,\"314\":2,\"316\":1,\"322\":1,\"329\":1,\"330\":3,\"333\":1,\"338\":9,\"339\":2,\"341\":1,\"342\":3,\"343\":5,\"344\":4,\"347\":4,\"348\":3,\"349\":1,\"350\":2,\"358\":1,\"367\":5,\"373\":2,\"410\":1,\"411\":1,\"412\":1,\"416\":2,\"422\":1,\"425\":1,\"435\":1,\"436\":2,\"439\":3,\"441\":1,\"442\":3,\"443\":1,\"444\":1,\"447\":2,\"448\":4,\"450\":1,\"451\":4,\"453\":1,\"454\":4,\"456\":1,\"458\":1,\"460\":1,\"462\":1,\"463\":3,\"473\":1,\"474\":1,\"501\":1,\"502\":1,\"503\":1}}],[\"1400\",{\"1\":{\"352\":2}}],[\"14211427\",{\"1\":{\"350\":1}}],[\"14\",{\"1\":{\"2\":1}}],[\"31290\",{\"1\":{\"436\":1,\"439\":1}}],[\"364\",{\"1\":{\"436\":1,\"439\":1}}],[\"360buyimg\",{\"1\":{\"436\":1,\"439\":1}}],[\"36\",{\"1\":{\"436\":1,\"439\":1}}],[\"36893488147419103232\",{\"1\":{\"183\":1}}],[\"39\",{\"1\":{\"293\":2,\"296\":32,\"297\":19,\"298\":12,\"304\":2}}],[\"3~4\",{\"1\":{\"207\":2}}],[\"38\",{\"1\":{\"187\":1,\"296\":2,\"297\":2,\"298\":1}}],[\"384一年\",{\"1\":{\"91\":1}}],[\"32\",{\"1\":{\"183\":1}}],[\"328636728\",{\"1\":{\"110\":1}}],[\"37\",{\"1\":{\"178\":2}}],[\"3表示最大记录\",{\"1\":{\"163\":1}}],[\"3分钟掌握uml类图zhuanlan\",{\"1\":{\"70\":1}}],[\"30t16\",{\"1\":{\"436\":2,\"439\":2}}],[\"300\",{\"1\":{\"373\":1}}],[\"30\",{\"1\":{\"43\":1,\"178\":1,\"187\":2,\"216\":2,\"218\":1,\"244\":1,\"282\":1,\"288\":1,\"322\":5,\"323\":1,\"324\":1,\"325\":2}}],[\"3333\",{\"1\":{\"32\":1}}],[\"3\",{\"0\":{\"62\":1,\"71\":1,\"77\":1,\"82\":1,\"116\":1,\"124\":1,\"156\":1,\"163\":1,\"256\":1,\"265\":1,\"324\":1,\"375\":1,\"379\":1,\"380\":1,\"386\":1,\"387\":1,\"390\":1,\"391\":1,\"392\":1,\"393\":2,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":2,\"404\":1,\"405\":1,\"406\":1,\"407\":2,\"408\":1,\"421\":1,\"422\":1,\"423\":1,\"424\":1,\"425\":1,\"426\":2,\"427\":2,\"428\":2,\"429\":2,\"430\":3,\"436\":1,\"437\":1,\"438\":1,\"439\":1,\"443\":1,\"462\":1,\"463\":1,\"474\":1,\"489\":1,\"492\":1,\"493\":1,\"494\":2,\"495\":1,\"496\":1,\"500\":1,\"524\":1},\"1\":{\"7\":3,\"41\":1,\"42\":1,\"43\":3,\"56\":1,\"57\":1,\"66\":1,\"72\":1,\"81\":1,\"103\":1,\"160\":1,\"161\":1,\"166\":1,\"178\":5,\"186\":1,\"187\":8,\"205\":5,\"207\":1,\"215\":2,\"226\":1,\"239\":1,\"243\":7,\"249\":1,\"250\":1,\"252\":8,\"286\":1,\"287\":1,\"291\":3,\"294\":4,\"296\":2,\"304\":3,\"312\":3,\"315\":1,\"316\":1,\"317\":1,\"324\":2,\"341\":2,\"342\":1,\"365\":1,\"368\":1,\"373\":1,\"410\":1,\"412\":1,\"419\":1,\"422\":1,\"436\":1,\"439\":1,\"442\":1,\"443\":1,\"448\":2,\"450\":1,\"451\":1,\"454\":1,\"458\":1,\"463\":1,\"473\":1,\"501\":1,\"502\":1,\"503\":1,\"508\":1,\"525\":1}}],[\"06\",{\"1\":{\"281\":1}}],[\"09\",{\"1\":{\"281\":1}}],[\"0+4\",{\"1\":{\"243\":1}}],[\"0表示普通记录\",{\"1\":{\"163\":1}}],[\"04\",{\"1\":{\"161\":1,\"436\":2,\"439\":2}}],[\"01\",{\"1\":{\"161\":2,\"277\":3,\"293\":1,\"298\":1,\"322\":1,\"323\":1,\"350\":1,\"367\":2}}],[\"0100\",{\"1\":{\"47\":1}}],[\"03\",{\"1\":{\"161\":2,\"291\":1}}],[\"0x06\",{\"1\":{\"162\":1}}],[\"0x04\",{\"1\":{\"162\":1}}],[\"0x00\",{\"1\":{\"162\":1}}],[\"0x03\",{\"1\":{\"161\":1}}],[\"0x01\",{\"1\":{\"161\":1}}],[\"02\",{\"1\":{\"110\":1,\"161\":1,\"290\":1}}],[\"000+00\",{\"1\":{\"436\":2,\"439\":2}}],[\"000\",{\"1\":{\"419\":2}}],[\"0008\",{\"1\":{\"255\":1}}],[\"0004\",{\"1\":{\"255\":2}}],[\"0002\",{\"1\":{\"206\":2}}],[\"00001000\",{\"1\":{\"47\":1}}],[\"00000006\",{\"1\":{\"473\":1}}],[\"00000010\",{\"1\":{\"47\":1}}],[\"0000001\",{\"1\":{\"47\":1}}],[\"00000100\",{\"1\":{\"47\":1}}],[\"0001\",{\"1\":{\"47\":1}}],[\"0010\",{\"1\":{\"47\":1}}],[\"00\",{\"1\":{\"44\":9,\"139\":3,\"152\":1,\"290\":1,\"291\":1,\"293\":3,\"294\":4,\"296\":2,\"297\":2,\"298\":1,\"322\":1,\"323\":1,\"367\":5,\"436\":6,\"439\":6}}],[\"0版本做准备\",{\"1\":{\"12\":1}}],[\"0\",{\"1\":{\"7\":7,\"15\":1,\"28\":1,\"29\":1,\"32\":6,\"34\":1,\"38\":8,\"39\":8,\"43\":2,\"44\":3,\"108\":1,\"139\":4,\"140\":4,\"142\":1,\"144\":2,\"150\":1,\"152\":1,\"158\":2,\"162\":2,\"182\":1,\"186\":1,\"194\":2,\"234\":1,\"236\":1,\"238\":2,\"239\":1,\"243\":1,\"258\":2,\"277\":5,\"279\":1,\"280\":1,\"288\":1,\"290\":3,\"291\":3,\"293\":6,\"294\":6,\"296\":3,\"297\":3,\"298\":3,\"300\":1,\"303\":1,\"312\":1,\"313\":1,\"320\":1,\"322\":7,\"323\":7,\"330\":1,\"333\":1,\"338\":11,\"343\":2,\"351\":1,\"367\":11,\"451\":4,\"454\":4,\"473\":3,\"499\":2,\"516\":1}}],[\"05\",{\"1\":{\"2\":1}}],[\"597ece38n0ddcbc77\",{\"1\":{\"436\":1,\"439\":1}}],[\"53\",{\"1\":{\"359\":1}}],[\"52\",{\"1\":{\"359\":3,\"360\":1}}],[\"5k\",{\"1\":{\"187\":1}}],[\"56\",{\"1\":{\"187\":1}}],[\"5559454\",{\"1\":{\"181\":1}}],[\"5设备\",{\"1\":{\"91\":1}}],[\"500w\",{\"1\":{\"187\":1}}],[\"50\",{\"1\":{\"43\":3,\"281\":1,\"359\":2,\"360\":1}}],[\"512b\",{\"1\":{\"248\":1}}],[\"512m\",{\"1\":{\"182\":1}}],[\"51\",{\"1\":{\"43\":1,\"359\":6,\"360\":2}}],[\"54\",{\"1\":{\"32\":1}}],[\"5\",{\"0\":{\"125\":1,\"412\":1,\"445\":1,\"448\":1,\"456\":1,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"496\":1},\"1\":{\"7\":3,\"32\":1,\"34\":1,\"41\":4,\"43\":1,\"57\":1,\"66\":1,\"138\":2,\"139\":1,\"142\":1,\"144\":2,\"149\":2,\"152\":1,\"158\":3,\"178\":3,\"187\":1,\"194\":1,\"198\":1,\"202\":2,\"204\":2,\"205\":7,\"215\":2,\"216\":3,\"217\":2,\"226\":1,\"239\":3,\"243\":1,\"244\":1,\"251\":2,\"275\":1,\"279\":4,\"286\":1,\"287\":2,\"291\":13,\"294\":29,\"297\":3,\"302\":2,\"304\":3,\"312\":4,\"315\":1,\"316\":2,\"317\":1,\"324\":1,\"329\":1,\"342\":1,\"348\":4,\"356\":2,\"363\":2,\"365\":1,\"367\":12}}],[\"测试报告\",{\"1\":{\"76\":1}}],[\"测试同事说明需求中用户与系统功能单元之间的关系\",{\"1\":{\"59\":1}}],[\"测试完毕\",{\"1\":{\"15\":1}}],[\"测试完毕准备发布的时候\",{\"1\":{\"7\":1}}],[\"测试中出现的小问题\",{\"1\":{\"7\":1}}],[\"测试\",{\"1\":{\"6\":1}}],[\"稳定的最新版本分支\",{\"1\":{\"6\":1}}],[\"哨兵的作用如下\",{\"1\":{\"391\":1}}],[\"哨兵的结构如图\",{\"1\":{\"391\":1}}],[\"哨兵原理\",{\"0\":{\"390\":1}}],[\"哨兵\",{\"1\":{\"2\":1,\"97\":1}}],[\"分代收集\",{\"0\":{\"525\":1}}],[\"分\",{\"1\":{\"462\":1}}],[\"分两种情况\",{\"1\":{\"402\":1}}],[\"分两阶段来完成\",{\"1\":{\"345\":1}}],[\"分配\",{\"1\":{\"538\":1}}],[\"分配内存并\",{\"1\":{\"492\":1}}],[\"分配了一片内存\",{\"1\":{\"343\":1}}],[\"分配不同的任务\",{\"1\":{\"44\":1}}],[\"分组\",{\"1\":{\"246\":1}}],[\"分为两个步骤\",{\"1\":{\"352\":1}}],[\"分为聚簇和二级索引\",{\"1\":{\"257\":1}}],[\"分为聚簇索引\",{\"1\":{\"234\":1}}],[\"分为young\",{\"1\":{\"180\":1}}],[\"分类名称\",{\"1\":{\"462\":1}}],[\"分类和使用\",{\"1\":{\"229\":1}}],[\"分类\",{\"0\":{\"261\":1},\"1\":{\"203\":4}}],[\"分叉\",{\"1\":{\"187\":2}}],[\"分析如下\",{\"1\":{\"297\":2}}],[\"分析下下它加了什么锁\",{\"1\":{\"290\":1}}],[\"分析两个事务执行过程中\",{\"1\":{\"280\":1}}],[\"分析\",{\"1\":{\"272\":1,\"304\":1}}],[\"分析完要求后\",{\"1\":{\"248\":1}}],[\"分析和执行\",{\"1\":{\"138\":1}}],[\"分析问题构造模型\",{\"1\":{\"58\":1}}],[\"分功能或功能单元的相互关系可以用图来描述\",{\"1\":{\"53\":1}}],[\"分别对这两个区域按照实际情况采取适当的收集算法\",{\"1\":{\"525\":1}}],[\"分别保存商品\",{\"1\":{\"419\":1}}],[\"分别添加缓存\",{\"1\":{\"414\":1}}],[\"分别提出了避免幻读的方案\",{\"1\":{\"369\":1}}],[\"分别如下\",{\"1\":{\"352\":1}}],[\"分别介绍这三种行级锁\",{\"1\":{\"284\":1}}],[\"分别指向上一个数据页和下一个数据页\",{\"1\":{\"243\":1}}],[\"分别进行了扫描\",{\"1\":{\"240\":1}}],[\"分别支持的索引类型\",{\"1\":{\"204\":1}}],[\"分别为\",{\"1\":{\"164\":1}}],[\"分别详细说下\",{\"1\":{\"159\":1}}],[\"分别是读未提交\",{\"1\":{\"361\":1}}],[\"分别是主键索引和\",{\"1\":{\"304\":1}}],[\"分别是\",{\"1\":{\"158\":1,\"275\":1,\"290\":1,\"291\":1,\"293\":1,\"294\":1,\"297\":1,\"304\":1,\"322\":1,\"341\":1,\"344\":1,\"357\":1}}],[\"分别是顺序结构\",{\"1\":{\"56\":1}}],[\"分别是流程的输入资源\",{\"1\":{\"54\":1}}],[\"分别监听不同的端口\",{\"0\":{\"37\":1}}],[\"分别命名为feature\",{\"1\":{\"10\":1}}],[\"分支与合并\",{\"1\":{\"88\":1}}],[\"分支\",{\"1\":{\"7\":1}}],[\"分支用来做分模块功能开发\",{\"1\":{\"7\":1}}],[\"分支用来做版本发布的预发布分支\",{\"1\":{\"7\":1}}],[\"分支合并后会打上对应版本标签\",{\"1\":{\"7\":1}}],[\"分支进行修改提交\",{\"1\":{\"7\":1}}],[\"分支名称命名为hotfix\",{\"1\":{\"7\":1}}],[\"分支管理具体说明\",{\"0\":{\"7\":1}}],[\"分支管理\",{\"0\":{\"5\":1}}],[\"分片集群特征\",{\"1\":{\"400\":1}}],[\"分片集群\",{\"1\":{\"2\":1,\"97\":1}}],[\"分布式缓存\",{\"1\":{\"2\":1,\"97\":1,\"416\":1}}],[\"分享我所学到的知识和经验\",{\"1\":{\"1\":1}}],[\"更快这个问题\",{\"1\":{\"337\":1}}],[\"更新对象的计数器时\",{\"1\":{\"516\":1}}],[\"更新的时间复杂度是\",{\"1\":{\"473\":2}}],[\"更新时间\",{\"1\":{\"462\":1}}],[\"更新缓存\",{\"1\":{\"456\":1}}],[\"更新频率较低\",{\"1\":{\"456\":1}}],[\"更新了一条事务\",{\"1\":{\"369\":1}}],[\"更新了这条数据\",{\"1\":{\"355\":1}}],[\"更新后的数据\",{\"1\":{\"354\":1}}],[\"更新存储引擎中的数据\",{\"1\":{\"342\":2}}],[\"更新多少行数据就会产生多少条记录\",{\"1\":{\"341\":1}}],[\"更新语句的流程会涉及到\",{\"1\":{\"333\":1}}],[\"更新语句也是同样会走一遍\",{\"1\":{\"333\":1}}],[\"更新\",{\"1\":{\"311\":1,\"337\":1,\"341\":1,\"367\":1}}],[\"更新日志\",{\"0\":{\"2\":1}}],[\"更偏向于左外连接\",{\"1\":{\"264\":1}}],[\"更重要的是要考虑磁盘\",{\"1\":{\"258\":1}}],[\"更多关于\",{\"1\":{\"257\":1}}],[\"更适合进行关键字的范围查询\",{\"1\":{\"244\":1}}],[\"更加难以优化\",{\"1\":{\"227\":1}}],[\"更好的使多道程序并发执行\",{\"1\":{\"126\":1}}],[\"更好地展示每个价值活动的责任\",{\"1\":{\"58\":1}}],[\"更方便java开发者直接进行使用\",{\"1\":{\"99\":1}}],[\"更是一个提醒\",{\"1\":{\"1\":1}}],[\"探索未知\",{\"1\":{\"1\":1}}],[\"👏\",{\"0\":{\"100\":1}}],[\"👏我不生产知识\",{\"1\":{\"1\":1}}],[\"😺\",{\"0\":{\"99\":1}}],[\"👇\",{\"1\":{\"96\":5,\"97\":1}}],[\"🔝让我们一起在这个知识的海洋中航行\",{\"1\":{\"1\":1}}],[\"激发你的思考\",{\"1\":{\"1\":1}}],[\"这类似于导出\",{\"1\":{\"442\":1}}],[\"这类当前读的语句\",{\"1\":{\"368\":1,\"369\":1}}],[\"这类字段就比较适合做索引或排在联合索引列的靠前的位置\",{\"1\":{\"218\":1}}],[\"这场景确实很违和\",{\"1\":{\"367\":1}}],[\"这很好理解\",{\"1\":{\"365\":1}}],[\"这四种隔离级别具体是如何实现的呢\",{\"1\":{\"357\":1}}],[\"这四个隔离级别如下\",{\"1\":{\"357\":1}}],[\"这四条模糊匹配的查询语句\",{\"1\":{\"231\":1}}],[\"这取决于是否能在\",{\"1\":{\"346\":1}}],[\"这行数据的\",{\"1\":{\"344\":2}}],[\"这行数据的字段\",{\"1\":{\"344\":1}}],[\"这三个现象的严重性排序如下\",{\"1\":{\"357\":1}}],[\"这三个参数的数据安全性和写入性能的比较如下\",{\"1\":{\"338\":1}}],[\"这三个参数的应用场景是什么\",{\"1\":{\"338\":1}}],[\"这三个值分别代表的策略如下\",{\"1\":{\"338\":1}}],[\"这三个文件分别代表着\",{\"1\":{\"152\":1}}],[\"这三种日志\",{\"1\":{\"333\":1}}],[\"这属于\",{\"1\":{\"333\":1}}],[\"这属于计算机组成的知识\",{\"1\":{\"161\":1}}],[\"这主要是通过\",{\"1\":{\"312\":1}}],[\"这相当于把整个表给锁住了\",{\"1\":{\"304\":1}}],[\"这段话表明尽管插入意向锁是一种特殊的间隙锁\",{\"1\":{\"275\":1,\"324\":1}}],[\"这篇文章讲非唯一索引等值查询时\",{\"1\":{\"275\":1}}],[\"这会涉及多个节点的磁盘\",{\"1\":{\"252\":1,\"256\":1,\"258\":1}}],[\"这就导致应用的响应速度变慢\",{\"1\":{\"527\":1}}],[\"这就相当于将某个字节码加载到内存中\",{\"1\":{\"483\":1}}],[\"这就需要我们先把json变为lua的table\",{\"1\":{\"442\":1}}],[\"这就需要花费更多的磁盘\",{\"1\":{\"252\":1}}],[\"这就要说到全量同步时的repl\",{\"1\":{\"386\":1}}],[\"这就避免了由于事务\",{\"1\":{\"365\":1}}],[\"这就出现了幻读\",{\"1\":{\"365\":1}}],[\"这就叫\",{\"1\":{\"334\":1,\"361\":1}}],[\"这就意味着磁盘\",{\"1\":{\"251\":1}}],[\"这就是缓存与数据库的同步\",{\"1\":{\"455\":1}}],[\"这就是wal\",{\"1\":{\"343\":1,\"350\":1}}],[\"这就是一主多从的\",{\"1\":{\"342\":1}}],[\"这就是事务四大特性中的隔离性\",{\"1\":{\"307\":1}}],[\"这就是\",{\"1\":{\"178\":1,\"337\":1}}],[\"这就是表明使用了覆盖索引优化\",{\"1\":{\"145\":1}}],[\"这就是对象的生命线\",{\"1\":{\"81\":1}}],[\"这左旋右旋的操作\",{\"1\":{\"251\":1}}],[\"这必然是灾难性的\",{\"1\":{\"250\":1}}],[\"这句话\",{\"1\":{\"247\":1}}],[\"这点不用担心\",{\"1\":{\"243\":1}}],[\"这点没错\",{\"1\":{\"242\":1}}],[\"这\",{\"1\":{\"243\":1}}],[\"这代表着是通过全扫描二级索引的\",{\"1\":{\"232\":1}}],[\"这将不得不移动其它数据来满足新数据的插入\",{\"1\":{\"226\":1}}],[\"这也正是静态代理的缺点\",{\"1\":{\"506\":1}}],[\"这也是面试时最常问的知识的点\",{\"1\":{\"352\":1}}],[\"这也是\",{\"1\":{\"207\":1}}],[\"这也有助于清晰表明开发的状态\",{\"1\":{\"12\":1}}],[\"这已经比\",{\"1\":{\"207\":1}}],[\"这意味着修改这条记录的事务早就在创建\",{\"1\":{\"360\":1}}],[\"这意味着修改这条记录的事务早就在事务\",{\"1\":{\"359\":1}}],[\"这意味着\",{\"1\":{\"353\":1}}],[\"这意味着事务执行期间\",{\"1\":{\"310\":1}}],[\"这意味着从千万级的表查询目标数据最多需要\",{\"1\":{\"205\":1}}],[\"这意味着该用户连接完\",{\"1\":{\"139\":1}}],[\"这不是正好就是文章开头说的最大行数建议值\",{\"1\":{\"187\":1}}],[\"这边我们暂时按一条行数据\",{\"1\":{\"187\":1}}],[\"这组数据是在\",{\"1\":{\"182\":1}}],[\"这可因为脏页在刷新到磁盘时导致数据库性能抖动\",{\"1\":{\"180\":1}}],[\"这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销\",{\"1\":{\"179\":1}}],[\"这五个页\",{\"1\":{\"178\":1}}],[\"这片连续的内存空间中的缓存页既有空闲的\",{\"1\":{\"176\":1}}],[\"这部分不需要\",{\"1\":{\"166\":1}}],[\"这条新记录的\",{\"1\":{\"367\":1}}],[\"这条查询会加什么锁呢\",{\"1\":{\"304\":1}}],[\"这条查询语句\",{\"1\":{\"216\":3}}],[\"这条查询语句执行计划如下\",{\"1\":{\"216\":1}}],[\"这条查询语句只有\",{\"1\":{\"216\":1}}],[\"这条查询语句的时候\",{\"1\":{\"216\":1}}],[\"这条查询语句的查询条件没有用到索引\",{\"1\":{\"148\":1}}],[\"这条查询语句的查询条件用到了主键索引\",{\"1\":{\"147\":1}}],[\"这条查询语句的结果既可以使用主键索引\",{\"1\":{\"145\":1}}],[\"这条记录进行了更新操作\",{\"1\":{\"367\":1}}],[\"这条记录并且提交事务了\",{\"1\":{\"365\":1}}],[\"这条记录是被还未提交的事务修改的\",{\"1\":{\"360\":1}}],[\"这条记录加锁\",{\"1\":{\"329\":1}}],[\"这条记录加上了\",{\"1\":{\"280\":1}}],[\"这条记录的主键索引加记录锁\",{\"1\":{\"298\":2}}],[\"这条记录的主键索引上\",{\"1\":{\"293\":4,\"294\":9,\"297\":2,\"298\":2}}],[\"这条记录的二级索引索引上加了范围为\",{\"1\":{\"297\":1}}],[\"这条记录的二级索引上有\",{\"1\":{\"297\":1}}],[\"这条记录的二级索引上\",{\"1\":{\"297\":4,\"298\":2}}],[\"这条记录\",{\"1\":{\"287\":1,\"291\":1,\"316\":1,\"367\":2}}],[\"这条记录了\",{\"1\":{\"286\":1,\"315\":1,\"365\":1}}],[\"这条记录上一个版本的指针\",{\"1\":{\"164\":1}}],[\"这条语句来看看事务\",{\"1\":{\"293\":2,\"294\":3,\"296\":1,\"297\":1}}],[\"这条语句来说是这个意思\",{\"1\":{\"194\":1}}],[\"这条语句\",{\"1\":{\"275\":1,\"290\":1,\"291\":1,\"304\":2,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1}}],[\"这条语句使用了主键索引查询\",{\"1\":{\"205\":1}}],[\"这条语句是统计\",{\"1\":{\"191\":2}}],[\"这两份日志的一致性了\",{\"1\":{\"346\":1}}],[\"这两份日志的时候\",{\"1\":{\"344\":1}}],[\"这两个解决方案是很大程度上解决了幻读现象\",{\"1\":{\"362\":1}}],[\"这两个事务同时在处理\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"这两个日志有四个区别\",{\"1\":{\"341\":1}}],[\"这两个日志都是\",{\"1\":{\"340\":1}}],[\"这两个\",{\"1\":{\"339\":1}}],[\"这两个隔离级别实现是通过\",{\"1\":{\"334\":1,\"361\":1}}],[\"这两个锁是冲突的\",{\"1\":{\"280\":1}}],[\"这两个区别在前面也提到了\",{\"1\":{\"208\":1}}],[\"这两个行格式和\",{\"1\":{\"168\":1}}],[\"这两个行格式跟\",{\"1\":{\"158\":1}}],[\"这两种开启事务的命令\",{\"1\":{\"357\":1}}],[\"这两种日志是属于\",{\"1\":{\"337\":1}}],[\"这两种查询会加锁的语句称为锁定读\",{\"1\":{\"283\":1}}],[\"这两种方式都会造成索引失效\",{\"1\":{\"228\":1,\"235\":1,\"241\":1}}],[\"这两种格式采用完全的行溢出方式\",{\"1\":{\"168\":1,\"169\":1}}],[\"这两种图合称为交互图\",{\"1\":{\"86\":1}}],[\"这一类数据使用相同的有效部分\",{\"1\":{\"403\":1}}],[\"这一行所在的数据页本来就在\",{\"1\":{\"343\":1,\"350\":1}}],[\"这一行加记录锁\",{\"1\":{\"297\":1}}],[\"这一行记录的主键索引加记录锁\",{\"1\":{\"298\":2}}],[\"这一行记录的锁会退化成间隙锁\",{\"1\":{\"294\":1}}],[\"这一行记录\",{\"1\":{\"293\":2,\"343\":1,\"350\":1}}],[\"这一些记录的话\",{\"1\":{\"291\":1}}],[\"这一重写\",{\"1\":{\"282\":1}}],[\"这一级别及以上的\",{\"1\":{\"228\":1}}],[\"这一个知识点\",{\"1\":{\"151\":1}}],[\"这一点从定义上也不难看出\",{\"1\":{\"68\":1}}],[\"这次将重点介绍事务的隔离性\",{\"1\":{\"352\":1}}],[\"这次就说到这啦\",{\"1\":{\"331\":1}}],[\"这次事务\",{\"1\":{\"329\":1}}],[\"这次我们就来看看\",{\"1\":{\"328\":1}}],[\"这次我以\",{\"1\":{\"300\":1}}],[\"这次我跟大家聊聊\",{\"1\":{\"151\":1}}],[\"这次实验环境的\",{\"1\":{\"288\":1}}],[\"这次会以下面这个表结构来进行实验说明\",{\"1\":{\"288\":1}}],[\"这次\",{\"1\":{\"242\":1,\"247\":1,\"306\":1,\"362\":1}}],[\"这次主要介绍了索引的原理\",{\"1\":{\"229\":1}}],[\"这次重点介绍\",{\"1\":{\"158\":1}}],[\"这次产品发布包含的功能也就固定下来了\",{\"1\":{\"12\":1}}],[\"这张表的字段没有\",{\"1\":{\"232\":1}}],[\"这张表数据\",{\"1\":{\"184\":1}}],[\"这张表是不存在的\",{\"1\":{\"144\":1}}],[\"这张\",{\"1\":{\"145\":1}}],[\"这位老哥专门写\",{\"1\":{\"144\":1}}],[\"这时需要将虚引用对象放入引用队列中\",{\"1\":{\"522\":1}}],[\"这时事务\",{\"1\":{\"359\":1,\"360\":1}}],[\"这时我们就要使用\",{\"1\":{\"331\":1}}],[\"这时我们就需要考虑如何建立合适的索引\",{\"1\":{\"244\":1}}],[\"这时我们就需要查看执行计划\",{\"1\":{\"228\":1}}],[\"这时会判断到插入的位置已经被事务\",{\"1\":{\"317\":1}}],[\"这时从库是按\",{\"1\":{\"312\":1}}],[\"这时数据库的线程很快就会爆满了\",{\"1\":{\"310\":1}}],[\"这时线程\",{\"1\":{\"310\":1}}],[\"这时其他线程执行以下操作\",{\"1\":{\"307\":1}}],[\"这时如果其他事务对该表进行增\",{\"1\":{\"299\":1}}],[\"这时在二级索引找到主键值后\",{\"1\":{\"245\":1}}],[\"这时因为字符串部分是输入参数\",{\"1\":{\"238\":1}}],[\"这时不得不选择相应的排序算法进行\",{\"1\":{\"228\":1}}],[\"这时就发生了幻读的现象\",{\"1\":{\"297\":1}}],[\"这时就要用文件排序\",{\"1\":{\"219\":1}}],[\"这时就是有序的\",{\"1\":{\"215\":1}}],[\"这时就不用再去主键索引中查寻了\",{\"1\":{\"206\":1}}],[\"这时一个页可能就存不了一条记录\",{\"1\":{\"168\":1}}],[\"这时候\",{\"1\":{\"365\":1}}],[\"这时候的性能是最好的\",{\"1\":{\"343\":1}}],[\"这时候我们擦除这些旧记录\",{\"1\":{\"339\":1}}],[\"这时候就\",{\"1\":{\"296\":1}}],[\"这时候就会走索引了\",{\"1\":{\"236\":1}}],[\"这时候要注意了\",{\"1\":{\"236\":1}}],[\"这时候怎么表示\",{\"1\":{\"162\":1}}],[\"这时候表里的行格式就不会有\",{\"1\":{\"161\":1,\"162\":1}}],[\"这时\",{\"1\":{\"142\":1,\"144\":1,\"145\":2,\"199\":1,\"312\":1,\"339\":1,\"359\":1}}],[\"这么看\",{\"1\":{\"140\":1}}],[\"这么看来直接传输密钥无论怎样都无法摆脱俄罗斯套娃的难题\",{\"1\":{\"106\":1}}],[\"这么描述可能还不够清晰\",{\"1\":{\"83\":1}}],[\"这还属于比较简单的顺序图\",{\"1\":{\"84\":1}}],[\"这是我的钱包\",{\"1\":{\"351\":1}}],[\"这是不对的\",{\"1\":{\"329\":1}}],[\"这是通过对主键字段声明\",{\"1\":{\"312\":1}}],[\"这是挺严重的问题\",{\"1\":{\"299\":1,\"300\":1,\"304\":1,\"305\":1}}],[\"这是读已提交隔离级别中为数不多的给记录添加间隙锁的场景\",{\"1\":{\"278\":1}}],[\"这是为什么呢\",{\"1\":{\"232\":1}}],[\"这是由于你的临时表内存设置的不够大\",{\"1\":{\"182\":1}}],[\"这是因为申请\",{\"1\":{\"310\":1}}],[\"这是因为事务\",{\"1\":{\"304\":1,\"325\":1,\"329\":1}}],[\"这是因为主键有唯一性的约束\",{\"1\":{\"285\":1}}],[\"这是因为\",{\"1\":{\"238\":1,\"240\":1,\"337\":1,\"344\":1}}],[\"这是因为每张\",{\"1\":{\"197\":1}}],[\"这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间\",{\"1\":{\"192\":1}}],[\"这是因为只有这些虚拟内存被访问后\",{\"1\":{\"174\":1,\"336\":1}}],[\"这是因为我们存储字段类型为\",{\"1\":{\"166\":1}}],[\"这是表示电梯运行状态的一张状态图\",{\"1\":{\"85\":1}}],[\"这是push流程的一张顺序图\",{\"1\":{\"84\":1}}],[\"这是一个部门维度的泳道图\",{\"1\":{\"58\":1}}],[\"这些内存都将在方法区中进行分配\",{\"1\":{\"492\":1}}],[\"这些内容我下次在讲啦\",{\"1\":{\"246\":1}}],[\"这些语句执行前都会查询最新版本的数据\",{\"1\":{\"365\":1}}],[\"这些现象会对事务的一致性产生不同程度的影响\",{\"1\":{\"357\":1}}],[\"这些缓存在\",{\"1\":{\"346\":1}}],[\"这些函数\",{\"1\":{\"341\":1}}],[\"这些新记录\",{\"1\":{\"296\":2}}],[\"这些插入语句都会发生阻塞\",{\"1\":{\"291\":1}}],[\"这些操作都会被阻塞\",{\"1\":{\"290\":1}}],[\"这些条件必然成立\",{\"1\":{\"281\":1}}],[\"这些冗余索引让\",{\"1\":{\"258\":1}}],[\"这些地址偏移量会按照先后顺序存储起来\",{\"1\":{\"243\":1}}],[\"这些记录包括最小记录和最大记录\",{\"1\":{\"243\":1}}],[\"这些情况下都会造成索引失效\",{\"1\":{\"228\":1}}],[\"这些行数据\",{\"1\":{\"204\":1}}],[\"这些名言民语就和\",{\"1\":{\"181\":1}}],[\"这些页都会被逐一访问\",{\"1\":{\"178\":1}}],[\"这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放\",{\"1\":{\"161\":1}}],[\"这些问题是如何发生的\",{\"1\":{\"353\":1}}],[\"这些问题就引刃而解了\",{\"1\":{\"151\":1}}],[\"这些问题看似毫不相干\",{\"1\":{\"151\":1}}],[\"这些连接对象资源只有在连接断开时才会释放\",{\"1\":{\"139\":1}}],[\"这些工具却能抓包出明文来\",{\"1\":{\"110\":1}}],[\"这些中间人能抓取\",{\"1\":{\"108\":1}}],[\"这些\",{\"1\":{\"108\":1}}],[\"这些对象会按调用时间顺序排序\",{\"1\":{\"83\":1}}],[\"这些最佳实践在对大规模\",{\"1\":{\"58\":1}}],[\"这被称为用例泛化\",{\"1\":{\"61\":1}}],[\"这种动态获取信息以及动态调用对象方法的功能称为\",{\"1\":{\"481\":1}}],[\"这种failover命令可以指定三种模式\",{\"1\":{\"411\":1}}],[\"这种通过\",{\"1\":{\"358\":1}}],[\"这种现象就被称为幻读\",{\"1\":{\"356\":1}}],[\"这种现象就被称为不可重复读\",{\"1\":{\"355\":1}}],[\"这种现象就被称为脏读\",{\"1\":{\"354\":1}}],[\"这种情况\",{\"1\":{\"346\":1}}],[\"这种情况下\",{\"1\":{\"307\":1}}],[\"这种情况下状态图明显在结构上要比流程图要更简单\",{\"1\":{\"85\":1}}],[\"这种\",{\"1\":{\"342\":1}}],[\"这种模式一旦主库宕机\",{\"1\":{\"342\":1}}],[\"这种方式在实际项目中\",{\"1\":{\"342\":1}}],[\"这种方法只适用于支持\",{\"1\":{\"307\":1}}],[\"这种方法的时间复杂度是\",{\"1\":{\"249\":1}}],[\"这种格式的日志\",{\"1\":{\"341\":1}}],[\"这种随时在变的函数会导致复制的数据不一致\",{\"1\":{\"341\":1}}],[\"这种不支持事务的引擎\",{\"1\":{\"307\":1}}],[\"这种机制称为隐式锁\",{\"1\":{\"276\":1}}],[\"这种设计对范围查找非常有帮助\",{\"1\":{\"256\":1}}],[\"这种其实严格意义上来说是属于索引截断\",{\"1\":{\"239\":1}}],[\"这种对索引进行简单的表达式计算\",{\"1\":{\"237\":1}}],[\"这种时间随着数据量的增加而增大\",{\"1\":{\"220\":1}}],[\"这种特殊情况就发生在范围查询\",{\"1\":{\"216\":1}}],[\"这种查询语句是当前读\",{\"1\":{\"365\":1}}],[\"这种查询会加锁的语句称为锁定读\",{\"1\":{\"313\":1}}],[\"这种查询条件没有办法利用联合索引的\",{\"1\":{\"215\":1}}],[\"这种查询扫描的方式是效率最低档次的\",{\"1\":{\"145\":1}}],[\"这种在二级索引的\",{\"1\":{\"206\":1}}],[\"这种大对象类型\",{\"1\":{\"166\":1}}],[\"这种大对象类型之外\",{\"1\":{\"165\":1}}],[\"这种可见性它分为3种\",{\"1\":{\"73\":1}}],[\"这种结构最简单\",{\"1\":{\"56\":1}}],[\"这种由分功能或功能单元按照其逻辑关系连成的结构称为功能结构\",{\"1\":{\"53\":1}}],[\"这种为解决紧急问题专设的绿色通道\",{\"1\":{\"13\":1}}],[\"这里只展示其中一个实现类\",{\"1\":{\"508\":1}}],[\"这里只关注在记录上加锁的类型\",{\"1\":{\"277\":2,\"280\":2}}],[\"这里给商品基本信息设置超时时间为30分钟\",{\"1\":{\"454\":1}}],[\"这里查询到的结果是json字符串\",{\"1\":{\"442\":1}}],[\"这里是windows电脑的ip和java服务端口\",{\"1\":{\"441\":1}}],[\"这里是图片站位\",{\"1\":{\"95\":1}}],[\"这里的腾出内存空间并不是将内存空间的字节清0\",{\"1\":{\"527\":1}}],[\"这里的common是函数库的文件名\",{\"1\":{\"442\":1}}],[\"这里的path是路径\",{\"1\":{\"441\":1}}],[\"这里的共同间隙包括两种场景\",{\"1\":{\"275\":1}}],[\"这里询问\",{\"1\":{\"408\":1}}],[\"这里需要两个新的功能\",{\"1\":{\"405\":1}}],[\"这里就会涉及磁盘\",{\"1\":{\"343\":1}}],[\"这里就简单做个比对\",{\"1\":{\"207\":1}}],[\"这里举个例子\",{\"1\":{\"329\":1}}],[\"这里举个多字段的情况的例子\",{\"1\":{\"167\":1}}],[\"这里\",{\"1\":{\"279\":1,\"280\":1}}],[\"这里不说组提交的过程\",{\"1\":{\"350\":1}}],[\"这里不考虑这种情况\",{\"1\":{\"278\":1}}],[\"这里不仅是一个知识库\",{\"1\":{\"1\":1}}],[\"这里在查询记录是否存在的时候\",{\"1\":{\"274\":1}}],[\"这里有一个问题\",{\"1\":{\"384\":1}}],[\"这里有一张数据库表\",{\"1\":{\"329\":1}}],[\"这里有一张\",{\"1\":{\"234\":1}}],[\"这里有个问题\",{\"1\":{\"243\":1}}],[\"这里简单说一下\",{\"1\":{\"228\":1}}],[\"这里出一个题目\",{\"1\":{\"219\":1}}],[\"这里我们利用initializingbean接口来实现\",{\"1\":{\"448\":1}}],[\"这里我们先根据商品id去tomcat查询商品信息\",{\"1\":{\"440\":1}}],[\"这里我们要从7001获取\",{\"1\":{\"408\":1}}],[\"这里我们重点关注\",{\"1\":{\"304\":1}}],[\"这里我们重点关注行级锁\",{\"1\":{\"290\":1}}],[\"这里我们重点关注行锁\",{\"1\":{\"275\":1,\"322\":1}}],[\"这里我们列举两个场景\",{\"1\":{\"276\":1}}],[\"这里我们只讨论\",{\"1\":{\"216\":1}}],[\"这里我们再看另一种加密方式\",{\"1\":{\"107\":1}}],[\"这里说几个重要的参考指标\",{\"1\":{\"228\":1}}],[\"这里说几个比较重要的\",{\"1\":{\"163\":1}}],[\"这里说一下几种常见优化索引的方法\",{\"1\":{\"223\":1}}],[\"这里说的查询缓存是\",{\"1\":{\"140\":1}}],[\"这里说的是最大连接数\",{\"1\":{\"48\":1}}],[\"这里一张用户表如下\",{\"1\":{\"149\":1}}],[\"这里贴个\",{\"1\":{\"144\":1}}],[\"这里同样不再赘述\",{\"1\":{\"70\":1}}],[\"这样一来程序开发中必然产生过多的代理\",{\"1\":{\"506\":1}}],[\"这样插槽转移就准备好了\",{\"1\":{\"408\":1}}],[\"这样数组头部的数据就会被覆盖\",{\"1\":{\"386\":1}}],[\"这样不是会产生冲突吗\",{\"1\":{\"365\":1}}],[\"这样不仅增多磁盘\",{\"1\":{\"252\":1}}],[\"这样即使写请求会锁表或者锁记录\",{\"1\":{\"342\":1}}],[\"这样即使使用索引快速查找到了第一条数据\",{\"1\":{\"228\":1}}],[\"这样下次有查询语句命中了这条记录\",{\"1\":{\"335\":1}}],[\"这样之后回滚时再把这些列更新为旧值就好了\",{\"1\":{\"334\":1}}],[\"这样之后回滚时再把由这些内容组成的记录插入到表中就好了\",{\"1\":{\"334\":1}}],[\"这样之后回滚时只需要把这个主键值对应的记录删掉就好了\",{\"1\":{\"334\":1}}],[\"这样效率会很慢\",{\"1\":{\"311\":1}}],[\"这样效率太低了\",{\"1\":{\"176\":1}}],[\"这样备份期间备份的数据一直是在开启事务时的数据\",{\"1\":{\"307\":1}}],[\"这样会造成业务停滞\",{\"1\":{\"307\":1}}],[\"这样会发生\",{\"1\":{\"139\":1}}],[\"这样前后两次查询的结果集就不相同了\",{\"1\":{\"298\":1}}],[\"这样前后两次查询的结果集就不会出现不相同的情况\",{\"1\":{\"290\":1}}],[\"这样事务\",{\"1\":{\"290\":2}}],[\"这样其他事务就无法对这条记录进行修改了\",{\"1\":{\"314\":1}}],[\"这样其他事务就无法对\",{\"1\":{\"290\":1}}],[\"这样删除非常快\",{\"1\":{\"255\":1}}],[\"这样使得删除一个节点的时候\",{\"1\":{\"255\":1}}],[\"这样查询操作的时间复杂度就会一直维持在\",{\"1\":{\"251\":1}}],[\"这样导致查询性能严重下降\",{\"1\":{\"250\":1}}],[\"这样时间复杂度就降到了\",{\"1\":{\"249\":1}}],[\"这样所需要进行的磁盘\",{\"1\":{\"244\":1}}],[\"这样做的好处就是避免了全表扫描\",{\"1\":{\"240\":1}}],[\"这样做的好处是不再需要对数据进行排序\",{\"1\":{\"228\":1}}],[\"这样做的好处是\",{\"1\":{\"7\":1}}],[\"这样实在太累了\",{\"1\":{\"232\":1}}],[\"这样二级索引占用的空间也就越小\",{\"1\":{\"226\":1}}],[\"这样在\",{\"1\":{\"312\":1}}],[\"这样在备份数据库期间\",{\"1\":{\"307\":1}}],[\"这样在插入的时候\",{\"1\":{\"250\":1}}],[\"这样在查询的时候就不需要再去做一次排序了\",{\"1\":{\"221\":1}}],[\"这样在没有遵循最左匹配原则的情况下\",{\"1\":{\"215\":1}}],[\"这样能够提高整个表的查询速度\",{\"1\":{\"221\":1}}],[\"这样能清晰地了解任务转交的流程\",{\"1\":{\"58\":1}}],[\"这样根据\",{\"1\":{\"219\":1}}],[\"这样区分度大的字段越有可能被更多的\",{\"1\":{\"218\":1}}],[\"这样优化器会自动采用\",{\"1\":{\"196\":1}}],[\"这样遍历二级索引的\",{\"1\":{\"192\":1}}],[\"这样我们在查询数据时\",{\"1\":{\"250\":1}}],[\"这样我们也就能大概估算这样的结构能存放多少数据了\",{\"1\":{\"187\":1}}],[\"这样我们就只要找一级\",{\"1\":{\"109\":1}}],[\"这样性能是极差的\",{\"1\":{\"172\":1}}],[\"这样可以通过位运算来计算hash值\",{\"1\":{\"475\":1}}],[\"这样可以明显地减少日志同步到磁盘的\",{\"1\":{\"338\":1}}],[\"这样可以保证hash值分布更均匀\",{\"1\":{\"475\":1}}],[\"这样可以保证最高位为1\",{\"1\":{\"475\":1}}],[\"这样可以保证\",{\"1\":{\"338\":1}}],[\"这样可以预防\",{\"1\":{\"331\":1}}],[\"这样可以避免其他事务执行增\",{\"1\":{\"305\":1}}],[\"这样可以使用\",{\"1\":{\"249\":1}}],[\"这样可以至少节省\",{\"1\":{\"162\":1}}],[\"这样可节省\",{\"1\":{\"169\":1}}],[\"这样的批量插入数据的语句\",{\"1\":{\"312\":1}}],[\"这样的好处是既能向右遍历\",{\"1\":{\"257\":1}}],[\"这样的好处是向左读就是记录头信息\",{\"1\":{\"161\":1,\"163\":1}}],[\"这样的话就解决了公钥传输过程中被调包的风险\",{\"1\":{\"108\":1}}],[\"这样的话\",{\"1\":{\"108\":3}}],[\"这样的话对于\",{\"1\":{\"107\":1}}],[\"这样理解起来不会觉得很抽象\",{\"1\":{\"157\":1}}],[\"这样大家能清楚的知道\",{\"1\":{\"149\":1}}],[\"这样就发生了读写冲突\",{\"1\":{\"357\":1}}],[\"这样就没办法对\",{\"1\":{\"348\":1}}],[\"这样就使得多个阶段可以并发执行\",{\"1\":{\"348\":1}}],[\"这样就使得链表中相邻的页的物理位置也相邻\",{\"1\":{\"156\":1}}],[\"这样就造成两份日志之间的逻辑不一致\",{\"1\":{\"344\":1}}],[\"这样就很容易理解这些加锁的规则了\",{\"1\":{\"300\":1}}],[\"这样就相当于锁住的全表\",{\"1\":{\"299\":2}}],[\"这样就避免幻读现象的发生\",{\"1\":{\"297\":1}}],[\"这样就有效的防止幻读现象的发生\",{\"1\":{\"286\":1,\"315\":1,\"365\":1}}],[\"这样就会出现前后两次查询的结果集合不一样\",{\"1\":{\"365\":1}}],[\"这样就会增加磁盘的\",{\"1\":{\"252\":1}}],[\"这样就会输出这条\",{\"1\":{\"145\":1}}],[\"这样就不用去遍历表里的记录\",{\"1\":{\"311\":1}}],[\"这样就不需要从根节点查询了\",{\"1\":{\"256\":1}}],[\"这样就不是在索引字段进行表达式计算了\",{\"1\":{\"237\":1}}],[\"这样就不会影响\",{\"1\":{\"178\":1}}],[\"这样就无法利用到索引快速查询的特性了\",{\"1\":{\"215\":1}}],[\"这样就保证了在事务期间读到的数据都是事务启动前的记录\",{\"1\":{\"334\":1,\"361\":1}}],[\"这样就保证了执行完\",{\"1\":{\"334\":1}}],[\"这样就保证了\",{\"1\":{\"207\":1}}],[\"这样就解决了\",{\"1\":{\"178\":1}}],[\"这样就解决了冒充风险\",{\"1\":{\"104\":1}}],[\"这样就大大降低了缓存命中率\",{\"1\":{\"178\":1}}],[\"这样就可以保证\",{\"1\":{\"346\":1}}],[\"这样就可以提高\",{\"1\":{\"161\":1}}],[\"这样就可以使用顺序\",{\"1\":{\"156\":1}}],[\"这样方便后面模块获取\",{\"1\":{\"142\":1}}],[\"这样客户端会按如下步骤进行验证\",{\"1\":{\"109\":1}}],[\"这样你们只要把\",{\"1\":{\"109\":1}}],[\"这样\",{\"1\":{\"108\":1,\"348\":1}}],[\"这样当\",{\"1\":{\"108\":1}}],[\"这样交换了密钥之后就可以用对称加密密钥通信了\",{\"1\":{\"107\":1}}],[\"这样中间人就可以用截获的密钥解密报文\",{\"1\":{\"106\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"41\":1}}],[\"这个加载的过程需要类加载器参与\",{\"1\":{\"492\":1}}],[\"这个对象就像一面镜子\",{\"1\":{\"480\":1}}],[\"这个对象就包含了完整的类的结构信息\",{\"1\":{\"480\":1}}],[\"这个工具将read\",{\"1\":{\"442\":1}}],[\"这个工作是由\",{\"1\":{\"146\":1}}],[\"这个工作交由\",{\"1\":{\"141\":1,\"145\":1}}],[\"这个请求会被nginx内部的server监听并处理\",{\"1\":{\"441\":1}}],[\"这个请求如下\",{\"1\":{\"434\":1}}],[\"这个监听\",{\"1\":{\"435\":1}}],[\"这个bean中配置的就是读写策略\",{\"1\":{\"398\":1}}],[\"这个文件是一个固定大小的数组\",{\"1\":{\"386\":1}}],[\"这个文件也称为独占表空间文件\",{\"1\":{\"152\":1}}],[\"这个命令执行后会开启独立进程完成rdb\",{\"1\":{\"373\":1}}],[\"这个隐藏列是个指针\",{\"1\":{\"358\":1}}],[\"这个并不是\",{\"1\":{\"358\":1}}],[\"这个方法是基于\",{\"1\":{\"349\":1}}],[\"这个等待的时长由\",{\"1\":{\"348\":1}}],[\"这个优化是将\",{\"1\":{\"348\":1}}],[\"这个要看\",{\"1\":{\"348\":1}}],[\"这个问题跟\",{\"1\":{\"340\":1}}],[\"这个问题我们有两个答案\",{\"1\":{\"337\":1}}],[\"这个默认的行为\",{\"1\":{\"338\":1}}],[\"这个策略可由\",{\"1\":{\"338\":1}}],[\"这个能力称为\",{\"1\":{\"337\":1}}],[\"这个链表就被称为版本链\",{\"1\":{\"334\":1}}],[\"这个链表称为\",{\"1\":{\"176\":1}}],[\"这个索引\",{\"1\":{\"333\":1}}],[\"这个锁并不是执行完\",{\"1\":{\"329\":1}}],[\"这个结论其实还不够准确\",{\"1\":{\"296\":1}}],[\"这个表中看到\",{\"1\":{\"280\":1}}],[\"这个表达式就是单纯数字\",{\"1\":{\"191\":1}}],[\"这个表达式不为\",{\"1\":{\"191\":1}}],[\"这个表达式\",{\"1\":{\"191\":1}}],[\"这个时候更新就算完成了\",{\"1\":{\"337\":1,\"343\":1,\"350\":1}}],[\"这个时候可以先查找到\",{\"1\":{\"256\":1}}],[\"这个时候就会\",{\"1\":{\"168\":1}}],[\"这个是在执行事务\",{\"1\":{\"280\":1}}],[\"这个是维基百科里的定义\",{\"1\":{\"255\":1}}],[\"这个是字符串比较\",{\"1\":{\"238\":1}}],[\"这个思考题其实是出自于\",{\"1\":{\"230\":1}}],[\"这个有序状态是局部的\",{\"1\":{\"215\":1}}],[\"这个字符的时候\",{\"1\":{\"194\":1}}],[\"这个影响的因素就会多很多\",{\"1\":{\"187\":1}}],[\"这个就是数字比较\",{\"1\":{\"238\":1}}],[\"这个就是覆盖索引\",{\"1\":{\"232\":1}}],[\"这个就是我们常说的\",{\"1\":{\"186\":1}}],[\"这个就是预读失效\",{\"1\":{\"178\":1}}],[\"这个部分\",{\"1\":{\"185\":1}}],[\"这个不用担心\",{\"1\":{\"179\":1}}],[\"这个间隔时间是由\",{\"1\":{\"178\":1}}],[\"这个过程中其它所有命令都会被阻塞\",{\"1\":{\"373\":1}}],[\"这个过程一般是异步的\",{\"1\":{\"342\":1}}],[\"这个过程就称为类的加载\",{\"1\":{\"483\":1}}],[\"这个过程就叫作\",{\"1\":{\"245\":2,\"246\":1}}],[\"这个过程就是回表\",{\"1\":{\"208\":1}}],[\"这个过程就是覆盖索引\",{\"1\":{\"208\":1}}],[\"这个过程是会影响数据库性能的\",{\"1\":{\"222\":1}}],[\"这个过程叫做覆盖索引\",{\"1\":{\"234\":1}}],[\"这个过程叫\",{\"1\":{\"206\":1}}],[\"这个过程的图示如下\",{\"1\":{\"185\":1}}],[\"这个过程被称为\",{\"1\":{\"178\":1}}],[\"这个过程并不会有页被淘汰\",{\"1\":{\"178\":1}}],[\"这个过程不需要重连和重新做权限验证\",{\"1\":{\"139\":1}}],[\"这个页只会被插入到\",{\"1\":{\"178\":1}}],[\"这个用不到的那点儿内存空间就被称为碎片了\",{\"1\":{\"174\":1}}],[\"这个\",{\"1\":{\"166\":1,\"232\":1,\"312\":1}}],[\"这个设计是有想法的\",{\"1\":{\"161\":1}}],[\"这个设置可以放入全局块\",{\"1\":{\"32\":1}}],[\"这个行为是由参数\",{\"1\":{\"152\":1}}],[\"这个动作\",{\"1\":{\"149\":1}}],[\"这个语句就执行完成了\",{\"1\":{\"147\":1,\"148\":1}}],[\"这个函数指针被指向为一个永远返回\",{\"1\":{\"147\":1}}],[\"这个函数指针被指向为\",{\"1\":{\"147\":1,\"148\":1}}],[\"这个查询缓存是以\",{\"1\":{\"140\":1}}],[\"这个客户端并不会马上知道\",{\"1\":{\"139\":1}}],[\"这个根证书前文我们提过\",{\"1\":{\"109\":1}}],[\"这个证书就叫\",{\"1\":{\"109\":1}}],[\"这个证书里有\",{\"1\":{\"108\":1}}],[\"这个学历必须由\",{\"1\":{\"108\":1}}],[\"这个密钥是如何协商出来的\",{\"1\":{\"106\":1}}],[\"这个通信路径称为连接\",{\"1\":{\"77\":1}}],[\"这个值是表示每个\",{\"1\":{\"48\":1}}],[\"这个网站是我自我提升和知识探索的见证\",{\"1\":{\"1\":1}}],[\"这星期我们要为发布4\",{\"1\":{\"12\":1}}],[\"忘记初心\",{\"1\":{\"1\":1}}],[\"我正在处理a方面的事情\",{\"1\":{\"507\":1}}],[\"我正在处理\",{\"1\":{\"507\":1}}],[\"我是monster\",{\"1\":{\"508\":1}}],[\"我是赵老板\",{\"1\":{\"507\":2}}],[\"我是小林\",{\"1\":{\"333\":1}}],[\"我举例了两个发生幻读场景的例子\",{\"1\":{\"369\":1}}],[\"我举例一个可重复读隔离级别发生幻读现象的场景\",{\"1\":{\"366\":1}}],[\"我举个例子\",{\"1\":{\"234\":1}}],[\"我的账户扣了\",{\"1\":{\"351\":1}}],[\"我的想法是\",{\"1\":{\"237\":1}}],[\"我决定给你的转账\",{\"1\":{\"351\":1}}],[\"我画了一个图\",{\"1\":{\"338\":1}}],[\"我直接说结论吧\",{\"1\":{\"304\":1}}],[\"我就不介绍了\",{\"1\":{\"345\":1}}],[\"我就不打印了\",{\"1\":{\"304\":1}}],[\"我就不一一列举了\",{\"1\":{\"163\":1}}],[\"我删减了一些不重要的信息\",{\"1\":{\"304\":1}}],[\"我说的结论是\",{\"1\":{\"296\":1}}],[\"我补充一点\",{\"1\":{\"275\":1,\"324\":1}}],[\"我有个读者就因为干了这个事情\",{\"1\":{\"275\":1}}],[\"我建了一张订单表\",{\"1\":{\"274\":1}}],[\"我用实战的方式来带大家看看死锁是怎么发生的\",{\"1\":{\"274\":1}}],[\"我想查找主键为\",{\"1\":{\"243\":1}}],[\"我跟大家说了是会走索引扫描\",{\"1\":{\"238\":1}}],[\"我也没找到合理的解释\",{\"1\":{\"278\":1}}],[\"我也跟大家说了是会走全表扫描\",{\"1\":{\"238\":1}}],[\"我也创建了二级索引\",{\"1\":{\"198\":1}}],[\"我通过下面这条语句\",{\"1\":{\"236\":1}}],[\"我使用的\",{\"1\":{\"234\":1}}],[\"我贴个第二条查询语句的执行计划结果图\",{\"1\":{\"231\":1}}],[\"我昨天分享的索引失效文章里也提及过\",{\"1\":{\"231\":1}}],[\"我今晚就跟大家聊聊这个思考题\",{\"1\":{\"230\":1}}],[\"我之前也写一篇加锁规则\",{\"1\":{\"275\":1}}],[\"我之前这篇文章\",{\"1\":{\"230\":1}}],[\"我之前写过索引失效的文章\",{\"1\":{\"228\":1}}],[\"我在上一篇文章提到\",{\"1\":{\"362\":1}}],[\"我在看\",{\"1\":{\"238\":1}}],[\"我在原本的\",{\"1\":{\"238\":1}}],[\"我在文末留了一个有点意思的思考题\",{\"1\":{\"230\":1}}],[\"我在表中总结了\",{\"1\":{\"204\":1}}],[\"我把重点总结在了下面这个表格\",{\"1\":{\"229\":1}}],[\"我上面说的是常见的索引失效场景\",{\"1\":{\"228\":1}}],[\"我上面这个例子是针对字符集为\",{\"1\":{\"166\":1}}],[\"我笑着画了\",{\"1\":{\"207\":1}}],[\"我这里总结下\",{\"1\":{\"300\":1}}],[\"我这里只截取了行级锁的内容\",{\"1\":{\"293\":2,\"294\":3,\"296\":1,\"297\":1}}],[\"我这里举联合索引\",{\"1\":{\"215\":1}}],[\"我这里将前面的商品表中的\",{\"1\":{\"206\":1}}],[\"我这里有一个名为\",{\"1\":{\"152\":1}}],[\"我前面将的案例都是基于\",{\"1\":{\"197\":1}}],[\"我先直接说结论\",{\"1\":{\"190\":1}}],[\"我曾经以为\",{\"1\":{\"189\":1}}],[\"我对\",{\"1\":{\"149\":1,\"304\":1}}],[\"我下面这条查询语句\",{\"1\":{\"142\":1,\"144\":1}}],[\"我们调用system\",{\"1\":{\"520\":1}}],[\"我们形象的称之为\",{\"1\":{\"480\":1}}],[\"我们将redis操作封装到之前的common\",{\"1\":{\"450\":1}}],[\"我们数据量较少\",{\"1\":{\"448\":1}}],[\"我们修改之前的item\",{\"1\":{\"444\":1}}],[\"我们修改\",{\"1\":{\"442\":1}}],[\"我们封装一个发送http请求的工具\",{\"1\":{\"442\":1}}],[\"我们实现如图部分\",{\"1\":{\"440\":1}}],[\"我们希望达到的多级缓存架构如图\",{\"1\":{\"433\":1}}],[\"我们希望索引的数据结构能在尽可能少的磁盘的\",{\"1\":{\"248\":1}}],[\"我们今天会利用caffeine框架来实现jvm进程缓存\",{\"1\":{\"416\":1}}],[\"我们把缓存分为两类\",{\"1\":{\"416\":1}}],[\"我们把三条记录的\",{\"1\":{\"162\":1}}],[\"我们的应用程序就会暂停\",{\"1\":{\"527\":1}}],[\"我们的请求路径是\",{\"1\":{\"446\":1}}],[\"我们的tomcat是单机部署\",{\"1\":{\"445\":1}}],[\"我们的tomcat服务将来也会部署为集群模式\",{\"1\":{\"414\":1}}],[\"我们的openresty是在虚拟机\",{\"1\":{\"440\":1}}],[\"我们的查询语句都有使用索引查询\",{\"1\":{\"299\":1}}],[\"我们计划让7002宕机\",{\"1\":{\"409\":1}}],[\"我们计划是3000个\",{\"1\":{\"408\":1}}],[\"我们假设select\",{\"1\":{\"365\":1}}],[\"我们来分析下为什么事务\",{\"1\":{\"360\":2}}],[\"我们来看下\",{\"1\":{\"498\":1}}],[\"我们来看下这三个字段是什么\",{\"1\":{\"164\":1}}],[\"我们来看一下源码\",{\"1\":{\"494\":1}}],[\"我们来看一下第三条查询语句的执行计划\",{\"1\":{\"232\":1}}],[\"我们来看看在两阶段提交的不同时刻\",{\"1\":{\"346\":1}}],[\"我们来看看一棵\",{\"1\":{\"252\":1}}],[\"我们重点看事务\",{\"1\":{\"360\":1}}],[\"我们还是以前面的例子来聊聊\",{\"1\":{\"360\":1}}],[\"我们还需要了解聚簇索引记录中的两个隐藏列\",{\"1\":{\"358\":1}}],[\"我们讨论的\",{\"1\":{\"357\":1}}],[\"我们常见的\",{\"1\":{\"352\":1,\"361\":1}}],[\"我们常说的索引数据结构\",{\"1\":{\"138\":1}}],[\"我们不需要显示的使用\",{\"1\":{\"310\":1}}],[\"我们不能根据查询条件\",{\"1\":{\"216\":1}}],[\"我们不能因为害怕预读失效\",{\"1\":{\"178\":1}}],[\"我们下次见啦\",{\"1\":{\"300\":1}}],[\"我们下面讲内容都是基于\",{\"1\":{\"184\":1}}],[\"我们前面也讲了\",{\"1\":{\"298\":2}}],[\"我们才能知道执行插入语句的时候\",{\"1\":{\"296\":1}}],[\"我们证明了\",{\"1\":{\"293\":1}}],[\"我们以前面的事务\",{\"1\":{\"290\":1}}],[\"我们是要考虑\",{\"1\":{\"275\":1,\"287\":1,\"316\":1}}],[\"我们是单拿一个节点来看\",{\"1\":{\"186\":1}}],[\"我们最常用的就是\",{\"1\":{\"257\":1}}],[\"我们最常使用的是\",{\"1\":{\"243\":1}}],[\"我们查找索引值为\",{\"1\":{\"250\":1}}],[\"我们针对每一个数据结构分析一下\",{\"1\":{\"248\":1}}],[\"我们看出\",{\"1\":{\"244\":1}}],[\"我们看看看看这三条记录的行格式中的\",{\"1\":{\"161\":1,\"162\":1}}],[\"我们更倾向于采用\",{\"1\":{\"244\":1}}],[\"我们通过一个测试来实现redistemplate集成哨兵机制\",{\"1\":{\"395\":1}}],[\"我们通过槽查找记录时\",{\"1\":{\"243\":1}}],[\"我们通常将这种情况称为页分裂\",{\"1\":{\"226\":1}}],[\"我们从数据页的角度看\",{\"1\":{\"242\":1}}],[\"我们再回过头看\",{\"1\":{\"296\":1}}],[\"我们再看看\",{\"1\":{\"244\":1}}],[\"我们再看第二个例子\",{\"1\":{\"238\":1}}],[\"我们再来看看这个问题\",{\"1\":{\"165\":1}}],[\"我们都知道联合索引要遵循最左匹配才能走索引\",{\"1\":{\"232\":1}}],[\"我们也要关注\",{\"1\":{\"228\":1}}],[\"我们也可以通过\",{\"1\":{\"293\":2,\"294\":3,\"296\":1,\"297\":1}}],[\"我们也可以从\",{\"1\":{\"280\":1}}],[\"我们也可以在执行计划中的\",{\"1\":{\"216\":4}}],[\"我们也可以得出第二条记录的行格式中\",{\"1\":{\"161\":1}}],[\"我们需要根据商品id做负载均衡\",{\"1\":{\"445\":1}}],[\"我们需要在openresty中编写业务\",{\"1\":{\"434\":1}}],[\"我们需要定义两个caffeine的缓存对象\",{\"1\":{\"419\":1}}],[\"我们需要了解两个知识\",{\"1\":{\"358\":1}}],[\"我们需要注意创建时的顺序问题\",{\"1\":{\"239\":1}}],[\"我们需要重点看这个\",{\"1\":{\"228\":1}}],[\"我们需要额外维护这个计数表\",{\"1\":{\"200\":1}}],[\"我们有没有什么其他更好的办法呢\",{\"1\":{\"198\":1}}],[\"我们得要深入\",{\"1\":{\"190\":1}}],[\"我们刚刚在说\",{\"1\":{\"187\":1}}],[\"我们就称为\",{\"1\":{\"483\":1}}],[\"我们就可以去修改item\",{\"1\":{\"451\":1}}],[\"我们就可以使用\",{\"1\":{\"199\":1}}],[\"我们就要知道并发事务时会引发什么问题\",{\"1\":{\"352\":1}}],[\"我们就当做它就是\",{\"1\":{\"187\":1}}],[\"我们就无法分辨了\",{\"1\":{\"85\":1}}],[\"我们大概已经了解了表的数据是怎么个结构了\",{\"1\":{\"187\":1}}],[\"我们为了查找\",{\"1\":{\"187\":1}}],[\"我们自己存储的记录会按照我们指定的行格式存储到\",{\"1\":{\"185\":1}}],[\"我们自己也可以手动断开空闲的连接\",{\"1\":{\"139\":1}}],[\"我们熟悉的\",{\"1\":{\"180\":1}}],[\"我们这次主要讲的是隔离性\",{\"1\":{\"361\":1}}],[\"我们这里字段类型是\",{\"1\":{\"166\":1}}],[\"我们这部分具体介绍e\",{\"1\":{\"91\":1}}],[\"我们要将num存储到7004节点\",{\"1\":{\"408\":1}}],[\"我们要明白\",{\"1\":{\"297\":1}}],[\"我们要先要知道二级索引树是如何存放记录的\",{\"1\":{\"296\":1}}],[\"我们要先知道每个变长字段的\",{\"1\":{\"166\":1}}],[\"我们要清楚一点\",{\"1\":{\"165\":1}}],[\"我们在openresty接收前端请求\",{\"1\":{\"437\":1}}],[\"我们在转账操作前先开启事务\",{\"1\":{\"351\":1}}],[\"我们在执行执行一条\",{\"1\":{\"334\":1}}],[\"我们在查询数据的时候\",{\"1\":{\"258\":1}}],[\"我们在建表的时候\",{\"1\":{\"226\":1}}],[\"我们在算\",{\"1\":{\"166\":1,\"169\":1}}],[\"我们在网上进行转账等操作时\",{\"1\":{\"109\":1}}],[\"我们定义一个\",{\"1\":{\"166\":1}}],[\"我们执行了下面这条查询语句\",{\"1\":{\"205\":1}}],[\"我们执行\",{\"1\":{\"163\":1,\"277\":2}}],[\"我们先在openresty接收请求\",{\"1\":{\"434\":1}}],[\"我们先要清楚\",{\"1\":{\"296\":1}}],[\"我们先来看看索引存储结构长什么样\",{\"1\":{\"234\":1}}],[\"我们先来测试看看\",{\"1\":{\"166\":1}}],[\"我们先来做个实验验证一下\",{\"1\":{\"166\":1}}],[\"我们先来说说预处理阶段做了什么事情\",{\"1\":{\"144\":1}}],[\"我们先创建这样一张表\",{\"1\":{\"161\":1}}],[\"我们知道了一条查询语句经历的过程\",{\"1\":{\"333\":1}}],[\"我们知道\",{\"1\":{\"156\":1,\"339\":1}}],[\"我们进入\",{\"1\":{\"152\":1}}],[\"我们每创建一个\",{\"1\":{\"152\":1}}],[\"我们本次的查询语句\",{\"1\":{\"145\":1}}],[\"我们必须信任它\",{\"1\":{\"109\":1}}],[\"我们可以再openresty中实现查询redis的逻辑了\",{\"1\":{\"449\":1}}],[\"我们可以利用反射机制\",{\"1\":{\"480\":1}}],[\"我们可以利用canal提供的java客户端\",{\"1\":{\"459\":1}}],[\"我们可以利用大数据统计用户访问的热点数据\",{\"1\":{\"448\":1}}],[\"我们可以利用for循环来遍历\",{\"1\":{\"426\":1}}],[\"我们可以及时在数据库表看到\",{\"1\":{\"334\":1}}],[\"我们可以打开\",{\"1\":{\"331\":1}}],[\"我们可以使用\",{\"1\":{\"330\":1}}],[\"我们可以将0~3000的插槽从7001转移到7004\",{\"1\":{\"408\":1}}],[\"我们可以将记录中的\",{\"1\":{\"358\":1}}],[\"我们可以将该值设置为\",{\"1\":{\"338\":1}}],[\"我们可以将\",{\"1\":{\"330\":1}}],[\"我们可以将这个计数值保存到单独的一张计数表中\",{\"1\":{\"200\":1}}],[\"我们可以回归业务的角度来预防死锁\",{\"1\":{\"281\":1}}],[\"我们可以执行\",{\"1\":{\"280\":2}}],[\"我们可以通过反射\",{\"1\":{\"499\":1}}],[\"我们可以通过这个对象看到类的结构\",{\"1\":{\"480\":1}}],[\"我们可以通过这个日志回滚到事务之前的数据\",{\"1\":{\"334\":1}}],[\"我们可以通过控制以下参数\",{\"1\":{\"349\":1}}],[\"我们可以通过\",{\"1\":{\"275\":1,\"290\":1,\"304\":1,\"321\":1}}],[\"我们可以通过将参数\",{\"1\":{\"140\":1}}],[\"我们可以从执行计划中的\",{\"1\":{\"239\":1}}],[\"我们可以建立一个联合索引\",{\"1\":{\"225\":1}}],[\"我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件\",{\"1\":{\"216\":1}}],[\"我们可以把读取一个节点当作一次磁盘\",{\"1\":{\"205\":1}}],[\"我们可以把表空间中的每一页都加载到内存中\",{\"1\":{\"185\":1}}],[\"我们可以按照四个角度来分类索引\",{\"1\":{\"203\":1}}],[\"我们可以看到\",{\"1\":{\"145\":1}}],[\"我们可以在查询语句最前面加个\",{\"1\":{\"145\":1}}],[\"我们可以很好的了解\",{\"1\":{\"137\":1}}],[\"我们可以很快地检查出来\",{\"1\":{\"85\":1}}],[\"我们可以向\",{\"1\":{\"109\":1}}],[\"我们只要引入该模块就能直接使用\",{\"1\":{\"450\":1}}],[\"我们只是想读取这些节点的索引数据来做比较查询\",{\"1\":{\"252\":1}}],[\"我们只是在\",{\"1\":{\"109\":1}}],[\"我们只需要将请求发送到反向代理服务器\",{\"1\":{\"22\":1}}],[\"我们肯定需要通信双方协商好密钥吧\",{\"1\":{\"106\":1}}],[\"我们很容易迷失方向\",{\"1\":{\"1\":1}}],[\"我都希望你能在这里找到一些有价值的内容\",{\"1\":{\"1\":1}}],[\"我希望这个网站能够成为一个互动的平台\",{\"1\":{\"1\":1}}],[\"我创建这个网站的初衷是为了记录我的学习旅程\",{\"1\":{\"1\":1}}],[\"🎉欢迎来到我的个人学习空间\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
