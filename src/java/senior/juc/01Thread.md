---
title: 线程基础
category: Java
tag:

- Java
- JUC

---

## 进程和线程

进程是资源分配的最小单位，进程是正在运行程序的实例

> 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的，当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程

线程是资源调度的最小单位，一个进程内有若干个线程。

> 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行

## 并行和并发

并行是同一时间内独立执行多个任务

并发是系统有处理多个任务的能力，但任一时刻内只有一个任务在执行（其实就是线程轮流使用CPU），即微观串行，宏观并行



## 创建线程的方式

共有四种方式可以创建线程，分别是：

- 继承Thread类
- 实现runnable接口
- 实现Callable接口（能够获取返回值）
- 线程池创建线程



## runnable和callable有什么区别

|          |  Runnable   |                Callable                |
| :------: |:-----------:| :------------------------------------: |
| 重写方法 |    run()    |                 call()                 |
|  返回值  |     /     | 配合FutureTask.get()获取，会阻塞主进程 |
|   异常   | 内部消化，不能继续上抛 |            call()可抛出异常            |



## 线程的run()和start()有什么区别？



start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。

run(): 封装了要被线程执行的代码，可以被调用多次。

也就是说，start() 方法的调用会告诉 JVM 准备好所有必要的新线程结构，分配其所需资源，并调用线程的 run() 方法在这个新线程中执行。

## 什么是守护线程

Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。

在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。同时JVM内部还启动了很多守护线程，比如垃圾回收线程。

当最后一个非守护线程束时，JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。

换而言之，**只要有一个用户线程还没结束，正常情况下JVM就不会退出**。



## 线程有哪些常用的调度方法？

![三分恶面渣逆袭：线程常用调度方法](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/juc/202412191558881.png)

## 线程之间状态的转换





## 线程之间是如何通信的？

主要依靠Java内存模型（JMM），JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见：JMM线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了共享变量的副本

![深入浅出 Java 多线程：JMM](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/juc/202412191432408.png)

线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：

- 线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。
- 线程 B 到主内存中读取线程 A 刷新过的共享变量，再同步到自己的共享变量副本中。

![深入浅出 Java 多线程：线程间通信](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/juc/202412191434279.png)









