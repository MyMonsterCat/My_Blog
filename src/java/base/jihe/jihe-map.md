---
title: Map接口
category: Java
tag:
  - Java
---

## HashMap


### 1.HashMap的底层实现是什么？


- JDK1.8之前：数组 + 链表


> 即拉链法，也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的 值加到链表中即可。


- JDK1.8之后：**数组 + （链表 | 红黑树）**


### 2.树化与退化


- 树化规则：**当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化**

- 退化规则：

    - 数组扩容时，会重新计算索引位置，也就是原本的树结构可能会变，如果**重新计算后的树元素个数 <= 6 则会退化为链表**

    - 移除树节点时，如果root、root.left、root.right、root.left.left有一个为 null ，退化为链表


> 树化的意义是什么？
>
> 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略
>
> 为什么一上来不树化？
>

> 哈希表的查找、更新的时间复杂度是 $O(1)$ ，而红黑树的查找、更新的时间复杂度是 $O(log_2n)$ ，TreeNode 占用空间也比普通Node 的大，如非必要，尽量还是使用链表
>
> 树化应是偶然情况，是保底策略
>
> 为什么树化的阈值是8？
>
> 按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小提高了计算效率。table.length * 3/4可以被优化为((table.length >> 2) << 2) - (table.length >> 2) == table.length - (table.length >> 2), JAVA的位运算比乘除的效率更高, 所以取3/4在保证hash冲突小的情况下兼顾了效率;
>
> 扩容时如何重新计算索引位置？
>
> hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap


### 3.索引计算规则


一共分为3步：


- 计算对象的 hashCode()

- 扰动计算`(h = key.hashCode()) ^ (h >>> 16)`

- 上面的结果 `& (capacity – 1)` 得到索引


> hashCode()都有了，为什么还要提供hash方法（为什么还要进行扰动计算）？
>
> 简单来说就是混合了原哈希值中的高位和低位，增大了**随机性**，可参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617/answer/111577937)

### 4.扩容流程

默认容量为16

数组容量为什么必须是2的n次幂？

只有2的幂次方在减1的时候，才会出现`01111`这样的值。

2的n次幂有什么好坏处？

数组容量不是2的n次幂可不可以

如果追求效率，应该用2的n次幂作为容量，这样可以保证最高位为1，这样可以通过位运算来计算hash值，而不是用取模运算，效率更高。

如果追求hash分布性，应该用质数作为容量，这样可以保证hash值分布更均匀，减少hash冲突，提高效率。
