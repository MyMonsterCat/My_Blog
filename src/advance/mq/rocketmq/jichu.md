## 基础

### 1.为什么要使用消息队列呢？

消息队列（Message Queue, MQ）是一种非常重要的中间件技术，广泛应用于分布式系统中，以提高系统的可用性、解耦能力和异步通信效率。

① **解耦**

生产者将消息放入队列，消费者从队列中取出消息，这样一来，生产者和消费者之间就不需要直接通信，生产者只管生产消息，消费者只管消费消息，这样就实现了解耦。

![消息队列解耦](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211651934.jpg)

② **异步**：

系统可以将那些耗时的任务放在消息队列中异步处理，从而快速响应用户的请求。比如说，用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息。

![消息队列异步](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211651826.jpg)

③ **削峰**：

削峰填谷是一种常见的技术手段，用于应对系统高并发请求的瞬时流量高峰，通过消息队列，可以将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃。

![消息队列削峰](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211651699.jpg)

### 2.为什么要选择 RocketMQ?

<img src="https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211652567.jpg" alt="四大消息队列对比" style="zoom:50%;" />

我们系统主要面向 C 端用户，有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的 RocketMQ。

### 3.RocketMQ 有什么优缺点？

**RocketMQ 优点**

- 单机吞吐量：十万级
- 可用性：非常高，分布式架构
- 消息可靠性：经过参数优化配置，消息可以做到 0 丢失
- 功能支持：MQ 功能较为完善，还是分布式的，扩展性好
- 支持 10 亿级别的消息堆积，不会因为堆积导致性能下降
- 源码是 Java，方便结合公司自己的业务二次开发
- 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况
- **RoketMQ**在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择**RocketMQ**

**RocketMQ 缺点：**

- 支持的客户端语言不多，目前是 Java 及 c++，其中 c++不成熟
- 没有在 MQ 核心中去实现**JMS**等接口，有些系统要迁移需要修改大量代码

#### 说说你对 RocketMQ 的理解？

RocketMQ 是阿里巴巴开源的一款分布式消息中间件，具有高吞吐量、低延迟和高可用性。其主要组件包括生产者、消费者、Broker、Topic 和队列。消息由生产者发送到 Broker，再根据路由规则存储到队列中，消费者从队列中拉取消息进行处理。适用于异步解耦和流量削峰等场景。

### 4.消息队列有哪些消息模型？

消息队列有两种模型：**队列模型**和**发布/订阅模型**。

**队列模型**

这是最初的一种消息队列模型，对应着消息队列==发-存-收==的模型。

- 生产者往某个队列里面发送消息
- 一个队列可以存储多个生产者的消息
- 一个队列也可以有多个消费者，但是消费者之间是竞争关系，也就是说每条消息只能被一个消费者消费。

![队列模型](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211653138.jpg)

**发布/订阅模型**

如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。解决的方式就是发布/订阅模型。

在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。

发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，==每份订阅中，订阅者都可以接收到主题的所有消息==。

![发布-订阅模型](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211655528.jpg)

它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：==一份消息数据是否可以被多次消费==。

### 5.那 RocketMQ 的消息模型呢？

RocketMQ 使用的消息模型是标准的发布-订阅模型，在 RocketMQ 的术语表中，生产者、消费者和主题，与发布-订阅模型中的概念是完全一样的。

RocketMQ 本身的消息是由下面几部分组成：

![RocketMQ消息的组成](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxrocketmqessw-4ab7f942-23d7-4462-8e36-e305cc0a045f.jpg)

|                           Message                            |                            Topic                             |                             Tag                              |                            Group                             |                        Message Queue                         | Offset                                                       |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址 | 一个 Topic 可以有 0 个、1 个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息 |       Tag（标签）可以看作子主题，它是消息的第二级类型        | 每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。 | 一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic 下所有的消息，就要遍历所有的 Message Queue。 | 在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。 |
| 一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。 |        一个 Topic 也可以被 0 个、1 个、多个消费者订阅        | 同一业务模块不同目的的消息就可以用相同 Topic 而不同的 Tag 来标识 | 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。 |                                                              | 也可以这么说，`Queue` 是一个长度无限的数组，**Offset** 就是下标。 |

画张图总结一下：

![](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211724948.jpg)

### 6.消息的消费模式了解吗？

消息消费模式有两种：**Clustering**（集群消费）和**Broadcasting**（广播消费）。

![两种消费模式](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211725738.jpg)

默认情况下就是集群消费，这种模式下`一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费`，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。

而广播消费消息会发给消费者组中的每一个消费者进行消费。

### 7.RoctetMQ 基本架构了解吗？

先看图，RocketMQ 的基本架构：

![RocketMQ架构](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211725471.jpg)

RocketMQ 一共有四个部分组成：NameServer，Broker，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。

### 8.那能介绍一下这四部分吗？

类比一下我们生活的邮政系统——

邮政系统要正常运行，离不开下面这四个角色， 一是发信者，二 是收信者， 三是负责暂存传输的邮局， 四是负责协调各个地方邮局的管理机构。对应到 RocketMQ 中，这四个角色就是 Producer、 Consumer、 Broker 、NameServer。

![RocketMQ类比邮政体系](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211725604.jpg)

##### NameServer

NameServer 是一个无状态的服务器，角色类似于 Kafka 使用的 Zookeeper，但比 Zookeeper 更轻量。

特点：

- 每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。
- Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。

功能主要有两个：

- 1、和 Broker 结点保持长连接。
- 2、维护 Topic 的路由信息。

##### Broker

消息存储和中转角色，负责存储和转发消息。

- Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。

![RocketMQ存储-图片来源官网](https://monster-note.oss-cn-hangzhou.aliyuncs.com/blog/mq/202411211725366.jpg)

- 单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。

##### Producer

消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。

- **Producer**由用户进行分布式部署，消息由**Producer**通过多种负载均衡模式发送到**Broker**集群，发送低延时，支持快速失败。
- **RocketMQ** 提供了三种方式发送消息：同步、异步和单向

- **同步发送**：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。
- **异步发送**：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。
- **单向发送**：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。

##### Consumer

消息消费者，负责消费消息，一般是后台系统负责异步消费。

- **Consumer**也由用户部署，支持 PUSH 和 PULL 两种消费模式，支持**集群消费**和**广播消费**，提供**实时的消息订阅机制**。
- **Pull**：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。
- **Push**：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。